/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 9906:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


if (true) {
  module.exports = __webpack_require__(2478);
} else {}


/***/ }),

/***/ 2478:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;


__webpack_unused_export__ = ({ value: true });

var memoize = __webpack_require__(8357);

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

var memoize__default = /*#__PURE__*/_interopDefault(memoize);

var reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/; // https://esbench.com/bench/5bfee68a4cd7e6009ef61d23

var isPropValid = /* #__PURE__ */memoize__default['default'](function (prop) {
  return reactPropsRegex.test(prop) || prop.charCodeAt(0) === 111
  /* o */
  && prop.charCodeAt(1) === 110
  /* n */
  && prop.charCodeAt(2) < 91;
}
/* Z+1 */
);

exports["default"] = isPropValid;


/***/ }),

/***/ 8357:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


if (true) {
  module.exports = __webpack_require__(456);
} else {}


/***/ }),

/***/ 456:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

function memoize(fn) {
  var cache = Object.create(null);
  return function (arg) {
    if (cache[arg] === undefined) cache[arg] = fn(arg);
    return cache[arg];
  };
}

exports["default"] = memoize;


/***/ }),

/***/ 3826:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4191);
/* harmony import */ var _components_Input__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(3622);
/* harmony import */ var _components_Button__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(8100);
/* harmony import */ var _components_Form_Form__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(9427);
/* harmony import */ var _components_Form_Fieldset__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(6967);
/* harmony import */ var _components_Icon__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(6137);
var __rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};







/**
 * AddTextField component
 */
const AddTextField = (_a) => {
    var { onConfirm, inputType, addInputProps, labelText, onKeyDown, setErrors, autoFocus, description } = _a, rest = __rest(_a, ["onConfirm", "inputType", "addInputProps", "labelText", "onKeyDown", "setErrors", "autoFocus", "description"]);
    const [value, setValue] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(inputType === 'number' ? '0' : '');
    const [isValid, setValid] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);
    const inputError = setErrors && setErrors(value);
    const onChange = (event) => {
        const { valid } = event.target.validity;
        setValue(event.target.value);
        setValid(valid);
    };
    const onSubmit = (event) => {
        event.preventDefault();
        setValue(inputType === 'number' ? '0' : '');
        if (onConfirm) {
            onConfirm(value);
        }
    };
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(_components_Form_Form__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z, Object.assign({ inline: true, onSubmit: onSubmit }, rest, { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components_Form_Fieldset__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z, { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components_Input__WEBPACK_IMPORTED_MODULE_4__/* .Input */ .II, Object.assign({ label: labelText, onKeyDown: onKeyDown, type: inputType, required: true, value: value, onChange: onChange, error: !isValid || inputError, size: "large", description: description, autoFocus: autoFocus }, addInputProps)) }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components_Form_Fieldset__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z, Object.assign({ padding: true, narrow: true }, { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components_Button__WEBPACK_IMPORTED_MODULE_5__/* .Button */ .z, { icon: _components_Icon__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z, variant: "primary", size: "large", disabled: !isValid || inputError === 'string' || inputError === true, "aria-label": "Toggle input" }) }))] })));
};
AddTextField.defaultProps = {
    inputType: 'text'
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AddTextField);


/***/ }),

/***/ 6965:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "C": () => (/* binding */ Badge)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38);
/* harmony import */ var styled_system__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4912);
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(8335);
/* harmony import */ var _theme__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3694);
/* harmony import */ var _Icon__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(7185);
var __rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};





const BadgeStyled = _theme__WEBPACK_IMPORTED_MODULE_2__/* .styled.span */ .zo.span `
  display: inline-flex;
  align-items: center;
  white-space: nowrap;
  pointer-events: none;
  user-select: none;

  ${({ highlight, theme }) => !highlight &&
    `
  &:before{
    display: block;
    content: '';
    width: ${theme.sizes.$4};
    height: ${theme.sizes.$4};
    border-radius: 50%;
  }
`}

  ${({ theme }) => (0,styled_system__WEBPACK_IMPORTED_MODULE_1__/* .variant */ .bU)({
    prop: 'size',
    variants: {
        small: {
            fontSize: theme.fontSizes.$11,
            lineHeight: theme.lineHeights.$120,
            padding: `0.1rem ${theme.sizes.$8}`,
            borderRadius: theme.sizes.$8,
            '&:before, .icon': {
                marginRight: theme.sizes.$4
            }
        },
        medium: {
            fontSize: theme.fontSizes.$12,
            lineHeight: theme.lineHeights.$100,
            padding: `0.3rem 1rem`,
            borderRadius: theme.sizes.$8,
            '&:before, .icon': {
                marginRight: '0.6rem'
            }
        },
        large: {
            fontSize: theme.fontSizes.$14,
            lineHeight: theme.lineHeights.$100,
            padding: `${theme.sizes.$4} ${theme.sizes.$12}`,
            borderRadius: theme.sizes.$24,
            '&:before, .icon': {
                marginRight: theme.sizes.$8
            }
        }
    }
})}

  ${({ theme }) => (0,styled_system__WEBPACK_IMPORTED_MODULE_1__/* .variant */ .bU)({
    variants: {
        danger: {
            backgroundColor: theme.color('red50', 'red90')({ theme }),
            color: theme.color('dark100', 'red10')({ theme }),
            '&:before': {
                backgroundColor: theme.colors.red40
            }
        },
        info: {
            backgroundColor: theme.color('blue50', 'blue90')({ theme }),
            color: theme.color('dark100', 'blue10')({ theme }),
            '&:before': {
                backgroundColor: theme.colors.blue50
            }
        },
        success: {
            backgroundColor: theme.color('green50', 'green90')({ theme }),
            color: theme.color('dark100', 'green10')({ theme }),
            '&:before': {
                backgroundColor: theme.colors.green50
            }
        },
        warning: {
            backgroundColor: theme.color('peach40', 'peach90')({ theme }),
            color: theme.color('dark100', 'peach10')({ theme }),
            '&:before': {
                backgroundColor: theme.colors.peach40
            }
        },
        primary: {
            backgroundColor: theme.color('dark60', 'light100')({ theme }),
            color: theme.color('dark10', 'light10')({ theme }),
            '&:before': {
                backgroundColor: theme.color('dark30')({ theme })
            }
        },
        secondary: {
            backgroundColor: theme.color('dark30', 'light60')({ theme }),
            color: theme.color('dark100', 'light10')({ theme }),
            '&:before': {
                backgroundColor: theme.color('dark30')({ theme })
            }
        },
        light: {
            backgroundColor: theme.color('dark60', 'light100')({ theme }),
            color: theme.color('dark10', 'light10')({ theme }),
            '&:before': {
                backgroundColor: theme.color('dark30')({ theme })
            }
        },
        blue: {
            backgroundColor: theme.color('blue50', 'blue90')({ theme }),
            color: theme.color('dark100', 'blue10')({ theme }),
            '&:before': {
                backgroundColor: theme.colors.blue50
            }
        },
        green: {
            backgroundColor: theme.color('green50', 'green90')({ theme }),
            color: theme.color('dark100', 'green10')({ theme }),
            '&:before': {
                backgroundColor: theme.colors.green50
            }
        },
        yellow: {
            backgroundColor: theme.color('yellow50', 'yellow80')({ theme }),
            color: theme.color('dark100', 'yellow10')({ theme }),
            '&:before': {
                backgroundColor: theme.colors.yellow50
            }
        },
        purple: {
            backgroundColor: theme.color('purple50', 'purple90')({ theme }),
            color: theme.color('dark100', 'purple30')({ theme }),
            '&:before': {
                backgroundColor: theme.colors.purple50
            }
        },
        magenta: {
            backgroundColor: theme.color('magenta50', 'magenta90')({ theme }),
            color: theme.color('dark100', 'magenta30')({ theme }),
            '&:before': {
                backgroundColor: theme.colors.magenta50
            }
        },
        teal: {
            backgroundColor: theme.color('teal40', 'teal90')({ theme }),
            color: theme.color('dark100', 'teal10')({ theme }),
            '&:before': {
                backgroundColor: theme.colors.teal40
            }
        },
        peach: {
            backgroundColor: theme.color('peach40', 'peach90')({ theme }),
            color: theme.color('dark100', 'peach10')({ theme }),
            '&:before': {
                backgroundColor: theme.colors.peach40
            }
        },
        red: {
            backgroundColor: theme.color('red50', 'red90')({ theme }),
            color: theme.color('dark100', 'red10')({ theme }),
            '&:before': {
                backgroundColor: theme.colors.red40
            }
        },
        gray: {
            backgroundColor: theme.color('dark30', 'light60')({ theme }),
            color: theme.color('dark100', 'light10')({ theme }),
            '&:before': {
                backgroundColor: theme.color('dark30')({ theme })
            }
        },
        'ticker-up': {
            backgroundColor: theme.color('dark60', 'light100')({ theme }),
            '.icon': {
                color: theme.color('green50')({ theme }),
                transform: 'translate(0, -1px)'
            },
            '&:before': {
                display: 'none'
            }
        },
        'ticker-down': {
            backgroundColor: theme.color('dark60', 'light100')({ theme }),
            '.icon': {
                color: theme.color('red50')({ theme }),
                transform: 'rotate(180deg) translate(0, -1px)'
            },
            '&:before': {
                display: 'none'
            }
        }
    }
})}

    ${({ highlight, theme }) => !highlight &&
    `
    background-color: ${theme.color('dark60', 'light100')({ theme })};
    color: ${theme.color('dark0', 'light10')({ theme })};
  `}

  ${({ highlight, theme }) => highlight &&
    `
    font-weight: ${theme.fontWeights.semibold};
  `}
`;
/**
 * Badge component is a visual label used to indicate status or highlight featured content.
 *
 * @see
 * {@link https://design-system.solventek.com/component/badge}
 *
 * @example
 * <Badge label="Label" variant="danger" highlight />
 */
const Badge = (0,_helpers__WEBPACK_IMPORTED_MODULE_3__/* .componentWithRef */ .w)((_a, forwardRef) => {
    var _b;
    var { label } = _a, rest = __rest(_a, ["label"]);
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(BadgeStyled, Object.assign({ ref: forwardRef }, rest, { children: [((_b = rest.variant) === null || _b === void 0 ? void 0 : _b.indexOf('ticker')) === 0 && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_Icon__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z, { size: 8 }), label] })));
});
Badge.defaultProps = {
    variant: 'primary',
    size: 'large'
};


/***/ }),

/***/ 6028:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var styled_system__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4912);
/* harmony import */ var _theme__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3694);
/* harmony import */ var _theme__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(3709);
/* harmony import */ var _theme_helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(9978);



/**
 * Box component
 */
const Box = (0,_theme__WEBPACK_IMPORTED_MODULE_1__/* .styled */ .zo)('div').withConfig({ shouldForwardProp: _theme_helpers__WEBPACK_IMPORTED_MODULE_2__/* .shouldForwardProp */ .x }) `
  color: ${(props) => props.color || 'inherit'};
  ${(0,styled_system__WEBPACK_IMPORTED_MODULE_0__/* .compose */ .qC)(styled_system__WEBPACK_IMPORTED_MODULE_0__/* .flexbox */ .GQ, styled_system__WEBPACK_IMPORTED_MODULE_0__/* .space */ .Dh, styled_system__WEBPACK_IMPORTED_MODULE_0__/* .order */ .vm, styled_system__WEBPACK_IMPORTED_MODULE_0__/* .width */ .bf, styled_system__WEBPACK_IMPORTED_MODULE_0__/* .maxWidth */ .kk, styled_system__WEBPACK_IMPORTED_MODULE_0__/* .minWidth */ .ih, styled_system__WEBPACK_IMPORTED_MODULE_0__/* .height */ .Cb, styled_system__WEBPACK_IMPORTED_MODULE_0__/* .maxHeight */ .kC, styled_system__WEBPACK_IMPORTED_MODULE_0__/* .minHeight */ .jw, styled_system__WEBPACK_IMPORTED_MODULE_0__/* .flex */ .fU, styled_system__WEBPACK_IMPORTED_MODULE_0__/* .alignSelf */ .uk, styled_system__WEBPACK_IMPORTED_MODULE_0__/* .display */ .jf, styled_system__WEBPACK_IMPORTED_MODULE_0__/* .textAlign */ .yd, styled_system__WEBPACK_IMPORTED_MODULE_0__/* .fontSize */ .JB, styled_system__WEBPACK_IMPORTED_MODULE_0__/* .fontWeight */ .Ue, styled_system__WEBPACK_IMPORTED_MODULE_0__/* .fontFamily */ .I8, styled_system__WEBPACK_IMPORTED_MODULE_0__/* .boxShadow */ .Wn, styled_system__WEBPACK_IMPORTED_MODULE_0__/* .borderRadius */ .E0)}
  ${_theme__WEBPACK_IMPORTED_MODULE_3__/* .parseColorProps */ .sL}
`;
Box.displayName = 'Box';
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Box);


/***/ }),

/***/ 8100:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "z": () => (/* binding */ Button),
  "X": () => (/* binding */ ButtonBase)
});

// EXTERNAL MODULE: ./node_modules/react/jsx-runtime.js
var jsx_runtime = __webpack_require__(38);
// EXTERNAL MODULE: ./node_modules/styled-system/dist/index.esm.js + 13 modules
var index_esm = __webpack_require__(4912);
// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/helpers/component.js
var component = __webpack_require__(8335);
// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/theme/index.js + 2 modules
var theme = __webpack_require__(3694);
// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/theme/helpers.js
var helpers = __webpack_require__(3709);
// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/components/Box/Box.js
var Box = __webpack_require__(6028);
// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/components/Progress/Progress.js
var Progress = __webpack_require__(2702);
// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(4191);
;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Button/components/Group.js
var __rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};




const Container = theme/* styled.div */.zo.div `
  white-space: nowrap;

  > button {
    border-radius: 0px;

    &:first-child {
      border-radius: ${({ theme }) => theme.sizes.$8} 0 0 ${({ theme }) => theme.sizes.$8};
    }

    &:last-child {
      border-radius: 0 ${({ theme }) => theme.sizes.$8} ${({ theme }) => theme.sizes.$8} 0;
    }

    &:not(:last-child) {
      border-right-color: transparent;
    }

    &.primary + .primary {
      border-left-color: ${({ theme }) => theme.color('purple30', 'purple70')};

      &:disabled {
        border-left-color: ${({ theme }) => theme.color('purple40', 'light70')};
      }
    }

    &.secondary + .secondary {
      border-left-color: ${({ theme }) => theme.color('dark50', 'light60')};

      &:disabled {
        border-left-color: ${({ theme }) => theme.color('dark60', 'light70')};
      }
    }
  }
`;
/**
 * Button.Group component can be used to group related buttons. The buttons need to be immediate children.
 * The `size` prop can be defined to be applied to all Buttons in group.
 *
 *
 * @see
 * {@link https://design-system.solventek.com/component/button#group}
 *
 * @example
 * <Button.Group size="small">
 *   <Button>One</Button>
 *   <Button>Two</Button>
 * </Button.Group>
 */
const Group = (0,component/* componentWithRef */.w)((_a, forwardedRef) => {
    var { children, size } = _a, rest = __rest(_a, ["children", "size"]);
    const childrenWithProps = react.Children.map(children, (child) => {
        if ((0,react.isValidElement)(child)) {
            return size ? (0,react.cloneElement)(child, { size }) : child;
        }
        return child;
    });
    return ((0,jsx_runtime.jsx)(Container, Object.assign({ role: "group", ref: forwardedRef }, rest, { children: childrenWithProps })));
});

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Button/Button.js
var Button_rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};








const compoundComponents = {
    Group: Group
};
const ButtonBaseStyled = theme/* styled.button */.zo.button `
  display: inline-flex;
  align-items: center;
  line-height: ${({ theme }) => theme.lineHeights.$100};
  white-space: nowrap;
  background: none;
  color: ${({ theme }) => theme.color('dark0')};
  justify-content: center;

  ${helpers/* styledFocus */.By}

  &:disabled {
    cursor: not-allowed;
  }

  ${({ iconOnly, theme }) => (0,index_esm/* variant */.bU)({
    prop: 'size',
    variants: {
        small: {
            height: theme.sizes.$24,
            width: iconOnly ? theme.sizes.$24 : 'auto',
            fontSize: theme.fontSizes.$12,
            paddingLeft: iconOnly ? 3 : theme.sizes.$12,
            paddingRight: iconOnly ? 3 : theme.sizes.$12
        },
        medium: {
            height: theme.sizes.$32,
            width: iconOnly ? theme.sizes.$32 : 'auto',
            fontSize: theme.fontSizes.$14,
            paddingLeft: iconOnly ? 7 : theme.sizes.$16,
            paddingRight: iconOnly ? 7 : theme.sizes.$16
        },
        large: {
            height: theme.sizes.$40,
            width: iconOnly ? theme.sizes.$40 : 'auto',
            fontSize: theme.fontSizes.$16,
            paddingLeft: iconOnly ? 11 : theme.sizes.$24,
            paddingRight: iconOnly ? 11 : theme.sizes.$24
        }
    }
})}
`;
const ButtonContent = theme/* styled.span */.zo.span `
  display: inline-flex;
  align-items: center;
`;
const LoadingContainer = theme/* styled.div */.zo.div `
  margin-right: 0px;
  overflow: hidden;
  width: ${({ $loading, theme }) => ($loading ? theme.sizes.$28 : 0)};
  transition: width ${({ theme }) => `${theme.transition.duration.normal}ms ${theme.transition.function.default}`};
`;
/**
 *  Button component with no default variant styling, for use in components requiring custom styled button.
 */
const ButtonBase = (0,component/* componentWithRef */.w)((_a, forwardRef) => {
    var { children, icon: IconBefore, iconAfter: IconAfter, size, loading, disabled } = _a, rest = Button_rest(_a, ["children", "icon", "iconAfter", "size", "loading", "disabled"]);
    return ((0,jsx_runtime.jsxs)(ButtonBaseStyled, Object.assign({ disabled: disabled || loading, iconOnly: !children, size: size, ref: forwardRef }, rest, { children: [(0,jsx_runtime.jsx)(LoadingContainer, Object.assign({ "$loading": loading }, { children: (0,jsx_runtime.jsx)(Progress/* default */.Z, { size: 16, color: "inherit", backgroundColor: "transparent", variant: "circular" }) })), IconBefore && ((0,jsx_runtime.jsx)(Box/* default */.Z, Object.assign({ height: "$16", mr: children ? '$8' : '0' }, { children: (0,jsx_runtime.jsx)(IconBefore, { size: 16 }) }))), children && (0,jsx_runtime.jsx)(ButtonContent, { children: children }), IconAfter && ((0,jsx_runtime.jsx)(Box/* default */.Z, Object.assign({ height: "$16", ml: children ? '$8' : '0' }, { children: (0,jsx_runtime.jsx)(IconAfter, { size: 16 }) })))] })));
}, compoundComponents);
/**
 * Button is used to initialize an action. Button icon and label express what action will occur when the user interacts with it.
 *
 * @see
 * {@link https://design-system.solventek.com/component/button}
 *
 * @example
 * <Button variant="secondary">
 *   Add Item
 * </Button>
 */
const Button = (0,theme/* styled */.zo)(ButtonBase).attrs(({ variant }) => ({ className: variant })) `
  border-radius: ${({ theme }) => theme.sizes.$8};
  border: 1px solid transparent;

  ${({ theme }) => (0,index_esm/* variant */.bU)({
    variants: {
        primary: {
            color: theme.color('dark0', 'light100')({ theme }),
            background: theme.colors.purple50,
            ':hover': {
                background: theme.colors.purple30
            },
            ':active': {
                background: theme.colors.purple30
            },
            ':disabled': {
                background: theme.color('purple30', 'purple90')({ theme }),
                color: theme.color('purple70', 'white')({ theme })
            }
        },
        secondary: {
            borderColor: theme.color('dark60', 'light60')({ theme }),
            color: theme.color('dark0')({ theme }),
            bg: theme.color('dark60', 'light100')({ theme }),
            ':hover': {
                borderColor: theme.color('dark60', 'light60')({ theme }),
                bg: theme.color('dark70', 'light100')({ theme })
            },
            ':active': {
                bg: theme.color('dark80', 'light70')({ theme })
            },
            ':disabled': {
                borderColor: theme.color('dark70', 'light60')({ theme }),
                bg: theme.color('dark70', 'light100')({ theme }),
                color: theme.color('dark40', 'light30')({ theme })
            }
        },
        ghost: {
            bg: 'transparent',
            color: 'inherit',
            ':hover': {
                bg: theme.color('dark70', 'light70')({ theme })
            },
            ':active': {
                bg: theme.color('dark70', 'light60')({ theme })
            },
            ':disabled': {
                bg: theme.color('dark70', 'light70')({ theme }),
                color: theme.color('dark40', 'light30')({ theme })
            }
        }
    }
})}
`;
Button.defaultProps = {
    variant: 'primary',
    size: 'medium'
};


/***/ }),

/***/ 5477:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "U": () => (/* binding */ CheckboxStyled),
/* harmony export */   "X": () => (/* binding */ Checkbox)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38);
/* harmony import */ var styled_system__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4912);
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(8335);
/* harmony import */ var _theme__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3694);
/* harmony import */ var _theme_helpers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(3709);
/* harmony import */ var _components_Icon__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(6470);
/* harmony import */ var _components_Icon__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(6137);
var __rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};






const Label = _theme__WEBPACK_IMPORTED_MODULE_2__/* .styled.label */ .zo.label `
  position: relative;
  display: inline-flex;
  align-items: center;
  cursor: pointer;
  user-select: none;
  color: ${({ theme }) => theme.color('dark0')};
`;
const CheckboxStyled = _theme__WEBPACK_IMPORTED_MODULE_2__/* .styled.input */ .zo.input `
  cursor: pointer;
  appearance: none;
  display: inline-block;

  background: ${({ theme }) => theme.color('dark100')};
  border: 1px solid ${({ theme }) => theme.color('dark20')};

  & + span {
    display: none;
    position: absolute;
    z-index: 2;
    pointer-events: none;
    color: ${({ theme }) => theme.color('white')};
  }

  &:checked,
  &.checked {
    border-color: ${({ theme }) => theme.color('purple50')};
    background: ${({ theme }) => theme.color('purple50')};

    & + span {
      display: block;
    }
  }

  &:disabled {
    cursor: not-allowed;
    border-color: ${({ theme }) => theme.color('dark40')};

    &:checked {
      border-color: ${({ theme }) => theme.color('purple10', 'purple70')};
      background: ${({ theme }) => theme.color('purple10', 'purple70')};
    }

    & + span {
      color: ${({ theme }) => theme.color('purple30', 'white')};
    }

    ~ strong {
      color: ${({ theme }) => theme.color('dark20')};
    }
  }

  ${_theme_helpers__WEBPACK_IMPORTED_MODULE_3__/* .styledFocus */ .By}

  ${({ theme }) => (0,styled_system__WEBPACK_IMPORTED_MODULE_1__/* .variant */ .bU)({
    prop: '$size',
    variants: {
        small: {
            height: theme.sizes.$20,
            width: theme.sizes.$20,
            minWidth: theme.sizes.$20,
            borderRadius: theme.sizes.$2,
            '& + span, & + span > svg': {
                width: theme.sizes.$20,
                height: theme.sizes.$20
            },
            '~ strong': {
                marginLeft: theme.sizes.$8,
                fontSize: theme.fontSizes.$12
            }
        },
        medium: {
            height: theme.sizes.$20,
            width: theme.sizes.$20,
            minWidth: theme.sizes.$20,
            borderRadius: theme.sizes.$2,
            '& + span, & + span > svg': {
                width: theme.sizes.$20,
                height: theme.sizes.$20
            },
            '~ strong': {
                marginLeft: theme.sizes.$8,
                fontSize: theme.fontSizes.$14
            }
        },
        large: {
            height: theme.sizes.$28,
            width: theme.sizes.$28,
            minWidth: theme.sizes.$28,
            borderRadius: theme.sizes.$2,
            '& + span, & + span > svg': {
                width: theme.sizes.$24,
                height: theme.sizes.$24,
                top: theme.sizes.$2,
                left: theme.sizes.$2
            },
            '~ strong': {
                marginLeft: theme.sizes.$12,
                fontSize: theme.fontSizes.$16
            }
        }
    }
})}
`;
/**
 * Checkboxes allow the user to select one or more items from a set.
 *
 * @see
 * {@link https://design-system.solventek.com/component/checkbox}
 *
 * @example
 * <Checkbox checked={checked} onChange={(e) => setChecked(e.target.checked)} />
 */
const Checkbox = (0,_helpers__WEBPACK_IMPORTED_MODULE_4__/* .componentWithRef */ .w)((_a, forwardedRef) => {
    var { indeterminate, label, size } = _a, rest = __rest(_a, ["indeterminate", "label", "size"]);
    const Icon = indeterminate ? _components_Icon__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z : _components_Icon__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z;
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(Label, { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(CheckboxStyled, Object.assign({ type: "checkbox", "$size": size, ref: forwardedRef }, rest)), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Icon, {}), label && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("strong", { children: label })] }));
});
Checkbox.defaultProps = {
    size: 'medium'
};


/***/ }),

/***/ 6190:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "EK": () => (/* binding */ Code),
  "tk": () => (/* reexport */ dist/* EditorView */.tk),
  "qQ": () => (/* reexport */ mode/* robotFramework */.q)
});

// EXTERNAL MODULE: ./node_modules/react/jsx-runtime.js
var jsx_runtime = __webpack_require__(38);
// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(4191);
// EXTERNAL MODULE: ./node_modules/@codemirror/view/dist/index.js + 1 modules
var dist = __webpack_require__(4512);
// EXTERNAL MODULE: ./node_modules/@codemirror/state/dist/index.js
var state_dist = __webpack_require__(802);
// EXTERNAL MODULE: ./node_modules/@codemirror/language/dist/index.js
var language_dist = __webpack_require__(4123);
// EXTERNAL MODULE: ./node_modules/@lezer/common/dist/index.js
var common_dist = __webpack_require__(8731);
;// CONCATENATED MODULE: ./node_modules/@codemirror/commands/dist/index.js





/**
Comment or uncomment the current selection. Will use line comments
if available, otherwise falling back to block comments.
*/
const toggleComment = target => {
    let config = getConfig(target.state);
    return config.line ? toggleLineComment(target) : config.block ? toggleBlockCommentByLine(target) : false;
};
function command(f, option) {
    return ({ state, dispatch }) => {
        if (state.readOnly)
            return false;
        let tr = f(option, state);
        if (!tr)
            return false;
        dispatch(state.update(tr));
        return true;
    };
}
/**
Comment or uncomment the current selection using line comments.
The line comment syntax is taken from the
[`commentTokens`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) [language
data](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt).
*/
const toggleLineComment = /*@__PURE__*/(/* unused pure expression or super */ null && (command(changeLineComment, 0 /* CommentOption.Toggle */)));
/**
Comment the current selection using line comments.
*/
const lineComment = /*@__PURE__*/(/* unused pure expression or super */ null && (command(changeLineComment, 1 /* CommentOption.Comment */)));
/**
Uncomment the current selection using line comments.
*/
const lineUncomment = /*@__PURE__*/(/* unused pure expression or super */ null && (command(changeLineComment, 2 /* CommentOption.Uncomment */)));
/**
Comment or uncomment the current selection using block comments.
The block comment syntax is taken from the
[`commentTokens`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) [language
data](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt).
*/
const toggleBlockComment = /*@__PURE__*/(/* unused pure expression or super */ null && (command(changeBlockComment, 0 /* CommentOption.Toggle */)));
/**
Comment the current selection using block comments.
*/
const blockComment = /*@__PURE__*/(/* unused pure expression or super */ null && (command(changeBlockComment, 1 /* CommentOption.Comment */)));
/**
Uncomment the current selection using block comments.
*/
const blockUncomment = /*@__PURE__*/(/* unused pure expression or super */ null && (command(changeBlockComment, 2 /* CommentOption.Uncomment */)));
/**
Comment or uncomment the lines around the current selection using
block comments.
*/
const toggleBlockCommentByLine = /*@__PURE__*/(/* unused pure expression or super */ null && (command((o, s) => changeBlockComment(o, s, selectedLineRanges(s)), 0 /* CommentOption.Toggle */)));
function getConfig(state, pos = state.selection.main.head) {
    let data = state.languageDataAt("commentTokens", pos);
    return data.length ? data[0] : {};
}
const SearchMargin = 50;
/**
Determines if the given range is block-commented in the given
state.
*/
function findBlockComment(state, { open, close }, from, to) {
    let textBefore = state.sliceDoc(from - SearchMargin, from);
    let textAfter = state.sliceDoc(to, to + SearchMargin);
    let spaceBefore = /\s*$/.exec(textBefore)[0].length, spaceAfter = /^\s*/.exec(textAfter)[0].length;
    let beforeOff = textBefore.length - spaceBefore;
    if (textBefore.slice(beforeOff - open.length, beforeOff) == open &&
        textAfter.slice(spaceAfter, spaceAfter + close.length) == close) {
        return { open: { pos: from - spaceBefore, margin: spaceBefore && 1 },
            close: { pos: to + spaceAfter, margin: spaceAfter && 1 } };
    }
    let startText, endText;
    if (to - from <= 2 * SearchMargin) {
        startText = endText = state.sliceDoc(from, to);
    }
    else {
        startText = state.sliceDoc(from, from + SearchMargin);
        endText = state.sliceDoc(to - SearchMargin, to);
    }
    let startSpace = /^\s*/.exec(startText)[0].length, endSpace = /\s*$/.exec(endText)[0].length;
    let endOff = endText.length - endSpace - close.length;
    if (startText.slice(startSpace, startSpace + open.length) == open &&
        endText.slice(endOff, endOff + close.length) == close) {
        return { open: { pos: from + startSpace + open.length,
                margin: /\s/.test(startText.charAt(startSpace + open.length)) ? 1 : 0 },
            close: { pos: to - endSpace - close.length,
                margin: /\s/.test(endText.charAt(endOff - 1)) ? 1 : 0 } };
    }
    return null;
}
function selectedLineRanges(state) {
    let ranges = [];
    for (let r of state.selection.ranges) {
        let fromLine = state.doc.lineAt(r.from);
        let toLine = r.to <= fromLine.to ? fromLine : state.doc.lineAt(r.to);
        let last = ranges.length - 1;
        if (last >= 0 && ranges[last].to > fromLine.from)
            ranges[last].to = toLine.to;
        else
            ranges.push({ from: fromLine.from, to: toLine.to });
    }
    return ranges;
}
// Performs toggle, comment and uncomment of block comments in
// languages that support them.
function changeBlockComment(option, state, ranges = state.selection.ranges) {
    let tokens = ranges.map(r => getConfig(state, r.from).block);
    if (!tokens.every(c => c))
        return null;
    let comments = ranges.map((r, i) => findBlockComment(state, tokens[i], r.from, r.to));
    if (option != 2 /* CommentOption.Uncomment */ && !comments.every(c => c)) {
        return { changes: state.changes(ranges.map((range, i) => {
                if (comments[i])
                    return [];
                return [{ from: range.from, insert: tokens[i].open + " " }, { from: range.to, insert: " " + tokens[i].close }];
            })) };
    }
    else if (option != 1 /* CommentOption.Comment */ && comments.some(c => c)) {
        let changes = [];
        for (let i = 0, comment; i < comments.length; i++)
            if (comment = comments[i]) {
                let token = tokens[i], { open, close } = comment;
                changes.push({ from: open.pos - token.open.length, to: open.pos + open.margin }, { from: close.pos - close.margin, to: close.pos + token.close.length });
            }
        return { changes };
    }
    return null;
}
// Performs toggle, comment and uncomment of line comments.
function changeLineComment(option, state, ranges = state.selection.ranges) {
    let lines = [];
    let prevLine = -1;
    for (let { from, to } of ranges) {
        let startI = lines.length, minIndent = 1e9;
        for (let pos = from; pos <= to;) {
            let line = state.doc.lineAt(pos);
            if (line.from > prevLine && (from == to || to > line.from)) {
                prevLine = line.from;
                let token = getConfig(state, pos).line;
                if (!token)
                    continue;
                let indent = /^\s*/.exec(line.text)[0].length;
                let empty = indent == line.length;
                let comment = line.text.slice(indent, indent + token.length) == token ? indent : -1;
                if (indent < line.text.length && indent < minIndent)
                    minIndent = indent;
                lines.push({ line, comment, token, indent, empty, single: false });
            }
            pos = line.to + 1;
        }
        if (minIndent < 1e9)
            for (let i = startI; i < lines.length; i++)
                if (lines[i].indent < lines[i].line.text.length)
                    lines[i].indent = minIndent;
        if (lines.length == startI + 1)
            lines[startI].single = true;
    }
    if (option != 2 /* CommentOption.Uncomment */ && lines.some(l => l.comment < 0 && (!l.empty || l.single))) {
        let changes = [];
        for (let { line, token, indent, empty, single } of lines)
            if (single || !empty)
                changes.push({ from: line.from + indent, insert: token + " " });
        let changeSet = state.changes(changes);
        return { changes: changeSet, selection: state.selection.map(changeSet, 1) };
    }
    else if (option != 1 /* CommentOption.Comment */ && lines.some(l => l.comment >= 0)) {
        let changes = [];
        for (let { line, comment, token } of lines)
            if (comment >= 0) {
                let from = line.from + comment, to = from + token.length;
                if (line.text[to - line.from] == " ")
                    to++;
                changes.push({ from, to });
            }
        return { changes };
    }
    return null;
}

const fromHistory = /*@__PURE__*/state_dist/* Annotation.define */.q6.define();
/**
Transaction annotation that will prevent that transaction from
being combined with other transactions in the undo history. Given
`"before"`, it'll prevent merging with previous transactions. With
`"after"`, subsequent transactions won't be combined with this
one. With `"full"`, the transaction is isolated on both sides.
*/
const isolateHistory = /*@__PURE__*/state_dist/* Annotation.define */.q6.define();
/**
This facet provides a way to register functions that, given a
transaction, provide a set of effects that the history should
store when inverting the transaction. This can be used to
integrate some kinds of effects in the history, so that they can
be undone (and redone again).
*/
const invertedEffects = /*@__PURE__*/state_dist/* Facet.define */.r$.define();
const historyConfig = /*@__PURE__*/state_dist/* Facet.define */.r$.define({
    combine(configs) {
        return (0,state_dist/* combineConfig */.BO)(configs, {
            minDepth: 100,
            newGroupDelay: 500
        }, { minDepth: Math.max, newGroupDelay: Math.min });
    }
});
function changeEnd(changes) {
    let end = 0;
    changes.iterChangedRanges((_, to) => end = to);
    return end;
}
const historyField_ = /*@__PURE__*/state_dist/* StateField.define */.QQ.define({
    create() {
        return HistoryState.empty;
    },
    update(state, tr) {
        let config = tr.state.facet(historyConfig);
        let fromHist = tr.annotation(fromHistory);
        if (fromHist) {
            let selection = tr.docChanged ? state_dist/* EditorSelection.single */.jT.single(changeEnd(tr.changes)) : undefined;
            let item = HistEvent.fromTransaction(tr, selection), from = fromHist.side;
            let other = from == 0 /* BranchName.Done */ ? state.undone : state.done;
            if (item)
                other = updateBranch(other, other.length, config.minDepth, item);
            else
                other = addSelection(other, tr.startState.selection);
            return new HistoryState(from == 0 /* BranchName.Done */ ? fromHist.rest : other, from == 0 /* BranchName.Done */ ? other : fromHist.rest);
        }
        let isolate = tr.annotation(isolateHistory);
        if (isolate == "full" || isolate == "before")
            state = state.isolate();
        if (tr.annotation(state_dist/* Transaction.addToHistory */.YW.addToHistory) === false)
            return !tr.changes.empty ? state.addMapping(tr.changes.desc) : state;
        let event = HistEvent.fromTransaction(tr);
        let time = tr.annotation(state_dist/* Transaction.time */.YW.time), userEvent = tr.annotation(state_dist/* Transaction.userEvent */.YW.userEvent);
        if (event)
            state = state.addChanges(event, time, userEvent, config.newGroupDelay, config.minDepth);
        else if (tr.selection)
            state = state.addSelection(tr.startState.selection, time, userEvent, config.newGroupDelay);
        if (isolate == "full" || isolate == "after")
            state = state.isolate();
        return state;
    },
    toJSON(value) {
        return { done: value.done.map(e => e.toJSON()), undone: value.undone.map(e => e.toJSON()) };
    },
    fromJSON(json) {
        return new HistoryState(json.done.map(HistEvent.fromJSON), json.undone.map(HistEvent.fromJSON));
    }
});
/**
Create a history extension with the given configuration.
*/
function dist_history(config = {}) {
    return [
        historyField_,
        historyConfig.of(config),
        dist/* EditorView.domEventHandlers */.tk.domEventHandlers({
            beforeinput(e, view) {
                let command = e.inputType == "historyUndo" ? undo : e.inputType == "historyRedo" ? redo : null;
                if (!command)
                    return false;
                e.preventDefault();
                return command(view);
            }
        })
    ];
}
/**
The state field used to store the history data. Should probably
only be used when you want to
[serialize](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) or
[deserialize](https://codemirror.net/6/docs/ref/#state.EditorState^fromJSON) state objects in a way
that preserves history.
*/
const historyField = (/* unused pure expression or super */ null && (historyField_));
function cmd(side, selection) {
    return function ({ state, dispatch }) {
        if (!selection && state.readOnly)
            return false;
        let historyState = state.field(historyField_, false);
        if (!historyState)
            return false;
        let tr = historyState.pop(side, state, selection);
        if (!tr)
            return false;
        dispatch(tr);
        return true;
    };
}
/**
Undo a single group of history events. Returns false if no group
was available.
*/
const undo = /*@__PURE__*/cmd(0 /* BranchName.Done */, false);
/**
Redo a group of history events. Returns false if no group was
available.
*/
const redo = /*@__PURE__*/cmd(1 /* BranchName.Undone */, false);
/**
Undo a change or selection change.
*/
const undoSelection = /*@__PURE__*/cmd(0 /* BranchName.Done */, true);
/**
Redo a change or selection change.
*/
const redoSelection = /*@__PURE__*/cmd(1 /* BranchName.Undone */, true);
function depth(side) {
    return function (state) {
        let histState = state.field(historyField_, false);
        if (!histState)
            return 0;
        let branch = side == 0 /* BranchName.Done */ ? histState.done : histState.undone;
        return branch.length - (branch.length && !branch[0].changes ? 1 : 0);
    };
}
/**
The amount of undoable change events available in a given state.
*/
const undoDepth = /*@__PURE__*/(/* unused pure expression or super */ null && (depth(0 /* BranchName.Done */)));
/**
The amount of redoable change events available in a given state.
*/
const redoDepth = /*@__PURE__*/(/* unused pure expression or super */ null && (depth(1 /* BranchName.Undone */)));
// History events store groups of changes or effects that need to be
// undone/redone together.
class HistEvent {
    constructor(
    // The changes in this event. Normal events hold at least one
    // change or effect. But it may be necessary to store selection
    // events before the first change, in which case a special type of
    // instance is created which doesn't hold any changes, with
    // changes == startSelection == undefined
    changes, 
    // The effects associated with this event
    effects, 
    // Accumulated mapping (from addToHistory==false) that should be
    // applied to events below this one.
    mapped, 
    // The selection before this event
    startSelection, 
    // Stores selection changes after this event, to be used for
    // selection undo/redo.
    selectionsAfter) {
        this.changes = changes;
        this.effects = effects;
        this.mapped = mapped;
        this.startSelection = startSelection;
        this.selectionsAfter = selectionsAfter;
    }
    setSelAfter(after) {
        return new HistEvent(this.changes, this.effects, this.mapped, this.startSelection, after);
    }
    toJSON() {
        var _a, _b, _c;
        return {
            changes: (_a = this.changes) === null || _a === void 0 ? void 0 : _a.toJSON(),
            mapped: (_b = this.mapped) === null || _b === void 0 ? void 0 : _b.toJSON(),
            startSelection: (_c = this.startSelection) === null || _c === void 0 ? void 0 : _c.toJSON(),
            selectionsAfter: this.selectionsAfter.map(s => s.toJSON())
        };
    }
    static fromJSON(json) {
        return new HistEvent(json.changes && state_dist/* ChangeSet.fromJSON */.as.fromJSON(json.changes), [], json.mapped && state_dist/* ChangeDesc.fromJSON */.n0.fromJSON(json.mapped), json.startSelection && state_dist/* EditorSelection.fromJSON */.jT.fromJSON(json.startSelection), json.selectionsAfter.map(state_dist/* EditorSelection.fromJSON */.jT.fromJSON));
    }
    // This does not check `addToHistory` and such, it assumes the
    // transaction needs to be converted to an item. Returns null when
    // there are no changes or effects in the transaction.
    static fromTransaction(tr, selection) {
        let effects = none;
        for (let invert of tr.startState.facet(invertedEffects)) {
            let result = invert(tr);
            if (result.length)
                effects = effects.concat(result);
        }
        if (!effects.length && tr.changes.empty)
            return null;
        return new HistEvent(tr.changes.invert(tr.startState.doc), effects, undefined, selection || tr.startState.selection, none);
    }
    static selection(selections) {
        return new HistEvent(undefined, none, undefined, undefined, selections);
    }
}
function updateBranch(branch, to, maxLen, newEvent) {
    let start = to + 1 > maxLen + 20 ? to - maxLen - 1 : 0;
    let newBranch = branch.slice(start, to);
    newBranch.push(newEvent);
    return newBranch;
}
function isAdjacent(a, b) {
    let ranges = [], isAdjacent = false;
    a.iterChangedRanges((f, t) => ranges.push(f, t));
    b.iterChangedRanges((_f, _t, f, t) => {
        for (let i = 0; i < ranges.length;) {
            let from = ranges[i++], to = ranges[i++];
            if (t >= from && f <= to)
                isAdjacent = true;
        }
    });
    return isAdjacent;
}
function eqSelectionShape(a, b) {
    return a.ranges.length == b.ranges.length &&
        a.ranges.filter((r, i) => r.empty != b.ranges[i].empty).length === 0;
}
function conc(a, b) {
    return !a.length ? b : !b.length ? a : a.concat(b);
}
const none = [];
const MaxSelectionsPerEvent = 200;
function addSelection(branch, selection) {
    if (!branch.length) {
        return [HistEvent.selection([selection])];
    }
    else {
        let lastEvent = branch[branch.length - 1];
        let sels = lastEvent.selectionsAfter.slice(Math.max(0, lastEvent.selectionsAfter.length - MaxSelectionsPerEvent));
        if (sels.length && sels[sels.length - 1].eq(selection))
            return branch;
        sels.push(selection);
        return updateBranch(branch, branch.length - 1, 1e9, lastEvent.setSelAfter(sels));
    }
}
// Assumes the top item has one or more selectionAfter values
function popSelection(branch) {
    let last = branch[branch.length - 1];
    let newBranch = branch.slice();
    newBranch[branch.length - 1] = last.setSelAfter(last.selectionsAfter.slice(0, last.selectionsAfter.length - 1));
    return newBranch;
}
// Add a mapping to the top event in the given branch. If this maps
// away all the changes and effects in that item, drop it and
// propagate the mapping to the next item.
function addMappingToBranch(branch, mapping) {
    if (!branch.length)
        return branch;
    let length = branch.length, selections = none;
    while (length) {
        let event = mapEvent(branch[length - 1], mapping, selections);
        if (event.changes && !event.changes.empty || event.effects.length) { // Event survived mapping
            let result = branch.slice(0, length);
            result[length - 1] = event;
            return result;
        }
        else { // Drop this event, since there's no changes or effects left
            mapping = event.mapped;
            length--;
            selections = event.selectionsAfter;
        }
    }
    return selections.length ? [HistEvent.selection(selections)] : none;
}
function mapEvent(event, mapping, extraSelections) {
    let selections = conc(event.selectionsAfter.length ? event.selectionsAfter.map(s => s.map(mapping)) : none, extraSelections);
    // Change-less events don't store mappings (they are always the last event in a branch)
    if (!event.changes)
        return HistEvent.selection(selections);
    let mappedChanges = event.changes.map(mapping), before = mapping.mapDesc(event.changes, true);
    let fullMapping = event.mapped ? event.mapped.composeDesc(before) : before;
    return new HistEvent(mappedChanges, state_dist/* StateEffect.mapEffects */.Py.mapEffects(event.effects, mapping), fullMapping, event.startSelection.map(before), selections);
}
const joinableUserEvent = /^(input\.type|delete)($|\.)/;
class HistoryState {
    constructor(done, undone, prevTime = 0, prevUserEvent = undefined) {
        this.done = done;
        this.undone = undone;
        this.prevTime = prevTime;
        this.prevUserEvent = prevUserEvent;
    }
    isolate() {
        return this.prevTime ? new HistoryState(this.done, this.undone) : this;
    }
    addChanges(event, time, userEvent, newGroupDelay, maxLen) {
        let done = this.done, lastEvent = done[done.length - 1];
        if (lastEvent && lastEvent.changes && !lastEvent.changes.empty && event.changes &&
            (!userEvent || joinableUserEvent.test(userEvent)) &&
            ((!lastEvent.selectionsAfter.length &&
                time - this.prevTime < newGroupDelay &&
                isAdjacent(lastEvent.changes, event.changes)) ||
                // For compose (but not compose.start) events, always join with previous event
                userEvent == "input.type.compose")) {
            done = updateBranch(done, done.length - 1, maxLen, new HistEvent(event.changes.compose(lastEvent.changes), conc(event.effects, lastEvent.effects), lastEvent.mapped, lastEvent.startSelection, none));
        }
        else {
            done = updateBranch(done, done.length, maxLen, event);
        }
        return new HistoryState(done, none, time, userEvent);
    }
    addSelection(selection, time, userEvent, newGroupDelay) {
        let last = this.done.length ? this.done[this.done.length - 1].selectionsAfter : none;
        if (last.length > 0 &&
            time - this.prevTime < newGroupDelay &&
            userEvent == this.prevUserEvent && userEvent && /^select($|\.)/.test(userEvent) &&
            eqSelectionShape(last[last.length - 1], selection))
            return this;
        return new HistoryState(addSelection(this.done, selection), this.undone, time, userEvent);
    }
    addMapping(mapping) {
        return new HistoryState(addMappingToBranch(this.done, mapping), addMappingToBranch(this.undone, mapping), this.prevTime, this.prevUserEvent);
    }
    pop(side, state, selection) {
        let branch = side == 0 /* BranchName.Done */ ? this.done : this.undone;
        if (branch.length == 0)
            return null;
        let event = branch[branch.length - 1];
        if (selection && event.selectionsAfter.length) {
            return state.update({
                selection: event.selectionsAfter[event.selectionsAfter.length - 1],
                annotations: fromHistory.of({ side, rest: popSelection(branch) }),
                userEvent: side == 0 /* BranchName.Done */ ? "select.undo" : "select.redo",
                scrollIntoView: true
            });
        }
        else if (!event.changes) {
            return null;
        }
        else {
            let rest = branch.length == 1 ? none : branch.slice(0, branch.length - 1);
            if (event.mapped)
                rest = addMappingToBranch(rest, event.mapped);
            return state.update({
                changes: event.changes,
                selection: event.startSelection,
                effects: event.effects,
                annotations: fromHistory.of({ side, rest }),
                filter: false,
                userEvent: side == 0 /* BranchName.Done */ ? "undo" : "redo",
                scrollIntoView: true
            });
        }
    }
}
HistoryState.empty = /*@__PURE__*/new HistoryState(none, none);
/**
Default key bindings for the undo history.

- Mod-z: [`undo`](https://codemirror.net/6/docs/ref/#commands.undo).
- Mod-y (Mod-Shift-z on macOS) + Ctrl-Shift-z on Linux: [`redo`](https://codemirror.net/6/docs/ref/#commands.redo).
- Mod-u: [`undoSelection`](https://codemirror.net/6/docs/ref/#commands.undoSelection).
- Alt-u (Mod-Shift-u on macOS): [`redoSelection`](https://codemirror.net/6/docs/ref/#commands.redoSelection).
*/
const historyKeymap = [
    { key: "Mod-z", run: undo, preventDefault: true },
    { key: "Mod-y", mac: "Mod-Shift-z", run: redo, preventDefault: true },
    { linux: "Ctrl-Shift-z", run: redo, preventDefault: true },
    { key: "Mod-u", run: undoSelection, preventDefault: true },
    { key: "Alt-u", mac: "Mod-Shift-u", run: redoSelection, preventDefault: true }
];

function updateSel(sel, by) {
    return state_dist/* EditorSelection.create */.jT.create(sel.ranges.map(by), sel.mainIndex);
}
function setSel(state, selection) {
    return state.update({ selection, scrollIntoView: true, userEvent: "select" });
}
function moveSel({ state, dispatch }, how) {
    let selection = updateSel(state.selection, how);
    if (selection.eq(state.selection))
        return false;
    dispatch(setSel(state, selection));
    return true;
}
function rangeEnd(range, forward) {
    return state_dist/* EditorSelection.cursor */.jT.cursor(forward ? range.to : range.from);
}
function cursorByChar(view, forward) {
    return moveSel(view, range => range.empty ? view.moveByChar(range, forward) : rangeEnd(range, forward));
}
function ltrAtCursor(view) {
    return view.textDirectionAt(view.state.selection.main.head) == dist/* Direction.LTR */.Nm.LTR;
}
/**
Move the selection one character to the left (which is backward in
left-to-right text, forward in right-to-left text).
*/
const cursorCharLeft = view => cursorByChar(view, !ltrAtCursor(view));
/**
Move the selection one character to the right.
*/
const cursorCharRight = view => cursorByChar(view, ltrAtCursor(view));
/**
Move the selection one character forward.
*/
const cursorCharForward = view => cursorByChar(view, true);
/**
Move the selection one character backward.
*/
const cursorCharBackward = view => cursorByChar(view, false);
function cursorByGroup(view, forward) {
    return moveSel(view, range => range.empty ? view.moveByGroup(range, forward) : rangeEnd(range, forward));
}
/**
Move the selection to the left across one group of word or
non-word (but also non-space) characters.
*/
const cursorGroupLeft = view => cursorByGroup(view, !ltrAtCursor(view));
/**
Move the selection one group to the right.
*/
const cursorGroupRight = view => cursorByGroup(view, ltrAtCursor(view));
/**
Move the selection one group forward.
*/
const cursorGroupForward = view => cursorByGroup(view, true);
/**
Move the selection one group backward.
*/
const cursorGroupBackward = view => cursorByGroup(view, false);
function moveBySubword(view, range, forward) {
    let categorize = view.state.charCategorizer(range.from);
    return view.moveByChar(range, forward, start => {
        let cat = CharCategory.Space, pos = range.from;
        let done = false, sawUpper = false, sawLower = false;
        let step = (next) => {
            if (done)
                return false;
            pos += forward ? next.length : -next.length;
            let nextCat = categorize(next), ahead;
            if (cat == CharCategory.Space)
                cat = nextCat;
            if (cat != nextCat)
                return false;
            if (cat == CharCategory.Word) {
                if (next.toLowerCase() == next) {
                    if (!forward && sawUpper)
                        return false;
                    sawLower = true;
                }
                else if (sawLower) {
                    if (forward)
                        return false;
                    done = true;
                }
                else {
                    if (sawUpper && forward && categorize(ahead = view.state.sliceDoc(pos, pos + 1)) == CharCategory.Word &&
                        ahead.toLowerCase() == ahead)
                        return false;
                    sawUpper = true;
                }
            }
            return true;
        };
        step(start);
        return step;
    });
}
function cursorBySubword(view, forward) {
    return moveSel(view, range => range.empty ? moveBySubword(view, range, forward) : rangeEnd(range, forward));
}
/**
Move the selection one group or camel-case subword forward.
*/
const cursorSubwordForward = view => cursorBySubword(view, true);
/**
Move the selection one group or camel-case subword backward.
*/
const cursorSubwordBackward = view => cursorBySubword(view, false);
function interestingNode(state, node, bracketProp) {
    if (node.type.prop(bracketProp))
        return true;
    let len = node.to - node.from;
    return len && (len > 2 || /[^\s,.;:]/.test(state.sliceDoc(node.from, node.to))) || node.firstChild;
}
function moveBySyntax(state, start, forward) {
    let pos = syntaxTree(state).resolveInner(start.head);
    let bracketProp = forward ? NodeProp.closedBy : NodeProp.openedBy;
    // Scan forward through child nodes to see if there's an interesting
    // node ahead.
    for (let at = start.head;;) {
        let next = forward ? pos.childAfter(at) : pos.childBefore(at);
        if (!next)
            break;
        if (interestingNode(state, next, bracketProp))
            pos = next;
        else
            at = forward ? next.to : next.from;
    }
    let bracket = pos.type.prop(bracketProp), match, newPos;
    if (bracket && (match = forward ? matchBrackets(state, pos.from, 1) : matchBrackets(state, pos.to, -1)) && match.matched)
        newPos = forward ? match.end.to : match.end.from;
    else
        newPos = forward ? pos.to : pos.from;
    return EditorSelection.cursor(newPos, forward ? -1 : 1);
}
/**
Move the cursor over the next syntactic element to the left.
*/
const cursorSyntaxLeft = view => moveSel(view, range => moveBySyntax(view.state, range, !ltrAtCursor(view)));
/**
Move the cursor over the next syntactic element to the right.
*/
const cursorSyntaxRight = view => moveSel(view, range => moveBySyntax(view.state, range, ltrAtCursor(view)));
function cursorByLine(view, forward) {
    return moveSel(view, range => {
        if (!range.empty)
            return rangeEnd(range, forward);
        let moved = view.moveVertically(range, forward);
        return moved.head != range.head ? moved : view.moveToLineBoundary(range, forward);
    });
}
/**
Move the selection one line up.
*/
const cursorLineUp = view => cursorByLine(view, false);
/**
Move the selection one line down.
*/
const cursorLineDown = view => cursorByLine(view, true);
function pageHeight(view) {
    return Math.max(view.defaultLineHeight, Math.min(view.dom.clientHeight, innerHeight) - 5);
}
function cursorByPage(view, forward) {
    let { state } = view, selection = updateSel(state.selection, range => {
        return range.empty ? view.moveVertically(range, forward, pageHeight(view)) : rangeEnd(range, forward);
    });
    if (selection.eq(state.selection))
        return false;
    let startPos = view.coordsAtPos(state.selection.main.head);
    let scrollRect = view.scrollDOM.getBoundingClientRect();
    let effect;
    if (startPos && startPos.top > scrollRect.top && startPos.bottom < scrollRect.bottom &&
        startPos.top - scrollRect.top <= view.scrollDOM.scrollHeight - view.scrollDOM.scrollTop - view.scrollDOM.clientHeight)
        effect = dist/* EditorView.scrollIntoView */.tk.scrollIntoView(selection.main.head, { y: "start", yMargin: startPos.top - scrollRect.top });
    view.dispatch(setSel(state, selection), { effects: effect });
    return true;
}
/**
Move the selection one page up.
*/
const cursorPageUp = view => cursorByPage(view, false);
/**
Move the selection one page down.
*/
const cursorPageDown = view => cursorByPage(view, true);
function moveByLineBoundary(view, start, forward) {
    let line = view.lineBlockAt(start.head), moved = view.moveToLineBoundary(start, forward);
    if (moved.head == start.head && moved.head != (forward ? line.to : line.from))
        moved = view.moveToLineBoundary(start, forward, false);
    if (!forward && moved.head == line.from && line.length) {
        let space = /^\s*/.exec(view.state.sliceDoc(line.from, Math.min(line.from + 100, line.to)))[0].length;
        if (space && start.head != line.from + space)
            moved = state_dist/* EditorSelection.cursor */.jT.cursor(line.from + space);
    }
    return moved;
}
/**
Move the selection to the next line wrap point, or to the end of
the line if there isn't one left on this line.
*/
const cursorLineBoundaryForward = view => moveSel(view, range => moveByLineBoundary(view, range, true));
/**
Move the selection to previous line wrap point, or failing that to
the start of the line. If the line is indented, and the cursor
isn't already at the end of the indentation, this will move to the
end of the indentation instead of the start of the line.
*/
const cursorLineBoundaryBackward = view => moveSel(view, range => moveByLineBoundary(view, range, false));
/**
Move the selection one line wrap point to the left.
*/
const cursorLineBoundaryLeft = view => moveSel(view, range => moveByLineBoundary(view, range, !ltrAtCursor(view)));
/**
Move the selection one line wrap point to the right.
*/
const cursorLineBoundaryRight = view => moveSel(view, range => moveByLineBoundary(view, range, ltrAtCursor(view)));
/**
Move the selection to the start of the line.
*/
const cursorLineStart = view => moveSel(view, range => state_dist/* EditorSelection.cursor */.jT.cursor(view.lineBlockAt(range.head).from, 1));
/**
Move the selection to the end of the line.
*/
const cursorLineEnd = view => moveSel(view, range => state_dist/* EditorSelection.cursor */.jT.cursor(view.lineBlockAt(range.head).to, -1));
function toMatchingBracket(state, dispatch, extend) {
    let found = false, selection = updateSel(state.selection, range => {
        let matching = matchBrackets(state, range.head, -1)
            || matchBrackets(state, range.head, 1)
            || (range.head > 0 && matchBrackets(state, range.head - 1, 1))
            || (range.head < state.doc.length && matchBrackets(state, range.head + 1, -1));
        if (!matching || !matching.end)
            return range;
        found = true;
        let head = matching.start.from == range.head ? matching.end.to : matching.end.from;
        return extend ? EditorSelection.range(range.anchor, head) : EditorSelection.cursor(head);
    });
    if (!found)
        return false;
    dispatch(setSel(state, selection));
    return true;
}
/**
Move the selection to the bracket matching the one it is currently
on, if any.
*/
const cursorMatchingBracket = ({ state, dispatch }) => toMatchingBracket(state, dispatch, false);
/**
Extend the selection to the bracket matching the one the selection
head is currently on, if any.
*/
const selectMatchingBracket = ({ state, dispatch }) => toMatchingBracket(state, dispatch, true);
function extendSel(view, how) {
    let selection = updateSel(view.state.selection, range => {
        let head = how(range);
        return state_dist/* EditorSelection.range */.jT.range(range.anchor, head.head, head.goalColumn);
    });
    if (selection.eq(view.state.selection))
        return false;
    view.dispatch(setSel(view.state, selection));
    return true;
}
function selectByChar(view, forward) {
    return extendSel(view, range => view.moveByChar(range, forward));
}
/**
Move the selection head one character to the left, while leaving
the anchor in place.
*/
const selectCharLeft = view => selectByChar(view, !ltrAtCursor(view));
/**
Move the selection head one character to the right.
*/
const selectCharRight = view => selectByChar(view, ltrAtCursor(view));
/**
Move the selection head one character forward.
*/
const selectCharForward = view => selectByChar(view, true);
/**
Move the selection head one character backward.
*/
const selectCharBackward = view => selectByChar(view, false);
function selectByGroup(view, forward) {
    return extendSel(view, range => view.moveByGroup(range, forward));
}
/**
Move the selection head one [group](https://codemirror.net/6/docs/ref/#commands.cursorGroupLeft) to
the left.
*/
const selectGroupLeft = view => selectByGroup(view, !ltrAtCursor(view));
/**
Move the selection head one group to the right.
*/
const selectGroupRight = view => selectByGroup(view, ltrAtCursor(view));
/**
Move the selection head one group forward.
*/
const selectGroupForward = view => selectByGroup(view, true);
/**
Move the selection head one group backward.
*/
const selectGroupBackward = view => selectByGroup(view, false);
function selectBySubword(view, forward) {
    return extendSel(view, range => moveBySubword(view, range, forward));
}
/**
Move the selection head one group or camel-case subword forward.
*/
const selectSubwordForward = view => selectBySubword(view, true);
/**
Move the selection head one group or subword backward.
*/
const selectSubwordBackward = view => selectBySubword(view, false);
/**
Move the selection head over the next syntactic element to the left.
*/
const selectSyntaxLeft = view => extendSel(view, range => moveBySyntax(view.state, range, !ltrAtCursor(view)));
/**
Move the selection head over the next syntactic element to the right.
*/
const selectSyntaxRight = view => extendSel(view, range => moveBySyntax(view.state, range, ltrAtCursor(view)));
function selectByLine(view, forward) {
    return extendSel(view, range => view.moveVertically(range, forward));
}
/**
Move the selection head one line up.
*/
const selectLineUp = view => selectByLine(view, false);
/**
Move the selection head one line down.
*/
const selectLineDown = view => selectByLine(view, true);
function selectByPage(view, forward) {
    return extendSel(view, range => view.moveVertically(range, forward, pageHeight(view)));
}
/**
Move the selection head one page up.
*/
const selectPageUp = view => selectByPage(view, false);
/**
Move the selection head one page down.
*/
const selectPageDown = view => selectByPage(view, true);
/**
Move the selection head to the next line boundary.
*/
const selectLineBoundaryForward = view => extendSel(view, range => moveByLineBoundary(view, range, true));
/**
Move the selection head to the previous line boundary.
*/
const selectLineBoundaryBackward = view => extendSel(view, range => moveByLineBoundary(view, range, false));
/**
Move the selection head one line boundary to the left.
*/
const selectLineBoundaryLeft = view => extendSel(view, range => moveByLineBoundary(view, range, !ltrAtCursor(view)));
/**
Move the selection head one line boundary to the right.
*/
const selectLineBoundaryRight = view => extendSel(view, range => moveByLineBoundary(view, range, ltrAtCursor(view)));
/**
Move the selection head to the start of the line.
*/
const selectLineStart = view => extendSel(view, range => state_dist/* EditorSelection.cursor */.jT.cursor(view.lineBlockAt(range.head).from));
/**
Move the selection head to the end of the line.
*/
const selectLineEnd = view => extendSel(view, range => state_dist/* EditorSelection.cursor */.jT.cursor(view.lineBlockAt(range.head).to));
/**
Move the selection to the start of the document.
*/
const cursorDocStart = ({ state, dispatch }) => {
    dispatch(setSel(state, { anchor: 0 }));
    return true;
};
/**
Move the selection to the end of the document.
*/
const cursorDocEnd = ({ state, dispatch }) => {
    dispatch(setSel(state, { anchor: state.doc.length }));
    return true;
};
/**
Move the selection head to the start of the document.
*/
const selectDocStart = ({ state, dispatch }) => {
    dispatch(setSel(state, { anchor: state.selection.main.anchor, head: 0 }));
    return true;
};
/**
Move the selection head to the end of the document.
*/
const selectDocEnd = ({ state, dispatch }) => {
    dispatch(setSel(state, { anchor: state.selection.main.anchor, head: state.doc.length }));
    return true;
};
/**
Select the entire document.
*/
const selectAll = ({ state, dispatch }) => {
    dispatch(state.update({ selection: { anchor: 0, head: state.doc.length }, userEvent: "select" }));
    return true;
};
/**
Expand the selection to cover entire lines.
*/
const selectLine = ({ state, dispatch }) => {
    let ranges = selectedLineBlocks(state).map(({ from, to }) => EditorSelection.range(from, Math.min(to + 1, state.doc.length)));
    dispatch(state.update({ selection: EditorSelection.create(ranges), userEvent: "select" }));
    return true;
};
/**
Select the next syntactic construct that is larger than the
selection. Note that this will only work insofar as the language
[provider](https://codemirror.net/6/docs/ref/#language.language) you use builds up a full
syntax tree.
*/
const selectParentSyntax = ({ state, dispatch }) => {
    let selection = updateSel(state.selection, range => {
        var _a;
        let context = syntaxTree(state).resolveInner(range.head, 1);
        while (!((context.from < range.from && context.to >= range.to) ||
            (context.to > range.to && context.from <= range.from) ||
            !((_a = context.parent) === null || _a === void 0 ? void 0 : _a.parent)))
            context = context.parent;
        return EditorSelection.range(context.to, context.from);
    });
    dispatch(setSel(state, selection));
    return true;
};
/**
Simplify the current selection. When multiple ranges are selected,
reduce it to its main range. Otherwise, if the selection is
non-empty, convert it to a cursor selection.
*/
const simplifySelection = ({ state, dispatch }) => {
    let cur = state.selection, selection = null;
    if (cur.ranges.length > 1)
        selection = EditorSelection.create([cur.main]);
    else if (!cur.main.empty)
        selection = EditorSelection.create([EditorSelection.cursor(cur.main.head)]);
    if (!selection)
        return false;
    dispatch(setSel(state, selection));
    return true;
};
function deleteBy(target, by) {
    if (target.state.readOnly)
        return false;
    let event = "delete.selection", { state } = target;
    let changes = state.changeByRange(range => {
        let { from, to } = range;
        if (from == to) {
            let towards = by(from);
            if (towards < from) {
                event = "delete.backward";
                towards = skipAtomic(target, towards, false);
            }
            else if (towards > from) {
                event = "delete.forward";
                towards = skipAtomic(target, towards, true);
            }
            from = Math.min(from, towards);
            to = Math.max(to, towards);
        }
        else {
            from = skipAtomic(target, from, false);
            to = skipAtomic(target, from, true);
        }
        return from == to ? { range } : { changes: { from, to }, range: state_dist/* EditorSelection.cursor */.jT.cursor(from) };
    });
    if (changes.changes.empty)
        return false;
    target.dispatch(state.update(changes, {
        scrollIntoView: true,
        userEvent: event,
        effects: event == "delete.selection" ? dist/* EditorView.announce.of */.tk.announce.of(state.phrase("Selection deleted")) : undefined
    }));
    return true;
}
function skipAtomic(target, pos, forward) {
    if (target instanceof dist/* EditorView */.tk)
        for (let ranges of target.state.facet(dist/* EditorView.atomicRanges */.tk.atomicRanges).map(f => f(target)))
            ranges.between(pos, pos, (from, to) => {
                if (from < pos && to > pos)
                    pos = forward ? to : from;
            });
    return pos;
}
const deleteByChar = (target, forward) => deleteBy(target, pos => {
    let { state } = target, line = state.doc.lineAt(pos), before, targetPos;
    if (!forward && pos > line.from && pos < line.from + 200 &&
        !/[^ \t]/.test(before = line.text.slice(0, pos - line.from))) {
        if (before[before.length - 1] == "\t")
            return pos - 1;
        let col = (0,state_dist/* countColumn */.IS)(before, state.tabSize), drop = col % (0,language_dist/* getIndentUnit */.y1)(state) || (0,language_dist/* getIndentUnit */.y1)(state);
        for (let i = 0; i < drop && before[before.length - 1 - i] == " "; i++)
            pos--;
        targetPos = pos;
    }
    else {
        targetPos = (0,state_dist/* findClusterBreak */.cp)(line.text, pos - line.from, forward, forward) + line.from;
        if (targetPos == pos && line.number != (forward ? state.doc.lines : 1))
            targetPos += forward ? 1 : -1;
    }
    return targetPos;
});
/**
Delete the selection, or, for cursor selections, the character
before the cursor.
*/
const deleteCharBackward = view => deleteByChar(view, false);
/**
Delete the selection or the character after the cursor.
*/
const deleteCharForward = view => deleteByChar(view, true);
const deleteByGroup = (target, forward) => deleteBy(target, start => {
    let pos = start, { state } = target, line = state.doc.lineAt(pos);
    let categorize = state.charCategorizer(pos);
    for (let cat = null;;) {
        if (pos == (forward ? line.to : line.from)) {
            if (pos == start && line.number != (forward ? state.doc.lines : 1))
                pos += forward ? 1 : -1;
            break;
        }
        let next = (0,state_dist/* findClusterBreak */.cp)(line.text, pos - line.from, forward) + line.from;
        let nextChar = line.text.slice(Math.min(pos, next) - line.from, Math.max(pos, next) - line.from);
        let nextCat = categorize(nextChar);
        if (cat != null && nextCat != cat)
            break;
        if (nextChar != " " || pos != start)
            cat = nextCat;
        pos = next;
    }
    return pos;
});
/**
Delete the selection or backward until the end of the next
[group](https://codemirror.net/6/docs/ref/#view.EditorView.moveByGroup), only skipping groups of
whitespace when they consist of a single space.
*/
const deleteGroupBackward = target => deleteByGroup(target, false);
/**
Delete the selection or forward until the end of the next group.
*/
const deleteGroupForward = target => deleteByGroup(target, true);
/**
Delete the selection, or, if it is a cursor selection, delete to
the end of the line. If the cursor is directly at the end of the
line, delete the line break after it.
*/
const deleteToLineEnd = view => deleteBy(view, pos => {
    let lineEnd = view.lineBlockAt(pos).to;
    return pos < lineEnd ? lineEnd : Math.min(view.state.doc.length, pos + 1);
});
/**
Delete the selection, or, if it is a cursor selection, delete to
the start of the line. If the cursor is directly at the start of the
line, delete the line break before it.
*/
const deleteToLineStart = view => deleteBy(view, pos => {
    let lineStart = view.lineBlockAt(pos).from;
    return pos > lineStart ? lineStart : Math.max(0, pos - 1);
});
/**
Delete all whitespace directly before a line end from the
document.
*/
const deleteTrailingWhitespace = ({ state, dispatch }) => {
    if (state.readOnly)
        return false;
    let changes = [];
    for (let pos = 0, prev = "", iter = state.doc.iter();;) {
        iter.next();
        if (iter.lineBreak || iter.done) {
            let trailing = prev.search(/\s+$/);
            if (trailing > -1)
                changes.push({ from: pos - (prev.length - trailing), to: pos });
            if (iter.done)
                break;
            prev = "";
        }
        else {
            prev = iter.value;
        }
        pos += iter.value.length;
    }
    if (!changes.length)
        return false;
    dispatch(state.update({ changes, userEvent: "delete" }));
    return true;
};
/**
Replace each selection range with a line break, leaving the cursor
on the line before the break.
*/
const splitLine = ({ state, dispatch }) => {
    if (state.readOnly)
        return false;
    let changes = state.changeByRange(range => {
        return { changes: { from: range.from, to: range.to, insert: state_dist/* Text.of */.xv.of(["", ""]) },
            range: state_dist/* EditorSelection.cursor */.jT.cursor(range.from) };
    });
    dispatch(state.update(changes, { scrollIntoView: true, userEvent: "input" }));
    return true;
};
/**
Flip the characters before and after the cursor(s).
*/
const transposeChars = ({ state, dispatch }) => {
    if (state.readOnly)
        return false;
    let changes = state.changeByRange(range => {
        if (!range.empty || range.from == 0 || range.from == state.doc.length)
            return { range };
        let pos = range.from, line = state.doc.lineAt(pos);
        let from = pos == line.from ? pos - 1 : (0,state_dist/* findClusterBreak */.cp)(line.text, pos - line.from, false) + line.from;
        let to = pos == line.to ? pos + 1 : (0,state_dist/* findClusterBreak */.cp)(line.text, pos - line.from, true) + line.from;
        return { changes: { from, to, insert: state.doc.slice(pos, to).append(state.doc.slice(from, pos)) },
            range: state_dist/* EditorSelection.cursor */.jT.cursor(to) };
    });
    if (changes.changes.empty)
        return false;
    dispatch(state.update(changes, { scrollIntoView: true, userEvent: "move.character" }));
    return true;
};
function selectedLineBlocks(state) {
    let blocks = [], upto = -1;
    for (let range of state.selection.ranges) {
        let startLine = state.doc.lineAt(range.from), endLine = state.doc.lineAt(range.to);
        if (!range.empty && range.to == endLine.from)
            endLine = state.doc.lineAt(range.to - 1);
        if (upto >= startLine.number) {
            let prev = blocks[blocks.length - 1];
            prev.to = endLine.to;
            prev.ranges.push(range);
        }
        else {
            blocks.push({ from: startLine.from, to: endLine.to, ranges: [range] });
        }
        upto = endLine.number + 1;
    }
    return blocks;
}
function moveLine(state, dispatch, forward) {
    if (state.readOnly)
        return false;
    let changes = [], ranges = [];
    for (let block of selectedLineBlocks(state)) {
        if (forward ? block.to == state.doc.length : block.from == 0)
            continue;
        let nextLine = state.doc.lineAt(forward ? block.to + 1 : block.from - 1);
        let size = nextLine.length + 1;
        if (forward) {
            changes.push({ from: block.to, to: nextLine.to }, { from: block.from, insert: nextLine.text + state.lineBreak });
            for (let r of block.ranges)
                ranges.push(EditorSelection.range(Math.min(state.doc.length, r.anchor + size), Math.min(state.doc.length, r.head + size)));
        }
        else {
            changes.push({ from: nextLine.from, to: block.from }, { from: block.to, insert: state.lineBreak + nextLine.text });
            for (let r of block.ranges)
                ranges.push(EditorSelection.range(r.anchor - size, r.head - size));
        }
    }
    if (!changes.length)
        return false;
    dispatch(state.update({
        changes,
        scrollIntoView: true,
        selection: EditorSelection.create(ranges, state.selection.mainIndex),
        userEvent: "move.line"
    }));
    return true;
}
/**
Move the selected lines up one line.
*/
const moveLineUp = ({ state, dispatch }) => moveLine(state, dispatch, false);
/**
Move the selected lines down one line.
*/
const moveLineDown = ({ state, dispatch }) => moveLine(state, dispatch, true);
function copyLine(state, dispatch, forward) {
    if (state.readOnly)
        return false;
    let changes = [];
    for (let block of selectedLineBlocks(state)) {
        if (forward)
            changes.push({ from: block.from, insert: state.doc.slice(block.from, block.to) + state.lineBreak });
        else
            changes.push({ from: block.to, insert: state.lineBreak + state.doc.slice(block.from, block.to) });
    }
    dispatch(state.update({ changes, scrollIntoView: true, userEvent: "input.copyline" }));
    return true;
}
/**
Create a copy of the selected lines. Keep the selection in the top copy.
*/
const copyLineUp = ({ state, dispatch }) => copyLine(state, dispatch, false);
/**
Create a copy of the selected lines. Keep the selection in the bottom copy.
*/
const copyLineDown = ({ state, dispatch }) => copyLine(state, dispatch, true);
/**
Delete selected lines.
*/
const deleteLine = view => {
    if (view.state.readOnly)
        return false;
    let { state } = view, changes = state.changes(selectedLineBlocks(state).map(({ from, to }) => {
        if (from > 0)
            from--;
        else if (to < state.doc.length)
            to++;
        return { from, to };
    }));
    let selection = updateSel(state.selection, range => view.moveVertically(range, true)).map(changes);
    view.dispatch({ changes, selection, scrollIntoView: true, userEvent: "delete.line" });
    return true;
};
/**
Replace the selection with a newline.
*/
const insertNewline = ({ state, dispatch }) => {
    dispatch(state.update(state.replaceSelection(state.lineBreak), { scrollIntoView: true, userEvent: "input" }));
    return true;
};
function isBetweenBrackets(state, pos) {
    if (/\(\)|\[\]|\{\}/.test(state.sliceDoc(pos - 1, pos + 1)))
        return { from: pos, to: pos };
    let context = (0,language_dist/* syntaxTree */.qz)(state).resolveInner(pos);
    let before = context.childBefore(pos), after = context.childAfter(pos), closedBy;
    if (before && after && before.to <= pos && after.from >= pos &&
        (closedBy = before.type.prop(common_dist/* NodeProp.closedBy */.md.closedBy)) && closedBy.indexOf(after.name) > -1 &&
        state.doc.lineAt(before.to).from == state.doc.lineAt(after.from).from)
        return { from: before.to, to: after.from };
    return null;
}
/**
Replace the selection with a newline and indent the newly created
line(s). If the current line consists only of whitespace, this
will also delete that whitespace. When the cursor is between
matching brackets, an additional newline will be inserted after
the cursor.
*/
const insertNewlineAndIndent = /*@__PURE__*/newlineAndIndent(false);
/**
Create a blank, indented line below the current line.
*/
const insertBlankLine = /*@__PURE__*/(/* unused pure expression or super */ null && (newlineAndIndent(true)));
function newlineAndIndent(atEof) {
    return ({ state, dispatch }) => {
        if (state.readOnly)
            return false;
        let changes = state.changeByRange(range => {
            let { from, to } = range, line = state.doc.lineAt(from);
            let explode = !atEof && from == to && isBetweenBrackets(state, from);
            if (atEof)
                from = to = (to <= line.to ? line : state.doc.lineAt(to)).to;
            let cx = new language_dist/* IndentContext */.Gn(state, { simulateBreak: from, simulateDoubleBreak: !!explode });
            let indent = (0,language_dist/* getIndentation */.K0)(cx, from);
            if (indent == null)
                indent = /^\s*/.exec(state.doc.lineAt(from).text)[0].length;
            while (to < line.to && /\s/.test(line.text[to - line.from]))
                to++;
            if (explode)
                ({ from, to } = explode);
            else if (from > line.from && from < line.from + 100 && !/\S/.test(line.text.slice(0, from)))
                from = line.from;
            let insert = ["", (0,language_dist/* indentString */.SS)(state, indent)];
            if (explode)
                insert.push((0,language_dist/* indentString */.SS)(state, cx.lineIndent(line.from, -1)));
            return { changes: { from, to, insert: state_dist/* Text.of */.xv.of(insert) },
                range: state_dist/* EditorSelection.cursor */.jT.cursor(from + 1 + insert[1].length) };
        });
        dispatch(state.update(changes, { scrollIntoView: true, userEvent: "input" }));
        return true;
    };
}
function changeBySelectedLine(state, f) {
    let atLine = -1;
    return state.changeByRange(range => {
        let changes = [];
        for (let pos = range.from; pos <= range.to;) {
            let line = state.doc.lineAt(pos);
            if (line.number > atLine && (range.empty || range.to > line.from)) {
                f(line, changes, range);
                atLine = line.number;
            }
            pos = line.to + 1;
        }
        let changeSet = state.changes(changes);
        return { changes,
            range: state_dist/* EditorSelection.range */.jT.range(changeSet.mapPos(range.anchor, 1), changeSet.mapPos(range.head, 1)) };
    });
}
/**
Auto-indent the selected lines. This uses the [indentation service
facet](https://codemirror.net/6/docs/ref/#language.indentService) as source for auto-indent
information.
*/
const indentSelection = ({ state, dispatch }) => {
    if (state.readOnly)
        return false;
    let updated = Object.create(null);
    let context = new IndentContext(state, { overrideIndentation: start => {
            let found = updated[start];
            return found == null ? -1 : found;
        } });
    let changes = changeBySelectedLine(state, (line, changes, range) => {
        let indent = getIndentation(context, line.from);
        if (indent == null)
            return;
        if (!/\S/.test(line.text))
            indent = 0;
        let cur = /^\s*/.exec(line.text)[0];
        let norm = indentString(state, indent);
        if (cur != norm || range.from < line.from + cur.length) {
            updated[line.from] = indent;
            changes.push({ from: line.from, to: line.from + cur.length, insert: norm });
        }
    });
    if (!changes.changes.empty)
        dispatch(state.update(changes, { userEvent: "indent" }));
    return true;
};
/**
Add a [unit](https://codemirror.net/6/docs/ref/#language.indentUnit) of indentation to all selected
lines.
*/
const indentMore = ({ state, dispatch }) => {
    if (state.readOnly)
        return false;
    dispatch(state.update(changeBySelectedLine(state, (line, changes) => {
        changes.push({ from: line.from, insert: state.facet(language_dist/* indentUnit */.c) });
    }), { userEvent: "input.indent" }));
    return true;
};
/**
Remove a [unit](https://codemirror.net/6/docs/ref/#language.indentUnit) of indentation from all
selected lines.
*/
const indentLess = ({ state, dispatch }) => {
    if (state.readOnly)
        return false;
    dispatch(state.update(changeBySelectedLine(state, (line, changes) => {
        let space = /^\s*/.exec(line.text)[0];
        if (!space)
            return;
        let col = (0,state_dist/* countColumn */.IS)(space, state.tabSize), keep = 0;
        let insert = (0,language_dist/* indentString */.SS)(state, Math.max(0, col - (0,language_dist/* getIndentUnit */.y1)(state)));
        while (keep < space.length && keep < insert.length && space.charCodeAt(keep) == insert.charCodeAt(keep))
            keep++;
        changes.push({ from: line.from + keep, to: line.from + space.length, insert: insert.slice(keep) });
    }), { userEvent: "delete.dedent" }));
    return true;
};
/**
Insert a tab character at the cursor or, if something is selected,
use [`indentMore`](https://codemirror.net/6/docs/ref/#commands.indentMore) to indent the entire
selection.
*/
const insertTab = ({ state, dispatch }) => {
    if (state.selection.ranges.some(r => !r.empty))
        return indentMore({ state, dispatch });
    dispatch(state.update(state.replaceSelection("\t"), { scrollIntoView: true, userEvent: "input" }));
    return true;
};
/**
Array of key bindings containing the Emacs-style bindings that are
available on macOS by default.

 - Ctrl-b: [`cursorCharLeft`](https://codemirror.net/6/docs/ref/#commands.cursorCharLeft) ([`selectCharLeft`](https://codemirror.net/6/docs/ref/#commands.selectCharLeft) with Shift)
 - Ctrl-f: [`cursorCharRight`](https://codemirror.net/6/docs/ref/#commands.cursorCharRight) ([`selectCharRight`](https://codemirror.net/6/docs/ref/#commands.selectCharRight) with Shift)
 - Ctrl-p: [`cursorLineUp`](https://codemirror.net/6/docs/ref/#commands.cursorLineUp) ([`selectLineUp`](https://codemirror.net/6/docs/ref/#commands.selectLineUp) with Shift)
 - Ctrl-n: [`cursorLineDown`](https://codemirror.net/6/docs/ref/#commands.cursorLineDown) ([`selectLineDown`](https://codemirror.net/6/docs/ref/#commands.selectLineDown) with Shift)
 - Ctrl-a: [`cursorLineStart`](https://codemirror.net/6/docs/ref/#commands.cursorLineStart) ([`selectLineStart`](https://codemirror.net/6/docs/ref/#commands.selectLineStart) with Shift)
 - Ctrl-e: [`cursorLineEnd`](https://codemirror.net/6/docs/ref/#commands.cursorLineEnd) ([`selectLineEnd`](https://codemirror.net/6/docs/ref/#commands.selectLineEnd) with Shift)
 - Ctrl-d: [`deleteCharForward`](https://codemirror.net/6/docs/ref/#commands.deleteCharForward)
 - Ctrl-h: [`deleteCharBackward`](https://codemirror.net/6/docs/ref/#commands.deleteCharBackward)
 - Ctrl-k: [`deleteToLineEnd`](https://codemirror.net/6/docs/ref/#commands.deleteToLineEnd)
 - Ctrl-Alt-h: [`deleteGroupBackward`](https://codemirror.net/6/docs/ref/#commands.deleteGroupBackward)
 - Ctrl-o: [`splitLine`](https://codemirror.net/6/docs/ref/#commands.splitLine)
 - Ctrl-t: [`transposeChars`](https://codemirror.net/6/docs/ref/#commands.transposeChars)
 - Ctrl-v: [`cursorPageDown`](https://codemirror.net/6/docs/ref/#commands.cursorPageDown)
 - Alt-v: [`cursorPageUp`](https://codemirror.net/6/docs/ref/#commands.cursorPageUp)
*/
const emacsStyleKeymap = [
    { key: "Ctrl-b", run: cursorCharLeft, shift: selectCharLeft, preventDefault: true },
    { key: "Ctrl-f", run: cursorCharRight, shift: selectCharRight },
    { key: "Ctrl-p", run: cursorLineUp, shift: selectLineUp },
    { key: "Ctrl-n", run: cursorLineDown, shift: selectLineDown },
    { key: "Ctrl-a", run: cursorLineStart, shift: selectLineStart },
    { key: "Ctrl-e", run: cursorLineEnd, shift: selectLineEnd },
    { key: "Ctrl-d", run: deleteCharForward },
    { key: "Ctrl-h", run: deleteCharBackward },
    { key: "Ctrl-k", run: deleteToLineEnd },
    { key: "Ctrl-Alt-h", run: deleteGroupBackward },
    { key: "Ctrl-o", run: splitLine },
    { key: "Ctrl-t", run: transposeChars },
    { key: "Ctrl-v", run: cursorPageDown },
];
/**
An array of key bindings closely sticking to platform-standard or
widely used bindings. (This includes the bindings from
[`emacsStyleKeymap`](https://codemirror.net/6/docs/ref/#commands.emacsStyleKeymap), with their `key`
property changed to `mac`.)

 - ArrowLeft: [`cursorCharLeft`](https://codemirror.net/6/docs/ref/#commands.cursorCharLeft) ([`selectCharLeft`](https://codemirror.net/6/docs/ref/#commands.selectCharLeft) with Shift)
 - ArrowRight: [`cursorCharRight`](https://codemirror.net/6/docs/ref/#commands.cursorCharRight) ([`selectCharRight`](https://codemirror.net/6/docs/ref/#commands.selectCharRight) with Shift)
 - Ctrl-ArrowLeft (Alt-ArrowLeft on macOS): [`cursorGroupLeft`](https://codemirror.net/6/docs/ref/#commands.cursorGroupLeft) ([`selectGroupLeft`](https://codemirror.net/6/docs/ref/#commands.selectGroupLeft) with Shift)
 - Ctrl-ArrowRight (Alt-ArrowRight on macOS): [`cursorGroupRight`](https://codemirror.net/6/docs/ref/#commands.cursorGroupRight) ([`selectGroupRight`](https://codemirror.net/6/docs/ref/#commands.selectGroupRight) with Shift)
 - Cmd-ArrowLeft (on macOS): [`cursorLineStart`](https://codemirror.net/6/docs/ref/#commands.cursorLineStart) ([`selectLineStart`](https://codemirror.net/6/docs/ref/#commands.selectLineStart) with Shift)
 - Cmd-ArrowRight (on macOS): [`cursorLineEnd`](https://codemirror.net/6/docs/ref/#commands.cursorLineEnd) ([`selectLineEnd`](https://codemirror.net/6/docs/ref/#commands.selectLineEnd) with Shift)
 - ArrowUp: [`cursorLineUp`](https://codemirror.net/6/docs/ref/#commands.cursorLineUp) ([`selectLineUp`](https://codemirror.net/6/docs/ref/#commands.selectLineUp) with Shift)
 - ArrowDown: [`cursorLineDown`](https://codemirror.net/6/docs/ref/#commands.cursorLineDown) ([`selectLineDown`](https://codemirror.net/6/docs/ref/#commands.selectLineDown) with Shift)
 - Cmd-ArrowUp (on macOS): [`cursorDocStart`](https://codemirror.net/6/docs/ref/#commands.cursorDocStart) ([`selectDocStart`](https://codemirror.net/6/docs/ref/#commands.selectDocStart) with Shift)
 - Cmd-ArrowDown (on macOS): [`cursorDocEnd`](https://codemirror.net/6/docs/ref/#commands.cursorDocEnd) ([`selectDocEnd`](https://codemirror.net/6/docs/ref/#commands.selectDocEnd) with Shift)
 - Ctrl-ArrowUp (on macOS): [`cursorPageUp`](https://codemirror.net/6/docs/ref/#commands.cursorPageUp) ([`selectPageUp`](https://codemirror.net/6/docs/ref/#commands.selectPageUp) with Shift)
 - Ctrl-ArrowDown (on macOS): [`cursorPageDown`](https://codemirror.net/6/docs/ref/#commands.cursorPageDown) ([`selectPageDown`](https://codemirror.net/6/docs/ref/#commands.selectPageDown) with Shift)
 - PageUp: [`cursorPageUp`](https://codemirror.net/6/docs/ref/#commands.cursorPageUp) ([`selectPageUp`](https://codemirror.net/6/docs/ref/#commands.selectPageUp) with Shift)
 - PageDown: [`cursorPageDown`](https://codemirror.net/6/docs/ref/#commands.cursorPageDown) ([`selectPageDown`](https://codemirror.net/6/docs/ref/#commands.selectPageDown) with Shift)
 - Home: [`cursorLineBoundaryBackward`](https://codemirror.net/6/docs/ref/#commands.cursorLineBoundaryBackward) ([`selectLineBoundaryBackward`](https://codemirror.net/6/docs/ref/#commands.selectLineBoundaryBackward) with Shift)
 - End: [`cursorLineBoundaryForward`](https://codemirror.net/6/docs/ref/#commands.cursorLineBoundaryForward) ([`selectLineBoundaryForward`](https://codemirror.net/6/docs/ref/#commands.selectLineBoundaryForward) with Shift)
 - Ctrl-Home (Cmd-Home on macOS): [`cursorDocStart`](https://codemirror.net/6/docs/ref/#commands.cursorDocStart) ([`selectDocStart`](https://codemirror.net/6/docs/ref/#commands.selectDocStart) with Shift)
 - Ctrl-End (Cmd-Home on macOS): [`cursorDocEnd`](https://codemirror.net/6/docs/ref/#commands.cursorDocEnd) ([`selectDocEnd`](https://codemirror.net/6/docs/ref/#commands.selectDocEnd) with Shift)
 - Enter: [`insertNewlineAndIndent`](https://codemirror.net/6/docs/ref/#commands.insertNewlineAndIndent)
 - Ctrl-a (Cmd-a on macOS): [`selectAll`](https://codemirror.net/6/docs/ref/#commands.selectAll)
 - Backspace: [`deleteCharBackward`](https://codemirror.net/6/docs/ref/#commands.deleteCharBackward)
 - Delete: [`deleteCharForward`](https://codemirror.net/6/docs/ref/#commands.deleteCharForward)
 - Ctrl-Backspace (Alt-Backspace on macOS): [`deleteGroupBackward`](https://codemirror.net/6/docs/ref/#commands.deleteGroupBackward)
 - Ctrl-Delete (Alt-Delete on macOS): [`deleteGroupForward`](https://codemirror.net/6/docs/ref/#commands.deleteGroupForward)
 - Cmd-Backspace (macOS): [`deleteToLineStart`](https://codemirror.net/6/docs/ref/#commands.deleteToLineStart).
 - Cmd-Delete (macOS): [`deleteToLineEnd`](https://codemirror.net/6/docs/ref/#commands.deleteToLineEnd).
*/
const standardKeymap = /*@__PURE__*/[
    { key: "ArrowLeft", run: cursorCharLeft, shift: selectCharLeft, preventDefault: true },
    { key: "Mod-ArrowLeft", mac: "Alt-ArrowLeft", run: cursorGroupLeft, shift: selectGroupLeft, preventDefault: true },
    { mac: "Cmd-ArrowLeft", run: cursorLineBoundaryLeft, shift: selectLineBoundaryLeft, preventDefault: true },
    { key: "ArrowRight", run: cursorCharRight, shift: selectCharRight, preventDefault: true },
    { key: "Mod-ArrowRight", mac: "Alt-ArrowRight", run: cursorGroupRight, shift: selectGroupRight, preventDefault: true },
    { mac: "Cmd-ArrowRight", run: cursorLineBoundaryRight, shift: selectLineBoundaryRight, preventDefault: true },
    { key: "ArrowUp", run: cursorLineUp, shift: selectLineUp, preventDefault: true },
    { mac: "Cmd-ArrowUp", run: cursorDocStart, shift: selectDocStart },
    { mac: "Ctrl-ArrowUp", run: cursorPageUp, shift: selectPageUp },
    { key: "ArrowDown", run: cursorLineDown, shift: selectLineDown, preventDefault: true },
    { mac: "Cmd-ArrowDown", run: cursorDocEnd, shift: selectDocEnd },
    { mac: "Ctrl-ArrowDown", run: cursorPageDown, shift: selectPageDown },
    { key: "PageUp", run: cursorPageUp, shift: selectPageUp },
    { key: "PageDown", run: cursorPageDown, shift: selectPageDown },
    { key: "Home", run: cursorLineBoundaryBackward, shift: selectLineBoundaryBackward, preventDefault: true },
    { key: "Mod-Home", run: cursorDocStart, shift: selectDocStart },
    { key: "End", run: cursorLineBoundaryForward, shift: selectLineBoundaryForward, preventDefault: true },
    { key: "Mod-End", run: cursorDocEnd, shift: selectDocEnd },
    { key: "Enter", run: insertNewlineAndIndent },
    { key: "Mod-a", run: selectAll },
    { key: "Backspace", run: deleteCharBackward, shift: deleteCharBackward },
    { key: "Delete", run: deleteCharForward },
    { key: "Mod-Backspace", mac: "Alt-Backspace", run: deleteGroupBackward },
    { key: "Mod-Delete", mac: "Alt-Delete", run: deleteGroupForward },
    { mac: "Mod-Backspace", run: deleteToLineStart },
    { mac: "Mod-Delete", run: deleteToLineEnd }
].concat(/*@__PURE__*/emacsStyleKeymap.map(b => ({ mac: b.key, run: b.run, shift: b.shift })));
/**
The default keymap. Includes all bindings from
[`standardKeymap`](https://codemirror.net/6/docs/ref/#commands.standardKeymap) plus the following:

- Alt-ArrowLeft (Ctrl-ArrowLeft on macOS): [`cursorSyntaxLeft`](https://codemirror.net/6/docs/ref/#commands.cursorSyntaxLeft) ([`selectSyntaxLeft`](https://codemirror.net/6/docs/ref/#commands.selectSyntaxLeft) with Shift)
- Alt-ArrowRight (Ctrl-ArrowRight on macOS): [`cursorSyntaxRight`](https://codemirror.net/6/docs/ref/#commands.cursorSyntaxRight) ([`selectSyntaxRight`](https://codemirror.net/6/docs/ref/#commands.selectSyntaxRight) with Shift)
- Alt-ArrowUp: [`moveLineUp`](https://codemirror.net/6/docs/ref/#commands.moveLineUp)
- Alt-ArrowDown: [`moveLineDown`](https://codemirror.net/6/docs/ref/#commands.moveLineDown)
- Shift-Alt-ArrowUp: [`copyLineUp`](https://codemirror.net/6/docs/ref/#commands.copyLineUp)
- Shift-Alt-ArrowDown: [`copyLineDown`](https://codemirror.net/6/docs/ref/#commands.copyLineDown)
- Escape: [`simplifySelection`](https://codemirror.net/6/docs/ref/#commands.simplifySelection)
- Ctrl-Enter (Comd-Enter on macOS): [`insertBlankLine`](https://codemirror.net/6/docs/ref/#commands.insertBlankLine)
- Alt-l (Ctrl-l on macOS): [`selectLine`](https://codemirror.net/6/docs/ref/#commands.selectLine)
- Ctrl-i (Cmd-i on macOS): [`selectParentSyntax`](https://codemirror.net/6/docs/ref/#commands.selectParentSyntax)
- Ctrl-[ (Cmd-[ on macOS): [`indentLess`](https://codemirror.net/6/docs/ref/#commands.indentLess)
- Ctrl-] (Cmd-] on macOS): [`indentMore`](https://codemirror.net/6/docs/ref/#commands.indentMore)
- Ctrl-Alt-\\ (Cmd-Alt-\\ on macOS): [`indentSelection`](https://codemirror.net/6/docs/ref/#commands.indentSelection)
- Shift-Ctrl-k (Shift-Cmd-k on macOS): [`deleteLine`](https://codemirror.net/6/docs/ref/#commands.deleteLine)
- Shift-Ctrl-\\ (Shift-Cmd-\\ on macOS): [`cursorMatchingBracket`](https://codemirror.net/6/docs/ref/#commands.cursorMatchingBracket)
- Ctrl-/ (Cmd-/ on macOS): [`toggleComment`](https://codemirror.net/6/docs/ref/#commands.toggleComment).
- Shift-Alt-a: [`toggleBlockComment`](https://codemirror.net/6/docs/ref/#commands.toggleBlockComment).
*/
const defaultKeymap = /*@__PURE__*/(/* unused pure expression or super */ null && ([
    { key: "Alt-ArrowLeft", mac: "Ctrl-ArrowLeft", run: cursorSyntaxLeft, shift: selectSyntaxLeft },
    { key: "Alt-ArrowRight", mac: "Ctrl-ArrowRight", run: cursorSyntaxRight, shift: selectSyntaxRight },
    { key: "Alt-ArrowUp", run: moveLineUp },
    { key: "Shift-Alt-ArrowUp", run: copyLineUp },
    { key: "Alt-ArrowDown", run: moveLineDown },
    { key: "Shift-Alt-ArrowDown", run: copyLineDown },
    { key: "Escape", run: simplifySelection },
    { key: "Mod-Enter", run: insertBlankLine },
    { key: "Alt-l", mac: "Ctrl-l", run: selectLine },
    { key: "Mod-i", run: selectParentSyntax, preventDefault: true },
    { key: "Mod-[", run: indentLess },
    { key: "Mod-]", run: indentMore },
    { key: "Mod-Alt-\\", run: indentSelection },
    { key: "Shift-Mod-k", run: deleteLine },
    { key: "Shift-Mod-\\", run: cursorMatchingBracket },
    { key: "Mod-/", run: toggleComment },
    { key: "Alt-A", run: toggleBlockComment }
].concat(standardKeymap)));
/**
A binding that binds Tab to [`indentMore`](https://codemirror.net/6/docs/ref/#commands.indentMore) and
Shift-Tab to [`indentLess`](https://codemirror.net/6/docs/ref/#commands.indentLess).
Please see the [Tab example](../../examples/tab/) before using
this.
*/
const indentWithTab = { key: "Tab", run: indentMore, shift: indentLess };



// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/helpers/component.js
var component = __webpack_require__(8335);
// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/theme/index.js + 2 modules
var theme = __webpack_require__(3694);
// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/hooks/useTheme.js
var useTheme = __webpack_require__(5050);
// EXTERNAL MODULE: ./node_modules/@lezer/highlight/dist/index.js
var highlight_dist = __webpack_require__(1087);
;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Code/components/theme.js



/**
 * Robocrop Design System Codemirror theme
 */
const getCodemirrorTheme = (theme) => {
    const color = (...args) => theme.color(...args)({ theme });
    const editorTheme = dist/* EditorView.theme */.tk.theme({
        '&': {
            height: '100%',
            color: color('dark0'),
            backgroundColor: color('dark90')
        },
        '.cm-content': {
            caretColor: '#a0a4ae',
            fontFamily: theme.fonts.code,
            lineHeight: theme.lineHeights.$140,
            fontSize: theme.fontSizes.$14,
            padding: theme.space.$8
        },
        '.cm-cursor, .cm-dropCursor': {
            borderLeftColor: color('yellow50', 'light0'),
            borderLeftWidth: '2px',
            transform: 'translateX(1px)'
        },
        '&.cm-focused .cm-selectionBackground, .cm-selectionBackground, .cm-content ::selection': {
            backgroundColor: color('dark60')
        },
        '.cm-activeLine': { backgroundColor: color('dark80') },
        '.cm-gutters': {
            backgroundColor: color('dark90'),
            borderRight: `1px solid ${color('dark80')}`,
            paddingRight: '4px',
            color: color('dark50')
        },
        '.cm-activeLineGutter': {
            backgroundColor: color('dark90'),
            color: color('dark20')
        },
        '.cm-indent span': {
            color: color('dark90'),
            'user-select': 'text'
        },
        '.cm-indent span::selection': {
            color: color('dark40'),
            backgroundColor: color('dark60')
        }
    }, { dark: theme.name === 'dark' });
    const highlightTheme = language_dist/* HighlightStyle.define */.Qf.define([
        {
            tag: [highlight_dist/* tags.comment */.pJ.comment],
            color: color('dark30'),
            fontStyle: 'italic'
        },
        {
            tag: [highlight_dist/* tags.variableName */.pJ.variableName],
            color: color('dark10')
        },
        {
            tag: [highlight_dist/* tags.typeName */.pJ.typeName, highlight_dist/* tags.className */.pJ.className],
            color: color('yellow70', 'yellow30')
        },
        {
            tag: [highlight_dist/* tags.propertyName */.pJ.propertyName],
            color: color('yellow40', 'yellow30')
        },
        {
            tag: [highlight_dist/* tags.attributeName */.pJ.attributeName],
            color: color('magenta70', 'magenta50')
        },
        {
            tag: [highlight_dist/* tags.tagName */.pJ.tagName],
            color: color('yellow70', 'yellow30')
        },
        {
            tag: [highlight_dist/* tags.squareBracket */.pJ.squareBracket],
            color: color('dark30')
        },
        {
            tag: [highlight_dist/* tags.string */.pJ.string],
            color: color('green70', 'green30')
        },
        {
            tag: [highlight_dist/* tags.number */.pJ.number, highlight_dist/* tags.changed */.pJ.changed, highlight_dist/* tags.annotation */.pJ.annotation, highlight_dist/* tags.modifier */.pJ.modifier, highlight_dist/* tags.self */.pJ.self, highlight_dist/* tags.namespace */.pJ.namespace],
            color: color('dark10')
        },
        {
            tag: highlight_dist/* tags.heading */.pJ.heading,
            color: color('dark30')
        },
        {
            tag: [highlight_dist/* tags.special */.pJ.special(highlight_dist/* tags.variableName */.pJ.variableName), highlight_dist/* tags.variableName */.pJ.variableName],
            color: color('purple70', 'purple30')
        },
        {
            tag: [highlight_dist/* tags.atom */.pJ.atom, highlight_dist/* tags.heading2 */.pJ.heading2, highlight_dist/* tags.angleBracket */.pJ.angleBracket, highlight_dist/* tags.keyword */.pJ.keyword],
            color: color('blue60', 'blue30')
        },
        {
            tag: [highlight_dist/* tags.meta */.pJ.meta],
            color: color('teal50', 'teal30')
        },
        {
            tag: [highlight_dist/* tags.operator */.pJ.operator, highlight_dist/* tags.operatorKeyword */.pJ.operatorKeyword],
            color: color('dark10')
        }
    ]);
    const robocorpTheme = [editorTheme, (0,language_dist/* syntaxHighlighting */.nF)(highlightTheme)];
    return robocorpTheme;
};

// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/components/Code/components/robotFramework/mode.js + 1 modules
var mode = __webpack_require__(4612);
;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Code/Code.js
var __rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};












const Container = theme/* styled.div */.zo.div `
  width: 100%;
  height: 100%;

  > div {
    height: 100%;
  }
`;
/**
 * An extensible code editor and code display component. It wraps the [Codemirror Code Editor](https://codemirror.net/) by defining the Robocorp theme
 * and adding support for Robot Framework syntax highlight.
 *
 * @see
 * {@link https://design-system.solventek.com/component/code}
 *
 * @example
 * <Code value={value} onChange={onChange} extensions=[{robotFramework()}] />
 */
const Code = (0,component/* componentWithRef */.w)((_a, forwardedRef) => {
    var { codemirrorRef, extensions, value, lineNumbers, onChange, readOnly } = _a, rest = __rest(_a, ["codemirrorRef", "extensions", "value", "lineNumbers", "onChange", "readOnly"]);
    const container = (0,react.useRef)(null);
    const view = (0,react.useRef)();
    const theme = (0,useTheme/* default */.Z)();
    (0,react.useEffect)(() => {
        const updateListener = dist/* EditorView.updateListener.of */.tk.updateListener.of((event) => {
            if (event.docChanged && typeof onChange === 'function') {
                const doc = event.state.doc.toString();
                onChange(doc, event);
            }
        });
        const extensionList = [
            dist/* keymap.of */.$f.of(standardKeymap),
            dist_history(),
            getCodemirrorTheme(theme),
            updateListener,
            ...(extensions || [])
        ];
        if (lineNumbers) {
            extensionList.push((0,dist/* lineNumbers */.Eu)());
        }
        if (readOnly) {
            extensionList.push(dist/* EditorView.editable.of */.tk.editable.of(false));
        }
        const state = state_dist/* EditorState.create */.yy.create({
            doc: value,
            extensions: extensionList
        });
        if (container.current) {
            view.current = new dist/* EditorView */.tk({ state, parent: container.current });
            if (codemirrorRef) {
                // eslint-disable-next-line no-param-reassign
                codemirrorRef.current = view.current;
            }
        }
        return () => {
            var _a;
            (_a = view.current) === null || _a === void 0 ? void 0 : _a.destroy();
        };
    }, [extensions, lineNumbers, onChange, theme.name]);
    (0,react.useEffect)(() => {
        if (!view.current) {
            return;
        }
        const currentValue = view.current.state.doc.toString();
        if (view.current && value !== currentValue) {
            view.current.dispatch({
                changes: { from: 0, to: currentValue.length, insert: value || '' }
            });
        }
    }, [value]);
    return ((0,jsx_runtime.jsx)(Container, Object.assign({ ref: forwardedRef }, rest, { children: (0,jsx_runtime.jsx)("div", { ref: container }) })));
});
Code.defaultProps = {
    lineNumbers: true
};


/***/ }),

/***/ 4612:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "q": () => (/* binding */ robotFramework)
});

// UNUSED EXPORTS: TT

// EXTERNAL MODULE: ./node_modules/@codemirror/language/dist/index.js
var dist = __webpack_require__(4123);
;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Code/components/robotFramework/simpleMode.js
/* eslint-disable @typescript-eslint/no-explicit-any */
/* eslint-disable no-param-reassign */
/* eslint-disable react/destructuring-assignment */
const ensureState = (states, name) => {
    if (!Object.prototype.hasOwnProperty.call(states, name)) {
        throw new Error(`Undefined state ${name} in simple mode`);
    }
};
const toRegex = (input, caret) => {
    if (!input)
        return /(?:)/;
    let flags = '';
    let val;
    if (input instanceof RegExp) {
        if (input.ignoreCase) {
            flags = 'i';
        }
        val = input.source;
    }
    else {
        val = String(input);
    }
    return new RegExp(`${caret === false ? '' : '^'}(?:${val})`, flags);
};
const asToken = (val) => {
    if (!val) {
        return null;
    }
    if (val.apply) {
        return val;
    }
    if (typeof val === 'string') {
        return val.replace(/\./g, ' ');
    }
    const result = [];
    for (let i = 0; i < val.length; i += 1) {
        result.push(val[i] && val[i].replace(/\./g, ' '));
    }
    return result;
};
class Rule {
    constructor(data, states) {
        if (data.next || data.push)
            ensureState(states, data.next || data.push);
        this.data = data;
        this.regex = toRegex(data.regex);
        this.token = asToken(this.data.token);
    }
}
const tokenFunction = (states) => (stream, state) => {
    if (state.pending) {
        const pend = state.pending.shift();
        if (state.pending.length === 0) {
            state.pending = null;
        }
        stream.pos += pend.text.length;
        return pend.token;
    }
    const curState = states[state.state];
    for (let i = 0; i < curState.length; i += 1) {
        const rule = curState[i];
        const matches = (!rule.data.sol || stream.sol()) && stream.match(rule.regex);
        if (matches) {
            if (rule.data.next) {
                state.state = rule.data.next;
            }
            else if (rule.data.push) {
                (state.stack || (state.stack = [])).push(state.state);
                state.state = rule.data.push;
            }
            else if (rule.data.pop && state.stack && state.stack.length) {
                state.state = state.stack.pop();
            }
            if (rule.data.indent)
                state.indent.push(stream.indentation() + stream.indentUnit);
            if (rule.data.dedent)
                state.indent.pop();
            let { token } = rule;
            if (token && token.apply) {
                token = token(matches);
            }
            if (matches.length > 2 && rule.token && typeof rule.token !== 'string') {
                state.pending = [];
                for (let j = 2; j < matches.length; j += 1)
                    if (matches[j])
                        state.pending.push({ text: matches[j], token: rule.token[j - 1] });
                stream.backUp(matches[0].length - (matches[1] ? matches[1].length : 0));
                return token[0];
            }
            if (token && token.join) {
                return token[0];
            }
            return token;
        }
    }
    stream.next();
    return null;
};
const indentFunction = (states, meta) => (state, textAfter) => {
    if (state.indent == null || (meta.dontIndentStates && meta.doneIndentState.indexOf(state.state) > -1)) {
        return null;
    }
    let pos = state.indent.length - 1;
    const scan = (rules) => {
        for (let i = 0; i < rules.length; i += 1) {
            const rule = rules[i];
            if (rule.data.dedent && rule.data.dedentIfLineStart !== false) {
                const m = rule.regex.exec(textAfter);
                if (m && m[0]) {
                    pos -= 1;
                    textAfter = textAfter.slice(m[0].length);
                    if (rule.next || rule.push) {
                        scan(states[rule.next || rule.push]);
                    }
                }
            }
        }
    };
    scan(states[state.state]);
    return pos < 0 ? 0 : state.indent[pos];
};
const simpleMode = (states) => {
    ensureState(states, 'start');
    const output = {};
    const meta = states.languageData || {};
    let hasIndentation = false;
    Object.keys(states).forEach((currentState) => {
        if (currentState !== 'meta') {
            output[currentState] = [];
            const orig = states[currentState];
            for (let i = 0; i < orig.length; i += 1) {
                const data = orig[i];
                output[currentState].push(new Rule(data, states));
                if (data.indent || data.dedent) {
                    hasIndentation = true;
                }
            }
        }
    });
    return {
        startState: () => {
            return { state: 'start', pending: null, indent: hasIndentation ? [] : null };
        },
        copyState: (state) => {
            const s = { state: state.state, pending: state.pending, indent: state.indent && state.indent.slice(0), stack: undefined };
            if (state.stack) {
                s.stack = state.stack.slice(0);
            }
            return s;
        },
        token: tokenFunction(output),
        indent: indentFunction(output, meta),
        languageData: meta
    };
};

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Code/components/robotFramework/mode.js
/* eslint-disable @typescript-eslint/no-explicit-any */
/**
 * Copyright (c) 2022 MarketSquare
 * Distributed under the terms of the BSD-3-Clause License
 *
 * Original source https://github.com/MarketSquare/jupyterlab_robotmode/blob/main/src/mode.ts
 */


/** the tokens we use */
// eslint-disable-next-line no-shadow
var TT;
(function (TT) {
    TT["AM"] = "atom";
    TT["AT"] = "attribute";
    TT["BE"] = "builtin.em";
    TT["BI"] = "builtin";
    TT["BK"] = "bracket";
    TT["CM"] = "comment";
    TT["DF"] = "keyword";
    TT["HL"] = "header";
    TT["KW"] = "property";
    TT["MT"] = "meta";
    TT["NB"] = "number";
    TT["OP"] = "operator";
    TT["PC"] = "punctuation";
    TT["PR"] = "property";
    TT["SE"] = "string.em";
    TT["SH"] = "heading2";
    TT["SS"] = "string.strong";
    TT["SSE"] = "string.strong.em";
    TT["S2"] = "string-2";
    TT["ST"] = "text";
    TT["TG"] = "tag";
    TT["V2"] = "variable-2";
})(TT || (TT = {}));
/** helper function for compactly representing a rule */
function r(regex, token, opt) {
    return Object.assign({ regex, token }, opt);
}
/** Possible Robot Framework table names. Group count is important.  */
const TABLE_NAMES = {
    keywords: /(\|\s)?(\*+ *)(user keywords?|keywords?)( *\**)/i,
    settings: /(\|\s)?(\*+ *)(settings?)( *\**)/i,
    test_cases: /(\|\s)?(\*+ *)(tasks?|test cases?)( *\**)/i,
    variables: /(\|\s)?(\*+ *)(variables?)( *\**)/i
};
/** Enumerate the possible rules  */
const RULES_TABLE = Object.keys(TABLE_NAMES).map((next) => {
    return r(TABLE_NAMES[next], [TT.BK, TT.HL, TT.HL, TT.HL], {
        next: next,
        sol: true
    });
});
const RULE_COMMENT_POP = r(/#.*$/, TT.CM, { pop: true });
/** Valid python operators */
const VAR_OP = /[*\-+\\%&|=><!]/;
/** Valid python numbers */
const VAR_NUM = /0(b[01]+|o[0-7]+|x[0-9a-f]+)|(\d+)(\.\d+)?(e-?(\d+)(\.\d+)?)?/i;
/**
    Valid python builtins
    Valid  way out at the end is a lookahead for VAR_OP, end or .
*/
const VAR_BUILTIN = /(none|(cur|temp|exec)dir|\/|:|\\n|true|empty|false|null|space|test (name|documentation|status|message|tags)|prev test (name|status|message)|suite (name|source|documentation|status|message|metadata)|keyword (status|message)|(report|debug) file|log (file|level)|output (dir|file))(?=[.}]|\s+[*\-+\\%&|=><!])/i;
/** a rule for the beginning of the variable state */
const RULE_VAR_START = r(/[$&@%]\{/, TT.V2, { push: 'variable' });
/** a rule for the end of the variable state */
const RULE_VAR_END = r(/\}/, TT.V2);
/** a rule for a number */
const RULE_NUM = r(VAR_NUM, TT.NB);
/** a rule for starting a single quote */
const RULE_SINGLE_STRING_START = r(/'/, TT.ST, { push: 'single_string' });
/** a rule for starting a double quote */
const RULE_DOUBLE_STRING_START = r(/"/, TT.ST, { push: 'double_string' });
/** a rule for capturing tags (and friends) in keyword/test/task definitions */
const RULE_TAGS = r(/([|\s]*\s*)(\[\s*)(tags)(\s*\])(\s*\|?)/i, [TT.BK, TT.MT, TT.MT, TT.MT, TT.BK], { sol: true, push: 'tags' });
/** rule for special case of applying tags at the suite level */
const RULE_SUITE_TAGS = r(/(force tags|default tags)(\t+|  +)/i, [TT.MT, null], {
    push: 'tags',
    sol: true
});
/** rule for special case of applying tags at the suite level (with pipes) */
const RULE_SUITE_TAGS_PIPE = r(/(\| +)(force tags|default tags)( *\|?)/i, [TT.BK, TT.MT, TT.BK], { sol: true, push: 'tags' });
/** rule for bracketed settings of keyword/test/task */
const RULE_SETTING_KEYWORD = r(/([|\s]*)(\[\s*)(setup|teardown|template)(\s*\])(\s*\|?)/i, [TT.BK, TT.MT, TT.MT, TT.MT, TT.BK], {
    push: 'keyword_invocation_no_continue',
    sol: true
});
/** rule for bracketed settings of keyword/test/task that include a keyword */
const RULE_SUITE_SETTING_KEYWORD = r(/(suite setup|suite teardown|test setup|test teardown|test template|task setup|task teardown|task template)(\t+|  +)/i, [TT.MT, null], { push: 'keyword_invocation', sol: true });
/** rule for bracketed settings of keyword/test/task that include a keyword (with pipes) */
const RULE_SUITE_SETTING_KEYWORD_PIPE = r(/(\| +)(suite setup|suite teardown|test setup|test teardown|test template|task setup|task teardown|task template)( +\|)/i, [TT.BK, TT.MT, TT.BK], { push: 'keyword_invocation', sol: true });
const RULE_SETTING_LIBRARY = r(/(library)(\t+|  +)/i, [TT.MT, null], {
    push: 'library',
    sol: true
});
const RULE_SETTING_LIBRARY_PIPE = r(/(\| +)(library)( +\|)/i, [TT.BK, TT.MT, TT.BK], {
    push: 'library',
    sol: true
});
/** rule to escape the final closing bracket of a var at the end of a line */
const RULE_LINE_ENDS_WITH_VAR = r(/\}\s*(?=$)/, TT.V2, { pop: true });
const RULE_ELLIPSIS = r(/(\s*)(\.\.\.)/, [null, TT.BK], { sol: true });
const RULE_NOT_ELLIPSIS_POP = r(/(?!\s*(\\|\.\.\.))/, null, {
    pop: true,
    sol: true
});
const RULE_DOC_TAGS = r(/(Tags:)(\s*)/i, [TT.MT, null], { push: 'tags_comma' });
/** collects the states that we build */
const states = {};
/** base isn't a state. these are the "normal business" that any state might use */
const base = [
    ...RULES_TABLE,
    RULE_VAR_START,
    RULE_VAR_END,
    RULE_DOC_TAGS,
    RULE_ELLIPSIS,
    r(/\|/, TT.BK),
    r(/#.*$/, TT.CM),
    r(/\\ +/, TT.BK),
    r(/\\(?=$)/, TT.BK),
    r(
    // a non-variable argument fragment before a variable before an equal
    /([^\s$@&%=]((?!\t+|\s+\|\s+|  +)([^=]|\\=))*?)(?=[$@&%].*?[^ =\\]=($| {2}|[^=]|\s+\||\t))/, TT.AT),
    r(
    // a non-variable argument fragment before an equal
    /([^\s$@&%=]((?!\t+|\s+\|\s+|  +)([^=]|\\=))*?)(?==($| {2}|[^=]|\s+\||\t))/, TT.AT),
    // r(/[^\s]+:(?!\/)/, TT.OP),  // this was generating false positives with TRY
    r(/(=!<>+-*\/%)*==?/, TT.OP),
    r(/_\*.*?\*_/, TT.SSE),
    r(/\*.*?\*/, TT.SS),
    r(/_.*?_/, TT.SE),
    // this is pretty extreme, but seems to work
    r(/[^\s$@%&]+/, TT.ST),
    r(/[$@%&](?!\{)/, TT.ST)
];
/** the starting state (begining of a file) */
states.start = [
    r(/(%%python)( module )?(.*)?/, [TT.MT, TT.KW, TT.V2], {
        mode: { spec: 'ipython' },
        sol: true
    }),
    r(/(%%[^\s]*).*$/, TT.MT, { sol: true }),
    ...base
];
/** settings states */
states.settings = [
    RULE_SUITE_TAGS_PIPE,
    RULE_SUITE_TAGS,
    RULE_SUITE_SETTING_KEYWORD_PIPE,
    RULE_SUITE_SETTING_KEYWORD,
    RULE_SETTING_LIBRARY,
    RULE_SETTING_LIBRARY_PIPE,
    r(/(\|*\s*)(resource|variables|documentation|metadata|test timeout|task timeout)(\s*)/i, [TT.BK, TT.MT, null], { sol: true }),
    ...base
];
states.library = [
    RULE_NOT_ELLIPSIS_POP,
    RULE_ELLIPSIS,
    RULE_LINE_ENDS_WITH_VAR,
    r(/(WITH NAME)(\t+|  +| +\| +)([^|\s]*)(\s*)(\|?)(\s*)(?=$)/, [TT.AM, TT.BK, TT.DF, null, TT.BK, null], {
        pop: true
    }),
    ...base
];
/** rule for behavior-driven-development keywords */
const RULE_START_BDD = r(/(\|\s*\|\s*|\s\s+)?(given|when|then|and|but)/i, [TT.BK, TT.BE], {
    push: 'keyword_invocation',
    sol: true
});
/** rule for whitespace keywords */
const RULE_KEY_START = r(/(\t+|  +)(?!\.\.\.)/, null, {
    push: 'keyword_invocation',
    sol: true
});
/** rule for pipe keywords */
const RULE_KEY_START_PIPE = r(/(\| )(\s*)(|[^|\s][^|]*)(\s*)( \|)(\s+)/, [TT.BK, null, TT.SH, null, TT.BK, null], {
    push: 'keyword_invocation',
    sol: true
});
/** rule for for old-style loops (slashes) */
const RULE_START_LOOP_OLD = r(/(\s\|*\s*)(:FOR)(\s\|*\s*)/, [null, TT.AM, null], {
    push: 'loop_start_old',
    sol: true
});
/** rule for for new-style loops (slashes) */
const RULE_START_LOOP_NEW = r(/(\s\|*\s*)(FOR)(\s\|*\s*)/, [null, TT.AM, null], {
    push: 'loop_start_new',
    sol: true
});
/** rule for inline if keyword */
const RULE_START_INLINE_IF = r(/(\s*)(IF)(\s\|*\s*)(?=[^\s].*\s{2,})/, [null, TT.AM, null], {
    push: 'inline_if_start',
    sol: true
});
/** rule for inline if keyword with assignment */
const RULE_START_INLINE_IF_VAR = r(/(\s+)(.*?)(\s+)(=)(\s+)(IF)(\s\|*\s*)(?=[^\s].*\s{2,})/, [null, TT.V2, null, TT.OP, null, TT.AM, null], { push: 'inline_if_start', sol: true });
/** rule for if keyword */
const RULE_START_IF = r(/(\s\|*\s*)(IF)(\s\|*\s*)(?![^\s].*\s{2,})/, [null, TT.AM, null], {
    push: 'if_start',
    sol: true
});
/** rule for else if keyword */
const RULE_START_IF_ELSE_IF = r(/(\s\|*\s*)(ELSE IF)(\s\|*\s*)/, [null, TT.AM, null], {
    next: 'if_else_if_start',
    sol: true
});
/** rule for else keyword */
const RULE_START_IF_ELSE = r(/(\s\|*\s*)(ELSE)(?=$)/, [null, TT.AM], {
    next: 'if_else_start',
    sol: true
});
/** rule for try keyword */
const RULE_START_TRY = r(/(\s\|*\s*)(TRY)(?=$)/, [null, TT.AM], {
    push: 'try_start',
    sol: true
});
/** rule for simple try/except */
const RULE_START_EXCEPT = r(/(\s\|*\s*)(EXCEPT)/, [null, TT.AM], {
    next: 'try_except_start',
    sol: true
});
/** rule for try/else keyword */
const RULE_START_TRY_ELSE = r(/(\s\|*\s*)(ELSE)(?=$)/, [null, TT.AM], {
    next: 'try_else_start',
    sol: true
});
/** rule for try/finally keyword */
const RULE_START_FINALLY = r(/(\s\|*\s*)(FINALLY)/, [null, TT.AM], {
    next: 'try_finally_start',
    sol: true
});
const RULE_START_WHILE = r(/(\s\|*\s*)(WHILE)/, [null, TT.AM], {
    push: 'while_start',
    sol: true
});
/** rule for end keyword */
const RULE_END = r(/([|\s]*\s*)(END)(?=$)/, [null, TT.AM], {
    sol: true,
    pop: true
});
const RULES_TAGS_COMMON = [
    r(/\s\|\s*/, TT.BK),
    RULE_COMMENT_POP,
    RULE_ELLIPSIS,
    RULE_NOT_ELLIPSIS_POP,
    RULE_VAR_START,
    RULE_LINE_ENDS_WITH_VAR,
    RULE_VAR_END,
    r(/ +/, null)
];
/** rules for capturing individual tags */
states.tags = [
    ...RULES_TAGS_COMMON,
    r(/[^$&%@]*?(?=(  +| \|))/, TT.TG),
    // fall back to single char
    r(/[^$&%@|]/, TT.TG)
];
/** rules for capturing tags inside docs */
states.tags_comma = [
    ...RULES_TAGS_COMMON,
    r(/(,)(\s*)/, [TT.PC, null]),
    r(/[^$&%@,]+(?=,$)/, TT.TG),
    // fall back to single char
    r(/[^$&%@|,]/, TT.TG)
];
/** need to catch empty white lines pretty explicitly */
const RULE_WS_LINE = r(/\s*(?=$)/, null, { sol: true });
/** not a state. rules for starting keyword invocation */
const RULES_KEYWORD_INVOKING = [
    RULE_START_BDD,
    RULE_KEY_START_PIPE,
    RULE_KEY_START,
    r(/\|\s(?=[^\s*]*\|)/, null, { sol: true, push: 'keyword_invocation' }),
    r(/(?=[^\s*])/, null, { sol: true, push: 'keyword_invocation' })
];
const RULE_SETTING_SIMPLE = r(/(\t+|  +)(\[\s*)(arguments|documentation|return|timeout)(\s*\])(\s*)/i, [null, TT.MT, TT.MT, TT.MT, null], { sol: true });
const RULE_SETTING_SIMPLE_PIPE = r(/(\|)(\s+)([^|*]*)(\s+)(\|)(\s+)(\[\s*)(arguments|documentation|return|timeout)(\s*\])(\s*)(\|?)/i, [TT.BK, null, TT.SH, null, TT.BK, null, TT.MT, TT.MT, TT.MT, null, TT.BK], { sol: true });
/** rule for atomic control flow */
const RULE_CONTROL_FLOW_ATOM = r(/(\s*)(BREAK|CONTINUE|RETURN)([\s|]{2,}|$)/, [null, TT.AM, null]);
/** rules for starting control flow blocks */
const RULES_CONTROL_FLOW = [
    RULE_CONTROL_FLOW_ATOM,
    RULE_START_LOOP_OLD,
    RULE_START_LOOP_NEW,
    RULE_START_WHILE,
    RULE_START_INLINE_IF_VAR,
    RULE_START_INLINE_IF,
    RULE_START_IF,
    RULE_START_TRY
];
/** rules for data rows inside a keyword table */
states.keywords = [
    RULE_ELLIPSIS,
    RULE_TAGS,
    RULE_SETTING_KEYWORD,
    RULE_SETTING_SIMPLE,
    RULE_SETTING_SIMPLE_PIPE,
    r(/(?=[^\s$&%@*|]+)/, null, { sol: true, push: 'keyword_def' }),
    ...RULES_CONTROL_FLOW,
    RULE_WS_LINE,
    ...RULES_KEYWORD_INVOKING,
    ...base
];
/** a keyword name fragment before an inline variable */
const KEYWORD_WORD_BEFORE_VAR = /([^\s]*?(?=[$&%@]\{))/i;
/** a keyword containing spaces before a separator */
const KEYWORD_WORD_WITH_SPACES_BEFORE_SEP = /(?:[^\t\n\r|])+?(?=$|\t|\n|\r|  +)/;
/** a keyword name fragment before a separator */
const KEYWORD_WORD_BEFORE_SEP = /[^\s|]+(?=$|[|]|\t|  +)/;
/** a keyword name fragment before a non-separator whitespace character */
const KEYWORD_WORD_BEFORE_WS = /([^\n$\s*=|]+?(?= ))/i;
states.keyword_def = [
    RULE_VAR_START,
    RULE_LINE_ENDS_WITH_VAR,
    RULE_VAR_END,
    r(/ /, null),
    r(KEYWORD_WORD_BEFORE_VAR, TT.DF),
    r(KEYWORD_WORD_BEFORE_SEP, TT.DF, { pop: true }),
    r(KEYWORD_WORD_BEFORE_WS, TT.DF),
    r(/(?=$)/, null, { sol: true, pop: true })
];
/** A range as used in for loops */
const RULE_RANGE = r(/([|\s]*\s*)(IN)( RANGE| ENUMERATE| ZIP)?/, [null, TT.AM, TT.AM]);
states.loop_start_new = [
    RULE_RANGE,
    r(/[.]{3}/, TT.BK),
    RULE_VAR_START,
    r(/\}(?=$)/, TT.V2),
    RULE_VAR_END,
    ...RULES_CONTROL_FLOW,
    RULE_END,
    RULE_WS_LINE,
    ...RULES_KEYWORD_INVOKING,
    ...base
];
/** the state when in an (ELSE)IF predictate */
states.inline_if_start = [
    RULE_ELLIPSIS,
    r(/[\s|]{2,}/, null, { next: 'inline_if_start_keyword' }),
    RULE_NOT_ELLIPSIS_POP,
    RULE_VAR_START,
    r(/\}(?=$)/, TT.V2),
    RULE_VAR_END,
    ...base
];
/** the state when in an ELSE( IF) object */
states.inline_if_start_keyword = [
    RULE_ELLIPSIS,
    RULE_CONTROL_FLOW_ATOM,
    RULE_NOT_ELLIPSIS_POP,
    r(KEYWORD_WORD_BEFORE_VAR, TT.KW, { next: 'inline_if_keyword_invoking' }),
    r(KEYWORD_WORD_WITH_SPACES_BEFORE_SEP, TT.KW, { next: 'inline_if_keyword_invoking' }),
    r(KEYWORD_WORD_BEFORE_SEP, TT.KW, { next: 'inline_if_keyword_invoking' }),
    r(KEYWORD_WORD_BEFORE_WS, TT.KW, { next: 'inline_if_keyword_invoking' })
];
/** the state when in an ELSE( IF) object */
states.inline_if_keyword_invoking = [
    RULE_ELLIPSIS,
    RULE_NOT_ELLIPSIS_POP,
    r(/(\s\|*\s*)(ELSE IF)(\s\|*\s*)/, [null, TT.AM, null], { next: 'inline_if_start' }),
    r(/(\s\|*\s*)(ELSE)(\s\|*\s*)/, [null, TT.AM, null], {
        next: 'inline_if_start_else'
    }),
    RULE_VAR_START,
    r(/\}(?=$)/, TT.V2),
    RULE_VAR_END,
    ...base
];
states.inline_if_start_else = [
    RULE_ELLIPSIS,
    r(KEYWORD_WORD_BEFORE_VAR, TT.KW, { next: 'inline_if_else_keyword_invoking' }),
    r(KEYWORD_WORD_WITH_SPACES_BEFORE_SEP, TT.KW, {
        next: 'inline_if_else_keyword_invoking'
    }),
    r(KEYWORD_WORD_BEFORE_SEP, TT.KW, { next: 'inline_if_else_keyword_invoking' }),
    r(KEYWORD_WORD_BEFORE_WS, TT.KW, { next: 'inline_if_else_keyword_invoking' }),
    ...base
];
states.inline_if_else_keyword_invoking = [
    RULE_ELLIPSIS,
    RULE_NOT_ELLIPSIS_POP,
    RULE_VAR_START,
    r(/\}(?=$)/, TT.V2),
    RULE_VAR_END,
    ...base
];
states.if_start = [
    r(/[.]{3}/, TT.BK),
    RULE_VAR_START,
    r(/\}(?=$)/, TT.V2),
    RULE_VAR_END,
    ...RULES_CONTROL_FLOW,
    RULE_START_IF_ELSE_IF,
    RULE_START_IF_ELSE,
    RULE_END,
    RULE_WS_LINE,
    ...RULES_KEYWORD_INVOKING,
    ...base
];
states.if_else_if_start = [
    r(/[.]{3}/, TT.BK),
    RULE_VAR_START,
    r(/\}(?=$)/, TT.V2),
    RULE_VAR_END,
    ...RULES_CONTROL_FLOW,
    RULE_START_IF_ELSE_IF,
    RULE_START_IF_ELSE,
    RULE_END,
    RULE_WS_LINE,
    ...RULES_KEYWORD_INVOKING,
    ...base
];
states.if_else_start = [...RULES_CONTROL_FLOW, RULE_END, RULE_WS_LINE, ...RULES_KEYWORD_INVOKING, ...base];
states.try_start = [
    ...RULES_CONTROL_FLOW,
    RULE_START_EXCEPT,
    RULE_START_TRY_ELSE,
    RULE_START_FINALLY,
    RULE_END,
    RULE_WS_LINE,
    ...RULES_KEYWORD_INVOKING,
    ...base
];
states.try_except_start = [
    r(/[.]{3}/, TT.BK),
    r(/AS/, TT.AM),
    r(/(glob|regexp):/i, TT.BI),
    RULE_VAR_START,
    r(/\}(?=$)/, TT.V2),
    RULE_VAR_END,
    ...RULES_CONTROL_FLOW,
    RULE_START_EXCEPT,
    RULE_START_TRY_ELSE,
    RULE_START_FINALLY,
    RULE_END,
    RULE_WS_LINE,
    ...RULES_KEYWORD_INVOKING,
    ...base
];
states.try_else_start = [...RULES_CONTROL_FLOW, RULE_START_FINALLY, RULE_END, RULE_WS_LINE, ...RULES_KEYWORD_INVOKING, ...base];
states.try_finally_start = [...RULES_CONTROL_FLOW, RULE_END, RULE_WS_LINE, ...RULES_KEYWORD_INVOKING, ...base];
states.while_start = [
    r(/[.]{3}/, TT.BK),
    r(/AS/, TT.AM),
    r(/(glob|regexp):/i, TT.BI),
    RULE_VAR_START,
    r(/\}(?=$)/, TT.V2),
    RULE_VAR_END,
    ...RULES_CONTROL_FLOW,
    RULE_END,
    RULE_WS_LINE,
    ...RULES_KEYWORD_INVOKING,
    ...base
];
states.loop_start_old = [
    r(/(?=.*)/, null, { sol: true, next: 'loop_body_old' }),
    RULE_RANGE,
    RULE_VAR_START,
    r(/\}(?=$)/, TT.V2),
    RULE_VAR_END,
    ...base
];
states.loop_body_old = [
    ...RULES_KEYWORD_INVOKING.map((rule) => {
        return Object.assign(Object.assign({}, rule), { regex: new RegExp(/([|\s]*\s*)(\\)/.source + (rule.regex instanceof RegExp ? rule.regex.source : rule.regex)), token: rule.token instanceof Array ? [null, TT.BK, ...rule.token] : [null, TT.BK, null] });
    }),
    r(/(?=\s+[^\\])/, null, { pop: true, sol: true }),
    ...base
];
const RULE_CASE_SETTING_SIMPLE = r(/(\t+|  +)(\[\s*)(documentation|timeout)(\s*\])(\s*)/i, [null, TT.MT, TT.MT, TT.MT, null], {
    sol: true
});
const RULE_CASE_SETTING_SIMPLE_PIPE = r(/(\|)(\s+)([^|*]*)(\s+)(\|)(\s+)(\[\s*)(documentation|timeout)(\s*\])(\s*)(\|?)/i, [TT.BK, null, TT.SH, null, TT.BK, null, TT.MT, TT.MT, TT.MT, null, TT.BK], { sol: true });
/** rules for data rows inside test/task definition */
states.test_cases = [
    ...RULES_TABLE,
    RULE_WS_LINE,
    RULE_ELLIPSIS,
    RULE_TAGS,
    RULE_SETTING_KEYWORD,
    RULE_CASE_SETTING_SIMPLE,
    RULE_CASE_SETTING_SIMPLE_PIPE,
    ...RULES_CONTROL_FLOW,
    r(/([^|\s*].+?)(?=(\t|  +|$))/, TT.SH, { sol: true }),
    ...RULES_KEYWORD_INVOKING,
    r(/(\|\s+)([^\s*|.][^|]*?)(\s*)(\|?$)/, [TT.BK, TT.SH, TT.BK], {
        sol: true
    }),
    r(/(\| +)([^|\s].+?)(\s*)( \| )/, [TT.BK, TT.SH, null, TT.BK], {
        sol: true
    }),
    ...base
];
/** rules for inside of an invoked keyword instance */
states.keyword_invocation = [
    r(/( ?)(=)(\t+|  +|\s+\|)/, [null, TT.OP, null]),
    r(/(?=\s*$)/, null, { pop: true }),
    r(/(\\|\.\.\.) +/, TT.BK),
    RULE_VAR_START,
    RULE_LINE_ENDS_WITH_VAR,
    RULE_VAR_END,
    RULE_COMMENT_POP,
    r(/( \| |  +|\t+)(?=[$@&])/, TT.BK),
    r(/( \| |  +|\t+)/, TT.BK, { pop: true }),
    r(/ /, null),
    r(KEYWORD_WORD_BEFORE_VAR, TT.KW, { pop: true }),
    r(KEYWORD_WORD_WITH_SPACES_BEFORE_SEP, TT.KW, { pop: true }),
    r(KEYWORD_WORD_BEFORE_SEP, TT.KW, { pop: true }),
    r(KEYWORD_WORD_BEFORE_WS, TT.KW),
    ...base
];
states.keyword_invocation_no_continue = [RULE_NOT_ELLIPSIS_POP, ...states.keyword_invocation];
/** curious rule for the variables table */
states.variables = [...base];
/** rules for inside of a variable reference */
states.variable = [
    RULE_VAR_START,
    r(VAR_BUILTIN, TT.BI),
    RULE_NUM,
    r(VAR_OP, TT.OP),
    r(/(:)(.*?[^\\])(?=\}\s*$)/, [TT.OP, TT.S2], { pop: true }),
    r(/(:)(.*?[^\\])(?=\})/, [TT.OP, TT.S2]),
    r(/\./, TT.OP, { push: 'variable_property' }),
    r(/\[/, TT.BK, { next: 'variable_index' }),
    r(/\}(?=\[)/, TT.V2),
    r(/(?=\}\s*$)/, null, { pop: true }),
    r(/\}/, TT.V2, { pop: true }),
    r(/[^{}\n:]/, TT.V2)
];
/** rules for extended syntax in a variable reference */
states.variable_property = [
    RULE_VAR_START,
    RULE_VAR_END,
    RULE_NUM,
    RULE_SINGLE_STRING_START,
    RULE_DOUBLE_STRING_START,
    r(VAR_OP, TT.OP),
    r(/\(/, TT.BK),
    r(/\)/, TT.BK, { pop: true }),
    r(/([a-z_][a-z_\d]*)(=)/i, [TT.V2, TT.OP]),
    r(/,/, TT.PC),
    r(/[^}](?=\})/, TT.PR, { pop: true }),
    r(/(\})(\s*(?=$|\n))/, [TT.BK, null], { pop: true }),
    r(/\t*(?=$|\n)/, null, { pop: true }),
    r(/[^}]/, TT.PR)
];
/** rules for strings with single quotes */
states.single_string = [r(/\\'/, TT.ST), r(/'/, TT.ST, { pop: true }), r(/./, TT.ST)];
/** rules for strings with double quotes */
states.double_string = [r(/\\"/, TT.ST), r(/"/, TT.ST, { pop: true }), r(/./, TT.ST)];
/** rules for square-bracketed index referencing */
states.variable_index = [
    RULE_VAR_START,
    RULE_VAR_END,
    RULE_NUM,
    r(/\[/, TT.BK),
    r(/\](?=\])/, TT.BK),
    r(/(\])(\})( ?=?)/, [TT.BK, TT.V2, TT.OP], { pop: true }),
    r(/(\])(\[)/, TT.BK),
    r(/\]/, TT.BK, { pop: true }),
    r(/[^\]]/, TT.ST)
];
// TODO: Re-add `indentPlugin` once the mac double-space-dot-issue tracked here https://github.com/codemirror/view/pull/39
const robotFramework = () => [dist/* StreamLanguage.define */.il.define(simpleMode(states))];


/***/ }),

/***/ 7802:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "V": () => (/* binding */ Dialog)
});

// EXTERNAL MODULE: ./node_modules/react/jsx-runtime.js
var jsx_runtime = __webpack_require__(38);
// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(4191);
// EXTERNAL MODULE: ./node_modules/styled-system/dist/index.esm.js + 13 modules
var index_esm = __webpack_require__(4912);
// EXTERNAL MODULE: ./node_modules/@robocorp/ds/node_modules/@floating-ui/react-dom-interactions/dist/floating-ui.react-dom-interactions.mjs + 2 modules
var floating_ui_react_dom_interactions = __webpack_require__(9277);
// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/components/Button/Button.js + 1 modules
var Button = __webpack_require__(8100);
// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconX.js
var IconX = __webpack_require__(845);
// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/components/Panel/Panel.js
var Panel = __webpack_require__(1739);
// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/helpers/component.js
var component = __webpack_require__(8335);
// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/theme/index.js + 2 modules
var theme = __webpack_require__(3694);
// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/hooks/usePortal.js
var usePortal = __webpack_require__(5593);
// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/theme/shouldForwardProp.js
var shouldForwardProp = __webpack_require__(9978);
// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/components/Transition/Transition.js + 4 modules
var Transition = __webpack_require__(8159);
;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Dialog/components/Actions.js

/**
 * Dialog component helper component to display main actions controls.
 *
 * @see
 * {@link https://design-system.solventek.com/component/dialog}
 */
const Actions = theme/* styled.footer */.zo.footer `
  display: flex;
  justify-content: flex-end;
  align-items: center;
  padding: 18px 20px;
  border-top: 1px solid ${({ theme }) => theme.color('dark60')};
  width: 100%;

  > * + * {
    margin-left: 18px;
  }
`;
/* harmony default export */ const components_Actions = (Actions);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Dialog/components/Content.js


const Container = theme/* styled.section */.zo.section `
  overflow-y: auto;
  height: 100%;
  max-height: calc(100vh - 160px);
  padding: 18px ${({ padding }) => padding}px;
`;
const TextStyled = theme/* styled.p */.zo.p `
  padding: 8px 18px;
  line-height: ${({ theme }) => theme.lineHeights.$140};
`;
/**
 * Dialog component helper component to display dialog's content.
 *
 * @see
 * {@link https://design-system.solventek.com/component/dialog}
 */
const Content = ({ children, padding }) => {
    return ((0,jsx_runtime.jsx)(Container, Object.assign({ className: "dialog-content", padding: padding }, { children: typeof children === 'string' ? (0,jsx_runtime.jsx)(TextStyled, { children: children }) : children })));
};
Content.defaultProps = {
    padding: 20
};
/* harmony default export */ const components_Content = (Content);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Dialog/Dialog.js
var __rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};














const compoundComponents = {
    Content: components_Content,
    Actions: components_Actions
};
const Backdrop = (0,theme/* styled */.zo)(floating_ui_react_dom_interactions/* FloatingOverlay */.y0) `
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: ${({ $fullscreen, theme }) => ($fullscreen ? theme.zIndex.overlay : theme.zIndex.dialog)};
  background: ${({ theme }) => (theme.name === 'light' ? 'rgba(91, 105, 123, 0.8)' : 'rgba(0, 0, 0, 0.6)')};
`;
const DialogStyled = (0,theme/* styled */.zo)('div').withConfig({ shouldForwardProp: shouldForwardProp/* shouldForwardProp */.x }) `
  max-width: calc(100vw - 40px);
  ${index_esm/* width */.bf}
`;
const FullscreenDialogStyled = (0,theme/* styled */.zo)('div').withConfig({ shouldForwardProp: shouldForwardProp/* shouldForwardProp */.x }) `
  width: 100%;
  height: 100%;
  z-index: ${({ theme }) => theme.zIndex.dialog};
`;
/**
 * Dialog is a type of modal window that appears in front of app content to provide critical information or ask for a decision.
 *
 * @see
 * {@link https://design-system.solventek.com/component/dialog}
 *
 * @example
 *  <Dialog trigger={<Button onClick={onOpen}>Open</Button>} open={open} onClose={onClose} title="Dialog title" width={480}>
 *   <Dialog.Content>...</Dialog.Content>
 *   <Dialog.Actions>...</Dialog.Actions>
 * </Dialog
 */
const Dialog = (0,component/* componentWithRef */.w)((_a, forwardRef) => {
    var { children, onClose, open, title, headerImage, overlayImage, trigger, variant } = _a, rest = __rest(_a, ["children", "onClose", "open", "title", "headerImage", "overlayImage", "trigger", "variant"]);
    const { reference, floating, context } = (0,floating_ui_react_dom_interactions/* useFloating */.YF)({
        open,
        onOpenChange: onClose
    });
    const Portal = (0,usePortal/* usePortal */.v)();
    const id = (0,floating_ui_react_dom_interactions/* useId */.PC)();
    const labelId = `${id}-label`;
    const isFullscreen = variant === 'fullscreen';
    const { getReferenceProps, getFloatingProps } = (0,floating_ui_react_dom_interactions/* useInteractions */.NI)([
        (0,floating_ui_react_dom_interactions/* useClick */.eS)(context),
        (0,floating_ui_react_dom_interactions/* useRole */.qs)(context),
        (0,floating_ui_react_dom_interactions/* useDismiss */.bQ)(context, { bubbles: false, outsidePress: !isFullscreen })
    ]);
    const panelActions = (0,react.useCallback)(() => {
        return (0,jsx_runtime.jsx)(Button/* Button */.z, { "aria-label": "Close", icon: IconX/* default */.Z, onClick: onClose, variant: "secondary" });
    }, [onClose]);
    const Wrapper = isFullscreen ? FullscreenDialogStyled : DialogStyled;
    return ((0,jsx_runtime.jsxs)(jsx_runtime.Fragment, { children: [(0,react.isValidElement)(trigger) && (0,react.cloneElement)(trigger, getReferenceProps(Object.assign({ ref: reference }, trigger.props))), (0,jsx_runtime.jsx)(Transition/* Transition.Fade */.u.Fade, Object.assign({ in: open, timeout: { enter: 120, exit: 80 } }, { children: (0,jsx_runtime.jsx)(Portal, { children: (0,jsx_runtime.jsx)(Backdrop, Object.assign({ "$fullscreen": isFullscreen, lockScroll: true }, { children: (0,jsx_runtime.jsx)(floating_ui_react_dom_interactions/* FloatingFocusManager */.wD, Object.assign({ context: context }, { children: (0,jsx_runtime.jsx)(Transition/* Transition.Scale */.u.Scale, Object.assign({ in: open, enter: false, exit: false, appear: true }, { children: (0,jsx_runtime.jsx)(Wrapper, Object.assign({ ref: forwardRef }, rest, getFloatingProps({
                                    ref: floating,
                                    'aria-labelledby': labelId
                                }), { children: (0,jsx_runtime.jsx)(Panel/* default */.Z, Object.assign({ header: title, headerImage: headerImage, overlayImage: overlayImage, actions: panelActions, divider: !!title, titleId: labelId }, { children: children })) })) })) })) })) }) }))] }));
}, compoundComponents);
Dialog.defaultProps = {
    width: 400
};


/***/ }),

/***/ 1493:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38);
/* harmony import */ var _theme__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3694);
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(8335);
var __rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};



const StyledDivider = (0,_theme__WEBPACK_IMPORTED_MODULE_1__/* .styled */ .zo)('hr') `
  display: block;
  background: ${({ theme }) => theme.color('dark60', 'light70')};
  ${({ orientation }) => (orientation === 'horizontal' ? 'height: 1px' : 'width: 1px')};
  margin: 0px;

  &:last-child {
    display: none;
  }
`;
const StyledLabelDivider = _theme__WEBPACK_IMPORTED_MODULE_1__/* .styled.span */ .zo.span `
  font-size: ${({ theme }) => theme.fontSizes.$12};
  color: ${({ theme }) => theme.color('dark40', 'light40')};
  font-weight: 500;
  display: block;
  white-space: nowrap;
  text-overflow: ellipsis;
  overflow: hidden;
  position: relative;
  width: 100%;

  ::after {
    background-color: ${({ theme }) => theme.color('dark60', 'light70')};
    content: '';
    position: absolute;
    top: 50%;
    width: 100%;
    height: 1px;
    margin-left: 8px;
  }
`;
const Divider = (0,_helpers__WEBPACK_IMPORTED_MODULE_2__/* .componentWithRef */ .w)((_a, forwardedRef) => {
    var { orientation, label } = _a, rest = __rest(_a, ["orientation", "label"]);
    if (label === undefined) {
        return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(StyledDivider, Object.assign({ ref: forwardedRef, orientation: orientation, role: "separator" }, rest)));
    }
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(StyledLabelDivider, Object.assign({ ref: forwardedRef, role: "separator" }, rest, { children: label })));
});
Divider.defaultProps = {
    orientation: 'horizontal'
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Divider);


/***/ }),

/***/ 3853:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "L": () => (/* binding */ Dropdown),
  "x": () => (/* binding */ useDropdown)
});

// EXTERNAL MODULE: ./node_modules/react/jsx-runtime.js
var jsx_runtime = __webpack_require__(38);
// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(4191);
// EXTERNAL MODULE: ./node_modules/styled-system/dist/index.esm.js + 13 modules
var index_esm = __webpack_require__(4912);
// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/theme/index.js + 2 modules
var theme = __webpack_require__(3694);
// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/helpers/component.js
var component = __webpack_require__(8335);
// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/components/Button/Button.js + 1 modules
var Button = __webpack_require__(8100);
// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconChevronDown.js
var IconChevronDown = __webpack_require__(3469);
// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/components/Tooltip/Tooltip.js
var Tooltip = __webpack_require__(4183);
// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/components/Menu/Menu.js + 7 modules
var Menu = __webpack_require__(9492);
// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/components/Typography/Typography.js
var Typography = __webpack_require__(2888);
;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Dropdown/components/Item.js
var __rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};




/**
 * A Dropdown item as a button or anchor element containing a single choice of the Dropdown.
 *
 * @see
 * {@link https://design-system.solventek.com/component/dropdown#item}
 *
 * @example
 * <Dropdown.Item>
 *   <Dropdown.Item label="With onClick" onClick={() => ''} />
 * </Menu>
 */
const Item = (0,component/* componentWithRef */.w)((_a, forwardedRef) => {
    var { children, icon, label, secondary, href, active } = _a, rest = __rest(_a, ["children", "icon", "label", "secondary", "href", "active"]);
    if (href) {
        return ((0,jsx_runtime.jsxs)(Menu/* Menu.Link */.v.Link, Object.assign({ href: href, active: active, icon: icon, ref: forwardedRef }, rest, { children: [(0,jsx_runtime.jsx)(Typography/* Typography */.Z, { children: label }), secondary && ((0,jsx_runtime.jsx)(Typography/* Typography */.Z, Object.assign({ fontSize: "$11", color: "dark30" }, { children: secondary }))), children] })));
    }
    return ((0,jsx_runtime.jsxs)(Menu/* Menu.Item */.v.Item, Object.assign({ active: active, icon: icon, ref: forwardedRef }, rest, { children: [(0,jsx_runtime.jsx)(Typography/* Typography */.Z, { children: label }), secondary && ((0,jsx_runtime.jsx)(Typography/* Typography */.Z, Object.assign({ fontSize: "$11", color: "dark30" }, { children: secondary }))), children] })));
});

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Dropdown/Dropdown.js
var Dropdown_rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};










const compoundComponents = {
    Item: Item
};
const DropdownWrapper = theme/* styled.div */.zo.div `
  position: relative;
  display: flex;
  ${index_esm/* padding */.o3}
  ${index_esm/* margin */.e6}
`;
const StyledButtonLeft = (0,theme/* styled */.zo)(Button/* Button */.z) `
  border-top-right-radius: 0;
  border-bottom-right-radius: 0;
  border-right: none;
`;
const StyledButtonRight = (0,theme/* styled */.zo)(Button/* Button */.z) `
  border-top-left-radius: 0;
  border-bottom-left-radius: 0;
  border-left: none;
`;
/**
 * Dropdown context
 */
const DropdownContext = (0,react.createContext)(() => null);
const useDropdown = () => ({
    toggleDropdown: (0,react.useContext)(DropdownContext)
});
/**
 * A Dropdown displays a list of choices, appearing when the user interacts with a Button.
 *
 * For controlled or custom trigger element, use the [Menu](https://design-system.solventek.com/component/menu) component.
 *
 * @see
 * {@link https://design-system.solventek.com/component/dropdown}
 *
 * @example
 * <Dropdown icon={IconMoreHorizontal}>
 *   <Dropdown.Item label="Edit" />
 * </Dropdown>
 */
const Dropdown = (0,component/* componentWithRef */.w)((_a, forwardedRef) => {
    var { children, width, maxHeight, offset, icon, iconAfter, disabled, title, tooltip, tooltipPosition, onButtonClick, variant, position, onClose, size } = _a, rest = Dropdown_rest(_a, ["children", "width", "maxHeight", "offset", "icon", "iconAfter", "disabled", "title", "tooltip", "tooltipPosition", "onButtonClick", "variant", "position", "onClose", "size"]);
    const [isMenuVisible, setMenuVisible] = (0,react.useState)(false);
    const handleVisible = (0,react.useCallback)((e, allowPropagation) => {
        if (!allowPropagation) {
            e.stopPropagation();
        }
        setMenuVisible((value) => {
            if (value)
                onClose === null || onClose === void 0 ? void 0 : onClose();
            return !value;
        });
    }, [onClose]);
    const buttonTrigger = (0,react.useMemo)(() => {
        return (typeof onButtonClick === 'function' && ((0,jsx_runtime.jsx)(StyledButtonLeft, Object.assign({ icon: icon, variant: variant, onClick: onButtonClick, disabled: disabled, size: size }, { children: title }))));
    }, [onButtonClick, title, icon, variant, disabled, handleVisible]);
    const menuTrigger = (0,react.useMemo)(() => {
        const hasButton = typeof onButtonClick === 'function';
        return !hasButton ? ((0,jsx_runtime.jsx)(Button/* Button */.z, Object.assign({ icon: icon, variant: variant, iconAfter: iconAfter, disabled: disabled, size: size }, { children: title }))) : ((0,jsx_runtime.jsx)(StyledButtonRight, { variant: variant, iconAfter: iconAfter || IconChevronDown/* default */.Z, disabled: disabled }));
    }, [onButtonClick, title, icon, iconAfter, variant, disabled, handleVisible]);
    return ((0,jsx_runtime.jsx)(DropdownContext.Provider, Object.assign({ value: handleVisible }, { children: (0,jsx_runtime.jsx)(DropdownWrapper, Object.assign({ ref: forwardedRef }, rest, { children: (0,jsx_runtime.jsxs)(Tooltip/* default */.Z, Object.assign({ text: tooltip, placement: tooltipPosition, fadeIn: 200 }, { children: [buttonTrigger, (0,jsx_runtime.jsx)(Menu/* Menu */.v, Object.assign({ visible: isMenuVisible, setVisible: setMenuVisible, width: width, offset: offset, placement: position, maxHeight: maxHeight, minWidth: 120, trigger: menuTrigger, size: size, "data-testid": rest.id }, { children: children }))] })) })) })));
}, compoundComponents);
Dropdown.defaultProps = {
    width: 120,
    offset: 8,
    variant: 'secondary',
    tooltipPosition: 'left',
    position: 'bottom-end',
    size: 'medium'
};


/***/ }),

/***/ 6967:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38);
/* harmony import */ var styled_system__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4912);
/* harmony import */ var _theme__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3694);
var __rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};



const FieldsetStyled = _theme__WEBPACK_IMPORTED_MODULE_2__/* .styled.div */ .zo.div `
  display: flex;
  align-items: stretch;
  margin-bottom: 20px;
  padding-right: 16px;
  padding-top: ${({ padding }) => (padding ? '24px' : '0')};
  ${styled_system__WEBPACK_IMPORTED_MODULE_1__/* .width */ .bf};
  ${({ narrow }) => narrow && 'width: auto;'}

  ${({ controls }) => controls
    ? `
      justify-content: flex-end;
      & > * {
        margin-left: 16px;
      }
    `
    : `
    & > * {
      flex: 1;
    }
  `}
`;
const Fieldset = (_a) => {
    var { children } = _a, rest = __rest(_a, ["children"]);
    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(FieldsetStyled, Object.assign({}, rest, { children: children }));
};
Fieldset.defaultProps = {
    width: 1
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Fieldset);


/***/ }),

/***/ 9427:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38);
/* harmony import */ var _theme__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3694);
var __rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};


const FormStyled = _theme__WEBPACK_IMPORTED_MODULE_1__/* .styled.form */ .zo.form `
  display: flex;
  flex-wrap: ${({ inline }) => (inline ? 'no-wrap' : 'wrap ')};
  padding: ${({ padding }) => padding && '20px'};
  padding-top: ${({ padding }) => padding && '12px'};
  padding-right: ${({ padding }) => padding && '4px'};
  padding-bottom: 0px;

  > label {
    display: block;
    padding-bottom: 12px;
  }
`;
const Form = (_a) => {
    var { children } = _a, props = __rest(_a, ["children"]);
    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(FormStyled, Object.assign({}, props, { children: children }));
};
Form.defaultProps = {
    inline: false,
    padding: true
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Form);


/***/ }),

/***/ 3170:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "A0": () => (/* binding */ IconBase)
/* harmony export */ });
/* unused harmony exports getIconSize, IconStyled */
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38);
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(8335);
/* harmony import */ var _theme__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3694);
/* harmony import */ var _theme__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(3709);
/* harmony import */ var _theme_helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(9978);
var __rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};




const getIconSize = (size) => {
    switch (size) {
        case 'small':
            return 18;
        case 'large':
            return 32;
        case 'medium':
        default:
            return typeof size === 'number' ? size : 24;
    }
};
const IconStyled = (0,_theme__WEBPACK_IMPORTED_MODULE_1__/* .styled */ .zo)('span').withConfig({ shouldForwardProp: _theme_helpers__WEBPACK_IMPORTED_MODULE_2__/* .shouldForwardProp */ .x }) `
  display: inline-block;
  height: ${({ size }) => getIconSize(size)}px;
  width: ${({ size }) => getIconSize(size)}px;
  line-height: ${({ size }) => getIconSize(size)}px;
  ${_theme__WEBPACK_IMPORTED_MODULE_3__/* .parseColorProps */ .sL}
`;
/**
 * Icon component wrapper
 */
const IconBase = (0,_helpers__WEBPACK_IMPORTED_MODULE_4__/* .componentWithRef */ .w)((_a, forwardRef) => {
    var { children, size } = _a, rest = __rest(_a, ["children", "size"]);
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(IconStyled, Object.assign({ size: size, className: "icon" }, rest, { ref: forwardRef }, { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("svg", Object.assign({ width: "100%", height: "100%", viewBox: "0 0 24 24", fill: "currentColor", stroke: "none" }, { children: children })) })));
});


/***/ }),

/***/ 1360:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38);
/* harmony import */ var _components_Icon_Icon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3170);
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8335);



/**
 * Semantic vector graphics icon IconBrowser.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconBrowser size="large" color="green50" />
 */
const IconBrowser = (0,_helpers__WEBPACK_IMPORTED_MODULE_1__/* .componentWithRef */ .w)((props, forwardRef) => {
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(_components_Icon_Icon__WEBPACK_IMPORTED_MODULE_2__/* .IconBase */ .A0, Object.assign({ ref: forwardRef }, props, { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M3 15.5h2.44a1 1 0 0 1 0 2H3a3 3 0 0 1-3-3V3a3 3 0 0 1 3-3h15.5a3 3 0 0 1 3 3v3.5a1 1 0 0 1-2 0V6a1 1 0 0 0-1-1H3a1 1 0 0 0-1 1v8.5a1 1 0 0 0 1 1ZM6.168 1.944a1 1 0 1 0 1.663 1.112 1 1 0 0 0-1.663-1.112Zm3.776 1.387a1 1 0 1 0 1.111-1.663 1 1 0 0 0-1.11 1.663Zm-5.613-.275a1 1 0 1 0-1.663-1.112 1 1 0 0 0 1.663 1.112Z", fill: "currentColor" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M11.556 9.348a8 8 0 1 1 8.888 13.303 8 8 0 0 1-8.888-13.303Zm7.834 5.762h2.76a6.229 6.229 0 0 0-4.33-5.06 11.19 11.19 0 0 1 1.57 5.06Zm-5 1.78a9.109 9.109 0 0 0 1.61 4.6 9.11 9.11 0 0 0 1.61-4.6h-3.22ZM16 10.51a9.109 9.109 0 0 0-1.61 4.6h3.22a9.11 9.11 0 0 0-1.61-4.6Zm-3.39 4.6a11.19 11.19 0 0 1 1.57-5.06 6.23 6.23 0 0 0-4.33 5.06h2.76Zm0 1.78H9.85A6.23 6.23 0 0 0 14.18 22a11.19 11.19 0 0 1-1.57-5.11Zm6.81 0a11.19 11.19 0 0 1-1.57 5.06l-.03.05a6.23 6.23 0 0 0 4.36-5.11h-2.76Z", fill: "currentColor" })] })));
});
IconBrowser.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (IconBrowser);


/***/ }),

/***/ 8566:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38);
/* harmony import */ var _components_Icon_Icon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3170);
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8335);



/**
 * Semantic vector graphics icon IconButton.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconButton size="large" color="green50" />
 */
const IconButton = (0,_helpers__WEBPACK_IMPORTED_MODULE_1__/* .componentWithRef */ .w)((props, forwardRef) => {
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(_components_Icon_Icon__WEBPACK_IMPORTED_MODULE_2__/* .IconBase */ .A0, Object.assign({ ref: forwardRef }, props, { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("path", { d: "M17.12 17H14.5a.25.25 0 0 1-.25-.25v-6.38a2.38 2.38 0 0 0-4.75 0v8.53a.24.24 0 0 1-.45.14c-.45-.62-1-1.4-1-1.44a2.11 2.11 0 0 0-2.66-.66 2.08 2.08 0 0 0-1 2.42c.09.27 0 0 2.26 4.37A.519.519 0 0 0 7 24h14.25a.49.49 0 0 0 .35-.15.47.47 0 0 0 .15-.35v-1.67A4.81 4.81 0 0 0 17.12 17Z", fill: "currentColor" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("path", { d: "M5.25 11a1 1 0 0 1-1-1V3a1 1 0 0 1 1-1h13.5a1 1 0 0 1 1 1v7a1 1 0 0 1-1 1H16a.25.25 0 0 0-.25.25v1.5A.25.25 0 0 0 16 13h2.75a3 3 0 0 0 3-3V3a3 3 0 0 0-3-3H5.25a3 3 0 0 0-3 3v7a3 3 0 0 0 3 3h2.5a.25.25 0 0 0 .25-.25v-1.5a.25.25 0 0 0-.25-.25h-2.5Z", fill: "currentColor" })] })));
});
IconButton.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (IconButton);


/***/ }),

/***/ 8939:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38);
/* harmony import */ var _components_Icon_Icon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3170);
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8335);



/**
 * Semantic vector graphics icon IconClickHand.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconClickHand size="large" color="green50" />
 */
const IconClickHand = (0,_helpers__WEBPACK_IMPORTED_MODULE_1__/* .componentWithRef */ .w)((props, forwardRef) => {
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components_Icon_Icon__WEBPACK_IMPORTED_MODULE_2__/* .IconBase */ .A0, Object.assign({ ref: forwardRef }, props, { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("path", { d: "M21.86 11.5a3 3 0 0 0-3-3h-.27a2 2 0 0 0-1.73-1h-1.27a2 2 0 0 0-1.73-1h-1V3a2.5 2.5 0 0 0-5 0v10.29l-1.21-1.7a2.485 2.485 0 1 0-4.05 2.88l6.09 8.61a1.005 1.005 0 0 0 1.64-1.16l-6.1-8.61a.48.48 0 0 1 .48-.755.49.49 0 0 1 .31.195l2.12 3a1.5 1.5 0 0 0 2.72-.87V3a.5.5 0 1 1 1 0v7.5a1 1 0 0 0 2 0V8.75a.25.25 0 0 1 .25-.25h.5a.25.25 0 0 1 .25.25v1.75a1 1 0 0 0 2 0v-.75a.25.25 0 0 1 .25-.25h.5a.25.25 0 0 1 .25.25v1.75a1 1 0 0 0 2 0v-.71a.232.232 0 0 1 .11-.2.26.26 0 0 1 .23 0 1 1 0 0 1 .66.95v2.6a9 9 0 0 1-.34 2.47l-1.62 5.61a1 1 0 0 0 1.447 1.149 1 1 0 0 0 .473-.599l1.62-5.65a11.06 11.06 0 0 0 .42-3V11.5Z", fill: "currentColor" }) })));
});
IconClickHand.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (IconClickHand);


/***/ }),

/***/ 1542:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38);
/* harmony import */ var _components_Icon_Icon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3170);
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8335);



/**
 * Semantic vector graphics icon IconGridCell.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconGridCell size="large" color="green50" />
 */
const IconGridCell = (0,_helpers__WEBPACK_IMPORTED_MODULE_1__/* .componentWithRef */ .w)((props, forwardRef) => {
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components_Icon_Icon__WEBPACK_IMPORTED_MODULE_2__/* .IconBase */ .A0, Object.assign({ ref: forwardRef }, props, { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("path", { d: "M7 4.5a1 1 0 0 0 1-1V1a1 1 0 0 0-2 0v2.5a1 1 0 0 0 1 1ZM4.5 7a1 1 0 0 0-1-1H1a1 1 0 0 0 0 2h2.5a1 1 0 0 0 1-1ZM3.5 16H1a1 1 0 0 0 0 2h2.5a1 1 0 0 0 0-2ZM17 0a1 1 0 0 0-1 1v2.5a1 1 0 0 0 2 0V1a1 1 0 0 0-1-1ZM7 19.5a1 1 0 0 0-1 1V23a1 1 0 1 0 2 0v-2.5a1 1 0 0 0-1-1ZM17 19.5a1 1 0 0 0-1 1V23a1 1 0 0 0 2 0v-2.5a1 1 0 0 0-1-1ZM20.5 8H23a1 1 0 1 0 0-2h-2.5a1 1 0 1 0 0 2ZM23 16h-2.5a1 1 0 0 0 0 2H23a1 1 0 0 0 0-2ZM18 7a1 1 0 0 0-1-1H7a1 1 0 0 0-1 1v10a1 1 0 0 0 1 1h10a1 1 0 0 0 1-1V7Zm-2 8.5a.5.5 0 0 1-.5.5h-7a.5.5 0 0 1-.5-.5v-7a.5.5 0 0 1 .5-.5h7a.5.5 0 0 1 .5.5v7Z", fill: "currentColor" }) })));
});
IconGridCell.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (IconGridCell);


/***/ }),

/***/ 9895:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38);
/* harmony import */ var _components_Icon_Icon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3170);
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8335);



/**
 * Semantic vector graphics icon IconInput.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconInput size="large" color="green50" />
 */
const IconInput = (0,_helpers__WEBPACK_IMPORTED_MODULE_1__/* .componentWithRef */ .w)((props, forwardRef) => {
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(_components_Icon_Icon__WEBPACK_IMPORTED_MODULE_2__/* .IconBase */ .A0, Object.assign({ ref: forwardRef }, props, { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("path", { d: "M17.274 22h-1.43a2.82 2.82 0 0 1-2.82-2.82v-2.57a.25.25 0 0 1 .25-.25h1.14a1 1 0 1 0 0-2h-1.14a.25.25 0 0 1-.25-.25V4.82A2.82 2.82 0 0 1 15.844 2h1.43a1 1 0 1 0 0-2h-1.43a4.8 4.8 0 0 0-3.63 1.65.25.25 0 0 1-.38 0A4.799 4.799 0 0 0 8.204 0h-1.43a1 1 0 0 0 0 2h1.43a2.82 2.82 0 0 1 2.82 2.82v9.29a.25.25 0 0 1-.25.25h-1.14a1 1 0 0 0 0 2h1.14a.25.25 0 0 1 .25.25v2.57A2.82 2.82 0 0 1 8.204 22h-1.43a1 1 0 0 0 0 2h1.43a4.8 4.8 0 0 0 3.63-1.65.252.252 0 0 1 .295-.065.25.25 0 0 1 .085.065 4.8 4.8 0 0 0 3.63 1.65h1.43a1 1 0 1 0 0-2ZM1.024 15a1 1 0 0 0 1-1v-2a1 1 0 1 0-2 0v2a1 1 0 0 0 1 1ZM1.024 9.46a1 1 0 0 0 1-.79.23.23 0 0 1 .19-.19 1 1 0 0 0-.19-1.98 2 2 0 0 0-2 1.96 1 1 0 0 0 1 1Z", fill: "currentColor" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("path", { d: "M5.594 8.5h1.91a1 1 0 0 0 0-2h-1.91a1 1 0 1 0 0 2ZM2.204 17.56a.26.26 0 0 1-.2-.2 1.004 1.004 0 1 0-2 .18 2 2 0 0 0 2 2 1.001 1.001 0 0 0 .2-1.98ZM8.504 18.5a1 1 0 0 0-1-1h-1.91a1 1 0 0 0 0 2h1.91a1 1 0 0 0 1-1ZM23.024 11a1 1 0 0 0-1 1v2a1 1 0 0 0 2 0v-2a1 1 0 0 0-1-1ZM21.844 8.44a.26.26 0 0 1 .2.2 1.004 1.004 0 0 0 2-.18 2 2 0 0 0-1.95-2 1 1 0 0 0-1 1 1 1 0 0 0 .75.98ZM18.454 6.5h-1.91a1 1 0 0 0 0 2h1.91a1 1 0 1 0 0-2ZM23.024 16.54a1 1 0 0 0-1 .79.23.23 0 0 1-.19.19 1.006 1.006 0 0 0 .22 2 2 2 0 0 0 1.95-2 1 1 0 0 0-.98-.98ZM18.454 17.5h-1.91a1 1 0 0 0 0 2h1.91a1 1 0 1 0 0-2Z", fill: "currentColor" })] })));
});
IconInput.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (IconInput);


/***/ }),

/***/ 8958:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38);
/* harmony import */ var _components_Icon_Icon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3170);
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8335);



/**
 * Semantic vector graphics icon IconLink.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconLink size="large" color="green50" />
 */
const IconLink = (0,_helpers__WEBPACK_IMPORTED_MODULE_1__/* .componentWithRef */ .w)((props, forwardRef) => {
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(_components_Icon_Icon__WEBPACK_IMPORTED_MODULE_2__/* .IconBase */ .A0, Object.assign({ ref: forwardRef }, props, { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("path", { d: "m10.46 18.37-2.74 2.74a2.86 2.86 0 0 1-3.94 0l-.89-.89a2.769 2.769 0 0 1-.82-2 2.74 2.74 0 0 1 .82-2l5.8-5.81a2.8 2.8 0 0 1 3.94 0l.89.9A1 1 0 1 0 14.94 10l-.89-.89a4.79 4.79 0 0 0-6.77 0l-5.81 5.8a4.79 4.79 0 0 0 0 6.77l.89.89a4.78 4.78 0 0 0 6.78 0l2.73-2.73a1 1 0 0 0 0-1.42 1 1 0 0 0-1.41-.05Z", fill: "currentColor" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("path", { d: "m22.53 2.36-.9-.89a4.8 4.8 0 0 0-6.77 0L12 4.38a1 1 0 1 0 1.41 1.41l2.91-2.9a2.79 2.79 0 0 1 3.94 0l.89.9a2.74 2.74 0 0 1 .82 2 2.77 2.77 0 0 1-.82 2l-5.8 5.8a2.77 2.77 0 0 1-2 .82 2.75 2.75 0 0 1-2-.82A1 1 0 0 0 10 14.93a4.758 4.758 0 0 0 3.39 1.41 4.75 4.75 0 0 0 3.38-1.4l5.81-5.81a4.79 4.79 0 0 0 0-6.77h-.05Z", fill: "currentColor" })] })));
});
IconLink.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (IconLink);


/***/ }),

/***/ 8788:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38);
/* harmony import */ var _components_Icon_Icon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3170);
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8335);



/**
 * Semantic vector graphics icon IconSetValue.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconSetValue size="large" color="green50" />
 */
const IconSetValue = (0,_helpers__WEBPACK_IMPORTED_MODULE_1__/* .componentWithRef */ .w)((props, forwardRef) => {
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(_components_Icon_Icon__WEBPACK_IMPORTED_MODULE_2__/* .IconBase */ .A0, Object.assign({ ref: forwardRef }, props, { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("path", { d: "M12 24A12 12 0 1 0 12 .001 12 12 0 0 0 12 24Zm0-2a10 10 0 1 1 0-20 10 10 0 0 1 0 20Z", fill: "currentColor" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("path", { d: "m12.11 15.62 1.94-1.94a.25.25 0 0 0 .06-.28.25.25 0 0 0-.23-.15H6a1.25 1.25 0 0 1 0-2.5h7.88a.25.25 0 0 0 .23-.15.24.24 0 0 0-.06-.28l-1.94-1.94a1.25 1.25 0 0 1 1.77-1.76l4.5 4.5a1.23 1.23 0 0 1 0 1.76l-4.5 4.5a1.25 1.25 0 0 1-1.77-1.76Z", fill: "currentColor" })] })));
});
IconSetValue.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (IconSetValue);


/***/ }),

/***/ 5550:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38);
/* harmony import */ var _components_Icon_Icon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3170);
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8335);



/**
 * Semantic vector graphics icon IconTime.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconTime size="large" color="green50" />
 */
const IconTime = (0,_helpers__WEBPACK_IMPORTED_MODULE_1__/* .componentWithRef */ .w)((props, forwardRef) => {
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(_components_Icon_Icon__WEBPACK_IMPORTED_MODULE_2__/* .IconBase */ .A0, Object.assign({ ref: forwardRef }, props, { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("path", { d: "M12 0a12 12 0 1 0 0 24 12 12 0 0 0 0-24Zm0 22a10 10 0 1 1 0-20 10 10 0 0 1 0 20Z", fill: "currentColor" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("path", { d: "m17.13 15.81-4.63-4.25V6.5a1 1 0 1 0-2 0V12a1 1 0 0 0 .32.74l5 4.54a1 1 0 0 0 1.42-.06 1 1 0 0 0-.11-1.41Z", fill: "currentColor" })] })));
});
IconTime.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (IconTime);


/***/ }),

/***/ 6137:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38);
/* harmony import */ var _components_Icon_Icon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3170);
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8335);



/**
 * Semantic vector graphics icon IconCheck.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconCheck size="large" color="green50" />
 */
const IconCheck = (0,_helpers__WEBPACK_IMPORTED_MODULE_1__/* .componentWithRef */ .w)((props, forwardRef) => {
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components_Icon_Icon__WEBPACK_IMPORTED_MODULE_2__/* .IconBase */ .A0, Object.assign({ ref: forwardRef }, props, { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M20.707 5.293a1 1 0 0 1 0 1.414l-11 11a1 1 0 0 1-1.414 0l-5-5a1 1 0 1 1 1.414-1.414L9 15.586 19.293 5.293a1 1 0 0 1 1.414 0Z", fill: "currentColor" }) })));
});
IconCheck.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (IconCheck);


/***/ }),

/***/ 5584:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38);
/* harmony import */ var _components_Icon_Icon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3170);
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8335);



/**
 * Semantic vector graphics icon IconCheckSquare.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconCheckSquare size="large" color="green50" />
 */
const IconCheckSquare = (0,_helpers__WEBPACK_IMPORTED_MODULE_1__/* .componentWithRef */ .w)((props, forwardRef) => {
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components_Icon_Icon__WEBPACK_IMPORTED_MODULE_2__/* .IconBase */ .A0, Object.assign({ ref: forwardRef }, props, { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M4.293 4.293A1 1 0 0 1 5 4h11a1 1 0 1 0 0-2H5a3 3 0 0 0-3 3v14a3 3 0 0 0 3 3h14a3 3 0 0 0 3-3v-7a1 1 0 1 0-2 0v7a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1V5a1 1 0 0 1 .293-.707Zm8.414 10.414 10-10a1 1 0 0 0-1.414-1.414L12 12.586l-2.293-2.293a1 1 0 1 0-1.414 1.414l3 3a1 1 0 0 0 1.414 0Z", fill: "currentColor" }) })));
});
IconCheckSquare.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (IconCheckSquare);


/***/ }),

/***/ 3469:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38);
/* harmony import */ var _components_Icon_Icon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3170);
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8335);



/**
 * Semantic vector graphics icon IconChevronDown.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconChevronDown size="large" color="green50" />
 */
const IconChevronDown = (0,_helpers__WEBPACK_IMPORTED_MODULE_1__/* .componentWithRef */ .w)((props, forwardRef) => {
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components_Icon_Icon__WEBPACK_IMPORTED_MODULE_2__/* .IconBase */ .A0, Object.assign({ ref: forwardRef }, props, { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M5.293 8.293a1 1 0 0 1 1.414 0L12 13.586l5.293-5.293a1 1 0 1 1 1.414 1.414l-6 6a1 1 0 0 1-1.414 0l-6-6a1 1 0 0 1 0-1.414Z", fill: "currentColor" }) })));
});
IconChevronDown.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (IconChevronDown);


/***/ }),

/***/ 2554:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38);
/* harmony import */ var _components_Icon_Icon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3170);
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8335);



/**
 * Semantic vector graphics icon IconChevronRight.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconChevronRight size="large" color="green50" />
 */
const IconChevronRight = (0,_helpers__WEBPACK_IMPORTED_MODULE_1__/* .componentWithRef */ .w)((props, forwardRef) => {
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components_Icon_Icon__WEBPACK_IMPORTED_MODULE_2__/* .IconBase */ .A0, Object.assign({ ref: forwardRef }, props, { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M8.293 5.293a1 1 0 0 1 1.414 0l6 6a1 1 0 0 1 0 1.414l-6 6a1 1 0 0 1-1.414-1.414L13.586 12 8.293 6.707a1 1 0 0 1 0-1.414Z", fill: "currentColor" }) })));
});
IconChevronRight.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (IconChevronRight);


/***/ }),

/***/ 4222:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38);
/* harmony import */ var _components_Icon_Icon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3170);
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8335);



/**
 * Semantic vector graphics icon IconClipboard.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconClipboard size="large" color="green50" />
 */
const IconClipboard = (0,_helpers__WEBPACK_IMPORTED_MODULE_1__/* .componentWithRef */ .w)((props, forwardRef) => {
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components_Icon_Icon__WEBPACK_IMPORTED_MODULE_2__/* .IconBase */ .A0, Object.assign({ ref: forwardRef }, props, { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M9 1a2 2 0 0 0-2 2H6a3 3 0 0 0-3 3v14a3 3 0 0 0 3 3h12a3 3 0 0 0 3-3V6a3 3 0 0 0-3-3h-1a2 2 0 0 0-2-2H9Zm8 4a2 2 0 0 1-2 2H9a2 2 0 0 1-2-2H6a1 1 0 0 0-1 1v14a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1V6a1 1 0 0 0-1-1h-1ZM9 4v1h6V3H9v1Z", fill: "currentColor" }) })));
});
IconClipboard.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (IconClipboard);


/***/ }),

/***/ 1747:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38);
/* harmony import */ var _components_Icon_Icon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3170);
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8335);



/**
 * Semantic vector graphics icon IconClock.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconClock size="large" color="green50" />
 */
const IconClock = (0,_helpers__WEBPACK_IMPORTED_MODULE_1__/* .componentWithRef */ .w)((props, forwardRef) => {
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components_Icon_Icon__WEBPACK_IMPORTED_MODULE_2__/* .IconBase */ .A0, Object.assign({ ref: forwardRef }, props, { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M3 12a9 9 0 1 1 18 0 9 9 0 0 1-18 0Zm9-11C5.925 1 1 5.925 1 12s4.925 11 11 11 11-4.925 11-11S18.075 1 12 1Zm1 5a1 1 0 1 0-2 0v6a1 1 0 0 0 .553.894l4 2a1 1 0 1 0 .894-1.788L13 11.382V6Z", fill: "currentColor" }) })));
});
IconClock.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (IconClock);


/***/ }),

/***/ 878:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38);
/* harmony import */ var _components_Icon_Icon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3170);
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8335);



/**
 * Semantic vector graphics icon IconCode.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconCode size="large" color="green50" />
 */
const IconCode = (0,_helpers__WEBPACK_IMPORTED_MODULE_1__/* .componentWithRef */ .w)((props, forwardRef) => {
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components_Icon_Icon__WEBPACK_IMPORTED_MODULE_2__/* .IconBase */ .A0, Object.assign({ ref: forwardRef }, props, { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M8.707 6.707a1 1 0 0 0-1.414-1.414l-6 6a1 1 0 0 0 0 1.414l6 6a1 1 0 0 0 1.414-1.414L3.414 12l5.293-5.293Zm8-1.414a1 1 0 1 0-1.414 1.414L20.586 12l-5.293 5.293a1 1 0 0 0 1.414 1.414l6-6a1 1 0 0 0 0-1.414l-6-6Z", fill: "currentColor" }) })));
});
IconCode.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (IconCode);


/***/ }),

/***/ 7457:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38);
/* harmony import */ var _components_Icon_Icon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3170);
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8335);



/**
 * Semantic vector graphics icon IconCrosshair.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconCrosshair size="large" color="green50" />
 */
const IconCrosshair = (0,_helpers__WEBPACK_IMPORTED_MODULE_1__/* .componentWithRef */ .w)((props, forwardRef) => {
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components_Icon_Icon__WEBPACK_IMPORTED_MODULE_2__/* .IconBase */ .A0, Object.assign({ ref: forwardRef }, props, { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M1 12C1 5.925 5.925 1 12 1s11 4.925 11 11-4.925 11-11 11S1 18.075 1 12Zm12 8.945V18a1 1 0 1 0-2 0v2.945A9.004 9.004 0 0 1 3.055 13H6a1 1 0 1 0 0-2H3.055A9.004 9.004 0 0 1 11 3.055V6a1 1 0 1 0 2 0V3.055A9.004 9.004 0 0 1 20.945 11H18a1 1 0 1 0 0 2h2.945A9.004 9.004 0 0 1 13 20.945Z", fill: "currentColor" }) })));
});
IconCrosshair.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (IconCrosshair);


/***/ }),

/***/ 1246:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38);
/* harmony import */ var _components_Icon_Icon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3170);
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8335);



/**
 * Semantic vector graphics icon IconDelete.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconDelete size="large" color="green50" />
 */
const IconDelete = (0,_helpers__WEBPACK_IMPORTED_MODULE_1__/* .componentWithRef */ .w)((props, forwardRef) => {
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components_Icon_Icon__WEBPACK_IMPORTED_MODULE_2__/* .IconBase */ .A0, Object.assign({ ref: forwardRef }, props, { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M9.293 3.293A1 1 0 0 1 10 3h4a1 1 0 0 1 1 1v1H9V4a1 1 0 0 1 .293-.707ZM7 5V4a3 3 0 0 1 3-3h4a3 3 0 0 1 3 3v1h4a1 1 0 1 1 0 2h-1v13a3 3 0 0 1-3 3H7a3 3 0 0 1-3-3V7H3a1 1 0 0 1 0-2h4ZM6 7v13a1 1 0 0 0 1 1h10a1 1 0 0 0 1-1V7H6Zm4 3a1 1 0 0 1 1 1v6a1 1 0 1 1-2 0v-6a1 1 0 0 1 1-1Zm5 7v-6a1 1 0 1 0-2 0v6a1 1 0 1 0 2 0Z", fill: "currentColor" }) })));
});
IconDelete.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (IconDelete);


/***/ }),

/***/ 6108:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38);
/* harmony import */ var _components_Icon_Icon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3170);
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8335);



/**
 * Semantic vector graphics icon IconEdit.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconEdit size="large" color="green50" />
 */
const IconEdit = (0,_helpers__WEBPACK_IMPORTED_MODULE_1__/* .componentWithRef */ .w)((props, forwardRef) => {
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components_Icon_Icon__WEBPACK_IMPORTED_MODULE_2__/* .IconBase */ .A0, Object.assign({ ref: forwardRef }, props, { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M19 3.172a1.829 1.829 0 0 0-1.293.535L4.395 17.02l-.97 3.556 3.556-.97L20.293 6.293A1.829 1.829 0 0 0 19 3.172Zm-1.465-1.709a3.829 3.829 0 0 1 4.172 6.244l-13.5 13.5a1 1 0 0 1-.444.258l-5.5 1.5a1 1 0 0 1-1.228-1.228l1.5-5.5a1 1 0 0 1 .258-.444l13.5-13.5a3.83 3.83 0 0 1 1.242-.83Z", fill: "currentColor" }) })));
});
IconEdit.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (IconEdit);


/***/ }),

/***/ 7760:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38);
/* harmony import */ var _components_Icon_Icon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3170);
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8335);



/**
 * Semantic vector graphics icon IconEditForm.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconEditForm size="large" color="green50" />
 */
const IconEditForm = (0,_helpers__WEBPACK_IMPORTED_MODULE_1__/* .componentWithRef */ .w)((props, forwardRef) => {
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components_Icon_Icon__WEBPACK_IMPORTED_MODULE_2__/* .IconBase */ .A0, Object.assign({ ref: forwardRef }, props, { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M19.207 3.207a1.121 1.121 0 0 1 1.586 1.586l-9.304 9.304-2.115.529.529-2.115 9.304-9.304ZM20 .88c-.828 0-1.622.329-2.207.914l-9.5 9.5a1 1 0 0 0-.263.464l-1 4a1 1 0 0 0 1.213 1.213l4-1a1 1 0 0 0 .464-.263l9.5-9.5A3.121 3.121 0 0 0 20 .88ZM4 3a3 3 0 0 0-3 3v14a3 3 0 0 0 3 3h14a3 3 0 0 0 3-3v-7a1 1 0 1 0-2 0v7a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1V6a1 1 0 0 1 1-1h7a1 1 0 1 0 0-2H4Z", fill: "currentColor" }) })));
});
IconEditForm.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (IconEditForm);


/***/ }),

/***/ 6699:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38);
/* harmony import */ var _components_Icon_Icon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3170);
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8335);



/**
 * Semantic vector graphics icon IconExclamationTriangle.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconExclamationTriangle size="large" color="green50" />
 */
const IconExclamationTriangle = (0,_helpers__WEBPACK_IMPORTED_MODULE_1__/* .componentWithRef */ .w)((props, forwardRef) => {
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components_Icon_Icon__WEBPACK_IMPORTED_MODULE_2__/* .IconBase */ .A0, Object.assign({ ref: forwardRef }, props, { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M10.528 2.283a3 3 0 0 1 4.037 1.058l.003.005 8.47 14.14.008.014A3 3 0 0 1 20.48 22H3.519a3 3 0 0 1-2.565-4.5l.008-.014 8.47-14.14.858.514-.855-.519a3 3 0 0 1 1.093-1.058Zm.618 2.094L2.682 18.506A1 1 0 0 0 3.536 20h16.927a1 1 0 0 0 .854-1.494L12.855 4.379l-.001-.002a1 1 0 0 0-1.708 0ZM12 8a1 1 0 0 1 1 1v4a1 1 0 1 1-2 0V9a1 1 0 0 1 1-1Zm0 8a1 1 0 1 0 0 2h.01a1 1 0 1 0 0-2H12Z", fill: "currentColor" }) })));
});
IconExclamationTriangle.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (IconExclamationTriangle);


/***/ }),

/***/ 4103:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38);
/* harmony import */ var _components_Icon_Icon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3170);
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8335);



/**
 * Semantic vector graphics icon IconFile.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconFile size="large" color="green50" />
 */
const IconFile = (0,_helpers__WEBPACK_IMPORTED_MODULE_1__/* .componentWithRef */ .w)((props, forwardRef) => {
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components_Icon_Icon__WEBPACK_IMPORTED_MODULE_2__/* .IconBase */ .A0, Object.assign({ ref: forwardRef }, props, { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M3.879 1.879A3 3 0 0 1 6 1h7a1 1 0 0 1 .707.293l7 7A1 1 0 0 1 21 9v11a3 3 0 0 1-3 3H6a3 3 0 0 1-3-3V4a3 3 0 0 1 .879-2.121ZM6 3a1 1 0 0 0-1 1v16a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1V10h-6a1 1 0 0 1-1-1V3H6Zm8 1.414L17.586 8H14V4.414Z", fill: "currentColor" }) })));
});
IconFile.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (IconFile);


/***/ }),

/***/ 2062:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38);
/* harmony import */ var _components_Icon_Icon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3170);
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8335);



/**
 * Semantic vector graphics icon IconFilledCircle.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconFilledCircle size="large" color="green50" />
 */
const IconFilledCircle = (0,_helpers__WEBPACK_IMPORTED_MODULE_1__/* .componentWithRef */ .w)((props, forwardRef) => {
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components_Icon_Icon__WEBPACK_IMPORTED_MODULE_2__/* .IconBase */ .A0, Object.assign({ ref: forwardRef }, props, { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("circle", { cx: "12", cy: "12", r: "12", fill: "currentColor" }) })));
});
IconFilledCircle.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (IconFilledCircle);


/***/ }),

/***/ 7185:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38);
/* harmony import */ var _components_Icon_Icon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3170);
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8335);



/**
 * Semantic vector graphics icon IconFilledTriangle.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconFilledTriangle size="large" color="green50" />
 */
const IconFilledTriangle = (0,_helpers__WEBPACK_IMPORTED_MODULE_1__/* .componentWithRef */ .w)((props, forwardRef) => {
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components_Icon_Icon__WEBPACK_IMPORTED_MODULE_2__/* .IconBase */ .A0, Object.assign({ ref: forwardRef }, props, { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("path", { d: "M10.457 1.405a3.145 3.145 0 0 1 4.232 1.109l.003.005L23.57 17.34l.009.014a3.145 3.145 0 0 1-2.69 4.717H3.11a3.146 3.146 0 0 1-2.689-4.717l.009-.014L9.308 2.519l.003-.005c.28-.462.675-.844 1.146-1.11Z", fill: "currentColor" }) })));
});
IconFilledTriangle.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (IconFilledTriangle);


/***/ }),

/***/ 6370:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38);
/* harmony import */ var _components_Icon_Icon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3170);
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8335);



/**
 * Semantic vector graphics icon IconFontType.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconFontType size="large" color="green50" />
 */
const IconFontType = (0,_helpers__WEBPACK_IMPORTED_MODULE_1__/* .componentWithRef */ .w)((props, forwardRef) => {
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components_Icon_Icon__WEBPACK_IMPORTED_MODULE_2__/* .IconBase */ .A0, Object.assign({ ref: forwardRef }, props, { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M3 4a1 1 0 0 1 1-1h16a1 1 0 0 1 1 1v3a1 1 0 1 1-2 0V5h-6v14h2a1 1 0 1 1 0 2H9a1 1 0 1 1 0-2h2V5H5v2a1 1 0 0 1-2 0V4Z", fill: "currentColor" }) })));
});
IconFontType.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (IconFontType);


/***/ }),

/***/ 9339:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38);
/* harmony import */ var _components_Icon_Icon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3170);
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8335);



/**
 * Semantic vector graphics icon IconImage.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconImage size="large" color="green50" />
 */
const IconImage = (0,_helpers__WEBPACK_IMPORTED_MODULE_1__/* .componentWithRef */ .w)((props, forwardRef) => {
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components_Icon_Icon__WEBPACK_IMPORTED_MODULE_2__/* .IconBase */ .A0, Object.assign({ ref: forwardRef }, props, { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M5 4a1 1 0 0 0-1 1v14a1 1 0 0 0 .65.937L15.292 9.293a1 1 0 0 1 1.414 0L20 12.586V5a1 1 0 0 0-1-1H5Zm17 10.999V5a3 3 0 0 0-3-3H5a3 3 0 0 0-3 3v14a3 3 0 0 0 3 3h14a3 3 0 0 0 3-3v-4.001Zm-2 .415-4-4L7.414 20H19a1 1 0 0 0 1-1v-3.586ZM8.5 8a.5.5 0 1 0 0 1 .5.5 0 0 0 0-1ZM6 8.5a2.5 2.5 0 1 1 5 0 2.5 2.5 0 0 1-5 0Z", fill: "currentColor" }) })));
});
IconImage.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (IconImage);


/***/ }),

/***/ 563:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38);
/* harmony import */ var _components_Icon_Icon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3170);
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8335);



/**
 * Semantic vector graphics icon IconLeft.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconLeft size="large" color="green50" />
 */
const IconLeft = (0,_helpers__WEBPACK_IMPORTED_MODULE_1__/* .componentWithRef */ .w)((props, forwardRef) => {
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components_Icon_Icon__WEBPACK_IMPORTED_MODULE_2__/* .IconBase */ .A0, Object.assign({ ref: forwardRef }, props, { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M12.707 4.293a1 1 0 0 1 0 1.414L7.414 11H19a1 1 0 1 1 0 2H7.414l5.293 5.293a1 1 0 0 1-1.414 1.414l-7-7a1 1 0 0 1 0-1.414l7-7a1 1 0 0 1 1.414 0Z", fill: "currentColor" }) })));
});
IconLeft.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (IconLeft);


/***/ }),

/***/ 6632:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38);
/* harmony import */ var _components_Icon_Icon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3170);
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8335);



/**
 * Semantic vector graphics icon IconLink.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconLink size="large" color="green50" />
 */
const IconLink = (0,_helpers__WEBPACK_IMPORTED_MODULE_1__/* .componentWithRef */ .w)((props, forwardRef) => {
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components_Icon_Icon__WEBPACK_IMPORTED_MODULE_2__/* .IconBase */ .A0, Object.assign({ ref: forwardRef }, props, { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M3.172 9.172A4 4 0 0 1 6 8h3a1 1 0 1 0 0-2H6a6 6 0 1 0 0 12h3a1 1 0 1 0 0-2H6a4 4 0 0 1-2.828-6.828ZM15 6a1 1 0 1 0 0 2h3a4 4 0 1 1 0 8h-3a1 1 0 1 0 0 2h3a6 6 0 0 0 0-12h-3Zm-7 5a1 1 0 1 0 0 2h8a1 1 0 1 0 0-2H8Z", fill: "currentColor" }) })));
});
IconLink.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (IconLink);


/***/ }),

/***/ 591:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38);
/* harmony import */ var _components_Icon_Icon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3170);
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8335);



/**
 * Semantic vector graphics icon IconList.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconList size="large" color="green50" />
 */
const IconList = (0,_helpers__WEBPACK_IMPORTED_MODULE_1__/* .componentWithRef */ .w)((props, forwardRef) => {
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components_Icon_Icon__WEBPACK_IMPORTED_MODULE_2__/* .IconBase */ .A0, Object.assign({ ref: forwardRef }, props, { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M3 5a1 1 0 0 0 0 2h.01a1 1 0 0 0 0-2H3Zm5 0a1 1 0 0 0 0 2h13a1 1 0 1 0 0-2H8Zm0 6a1 1 0 1 0 0 2h13a1 1 0 1 0 0-2H8Zm-1 7a1 1 0 0 1 1-1h13a1 1 0 1 1 0 2H8a1 1 0 0 1-1-1Zm-5-6a1 1 0 0 1 1-1h.01a1 1 0 1 1 0 2H3a1 1 0 0 1-1-1Zm1 5a1 1 0 1 0 0 2h.01a1 1 0 1 0 0-2H3Z", fill: "currentColor" }) })));
});
IconList.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (IconList);


/***/ }),

/***/ 8530:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38);
/* harmony import */ var _components_Icon_Icon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3170);
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8335);



/**
 * Semantic vector graphics icon IconLoader.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconLoader size="large" color="green50" />
 */
const IconLoader = (0,_helpers__WEBPACK_IMPORTED_MODULE_1__/* .componentWithRef */ .w)((props, forwardRef) => {
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components_Icon_Icon__WEBPACK_IMPORTED_MODULE_2__/* .IconBase */ .A0, Object.assign({ ref: forwardRef }, props, { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M13 2a1 1 0 1 0-2 0v4a1 1 0 1 0 2 0V2Zm0 16a1 1 0 1 0-2 0v4a1 1 0 1 0 2 0v-4ZM4.223 4.223a1 1 0 0 1 1.414 0l2.83 2.83a1 1 0 1 1-1.414 1.414l-2.83-2.83a1 1 0 0 1 0-1.414Zm12.724 11.31a1 1 0 0 0-1.414 1.414l2.83 2.83a1 1 0 0 0 1.414-1.414l-2.83-2.83ZM1 12a1 1 0 0 1 1-1h4a1 1 0 1 1 0 2H2a1 1 0 0 1-1-1Zm17-1a1 1 0 1 0 0 2h4a1 1 0 1 0 0-2h-4Zm-9.533 4.533a1 1 0 0 1 0 1.414l-2.83 2.83a1 1 0 0 1-1.414-1.414l2.83-2.83a1 1 0 0 1 1.414 0Zm11.31-9.896a1 1 0 1 0-1.414-1.414l-2.83 2.83a1 1 0 0 0 1.414 1.414l2.83-2.83Z", fill: "currentColor" }) })));
});
IconLoader.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (IconLoader);


/***/ }),

/***/ 9438:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38);
/* harmony import */ var _components_Icon_Icon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3170);
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8335);



/**
 * Semantic vector graphics icon IconLockLocked.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconLockLocked size="large" color="green50" />
 */
const IconLockLocked = (0,_helpers__WEBPACK_IMPORTED_MODULE_1__/* .componentWithRef */ .w)((props, forwardRef) => {
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components_Icon_Icon__WEBPACK_IMPORTED_MODULE_2__/* .IconBase */ .A0, Object.assign({ ref: forwardRef }, props, { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M9.172 4.172A4 4 0 0 1 16 7v3H8V7a4 4 0 0 1 1.172-2.828ZM6 10V7a6 6 0 1 1 12 0v3h1a3 3 0 0 1 3 3v7a3 3 0 0 1-3 3H5a3 3 0 0 1-3-3v-7a3 3 0 0 1 3-3h1Zm11 2H5a1 1 0 0 0-1 1v7a1 1 0 0 0 1 1h14a1 1 0 0 0 1-1v-7a1 1 0 0 0-1-1h-2Z", fill: "currentColor" }) })));
});
IconLockLocked.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (IconLockLocked);


/***/ }),

/***/ 4557:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38);
/* harmony import */ var _components_Icon_Icon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3170);
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8335);



/**
 * Semantic vector graphics icon IconMenu.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconMenu size="large" color="green50" />
 */
const IconMenu = (0,_helpers__WEBPACK_IMPORTED_MODULE_1__/* .componentWithRef */ .w)((props, forwardRef) => {
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components_Icon_Icon__WEBPACK_IMPORTED_MODULE_2__/* .IconBase */ .A0, Object.assign({ ref: forwardRef }, props, { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M2 6a1 1 0 0 1 1-1h18a1 1 0 1 1 0 2H3a1 1 0 0 1-1-1Zm0 6a1 1 0 0 1 1-1h18a1 1 0 1 1 0 2H3a1 1 0 0 1-1-1Zm1 5a1 1 0 1 0 0 2h18a1 1 0 1 0 0-2H3Z", fill: "currentColor" }) })));
});
IconMenu.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (IconMenu);


/***/ }),

/***/ 6470:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38);
/* harmony import */ var _components_Icon_Icon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3170);
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8335);



/**
 * Semantic vector graphics icon IconMinus.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconMinus size="large" color="green50" />
 */
const IconMinus = (0,_helpers__WEBPACK_IMPORTED_MODULE_1__/* .componentWithRef */ .w)((props, forwardRef) => {
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components_Icon_Icon__WEBPACK_IMPORTED_MODULE_2__/* .IconBase */ .A0, Object.assign({ ref: forwardRef }, props, { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M4 12a1 1 0 0 1 1-1h14a1 1 0 1 1 0 2H5a1 1 0 0 1-1-1Z", fill: "currentColor" }) })));
});
IconMinus.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (IconMinus);


/***/ }),

/***/ 1364:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38);
/* harmony import */ var _components_Icon_Icon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3170);
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8335);



/**
 * Semantic vector graphics icon IconMoreHorizontal.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconMoreHorizontal size="large" color="green50" />
 */
const IconMoreHorizontal = (0,_helpers__WEBPACK_IMPORTED_MODULE_1__/* .componentWithRef */ .w)((props, forwardRef) => {
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components_Icon_Icon__WEBPACK_IMPORTED_MODULE_2__/* .IconBase */ .A0, Object.assign({ ref: forwardRef }, props, { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M5 10a2 2 0 1 0 0 4 2 2 0 0 0 0-4Zm5 2a2 2 0 1 1 4 0 2 2 0 0 1-4 0Zm7 0a2 2 0 1 1 4 0 2 2 0 0 1-4 0Z", fill: "currentColor" }) })));
});
IconMoreHorizontal.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (IconMoreHorizontal);


/***/ }),

/***/ 4019:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38);
/* harmony import */ var _components_Icon_Icon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3170);
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8335);



/**
 * Semantic vector graphics icon IconQuestionCircle.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconQuestionCircle size="large" color="green50" />
 */
const IconQuestionCircle = (0,_helpers__WEBPACK_IMPORTED_MODULE_1__/* .componentWithRef */ .w)((props, forwardRef) => {
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components_Icon_Icon__WEBPACK_IMPORTED_MODULE_2__/* .IconBase */ .A0, Object.assign({ ref: forwardRef }, props, { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M12 3a9 9 0 1 0 0 18 9 9 0 0 0 0-18ZM1 12C1 5.925 5.925 1 12 1s11 4.925 11 11-4.925 11-11 11S1 18.075 1 12Zm11.258-3.976a2 2 0 0 0-2.225 1.308 1 1 0 1 1-1.886-.664 4 4 0 0 1 7.773 1.333c0 1.53-1.135 2.54-1.945 3.081a8.044 8.044 0 0 1-1.686.848l-.035.013-.011.003-.004.002h-.002L11.92 13l.316.949a1 1 0 0 1-.633-1.897l.016-.006.074-.027a6.051 6.051 0 0 0 1.172-.6c.69-.46 1.055-.95 1.055-1.419v-.001a2 2 0 0 0-1.662-1.975ZM11 17a1 1 0 0 1 1-1h.01a1 1 0 1 1 0 2H12a1 1 0 0 1-1-1Z", fill: "currentColor" }) })));
});
IconQuestionCircle.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (IconQuestionCircle);


/***/ }),

/***/ 3581:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38);
/* harmony import */ var _components_Icon_Icon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3170);
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8335);



/**
 * Semantic vector graphics icon IconRecCircle.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconRecCircle size="large" color="green50" />
 */
const IconRecCircle = (0,_helpers__WEBPACK_IMPORTED_MODULE_1__/* .componentWithRef */ .w)((props, forwardRef) => {
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(_components_Icon_Icon__WEBPACK_IMPORTED_MODULE_2__/* .IconBase */ .A0, Object.assign({ ref: forwardRef }, props, { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M3 12a9 9 0 1 1 18 0 9 9 0 0 1-18 0Zm9-11C5.925 1 1 5.925 1 12s4.925 11 11 11 11-4.925 11-11S18.075 1 12 1Z", fill: "currentColor" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("path", { d: "M12 8a4 4 0 1 0 0 8 4 4 0 0 0 0-8Z", fill: "currentColor" })] })));
});
IconRecCircle.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (IconRecCircle);


/***/ }),

/***/ 8746:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38);
/* harmony import */ var _components_Icon_Icon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3170);
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8335);



/**
 * Semantic vector graphics icon IconRight.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconRight size="large" color="green50" />
 */
const IconRight = (0,_helpers__WEBPACK_IMPORTED_MODULE_1__/* .componentWithRef */ .w)((props, forwardRef) => {
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components_Icon_Icon__WEBPACK_IMPORTED_MODULE_2__/* .IconBase */ .A0, Object.assign({ ref: forwardRef }, props, { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M11.293 4.293a1 1 0 0 1 1.414 0l7 7a1 1 0 0 1 0 1.414l-7 7a1 1 0 0 1-1.414-1.414L16.586 13H5a1 1 0 1 1 0-2h11.586l-5.293-5.293a1 1 0 0 1 0-1.414Z", fill: "currentColor" }) })));
});
IconRight.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (IconRight);


/***/ }),

/***/ 5950:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38);
/* harmony import */ var _components_Icon_Icon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3170);
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8335);



/**
 * Semantic vector graphics icon IconRobocorp.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconRobocorp size="large" color="green50" />
 */
const IconRobocorp = (0,_helpers__WEBPACK_IMPORTED_MODULE_1__/* .componentWithRef */ .w)((props, forwardRef) => {
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components_Icon_Icon__WEBPACK_IMPORTED_MODULE_2__/* .IconBase */ .A0, Object.assign({ ref: forwardRef }, props, { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M8.687 7.404h6.626a.655.655 0 0 0 .655-.651.652.652 0 0 0-.65-.651H8.686a.652.652 0 0 0 0 1.302Zm3.808 2.958a.775.775 0 1 0 1.55.001.775.775 0 0 0-1.55 0Zm-2.538 0a.775.775 0 1 0 1.55.001.775.775 0 0 0-1.55 0Zm8.966-3.925a3.904 3.904 0 0 1-1.782 3.761.246.246 0 0 0-.058.375 6.655 6.655 0 0 1 1.579 3.788.245.245 0 0 1-.246.273H5.584a.251.251 0 0 1-.246-.273 6.66 6.66 0 0 1 1.583-3.788.242.242 0 0 0-.059-.37 3.901 3.901 0 0 1-1.734-4.074 3.838 3.838 0 0 1 3.239-3.083 3.922 3.922 0 0 1 2.21.308 3.406 3.406 0 0 0 2.846 0 3.908 3.908 0 0 1 2.225-.308c1.708.253 3.076 1.676 3.275 3.39ZM5.66 15.804h12.677a.25.25 0 0 1 .245.296 6.688 6.688 0 0 1-13.167 0 .25.25 0 0 1 .245-.296ZM3.117 7.38A3.388 3.388 0 0 0 1 10.514v.558c0 1.418.88 2.623 2.117 3.134a.248.248 0 0 0 .343-.23V7.61a.25.25 0 0 0-.343-.23Zm17.423.23c0-.18.18-.296.343-.23A3.392 3.392 0 0 1 23 10.514v.558a3.388 3.388 0 0 1-2.117 3.134.25.25 0 0 1-.343-.23V7.61Z", fill: "currentColor" }) })));
});
IconRobocorp.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (IconRobocorp);


/***/ }),

/***/ 2111:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38);
/* harmony import */ var _components_Icon_Icon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3170);
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8335);



/**
 * Semantic vector graphics icon IconRobocorpOutline.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconRobocorpOutline size="large" color="green50" />
 */
const IconRobocorpOutline = (0,_helpers__WEBPACK_IMPORTED_MODULE_1__/* .componentWithRef */ .w)((props, forwardRef) => {
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components_Icon_Icon__WEBPACK_IMPORTED_MODULE_2__/* .IconBase */ .A0, Object.assign({ ref: forwardRef }, props, { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M20.525 14.197a3.25 3.25 0 0 0 2.033-3.007v-.536a3.255 3.255 0 0 0-2.033-3.01.24.24 0 0 0-.33.22v6.112c0 .172.173.284.33.22Zm-2.135.146a6.369 6.369 0 0 0-1.516-3.64.233.233 0 0 1 .056-.356 3.75 3.75 0 0 0 1.711-3.613c-.19-1.648-1.505-3.011-3.145-3.258a3.787 3.787 0 0 0-2.139.295c-.438.203-.902.3-1.366.3-.468 0-.933-.101-1.367-.3a3.755 3.755 0 0 0-2.138-.295c-1.64.243-2.955 1.61-3.146 3.258a3.748 3.748 0 0 0 1.711 3.613c.128.083.154.24.057.356a6.394 6.394 0 0 0-1.517 3.64.237.237 0 0 0 .236.262h12.327a.242.242 0 0 0 .236-.262Zm-12.724 1.67c.539 3.007 3.16 5.295 6.325 5.295a6.428 6.428 0 0 0 6.325-5.295.24.24 0 0 0-.236-.285H5.902a.242.242 0 0 0-.236.285ZM3.46 14.197a.24.24 0 0 0 .33-.221V7.86a.238.238 0 0 0-.33-.221 3.259 3.259 0 0 0-2.033 3.01v.54c0 1.36.842 2.52 2.033 3.007Zm16.653-7.973c.314-.06.644-.03.951.094A4.709 4.709 0 0 1 24 10.65v.536a4.67 4.67 0 0 1-2.92 4.333 1.673 1.673 0 0 1-1.213.019c-.076-.03-.155.037-.14.115.038.199.041.405.004.61a7.846 7.846 0 0 1-7.733 6.475 7.846 7.846 0 0 1-7.733-6.474 1.671 1.671 0 0 1 .004-.61c.015-.08-.064-.147-.139-.117a1.705 1.705 0 0 1-.576.105c-.214 0-.427-.04-.633-.123A4.678 4.678 0 0 1 0 11.186v-.536a4.67 4.67 0 0 1 2.92-4.332c.308-.127.638-.154.952-.094.06.011.116-.022.127-.082A5.164 5.164 0 0 1 8.283 2.06a5.176 5.176 0 0 1 2.944.408 1.832 1.832 0 0 0 1.535 0 5.24 5.24 0 0 1 2.943-.408 5.164 5.164 0 0 1 4.284 4.082c.012.06.064.093.124.082Zm-11.305.187h6.366a.626.626 0 0 1 0 1.251H8.808a.626.626 0 0 1 0-1.25Zm3.655 4.094a.745.745 0 1 1 1.489-.002.745.745 0 0 1-1.49.002Zm-1.69-.746a.745.745 0 1 0 0 1.49.745.745 0 0 0 0-1.49Z", fill: "currentColor" }) })));
});
IconRobocorpOutline.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (IconRobocorpOutline);


/***/ }),

/***/ 530:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38);
/* harmony import */ var _components_Icon_Icon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3170);
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8335);



/**
 * Semantic vector graphics icon IconSortArrow.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconSortArrow size="large" color="green50" />
 */
const IconSortArrow = (0,_helpers__WEBPACK_IMPORTED_MODULE_1__/* .componentWithRef */ .w)((props, forwardRef) => {
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components_Icon_Icon__WEBPACK_IMPORTED_MODULE_2__/* .IconBase */ .A0, Object.assign({ ref: forwardRef }, props, { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M18.657 15.37a.416.416 0 0 1 .317.688l-6.62 7.795a.416.416 0 0 1-.635 0L5.1 16.058a.417.417 0 0 1 .317-.688h5.316V1.303a1.302 1.302 0 1 1 2.606 0V15.37h5.318Z", fill: "currentColor" }) })));
});
IconSortArrow.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (IconSortArrow);


/***/ }),

/***/ 7060:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38);
/* harmony import */ var _components_Icon_Icon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3170);
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8335);



/**
 * Semantic vector graphics icon IconSortFilled.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconSortFilled size="large" color="green50" />
 */
const IconSortFilled = (0,_helpers__WEBPACK_IMPORTED_MODULE_1__/* .componentWithRef */ .w)((props, forwardRef) => {
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components_Icon_Icon__WEBPACK_IMPORTED_MODULE_2__/* .IconBase */ .A0, Object.assign({ ref: forwardRef }, props, { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M12.927.39a1.333 1.333 0 0 0-1.886 0L4.374 7.057A1.333 1.333 0 0 0 6.26 8.943l5.724-5.725 5.724 5.725a1.333 1.333 0 0 0 1.885-1.886L12.927.39ZM4.373 16.943l6.667 6.667a1.333 1.333 0 0 0 1.886 0l6.666-6.667a1.334 1.334 0 0 0-1.885-1.886l-5.724 5.725-5.724-5.725a1.333 1.333 0 0 0-1.886 1.886Z", fill: "currentColor" }) })));
});
IconSortFilled.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (IconSortFilled);


/***/ }),

/***/ 8166:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38);
/* harmony import */ var _components_Icon_Icon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3170);
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8335);



/**
 * Semantic vector graphics icon IconStop.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconStop size="large" color="green50" />
 */
const IconStop = (0,_helpers__WEBPACK_IMPORTED_MODULE_1__/* .componentWithRef */ .w)((props, forwardRef) => {
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components_Icon_Icon__WEBPACK_IMPORTED_MODULE_2__/* .IconBase */ .A0, Object.assign({ ref: forwardRef }, props, { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M5 4a1 1 0 0 0-1 1v14a1 1 0 0 0 1 1h14a1 1 0 0 0 1-1V5a1 1 0 0 0-1-1H5ZM2 5a3 3 0 0 1 3-3h14a3 3 0 0 1 3 3v14a3 3 0 0 1-3 3H5a3 3 0 0 1-3-3V5Z", fill: "currentColor" }) })));
});
IconStop.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (IconStop);


/***/ }),

/***/ 2785:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38);
/* harmony import */ var _components_Icon_Icon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3170);
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8335);



/**
 * Semantic vector graphics icon IconUnlocked.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconUnlocked size="large" color="green50" />
 */
const IconUnlocked = (0,_helpers__WEBPACK_IMPORTED_MODULE_1__/* .componentWithRef */ .w)((props, forwardRef) => {
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components_Icon_Icon__WEBPACK_IMPORTED_MODULE_2__/* .IconBase */ .A0, Object.assign({ ref: forwardRef }, props, { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M9.172 4.172A4 4 0 0 1 15.919 6.2a1 1 0 0 0 1.96-.4A6 6 0 0 0 6 7v3H5a3 3 0 0 0-3 3v7a3 3 0 0 0 3 3h14a3 3 0 0 0 3-3v-7a3 3 0 0 0-3-3H8V7a4 4 0 0 1 1.172-2.828ZM7 12H5a1 1 0 0 0-1 1v7a1 1 0 0 0 1 1h14a1 1 0 0 0 1-1v-7a1 1 0 0 0-1-1H7Z", fill: "currentColor" }) })));
});
IconUnlocked.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (IconUnlocked);


/***/ }),

/***/ 8404:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38);
/* harmony import */ var _components_Icon_Icon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3170);
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8335);



/**
 * Semantic vector graphics icon IconWindows.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconWindows size="large" color="green50" />
 */
const IconWindows = (0,_helpers__WEBPACK_IMPORTED_MODULE_1__/* .componentWithRef */ .w)((props, forwardRef) => {
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components_Icon_Icon__WEBPACK_IMPORTED_MODULE_2__/* .IconBase */ .A0, Object.assign({ ref: forwardRef }, props, { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("path", { d: "m0 3.398 9.808-1.332.004 9.432-9.803.055L0 3.398Zm9.803 9.187.008 9.44L.008 20.68v-8.16l9.795.064Zm1.19-10.693L23.996 0v11.378l-13.005.103V1.892ZM24 12.673 23.997 24l-13.005-1.83-.018-9.518L24 12.673Z", fill: "currentColor" }) })));
});
IconWindows.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (IconWindows);


/***/ }),

/***/ 845:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38);
/* harmony import */ var _components_Icon_Icon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3170);
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8335);



/**
 * Semantic vector graphics icon IconX.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconX size="large" color="green50" />
 */
const IconX = (0,_helpers__WEBPACK_IMPORTED_MODULE_1__/* .componentWithRef */ .w)((props, forwardRef) => {
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components_Icon_Icon__WEBPACK_IMPORTED_MODULE_2__/* .IconBase */ .A0, Object.assign({ ref: forwardRef }, props, { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M18.707 6.707a1 1 0 0 0-1.414-1.414L12 10.586 6.707 5.293a1 1 0 0 0-1.414 1.414L10.586 12l-5.293 5.293a1 1 0 1 0 1.414 1.414L12 13.414l5.293 5.293a1 1 0 0 0 1.414-1.414L13.414 12l5.293-5.293Z", fill: "currentColor" }) })));
});
IconX.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (IconX);


/***/ }),

/***/ 3622:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "II": () => (/* binding */ Input),
  "d2": () => (/* binding */ InputDescription),
  "pd": () => (/* binding */ InputError)
});

// EXTERNAL MODULE: ./node_modules/react/jsx-runtime.js
var jsx_runtime = __webpack_require__(38);
// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(4191);
// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/helpers/component.js
var component = __webpack_require__(8335);
// EXTERNAL MODULE: ./node_modules/styled-system/dist/index.esm.js + 13 modules
var index_esm = __webpack_require__(4912);
// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/components/Button/Button.js + 1 modules
var Button = __webpack_require__(8100);
// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconUnlocked.js
var IconUnlocked = __webpack_require__(2785);
// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconLockLocked.js
var IconLockLocked = __webpack_require__(9438);
// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/theme/index.js + 2 modules
var theme = __webpack_require__(3694);
// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/theme/helpers.js
var helpers = __webpack_require__(3709);
// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/hooks/useForkRef.js
var useForkRef = __webpack_require__(5009);
// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/hooks/useAutoWidth.js
var useAutoWidth = __webpack_require__(926);
// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/components/Box/Box.js
var Box = __webpack_require__(6028);
// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/components/Tooltip/Tooltip.js
var Tooltip = __webpack_require__(4183);
// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconQuestionCircle.js
var IconQuestionCircle = __webpack_require__(4019);
;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Input/components/Label.js






const LabelStyled = theme/* styled.strong */.zo.strong `
  display: flex;
  align-items: center;
  cursor: pointer;
  color: ${({ theme }) => theme.color('dark0')};
  cursor: default;
  user-select: none;

  ${({ theme }) => (0,index_esm/* variant */.bU)({
    prop: '$size',
    variants: {
        small: {
            fontSize: theme.fontSizes.$12,
            marginBottom: theme.sizes.$4
        },
        medium: {
            fontSize: theme.fontSizes.$14,
            marginBottom: theme.sizes.$8
        },
        large: {
            fontSize: theme.fontSizes.$14,
            marginBottom: theme.sizes.$8
        }
    }
})}

  > span {
    text-transform: capitalize;
    line-height: 16px;
  }

  > div {
    cursor: help;
  }
`;
const Label = ({ label, tooltip, $size }) => {
    return ((0,jsx_runtime.jsxs)(LabelStyled, Object.assign({ "$size": $size }, { children: [(0,jsx_runtime.jsx)("span", { children: label }), tooltip && ((0,jsx_runtime.jsx)(Box/* default */.Z, Object.assign({ ml: 8, height: 16 }, { children: (0,jsx_runtime.jsx)(Tooltip/* default */.Z, Object.assign({ text: tooltip }, { children: (0,jsx_runtime.jsx)(IconQuestionCircle/* default */.Z, { size: 16 }) })) })))] })));
};
Label.defaultProps = {
    $size: 'medium'
};

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Input/Input.js
var __rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};










const Container = theme/* styled.label */.zo.label ``;
const Overlay = theme/* styled.div */.zo.div `
  position: relative;

  > div {
    display: flex;
    align-items: center;
    justify-content: space-between;
    position: absolute;
    left: 0px;
    bottom: 0px;
    width: 100%;
    height: 100%;
    pointer-events: none;

    > div {
      height: 18px;
    }

    button {
      pointer-events: all;
    }
  }
`;
const InputStyled = theme/* styled.input */.zo.input `
  appearance: none;
  resize: none;
  border-radius: ${({ theme }) => theme.sizes.$4};
  color: ${({ theme }) => theme.color('dark0')};
  background: ${({ theme }) => theme.color('dark100', 'light100')};
  padding: ${({ withPadding }) => (withPadding ? 12 : 0)}px;
  border: 1px solid;
  border-color: ${({ withError, theme }) => theme.color(withError ? 'peach50' : 'dark50')};
  width: 100%;

  ${helpers/* styledFocus */.By}
  ${index_esm/* maxWidth */.kk};

  &:-webkit-autofill {
    -webkit-text-fill-color: ${({ theme }) => theme.color('dark0')};
    -webkit-box-shadow: 0 0 0px 1000px ${({ theme }) => theme.color('dark100')} inset;
  }

  &::-webkit-inner-spin-button {
    -webkit-appearance: none;
    margin: 0;
  }

  &:focus,
  &:-webkit-autofill:focus {
    border-color: ${({ theme }) => theme.color('purple50')};
  }

  &:disabled {
    background: ${({ theme }) => theme.color('dark80')};
    color: ${({ theme }) => theme.color('dark40', 'light30')};
    border-color: ${({ theme }) => theme.color('dark60')};
    cursor: not-allowed;
  }

  &::placeholder {
    color: ${({ theme }) => theme.color('dark30')};
  }

  & + div {
    color: ${({ disabled, withError, theme }) => disabled ? theme.color('dark60') : theme.color(withError ? 'peach50' : 'dark10')};
  }

  ${({ theme, withLeftIcon, withRightIcon }) => (0,index_esm/* variant */.bU)({
    prop: '$size',
    variants: {
        small: {
            minHeight: 30,
            paddingLeft: withLeftIcon ? theme.sizes.$32 : 11,
            paddingRight: withRightIcon ? theme.sizes.$32 : 11,
            fontSize: theme.fontSizes.$12,
            '& + div': {
                paddingLeft: theme.sizes.$8,
                paddingRight: theme.sizes.$8
            }
        },
        medium: {
            minHeight: theme.sizes.$32,
            paddingLeft: withLeftIcon ? 38 : theme.sizes.$12,
            paddingRight: withRightIcon ? 38 : theme.sizes.$12,
            fontSize: theme.fontSizes.$14,
            '& + div': {
                paddingLeft: theme.sizes.$12,
                paddingRight: theme.sizes.$12
            }
        },
        large: {
            minHeight: theme.sizes.$40,
            paddingLeft: withLeftIcon ? 38 : theme.sizes.$12,
            paddingRight: withRightIcon ? 38 : theme.sizes.$12,
            fontSize: theme.fontSizes.$16,
            '& + div': {
                paddingLeft: theme.sizes.$12,
                paddingRight: theme.sizes.$12
            }
        }
    }
})}
`;
const InputDescription = theme/* styled.small */.zo.small `
  display: ${({ error }) => (typeof error === 'string' && error ? 'none' : 'block')};
  pointer-events: none;
  color: ${({ theme }) => theme.color('dark30', 'light10')};
  margin-top: ${({ theme }) => theme.sizes.$4};
  font-size: ${({ theme }) => theme.fontSizes.$12};
  line-height: ${({ theme }) => theme.lineHeights.$165};
`;
const InputError = theme/* styled.small */.zo.small `
  display: block;
  pointer-events: none;
  width: 100%;
  margin-top: ${({ theme }) => theme.sizes.$4};
  color: ${({ theme }) => theme.colors.peach50};
  font-size: ${({ theme }) => theme.fontSizes.$12};
  line-height: ${({ theme }) => theme.lineHeights.$165};
`;
/**
 * The Input component is a complete form text input control including a label, input, error message and help text.
 *
 * @see
 * {@link https://design-system.solventek.com/component/input}
 *
 * @example
 * <Input label="Label" value={value} onChange={(e) => setValue(e.target.value)} />
 */
const Input = (0,component/* componentWithRef */.w)((_a, forwardedRef) => {
    var { autoFocus, autoWidth, label, tooltip, type, iconLeft: IconLeft, iconRight: IconRight, error, description, onIconRightClick, size } = _a, rest = __rest(_a, ["autoFocus", "autoWidth", "label", "tooltip", "type", "iconLeft", "iconRight", "error", "description", "onIconRightClick", "size"]);
    const [secretType, setSecretType] = (0,react.useState)('password');
    const localRef = (0,react.useRef)(null);
    const IconLock = secretType === 'text' ? IconUnlocked/* default */.Z : IconLockLocked/* default */.Z;
    const inputRef = (0,useForkRef/* useForkRef */.c)(localRef, forwardedRef);
    (0,useAutoWidth/* useAutoWidth */.b)(localRef, [rest.value], autoWidth);
    const toggleSecretType = (0,react.useCallback)(() => {
        setSecretType((current) => (current === 'password' ? 'text' : 'password'));
    }, []);
    (0,react.useEffect)(() => {
        if (autoFocus) {
            setTimeout(() => {
                var _a;
                (_a = localRef.current) === null || _a === void 0 ? void 0 : _a.focus();
            }, 0);
        }
    }, [autoFocus]);
    const ContentRight = (0,react.useMemo)(() => {
        if (type === 'secret') {
            return ((0,jsx_runtime.jsx)(Button/* ButtonBase */.X, Object.assign({ onClick: toggleSecretType, type: "button" }, { children: (0,jsx_runtime.jsx)(IconLock, { color: "inherit", size: "small" }) })));
        }
        if (IconRight) {
            if (!onIconRightClick) {
                return (0,jsx_runtime.jsx)(IconRight, { color: "inherit", size: 18 });
            }
            return ((0,jsx_runtime.jsx)(Button/* ButtonBase */.X, Object.assign({ onClick: onIconRightClick, type: "button" }, { children: (0,jsx_runtime.jsx)(IconRight, { color: "inherit", size: 18 }) })));
        }
        return null;
    }, [type, IconRight, onIconRightClick]);
    return ((0,jsx_runtime.jsxs)(Container, { children: [label && (0,jsx_runtime.jsx)(Label, { "$size": size, label: label, tooltip: tooltip }), (0,jsx_runtime.jsxs)(Overlay, { children: [(0,jsx_runtime.jsx)(InputStyled, Object.assign({ withLeftIcon: !!IconLeft, withRightIcon: !!ContentRight, withPadding: !!(rest === null || rest === void 0 ? void 0 : rest.rows), withError: !!error, ref: inputRef, type: type === 'secret' ? secretType : type, autoFocus: autoFocus, "$size": size, as: (rest === null || rest === void 0 ? void 0 : rest.rows) ? 'textarea' : 'input', readOnly: !rest.onChange }, rest)), (0,jsx_runtime.jsxs)("div", { children: [(0,jsx_runtime.jsx)("div", { children: IconLeft && (0,jsx_runtime.jsx)(IconLeft, { color: "inherit", size: 18 }) }), (0,jsx_runtime.jsx)("div", { children: ContentRight })] })] }), typeof error === 'string' && (0,jsx_runtime.jsx)(InputError, { children: error }), description && (0,jsx_runtime.jsx)(InputDescription, Object.assign({ error: error }, { children: description }))] }));
});
Input.defaultProps = {
    type: 'text',
    size: 'medium'
};


/***/ }),

/***/ 5645:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "C": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "Z": () => (/* binding */ ListContext)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4191);
/* harmony import */ var styled_system__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(4912);
/* harmony import */ var styled_components__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(2294);
/* harmony import */ var _theme__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(3694);
var __rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};





const ListContext = (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)({});
const listStyle = styled_components__WEBPACK_IMPORTED_MODULE_3__.css `
  display: flex;
  flex-direction: column;
  width: 100%;
  background: ${({ theme, transparent }) => (transparent ? 'transparent' : theme.color('dark80', 'light100'))};
  ${styled_system__WEBPACK_IMPORTED_MODULE_2__/* .maxWidth */ .kk}
  ${styled_system__WEBPACK_IMPORTED_MODULE_2__/* .width */ .bf}
`;
const listTypes = {
    ul: _theme__WEBPACK_IMPORTED_MODULE_4__/* .styled.ul */ .zo.ul `
    ${listStyle}
  `,
    nav: _theme__WEBPACK_IMPORTED_MODULE_4__/* .styled.nav */ .zo.nav `
    ${listStyle}
  `,
    ol: _theme__WEBPACK_IMPORTED_MODULE_4__/* .styled.ol */ .zo.ol `
    ${listStyle}
  `
};
/**
 * List component
 */
const List = (_a) => {
    var { component, children, divider, dense, hover } = _a, rest = __rest(_a, ["component", "children", "divider", "dense", "hover"]);
    const ListStyled = listTypes[component || 'ul'];
    const contextValue = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => ({ divider, dense, hover }), [divider, dense, hover]);
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ListStyled, Object.assign({}, rest, { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ListContext.Provider, Object.assign({ value: contextValue }, { children: children })) })));
};
List.defaultProps = {
    component: 'ul',
    hover: true
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (List);


/***/ }),

/***/ 5343:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38);
/* harmony import */ var styled_system__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4912);
/* harmony import */ var _theme__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3694);
var __rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};



/**
 * List content component
 */
const StyledListContent = _theme__WEBPACK_IMPORTED_MODULE_2__/* .styled.div */ .zo.div `
  flex-grow: ${({ type, width }) => (type === 'icon' || width ? '0' : '1')};
  display: flex;
  align-items: center;
  min-height: 28px;
  word-break: break-word;
  overflow-wrap: break-word;
  ${styled_system__WEBPACK_IMPORTED_MODULE_1__/* .width */ .bf}

  > * {
    flex-grow: 1;
  }
`;
const TextStyled = _theme__WEBPACK_IMPORTED_MODULE_2__/* .styled.div */ .zo.div `
  display: flex;
  flex-direction: column;
  line-height: 20px;
  small {
    color: ${({ secondaryColor, theme }) => theme.color(secondaryColor || 'dark20', secondaryColor || 'light20')};
    line-height: 16px;
  }
`;
const ListContent = (_a) => {
    var { children, hover, secondary, secondaryColor, secondaryTop, type } = _a, rest = __rest(_a, ["children", "hover", "secondary", "secondaryColor", "secondaryTop", "type"]);
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(StyledListContent, Object.assign({ className: hover ? 'hover' : '', type: type }, rest, { children: type === 'text' ? ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(TextStyled, Object.assign({ secondaryColor: secondaryColor }, { children: [secondaryTop && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("small", { children: secondaryTop }), children, secondary && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("small", { children: secondary })] }))) : (children) })));
};
ListContent.defaultProps = {
    type: 'container'
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ListContent);


/***/ }),

/***/ 1090:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4191);
/* harmony import */ var _theme__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3694);
/* harmony import */ var _theme_helpers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(3709);
/* harmony import */ var _components_Divider__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(1493);
/* harmony import */ var _List__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(5645);
/* harmony import */ var _ListContent__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(5343);
var __rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};







const listElements = [_theme__WEBPACK_IMPORTED_MODULE_2__/* .styled.li */ .zo.li ``, _theme__WEBPACK_IMPORTED_MODULE_2__/* .styled.button */ .zo.button ``, _theme__WEBPACK_IMPORTED_MODULE_2__/* .styled.a */ .zo.a ``];
const ListItemsStyled = listElements.map((el) => (0,_theme__WEBPACK_IMPORTED_MODULE_2__/* .styled */ .zo)(el) `
    list-style: none;
    display: flex;
    align-items: center;
    background: none;
    width: 100%;
    text-align: left;
    padding: ${({ dense, offset }) => dense ? `8px 16px 8px ${offset ? 16 + offset : 16}px` : `12px 20px 12px ${offset ? 20 + offset : 20}px`};
    ${_theme_helpers__WEBPACK_IMPORTED_MODULE_3__/* .styledFocus */ .By}
    min-height: ${({ dense }) => (dense ? '44px' : '60px')};
    color: ${({ theme }) => theme.color('dark0')};

    .hover {
      opacity: 0;
      pointer-events: none;
    }

    ${({ button, hover, theme }) => (button || hover) &&
    `
    &:hover {
      background: ${theme.color('dark70', 'light80')({ theme })};
    }
  `}

    &:hover .hover {
      opacity: 1;
      pointer-events: all;
    }

    ${({ button }) => button &&
    `
    user-select: none;
    &:hover {
      cursor: pointer;
    }
  `}

    ${({ active, theme }) => active &&
    `
    background: ${theme.color('dark70')({ theme })};

    &:after {
      display: block;
      flex: 0 0 7px;
      border-radius: 50%;
      content: '';
      height: 7px;
      background: ${theme.colors.yellow50};
      margin-left: 8px;
    }
  `}

  > * + * {
      margin-left: 12px;
    }
  `);
/**
 * List item component
 */
const ListItem = (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)((_a, listItemRef) => {
    var { children, icon, label, onClick, active, href } = _a, rest = __rest(_a, ["children", "icon", "label", "onClick", "active", "href"]);
    const { divider, dense, hover } = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(_List__WEBPACK_IMPORTED_MODULE_4__/* .ListContext */ .Z);
    const Icon = icon;
    const [StyledLi, StyledButton, StyledLink] = ListItemsStyled;
    let ListItemStyled = typeof onClick === 'function' ? StyledButton : StyledLi;
    if (href) {
        ListItemStyled = StyledLink;
    }
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(ListItemStyled, Object.assign({ button: typeof onClick === 'function' || typeof href === 'string', onClick: onClick, href: href, dense: dense, hover: hover, active: active, ref: listItemRef }, rest, { children: [Icon && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_ListContent__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z, Object.assign({ type: "icon" }, { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Icon, { size: 20 }) }))), label && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_ListContent__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z, Object.assign({ type: "text" }, { children: label })), children] })), divider && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components_Divider__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z, {})] }));
});
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ListItem);


/***/ }),

/***/ 9492:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "v": () => (/* binding */ Menu)
});

// EXTERNAL MODULE: ./node_modules/react/jsx-runtime.js
var jsx_runtime = __webpack_require__(38);
// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(4191);
// EXTERNAL MODULE: ./node_modules/styled-system/dist/index.esm.js + 13 modules
var index_esm = __webpack_require__(4912);
// EXTERNAL MODULE: ./node_modules/@robocorp/ds/node_modules/@floating-ui/react-dom-interactions/dist/floating-ui.react-dom-interactions.mjs + 2 modules
var floating_ui_react_dom_interactions = __webpack_require__(9277);
// EXTERNAL MODULE: ./node_modules/@floating-ui/core/dist/floating-ui.core.mjs
var floating_ui_core = __webpack_require__(7680);
// EXTERNAL MODULE: ./node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs
var floating_ui_dom = __webpack_require__(7555);
// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/helpers/component.js
var component = __webpack_require__(8335);
// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/theme/index.js + 2 modules
var theme = __webpack_require__(3694);
// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/hooks/usePortal.js
var usePortal = __webpack_require__(5593);
// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/hooks/useLockScroll.js
var useLockScroll = __webpack_require__(6501);
// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/hooks/useForkRef.js
var useForkRef = __webpack_require__(5009);
// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconChevronRight.js
var IconChevronRight = __webpack_require__(2554);
// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/components/Box/Box.js
var Box = __webpack_require__(6028);
// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconCheck.js
var IconCheck = __webpack_require__(6137);
// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/Icon.js
var Icon_Icon = __webpack_require__(3170);
// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/components/Typography/Typography.js
var Typography = __webpack_require__(2888);
;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Menu/components/Container.js


const Container = theme/* styled.button */.zo.button `
  display: flex;
  align-items: center;
  justify-content: flex-start;
  padding: ${({ theme }) => theme.sizes.$8} ${({ theme }) => theme.sizes.$16};
  color: ${({ theme }) => theme.color('dark0')};
  text-align: left;
  background: ${({ active, theme }) => (active ? theme.color('dark90', 'light80') : 'transparent')};
  white-space: break-all;

  &:focus {
    background: ${({ active, theme }) => (active ? theme.color('dark80', 'light70') : theme.color('dark90', 'light80'))};
  }

  &:disabled {
    color: ${({ theme }) => theme.color('dark50', 'light30')};
    background: ${({ theme }) => theme.color('dark100')};
    pointer-events: none;
  }

  ${({ theme }) => (0,index_esm/* variant */.bU)({
    prop: 'size',
    variants: {
        small: {
            minHeight: theme.sizes.$36,
            fontSize: theme.fontSizes.$12,
            '> * + *': {
                marginLeft: '6px'
            },
            '> .icon': {
                width: '14px',
                height: '14px',
                lineHeight: '14px'
            }
        },
        medium: {
            minHeight: theme.sizes.$40,
            fontSize: theme.fontSizes.$14,
            '> * + *': {
                marginLeft: theme.sizes.$8
            },
            '> .icon': {
                width: theme.sizes.$16,
                height: theme.sizes.$16,
                lineHeight: theme.sizes.$16
            }
        }
    }
})}
`;

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Menu/components/Item.js
var __rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};









const ItemContent = ({ badge, children, checked, icon, hotkey }) => {
    const Icon = (0,react.useMemo)(() => {
        if (typeof checked === 'boolean') {
            return checked ? IconCheck/* default */.Z : Icon_Icon/* IconBase */.A0;
        }
        return icon || null;
    }, [checked, icon]);
    return ((0,jsx_runtime.jsxs)(jsx_runtime.Fragment, { children: [Icon && (0,jsx_runtime.jsx)(Icon, {}), (0,jsx_runtime.jsx)(Box/* default */.Z, Object.assign({ flex: "1" }, { children: children })), hotkey && ((0,jsx_runtime.jsx)(Typography/* Typography */.Z, Object.assign({ color: "dark30", fontSize: "$12" }, { children: hotkey }))), badge && ((0,jsx_runtime.jsx)(Box/* default */.Z, Object.assign({ display: "flex", alignItems: "center" }, { children: badge })))] }));
};
/**
 * A Menu item as a button element containing a single choice of the Menu.
 *
 * @see
 * {@link https://design-system.solventek.com/component/menu}
 *
 * @example
 * <Menu>
 *   <Menu.Item onClick={}>..</Menu.Item>
 * </Menu>
 */
const Item = (0,component/* componentWithRef */.w)((_a, forwardedRef) => {
    var { active, badge, checked, children, disabled, hotkey, icon, menuItemRef } = _a, rest = __rest(_a, ["active", "badge", "checked", "children", "disabled", "hotkey", "icon", "menuItemRef"]);
    const combinedRef = (0,useForkRef/* useForkRef */.c)(menuItemRef, forwardedRef);
    return ((0,jsx_runtime.jsx)(Container, Object.assign({ ref: combinedRef, disabled: disabled, active: active }, rest, { children: (0,jsx_runtime.jsx)(ItemContent, Object.assign({ badge: badge, icon: icon, hotkey: hotkey, checked: checked }, { children: children })) })));
});

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Menu/components/Link.js
var Link_rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};









const Link_ItemContent = ({ badge, children, checked, icon, hotkey }) => {
    const Icon = (0,react.useMemo)(() => {
        if (typeof checked === 'boolean') {
            return checked ? IconCheck/* default */.Z : Icon_Icon/* IconBase */.A0;
        }
        return icon || null;
    }, [checked, icon]);
    return ((0,jsx_runtime.jsxs)(jsx_runtime.Fragment, { children: [Icon && (0,jsx_runtime.jsx)(Icon, {}), (0,jsx_runtime.jsx)(Box/* default */.Z, Object.assign({ flex: "1" }, { children: children })), hotkey && ((0,jsx_runtime.jsx)(Typography/* Typography */.Z, Object.assign({ color: "dark30", fontSize: "$12" }, { children: hotkey }))), badge && ((0,jsx_runtime.jsx)(Box/* default */.Z, Object.assign({ display: "flex", alignItems: "center" }, { children: badge })))] }));
};
/**
 * A Menu item as an anchor element containing a single choice of a Menu.
 *
 * @see
 * {@link https://design-system.solventek.com/component/menu}
 *
 * @example
 * <Menu>
 *   <Menu.Link href="https://solventek.com">..</Menu.Link>
 * </Menu>
 */
const Link = (0,component/* componentWithRef */.w)((_a, forwardedRef) => {
    var { active, badge, checked, children, icon, hotkey, menuItemRef } = _a, rest = Link_rest(_a, ["active", "badge", "checked", "children", "icon", "hotkey", "menuItemRef"]);
    const combinedRef = (0,useForkRef/* useForkRef */.c)(menuItemRef, forwardedRef);
    return ((0,jsx_runtime.jsx)(Container, Object.assign({ as: "a", ref: combinedRef, active: active }, rest, { children: (0,jsx_runtime.jsx)(Link_ItemContent, Object.assign({ badge: badge, icon: icon, hotkey: hotkey, checked: checked }, { children: children })) })));
});

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Menu/components/Title.js


const Title = theme/* styled.div */.zo.div `
  display: flex;
  align-items: center;
  justify-content: flex-start;
  font-size: ${({ theme }) => theme.fontSizes.$12};
  color: ${({ theme }) => theme.color('dark30')};
  padding: 0 ${({ theme }) => theme.sizes.$12};

  ${({ theme }) => (0,index_esm/* variant */.bU)({
    prop: 'size',
    variants: {
        small: {
            height: theme.sizes.$36
        },
        medium: {
            height: theme.sizes.$40
        }
    }
})}
`;

// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/components/Checkbox/Checkbox.js
var Checkbox = __webpack_require__(5477);
;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Menu/components/Checkbox.js
var Checkbox_rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};








const Checkbox_ItemContent = ({ badge, children, checked = false, hotkey }) => {
    return ((0,jsx_runtime.jsxs)(Box/* default */.Z, Object.assign({ display: "flex", alignItems: "center", width: "100%" }, { children: [(0,jsx_runtime.jsx)(Box/* default */.Z, Object.assign({ display: "flex", mr: 8, colors: ['dark0', 'dark0'] }, { children: (0,jsx_runtime.jsx)(Checkbox/* CheckboxStyled */.U, Object.assign({ as: "div", checked: checked, "$size": "small", className: checked ? 'checked' : undefined }, { children: checked ? (0,jsx_runtime.jsx)(IconCheck/* default */.Z, { size: 18 }) : null })) })), (0,jsx_runtime.jsx)(Box/* default */.Z, Object.assign({ flex: "1", mr: "auto" }, { children: children })), hotkey && ((0,jsx_runtime.jsx)(Typography/* Typography */.Z, Object.assign({ color: "dark30", fontSize: "$12" }, { children: hotkey }))), badge && ((0,jsx_runtime.jsx)(Box/* default */.Z, Object.assign({ display: "flex", alignItems: "center" }, { children: badge })))] })));
};
/**
 * A Menu item as a button element containing a single choice of the Menu.
 *
 * @see
 * {@link https://design-system.solventek.com/component/menu}
 *
 * @example
 * <Menu>
 *   <Menu.Checkbox onClick={}>..</Menu.Checkbox>
 * </Menu>
 */
const Checkbox_Checkbox = (0,component/* componentWithRef */.w)((_a, forwardedRef) => {
    var { active, badge, checked, children, disabled, hotkey, menuItemRef } = _a, rest = Checkbox_rest(_a, ["active", "badge", "checked", "children", "disabled", "hotkey", "menuItemRef"]);
    const combinedRef = (0,useForkRef/* useForkRef */.c)(menuItemRef, forwardedRef);
    return ((0,jsx_runtime.jsx)(Container, Object.assign({ ref: combinedRef, disabled: disabled, active: active }, rest, { children: (0,jsx_runtime.jsx)(Checkbox_ItemContent, Object.assign({ badge: badge, hotkey: hotkey, checked: checked }, { children: children })) })));
});

// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/components/Radio/Radio.js + 1 modules
var Radio = __webpack_require__(5452);
;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Menu/components/Radio.js
var Radio_rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};







const Radio_ItemContent = ({ badge, children, checked = false, hotkey }) => {
    return ((0,jsx_runtime.jsxs)(Box/* default */.Z, Object.assign({ display: "flex", alignItems: "center", width: "100%" }, { children: [(0,jsx_runtime.jsx)(Box/* default */.Z, Object.assign({ display: "flex", mr: 8 }, { children: (0,jsx_runtime.jsx)(Radio/* RadioStyled */.w, { as: "div", checked: checked, "$size": "small", variant: "primary", className: checked ? 'checked' : undefined }) })), (0,jsx_runtime.jsx)(Box/* default */.Z, Object.assign({ flex: "1", mr: "auto" }, { children: children })), hotkey && ((0,jsx_runtime.jsx)(Typography/* Typography */.Z, Object.assign({ color: "dark30", fontSize: "$12" }, { children: hotkey }))), badge && ((0,jsx_runtime.jsx)(Box/* default */.Z, Object.assign({ display: "flex", alignItems: "center" }, { children: badge })))] })));
};
/**
 * A Menu item as a button element containing a single choice of the Menu.
 *
 * @see
 * {@link https://design-system.solventek.com/component/menu}
 *
 * @example
 * <Menu>
 *   <Menu.Radio onClick={}>..</Menu.Checkbox>
 * </Menu>
 */
const Radio_Radio = (0,component/* componentWithRef */.w)((_a, forwardedRef) => {
    var { active, badge, checked, children, disabled, hotkey, menuItemRef } = _a, rest = Radio_rest(_a, ["active", "badge", "checked", "children", "disabled", "hotkey", "menuItemRef"]);
    const combinedRef = (0,useForkRef/* useForkRef */.c)(menuItemRef, forwardedRef);
    return ((0,jsx_runtime.jsx)(Container, Object.assign({ ref: combinedRef, disabled: disabled, active: active }, rest, { children: (0,jsx_runtime.jsx)(Radio_ItemContent, Object.assign({ badge: badge, hotkey: hotkey, checked: checked }, { children: children })) })));
});

// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/components/Input/Input.js + 1 modules
var Input = __webpack_require__(3622);
;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Menu/components/Input.js
var Input_rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};




const MenuInput = (0,component/* componentWithRef */.w)((_a, forwardedRef) => {
    var { value, onChange, placeholder } = _a, rest = Input_rest(_a, ["value", "onChange", "placeholder"]);
    return ((0,jsx_runtime.jsx)(Box/* default */.Z, Object.assign({ px: 10, py: 5 }, { children: (0,jsx_runtime.jsx)(Input/* Input */.II, Object.assign({ value: value, onChange: onChange, placeholder: placeholder, ref: forwardedRef }, rest)) })));
});

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Menu/Menu.js
var Menu_rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};









const compoundComponents = {
    Item: Item,
    Link: Link,
    Title: Title,
    Checkbox: Checkbox_Checkbox,
    Radio: Radio_Radio,
    Input: MenuInput
};
const Menu_Container = theme/* styled.ul */.zo.ul `
  position: fixed;
  z-index: ${({ theme }) => theme.zIndex.dropdown};
  padding: ${({ theme }) => theme.sizes.$4} 0;
  border: 1px solid ${({ theme }) => theme.color('dark50')};
  border-radius: ${({ theme }) => theme.sizes.$4};
  background: ${({ theme }) => theme.color('dark100')};
  overflow: auto;
  box-shadow: ${({ theme }) => theme.shadows.level1};

  ${index_esm/* width */.bf}
  ${index_esm/* minWidth */.ih}
  ${index_esm/* maxHeight */.kC}

  > * {
    width: 100%;
  }
`;
const Overlay = theme/* styled.div */.zo.div `
  position: fixed;
  top: 0px;
  left: 0px;
  width: 100vw;
  height: 100vh;
  z-index: ${({ theme }) => theme.zIndex.dropdown - 1};
  background: transparent;
`;
const MenuBase = (0,component/* componentWithRef */.w)((_a, forwardedRef) => {
    var { activeIndex, contextRef, children, matchWidth, offset, visible, setVisible, placement, menuItemRef, trigger, size, onVirtualChange, leaveMenuOpenOnItemSelect, initialFocus } = _a, rest = Menu_rest(_a, ["activeIndex", "contextRef", "children", "matchWidth", "offset", "visible", "setVisible", "placement", "menuItemRef", "trigger", "size", "onVirtualChange", "leaveMenuOpenOnItemSelect", "initialFocus"]);
    const [localVisible, setLocalVisible] = (0,react.useState)(visible || false);
    const [localActiveIndex, setActiveIndex] = (0,react.useState)(activeIndex || null);
    const Portal = (0,usePortal/* usePortal */.v)();
    const menuItemsRef = (0,react.useRef)([]);
    const [allowHover, setAllowHover] = (0,react.useState)(false);
    const tree = (0,floating_ui_react_dom_interactions/* useFloatingTree */.ay)();
    const nodeId = (0,floating_ui_react_dom_interactions/* useFloatingNodeId */.jV)();
    const parentId = (0,floating_ui_react_dom_interactions/* useFloatingParentNodeId */.Zm)();
    const nested = parentId != null;
    (0,useLockScroll/* default */.Z)(localVisible && !!(contextRef === null || contextRef === void 0 ? void 0 : contextRef.current));
    (0,react.useEffect)(() => {
        if (typeof visible === 'boolean') {
            setLocalVisible(visible);
        }
    }, [visible]);
    (0,react.useEffect)(() => {
        if (typeof activeIndex === 'number' && localVisible) {
            setActiveIndex(activeIndex);
        }
    }, [activeIndex, localVisible]);
    const { x, y, reference, floating, strategy, refs, context } = (0,floating_ui_react_dom_interactions/* useFloating */.YF)({
        open: localVisible,
        onOpenChange: setVisible || setLocalVisible,
        middleware: [
            (0,floating_ui_core/* offset */.cv)({ mainAxis: nested ? -4 : offset, alignmentAxis: nested ? -5 : 0 }),
            (0,floating_ui_core/* flip */.RR)(),
            (0,floating_ui_core/* shift */.uY)(),
            (0,floating_ui_core/* size */.dp)({
                apply({ elements, rects }) {
                    var _a, _b;
                    if (matchWidth) {
                        Object.assign((_a = elements.floating) === null || _a === void 0 ? void 0 : _a.style, {
                            width: `${(_b = rects.reference) === null || _b === void 0 ? void 0 : _b.width}px`
                        });
                    }
                }
            })
        ],
        placement: nested ? 'right-start' : placement,
        nodeId,
        whileElementsMounted: floating_ui_dom/* autoUpdate */.Me
    });
    const combinedItemRef = (0,useForkRef/* useForkRef */.c)(menuItemRef, reference);
    const combinedMenuRef = (0,useForkRef/* useForkRef */.c)(forwardedRef, floating);
    const virtual = typeof onVirtualChange === 'function';
    const { getReferenceProps, getFloatingProps, getItemProps } = (0,floating_ui_react_dom_interactions/* useInteractions */.NI)([
        (0,floating_ui_react_dom_interactions/* useHover */.XI)(context, {
            handleClose: (0,floating_ui_react_dom_interactions/* safePolygon */.xp)({ restMs: 25 }),
            enabled: nested && allowHover,
            delay: { open: 75 }
        }),
        (0,floating_ui_react_dom_interactions/* useClick */.eS)(context, {
            toggle: !nested,
            event: 'mousedown',
            ignoreMouse: nested
        }),
        (0,floating_ui_react_dom_interactions/* useRole */.qs)(context, { role: virtual ? 'listbox' : 'menu' }),
        (0,floating_ui_react_dom_interactions/* useDismiss */.bQ)(context),
        (0,floating_ui_react_dom_interactions/* useListNavigation */.c0)(context, {
            listRef: menuItemsRef,
            activeIndex: localActiveIndex,
            nested,
            virtual,
            onNavigate: setActiveIndex,
            loop: true
        })
    ]);
    (0,react.useEffect)(() => {
        var _a;
        if (localActiveIndex != null) {
            (_a = menuItemsRef.current[localActiveIndex]) === null || _a === void 0 ? void 0 : _a.scrollIntoView({ block: 'nearest' });
        }
    }, [localActiveIndex]);
    // Closes all menus when an item gets clicked anywhere in the tree
    (0,react.useEffect)(() => {
        if (leaveMenuOpenOnItemSelect)
            return undefined;
        function onTreeClick() {
            (setVisible || setLocalVisible)(false);
        }
        tree === null || tree === void 0 ? void 0 : tree.events.on('click', onTreeClick);
        return () => {
            tree === null || tree === void 0 ? void 0 : tree.events.off('click', onTreeClick);
        };
    }, [parentId, tree, refs, leaveMenuOpenOnItemSelect]);
    // Prevents unwanted focus synchronization as menus open and close with
    // keyboard navigation and the cursor is resting on the menu.
    (0,react.useEffect)(() => {
        function onPointerMove() {
            setAllowHover(true);
        }
        function onKeyDown() {
            setAllowHover(false);
        }
        window.addEventListener('pointermove', onPointerMove, {
            once: true,
            capture: true
        });
        window.addEventListener('keydown', onKeyDown, { passive: true });
        return () => {
            window.removeEventListener('pointermove', onPointerMove);
            window.removeEventListener('keydown', onKeyDown);
        };
    }, [allowHover]);
    // Context menu handle
    (0,react.useEffect)(() => {
        var _a;
        const onContextMenu = (e) => {
            e.preventDefault();
            e.stopPropagation();
            reference({
                getBoundingClientRect() {
                    return {
                        x: e.clientX,
                        y: e.clientY,
                        width: 0,
                        height: 0,
                        top: e.clientY,
                        right: e.clientX,
                        bottom: e.clientY,
                        left: e.clientX
                    };
                }
            });
            (setVisible || setLocalVisible)(true);
        };
        (_a = contextRef === null || contextRef === void 0 ? void 0 : contextRef.current) === null || _a === void 0 ? void 0 : _a.addEventListener('contextmenu', onContextMenu);
        return () => {
            var _a;
            (_a = contextRef === null || contextRef === void 0 ? void 0 : contextRef.current) === null || _a === void 0 ? void 0 : _a.removeEventListener('contextmenu', onContextMenu);
        };
    }, [localVisible]);
    const Wrapper = nested ? react.Fragment : floating_ui_react_dom_interactions/* FloatingTree */.RB;
    const getContainerProps = (0,react.useCallback)(() => {
        return getFloatingProps({
            ref: combinedMenuRef,
            style: {
                position: strategy,
                top: y !== null && y !== void 0 ? y : '',
                left: x !== null && x !== void 0 ? x : '',
                visibility: allowHover && x == null ? 'hidden' : undefined
            },
            onKeyDown(event) {
                if (virtual && event.key === 'Enter' && localActiveIndex != null) {
                    onVirtualChange(localActiveIndex);
                    event.preventDefault();
                    event.stopPropagation();
                }
            }
        });
    }, [getFloatingProps, combinedMenuRef, strategy, x, y, allowHover, onVirtualChange, localActiveIndex, virtual]);
    return ((0,jsx_runtime.jsx)(Wrapper, { children: (0,jsx_runtime.jsxs)(floating_ui_react_dom_interactions/* FloatingNode */.mN, Object.assign({ id: nodeId }, { children: [(0,react.isValidElement)(trigger) &&
                    (0,react.cloneElement)(trigger, Object.assign({ size }, getReferenceProps(Object.assign(Object.assign({}, trigger.props), { ref: combinedItemRef, badge: nested ? (0,jsx_runtime.jsx)(IconChevronRight/* default */.Z, { size: 14 }) : undefined, onClick(event) {
                            if (nested) {
                                event.stopPropagation();
                            }
                            // allow the focus manager to handle the initial focus
                            if (initialFocus === undefined) {
                                event.currentTarget.focus();
                            }
                        },
                        onKeyDown(event) {
                            if (virtual && event.key === 'Enter' && localActiveIndex != null) {
                                onVirtualChange(localActiveIndex);
                                (setVisible || setLocalVisible)(false);
                            }
                            if (event.key === 'Tab') {
                                (setVisible || setLocalVisible)(false);
                            }
                        },
                        onPointerDown(event) {
                            if (nested) {
                                event.stopPropagation();
                            }
                            event.currentTarget.focus();
                        } })))), (0,jsx_runtime.jsx)(Portal, { children: localVisible && ((0,jsx_runtime.jsxs)(jsx_runtime.Fragment, { children: [(contextRef === null || contextRef === void 0 ? void 0 : contextRef.current) && (0,jsx_runtime.jsx)(Overlay, {}), (0,jsx_runtime.jsx)(floating_ui_react_dom_interactions/* FloatingFocusManager */.wD, Object.assign({ context: context, modal: !nested, order: ['reference', 'content'], initialFocus: initialFocus }, { children: (0,jsx_runtime.jsx)(Menu_Container, Object.assign({}, getContainerProps(), rest, { children: react.Children.map(children, (child, index) => {
                                        if (!(0,react.isValidElement)(child)) {
                                            return null;
                                        }
                                        return (0,react.cloneElement)(child, Object.assign({ menuItemRef: (node) => {
                                                menuItemsRef.current[index] = node;
                                            } }, getItemProps(Object.assign(Object.assign({ size, role: virtual ? 'option' : 'menuitem', active: localActiveIndex === index, 'aria-selected': virtual ? localActiveIndex === index : undefined }, child.props), { onClick() {
                                                var _a, _b;
                                                tree === null || tree === void 0 ? void 0 : tree.events.emit('click');
                                                (_b = (_a = child.props).onClick) === null || _b === void 0 ? void 0 : _b.call(_a);
                                            },
                                            onPointerEnter() {
                                                if (allowHover) {
                                                    setActiveIndex(index);
                                                }
                                            } }))));
                                    }) })) }))] })) })] })) }));
});
/**
 * A Menu displays a list of choices, appearing when the user interacts with a button, input field, or other control.
 *
 * @see
 * {@link https://design-system.solventek.com/component/menu}
 *
 * @example
 * <Menu visible={visible} setVisible={setVisible}>
 *   <Menu.Item onClick={}>..</Menu.Item>
 * </Menu>
 */
const Menu = (0,component/* componentWithRef */.w)((props, forwardedRef) => {
    const parentId = (0,floating_ui_react_dom_interactions/* useFloatingParentNodeId */.Zm)();
    const Wrapper = parentId ? react.Fragment : floating_ui_react_dom_interactions/* FloatingTree */.RB;
    return ((0,jsx_runtime.jsx)(Wrapper, { children: (0,jsx_runtime.jsx)(MenuBase, Object.assign({ ref: forwardedRef }, props)) }));
}, compoundComponents);
Menu.defaultProps = {
    offset: 2,
    placement: 'bottom-start',
    size: 'medium',
    minWidth: 160
};


/***/ }),

/***/ 1739:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4191);
/* harmony import */ var _theme__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3694);
/* harmony import */ var _helpers_animations__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(1867);
/* harmony import */ var _helpers_utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(3397);
/* harmony import */ var _components_Button__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(8100);
/* harmony import */ var _components_Box__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(6028);
/* harmony import */ var _components_Tooltip__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(4183);
/* harmony import */ var _components_Icon__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(845);
/* harmony import */ var _components_AddTextField__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(3826);
/* harmony import */ var _components_Divider__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(1493);
/* harmony import */ var _components_Transition__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(8159);
var __rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};












const PanelStyled = _theme__WEBPACK_IMPORTED_MODULE_2__/* .styled.div */ .zo.div `
  position: relative;
  height: inherit;
  background-color: ${({ theme }) => theme.color('dark80', 'light100')};
  border-radius: 2px;
  list-style: none;
  ${({ theme }) => theme.name === 'light' && `box-shadow: 0 1px 1px rgba(55, 66, 80, 0.08), 0 0 8px rgba(118, 134, 154, 0.08);`}
`;
const PanelHeader = _theme__WEBPACK_IMPORTED_MODULE_2__/* .styled.h4 */ .zo.h4 `
  max-width: 80%;
  min-height: 64px;
  font-size: ${({ theme }) => theme.fontSizes.$16};
  font-weight: ${({ theme }) => theme.fontWeights.semibold};
  padding: 20px 20px ${({ isOpen }) => (isOpen ? '8px' : '20px')};
`;
const PanelHeaderImage = _theme__WEBPACK_IMPORTED_MODULE_2__/* .styled.img */ .zo.img `
  width: 100%;
  height: 100px;
  object-fit: cover;
  ${({ overlay }) => overlay && 'margin-bottom: 40px'};
  opacity: 0.5;
`;
const PanelOverlayImage = _theme__WEBPACK_IMPORTED_MODULE_2__/* .styled.img */ .zo.img `
  position: absolute;
  height: 80px;
  width: 80px;
  margin-left: calc(50% - 40px);
  top: 60px;
  border-radius: 16px;
  object-fit: cover;
`;
const PanelAction = _theme__WEBPACK_IMPORTED_MODULE_2__/* .styled.span */ .zo.span `
  position: absolute;
  right: 20px;
  top: 16px;
`;
const PanelActions = _theme__WEBPACK_IMPORTED_MODULE_2__/* .styled.div */ .zo.div `
  display: flex;
  align-items: center;
  justify-content: flex-end;
  position: absolute;
  right: 20px;
  top: 16px;

  > * + * {
    margin-left: 20px;
  }
`;
const StyledText = _theme__WEBPACK_IMPORTED_MODULE_2__/* .styled.p */ .zo.p `
  width: 100%;
  text-align: center;
  color: ${({ theme }) => theme.color('dark30')}};
  line-height: 60px;
  user-select: none;

  &.loading {
    color: ${({ theme }) => theme.color('dark20', 'light30')}};
  }
`;
const StyledAddField = _theme__WEBPACK_IMPORTED_MODULE_2__/* .styled.span */ .zo.span `
  label {
    width: 100%;
  }
`;
/**
 * Panel component
 */
const Panel = (_a) => {
    var { actions, addFieldInputType, addFieldLabelText, addInputProps, cancelActionTitle, children, disabled, disabledTooltip, divider, dropdown, empty, emptyText, header, headerImage, overlayImage, loading, loadingText, onAdd, panelAction, panelActionIcon, panelActionTitle, panelActionTooltip, processingContent, setErrors, titleId, tooltipPosition } = _a, rest = __rest(_a, ["actions", "addFieldInputType", "addFieldLabelText", "addInputProps", "cancelActionTitle", "children", "disabled", "disabledTooltip", "divider", "dropdown", "empty", "emptyText", "header", "headerImage", "overlayImage", "loading", "loadingText", "onAdd", "panelAction", "panelActionIcon", "panelActionTitle", "panelActionTooltip", "processingContent", "setErrors", "titleId", "tooltipPosition"]);
    const [addOpen, setAddOpen] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);
    const toggleAdd = () => {
        setAddOpen(!addOpen);
    };
    const onConfirm = (value) => {
        if (onAdd) {
            onAdd(value);
        }
        toggleAdd();
    };
    const handleKeyDown = (event) => {
        if (event.keyCode === 27)
            toggleAdd();
    };
    const renderPanelAction = () => {
        if (panelActionIcon && panelActionTitle)
            return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components_Button__WEBPACK_IMPORTED_MODULE_3__/* .Button */ .z, Object.assign({ variant: headerImage ? 'ghost' : 'secondary', onClick: panelAction || toggleAdd, icon: addOpen ? _components_Icon__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z : panelActionIcon, disabled: disabled }, { children: addOpen ? cancelActionTitle : panelActionTitle })));
        if (panelActionIcon)
            return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components_Button__WEBPACK_IMPORTED_MODULE_3__/* .Button */ .z, { variant: headerImage ? 'ghost' : 'secondary', onClick: panelAction || toggleAdd, icon: addOpen ? _components_Icon__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z : panelActionIcon, disabled: disabled }));
        if (panelActionTitle)
            return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components_Button__WEBPACK_IMPORTED_MODULE_3__/* .Button */ .z, Object.assign({ variant: headerImage ? 'ghost' : 'secondary', onClick: panelAction || toggleAdd, disabled: disabled }, { children: addOpen ? cancelActionTitle : panelActionTitle })));
        return null;
    };
    const renderActionWithTooltip = () => {
        if (panelActionTooltip && !disabled && !addOpen) {
            return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components_Tooltip__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z, Object.assign({ text: panelActionTooltip, placement: tooltipPosition, fadeIn: 200 }, { children: renderPanelAction() })));
        }
        if (disabledTooltip && disabled && !addOpen) {
            return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components_Tooltip__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z, Object.assign({ text: disabledTooltip, placement: tooltipPosition, fadeIn: 200 }, { children: renderPanelAction() })));
        }
        return renderPanelAction();
    };
    const renderAddField = () => {
        return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components_AddTextField__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z, { onConfirm: onConfirm, onKeyDown: handleKeyDown, autoFocus: addOpen, inputType: addFieldInputType, labelText: addFieldLabelText, addInputProps: addInputProps, setErrors: setErrors }));
    };
    const isEmpty = empty || typeof children === 'undefined' || react__WEBPACK_IMPORTED_MODULE_1__.Children.count(children) === 0;
    const showProgress = loading || processingContent;
    if (panelAction) {
        (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_7__/* .warn */ .ZK)('@robocorp/ds: Panel `panelAction` prop will be deprecated. Use the `actions` prop instead. See https://design-system.solventek.com/layout-components/panel');
    }
    if (dropdown) {
        (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_7__/* .warn */ .ZK)('@robocorp/ds: Panel `dropdown` prop will be deprecated. Use the `actions` prop instead. See https://design-system.solventek.com/layout-components/panel');
    }
    const Actions = actions;
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(PanelStyled, Object.assign({}, rest, { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(_components_Box__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z, Object.assign({ display: "flex" }, { children: [typeof header !== 'undefined' && !headerImage && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(PanelHeader, Object.assign({ id: titleId, isOpen: addOpen }, { children: header }))), headerImage && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(PanelHeaderImage, { src: headerImage, overlay: !!overlayImage, alt: "" }), overlayImage && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(PanelOverlayImage, { src: overlayImage, alt: "" })] })), dropdown && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(PanelAction, { children: dropdown }), (onAdd || panelAction) && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(PanelAction, { children: renderActionWithTooltip() }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(PanelActions, { children: Actions && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Actions, { toggleAdd: toggleAdd, addOpen: addOpen }) })] })), onAdd && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components_Transition__WEBPACK_IMPORTED_MODULE_9__/* .Transition.Collapse */ .u.Collapse, Object.assign({ in: addOpen }, { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(StyledAddField, { children: renderAddField() }) }))), (divider || isEmpty) && !showProgress && !headerImage && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components_Divider__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .Z, {}), showProgress && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_helpers_animations__WEBPACK_IMPORTED_MODULE_11__/* .LinearProgress */ .uk, {}), loading || isEmpty ? ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(StyledText, Object.assign({ className: loading ? 'loading' : '' }, { children: loading ? loadingText : emptyText }))) : (children)] })));
};
Panel.defaultProps = {
    divider: true,
    disabled: false,
    loading: false,
    processingContent: false,
    addFieldInputType: 'text',
    tooltipPosition: 'left',
    loadingText: 'Loading...',
    emptyText: 'No data found'
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Panel);


/***/ }),

/***/ 2702:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4191);
/* harmony import */ var _theme__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3694);
/* harmony import */ var _theme__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(3709);
/* harmony import */ var _helpers_animations__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(1867);
/* harmony import */ var _hooks__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(5050);
/* harmony import */ var _Icon__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(5950);
/* harmony import */ var _Icon__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(2111);
var __rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};






const LinearProgress = _theme__WEBPACK_IMPORTED_MODULE_2__/* .styled.div */ .zo.div `
  height: 4px;
  position: relative;
  width: 100%;
  overflow: hidden;
  ${({ backgroundColor, theme }) => (0,_theme__WEBPACK_IMPORTED_MODULE_3__/* .parseColorProps */ .sL)({ theme, backgroundColor })}
  border-radius: 4px;

  &:after {
    content: '';
    height: 100%;
    position: absolute;
    width: ${({ value }) => (typeof value === 'number' ? `${value * 100}%` : 'auto')};
    ${({ color, colors, theme }) => (0,_theme__WEBPACK_IMPORTED_MODULE_3__/* .parseColorProps */ .sL)({ theme, color, colors, colorTag: 'background-color' })}
  }

  &.animated:after {
    animation: ${_helpers_animations__WEBPACK_IMPORTED_MODULE_4__/* .load */ .zD} 2s cubic-bezier(0.65, 0.815, 0.735, 0.395) infinite;
  }
`;
const CircuralProgress = _theme__WEBPACK_IMPORTED_MODULE_2__/* .styled.div */ .zo.div `
  position: relative;
  width: ${({ size }) => (typeof size === 'number' ? `${size}px` : size)};
  height: ${({ size }) => (typeof size === 'number' ? `${size}px` : size)};
  overflow: hidden;

  &:after,
  &:before {
    content: '';
    height: 100%;
    width: 100%;
    position: absolute;
    top: 0px;
    left: 0px;
    border-radius: 100%;
  }

  &:before {
    border: ${({ size }) => (size && size < 24 ? 2 : 3)}px solid;
    ${({ backgroundColor, theme }) => (0,_theme__WEBPACK_IMPORTED_MODULE_3__/* .parseColorProps */ .sL)({ theme, backgroundColor, backgroundTag: 'border-color' })}
  }

  &:after {
    border: ${({ size }) => (size && size < 24 ? 2 : 3)}px solid transparent;
    ${({ color, colors, theme }) => (0,_theme__WEBPACK_IMPORTED_MODULE_3__/* .parseColorProps */ .sL)({ theme, color, colors, colorTag: 'border-top-color' })}
    animation: ${_helpers_animations__WEBPACK_IMPORTED_MODULE_4__/* .spin */ .O2} 1s cubic-bezier(0.65, 0.815, 0.735, 0.395) infinite;
  }
`;
const FullscreenContainer = _theme__WEBPACK_IMPORTED_MODULE_2__/* .styled.div */ .zo.div `
  position: relative;
`;
const FullscreenStyled = _theme__WEBPACK_IMPORTED_MODULE_2__/* .styled.div */ .zo.div `
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
  width: 160px;
  height: 160px;
  background: ${({ theme }) => theme.color('dark90')};
  border-radius: 160px;
  margin: 10px;

  &::before {
    position: absolute;
    display: block;
    content: '';
    width: 180px;
    height: 180px;
    border-radius: 180px;
    background: ${({ theme }) => theme.color('dark0', 'purple50', 0.1)};
  }
`;
const Blur = _theme__WEBPACK_IMPORTED_MODULE_2__/* .styled.div */ .zo.div `
  position: absolute;
  animation: ${_helpers_animations__WEBPACK_IMPORTED_MODULE_4__/* .spin */ .O2} 4s linear infinite;
  padding: 20px 0 0 20px;
  span {
    display: block;
    width: 160px;
    height: 160px;
    border-radius: 160px;
    background: conic-gradient(
      from 180deg at 50% 50%,
      #9d8cf6 -27deg,
      #9e8cf6 76deg,
      #f6bf45 109deg,
      #9d8cf6 142deg,
      #4d33d1 192deg,
      #4d33d1 293deg,
      #0dcfc7 315deg,
      #9d8cf6 333deg,
      #9e8cf6 436deg
    );
    filter: blur(12px);
    animation: ${_helpers_animations__WEBPACK_IMPORTED_MODULE_4__/* .spin */ .O2} 3s linear infinite reverse;
  }
`;
const FullscreenProgress = () => {
    const { name } = (0,_hooks__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)();
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(FullscreenContainer, { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Blur, { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("span", {}) }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(FullscreenStyled, { children: name === 'dark' ? (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_Icon__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z, { color: "dark0", size: 74 }) : (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_Icon__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z, { color: "purple50", size: 74 }) })] }));
};
/**
 * Progress component
 */
const Progress = (_a) => {
    var { variant } = _a, rest = __rest(_a, ["variant"]);
    const Component = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => {
        switch (variant) {
            case 'fullscreen':
                return FullscreenProgress;
            case 'circular':
                return CircuralProgress;
            case 'linear':
            default:
                return LinearProgress;
        }
    }, [variant]);
    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Component, Object.assign({ className: typeof rest.value !== 'number' ? 'animated' : 'static' }, rest));
};
Progress.defaultProps = {
    variant: 'linear',
    color: 'purple50',
    backgroundColor: 'dark60',
    size: 24
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Progress);


/***/ }),

/***/ 5452:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "Y": () => (/* binding */ Radio),
  "w": () => (/* binding */ RadioStyled)
});

// EXTERNAL MODULE: ./node_modules/react/jsx-runtime.js
var jsx_runtime = __webpack_require__(38);
// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(4191);
// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/helpers/component.js
var component = __webpack_require__(8335);
// EXTERNAL MODULE: ./node_modules/styled-system/dist/index.esm.js + 13 modules
var index_esm = __webpack_require__(4912);
// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/theme/index.js + 2 modules
var theme = __webpack_require__(3694);
// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/theme/helpers.js
var helpers = __webpack_require__(3709);
;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Radio/components/RadioGroup.js
var __rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};





const RadioContext = (0,react.createContext)({});
const RadioGroupStyled = theme/* styled.div */.zo.div `
  display: flex;
  flex-wrap: wrap;
  flex-direction: ${({ direction }) => direction};

  ${({ theme }) => (0,index_esm/* variant */.bU)({
    prop: 'direction',
    variants: {
        row: {
            flexDirection: 'row',
            '> *': {
                marginRight: theme.space.$12,
                marginBottom: theme.space.$12
            }
        },
        column: {
            flexDirection: 'column',
            '> *': {
                marginBottom: theme.space.$16
            }
        }
    }
})}
`;
/**
 * A group of Radio buttons can be wrapped in a Radio group to provide a global value and value change callback
 *
 * @see
 * {@link https://design-system.solventek.com/component/radio}
 *
 * @example
 * <Radio.Group value={item} onChange={(e) => setItem(e.target.value)}>
 *   <Radio value="one" label="First item" />
 *   <Radio value="two" label="Second item" />
 * </Radio.Group>
 */
const RadioGroup = (0,component/* componentWithRef */.w)((_a, forwardedRef) => {
    var { children, name, onChange, value } = _a, rest = __rest(_a, ["children", "name", "onChange", "value"]);
    const contextValue = (0,react.useMemo)(() => ({
        groupName: name,
        handleChange: onChange,
        groupValue: value
    }), [name, onChange, value]);
    return ((0,jsx_runtime.jsx)(RadioGroupStyled, Object.assign({}, rest, { ref: forwardedRef }, { children: (0,jsx_runtime.jsx)(RadioContext.Provider, Object.assign({ value: contextValue }, { children: children })) })));
});
RadioGroup.defaultProps = {
    direction: 'column'
};

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Radio/Radio.js
var Radio_rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};







const compoundComponents = {
    Group: RadioGroup
};
const Label = theme/* styled.label */.zo.label `
  position: relative;
  display: inline-flex;
  align-items: center;
  cursor: pointer;
  user-select: none;
  color: ${({ theme }) => theme.color('dark0')};
`;
const RadioStyled = theme/* styled.input */.zo.input `
  cursor: pointer;
  appearance: none;
  display: inline-block;

  ${helpers/* styledFocus */.By}

  &:disabled {
    cursor: not-allowed;

    ~ strong {
      color: ${({ theme }) => theme.color('dark20')};
    }
  }

  ${({ theme, variant }) => variant === 'primary' &&
    (0,index_esm/* variant */.bU)({
        prop: '$size',
        variants: {
            small: {
                width: theme.sizes.$20,
                height: theme.sizes.$20,
                borderRadius: theme.sizes.$20,
                '&:checked,&.checked': {
                    borderWidth: 6
                },
                '~ strong': {
                    marginLeft: theme.sizes.$8,
                    fontSize: theme.fontSizes.$12
                }
            },
            medium: {
                width: theme.sizes.$20,
                height: theme.sizes.$20,
                borderRadius: theme.sizes.$20,
                '&:checked,&.checked': {
                    borderWidth: 6
                },
                '~ strong': {
                    marginLeft: theme.sizes.$8,
                    fontSize: theme.fontSizes.$14
                }
            },
            large: {
                width: theme.sizes.$28,
                height: theme.sizes.$28,
                borderRadius: theme.sizes.$28,
                '&:checked,&.checked': {
                    borderWidth: 8
                },
                '~ strong': {
                    marginLeft: theme.sizes.$12,
                    fontSize: theme.fontSizes.$16
                }
            }
        }
    })}

  ${({ theme }) => (0,index_esm/* variant */.bU)({
    variants: {
        primary: {
            background: theme.color('dark100')({ theme }),
            border: '1px solid',
            borderColor: theme.color('light20')({ theme }),
            transition: `background ${theme.transition.duration.fast}ms ${theme.transition.function.default}, border ${theme.transition.function.default}ms`,
            '&:checked,&.checked': {
                background: theme.color('white')({ theme }),
                borderColor: theme.color('purple50')({ theme })
            }
        },
        tag: {
            position: 'absolute',
            width: '100%',
            height: '100%',
            border: '1px solid',
            borderColor: theme.color('dark50')({ theme }),
            '&:checked,&.checked': {
                borderColor: theme.color('dark20')({ theme })
            },
            '& + strong': {
                padding: theme.sizes.$12,
                minWidth: theme.sizes.$36,
                textAlign: 'center'
            },
            '&:disabled': {
                borderColor: theme.color('dark50')({ theme })
            }
        }
    }
})}
`;
/**
 * Radio buttons allow the user to select one option from a set. A group of Radio buttons can be wrapped in `Radio.Group`.
 *
 * @see
 * {@link https://design-system.solventek.com/component/radio}
 *
 * @example
 * <Radio value="Foo" checked={item === 'Foo'} onChange={(e) => setItem(e.target.value)} />
 */
const Radio = (0,component/* componentWithRef */.w)((_a, forwardedRef) => {
    var { checked, label, name, onChange, size, value } = _a, rest = Radio_rest(_a, ["checked", "label", "name", "onChange", "size", "value"]);
    const { groupName, handleChange, groupValue } = (0,react.useContext)(RadioContext);
    const changeCallback = (0,react.useMemo)(() => {
        return handleChange || onChange;
    }, [handleChange, onChange]);
    const isChecked = (0,react.useMemo)(() => {
        return typeof groupValue !== 'undefined' ? groupValue === value : checked;
    }, [checked, groupValue, value]);
    return ((0,jsx_runtime.jsxs)(Label, { children: [(0,jsx_runtime.jsx)(RadioStyled, Object.assign({ name: groupName || name, type: "radio", "$size": size, checked: isChecked, onChange: changeCallback, ref: forwardedRef, value: value }, rest)), label && (0,jsx_runtime.jsx)("strong", { children: label })] }));
}, compoundComponents);
Radio.defaultProps = {
    size: 'medium',
    variant: 'primary'
};


/***/ }),

/***/ 3270:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4191);
/* harmony import */ var styled_system__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(4912);
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(8335);
/* harmony import */ var _theme__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(3694);
/* harmony import */ var _theme_helpers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(9978);
/* harmony import */ var _hooks__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(5009);
var __rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};







const ScrollStyled = (0,_theme__WEBPACK_IMPORTED_MODULE_3__/* .styled */ .zo)('div').withConfig({ shouldForwardProp: _theme_helpers__WEBPACK_IMPORTED_MODULE_4__/* .shouldForwardProp */ .x }) `
  height: 100%;
  width: 100%;
  position: relative;
  ${styled_system__WEBPACK_IMPORTED_MODULE_2__/* .width */ .bf}
  ${styled_system__WEBPACK_IMPORTED_MODULE_2__/* .height */ .Cb}


  &:before {
    position: absolute;
    content: '';
    width: 100%;
    height: 100%;
    border: 1px solid transparent;
    pointer-events: none;
    z-index: 2;
    transition: border-color ${({ theme }) => theme.transition.duration.slow}ms
      ${({ theme }) => theme.transition.function.easeOut};
  }

  &.top:before {
    border-top-color: ${({ theme }) => theme.color('dark50')};
  }

  &.bottom:before {
    border-bottom-color: ${({ theme }) => theme.color('dark50')};
  }

  &.left:before {
    border-left-color: ${({ theme }) => theme.color('dark50')};
  }

  &.right:before {
    border-right-color: ${({ theme }) => theme.color('dark50')};
  }

  > div {
    height: 100%;
    width: 100%;

    ${({ horizontal }) => horizontal &&
    _theme__WEBPACK_IMPORTED_MODULE_3__/* .css */ .iv `
        overflow-x: auto;
      `}

    ${({ vertical }) => vertical &&
    _theme__WEBPACK_IMPORTED_MODULE_3__/* .css */ .iv `
        overflow-y: auto;
      `}

  ${({ theme, variant }) => variant === 'custom' &&
    _theme__WEBPACK_IMPORTED_MODULE_3__/* .css */ .iv `
        scrollbar-width: thin;

        &::-webkit-scrollbar {
          width: 6px;
          height: 6px;
          background-color: transparent;
        }

        &::-webkit-scrollbar-thumb {
          border-radius: 3px;
          background-color: transparent;
        }

        &:hover::-webkit-scrollbar-thumb {
          background-color: ${theme.name === 'light' ? 'rgba(0, 0, 0, 0.4)' : 'rgba(255, 255, 255, 0.4)'};
        }

        &::-webkit-scrollbar-corner {
          background-color: transparent;
        }
      `}
  }
`;
/**
 * Scroll component
 */
const Scroll = (0,_helpers__WEBPACK_IMPORTED_MODULE_5__/* .componentWithRef */ .w)((_a, forwardRef) => {
    var { children, indicators } = _a, rest = __rest(_a, ["children", "indicators"]);
    const scrollRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);
    const localRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);
    const combinedRef = (0,_hooks__WEBPACK_IMPORTED_MODULE_6__/* .useForkRef */ .c)(localRef, forwardRef);
    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {
        var _a;
        const onScroll = () => {
            if (!scrollRef.current || !localRef.current) {
                return;
            }
            const { scrollTop, clientHeight, scrollHeight, scrollLeft, clientWidth, scrollWidth } = scrollRef.current;
            const isTop = scrollTop === 0;
            const isBottom = clientHeight === scrollHeight - scrollTop;
            const isRight = scrollLeft === 0;
            const isLeft = clientWidth === scrollWidth - scrollLeft;
            localRef.current.classList[isTop ? 'remove' : 'add']('top');
            localRef.current.classList[isBottom ? 'remove' : 'add']('bottom');
            localRef.current.classList[isLeft ? 'remove' : 'add']('left');
            localRef.current.classList[isRight ? 'remove' : 'add']('right');
        };
        if (indicators) {
            (_a = scrollRef.current) === null || _a === void 0 ? void 0 : _a.addEventListener('scroll', onScroll, { passive: true });
            window.addEventListener('resize', onScroll, { passive: true });
            onScroll();
        }
        return () => {
            var _a;
            (_a = scrollRef.current) === null || _a === void 0 ? void 0 : _a.removeEventListener('scroll', onScroll);
            window.removeEventListener('resize', onScroll);
        };
    }, [indicators]);
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ScrollStyled, Object.assign({ ref: combinedRef }, rest, { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", Object.assign({ ref: scrollRef }, { children: children })) })));
});
Scroll.defaultProps = {
    width: '100%',
    height: '100%',
    horizontal: false,
    vertical: true,
    variant: 'default'
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Scroll);


/***/ }),

/***/ 6138:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "P": () => (/* binding */ Select)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4191);
/* harmony import */ var _theme__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3694);
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(8335);
/* harmony import */ var _components_Input_Input__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(3622);
/* harmony import */ var _Icon__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(3469);
/* harmony import */ var _Badge_Badge__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(6965);
/* harmony import */ var _Menu__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(9492);
var __rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};








const SelectWrapper = _theme__WEBPACK_IMPORTED_MODULE_2__/* .styled.div */ .zo.div `
  width: 100%;
  min-width: 120px;

  > div {
    position: relative;
  }

  input {
    cursor: pointer;

    &:read-only {
      ::selection {
        background: ${({ theme }) => theme.color('dark80')};
      }
    }
  }

  nav {
    display: ${({ open }) => (open ? 'block' : 'none')};
  }

  label > div svg {
    transform: ${({ open }) => (open ? 'rotate(180deg)' : 'none')};
  }

  .right {
    pointer-events: none;
  }
`;
/**
 * Select component
 */
const Select = (0,_helpers__WEBPACK_IMPORTED_MODULE_3__/* .componentWithRef */ .w)((_a, forwardedRef) => {
    var { error, description, items, label, tooltip, placeholder, onChange, disabled, size, value, searchable, noItemsFound, autoComplete, renderItem: RenderItem } = _a, rest = __rest(_a, ["error", "description", "items", "label", "tooltip", "placeholder", "onChange", "disabled", "size", "value", "searchable", "noItemsFound", "autoComplete", "renderItem"]);
    const [searchText, setSearchText] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)('');
    const [searchActive, setSearchActive] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);
    const [filteredItems, setFilteredItems] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);
    const [isMenuVisible, setMenuVisible] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);
    const containerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);
    const onItemSelect = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((target) => () => {
        if (typeof onChange === 'function') {
            onChange(target.value);
        }
    }, [onChange]);
    const onKeyDown = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((e) => {
        if (!isMenuVisible && ['ArrowUp', 'Enter', ' '].indexOf(e.key) > -1) {
            e.preventDefault();
            setMenuVisible(true);
        }
        if (e.key === 'Escape') {
            e.preventDefault();
            setMenuVisible(false);
            e.currentTarget.blur();
        }
    }, [isMenuVisible]);
    // TODO: For what use case is this effect in place?
    const onToggle = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(() => {
        if (!disabled) {
            setMenuVisible(!isMenuVisible);
        }
    }, [disabled, isMenuVisible]);
    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {
        const exists = items.find((item) => item.value === value);
        setSearchText((exists === null || exists === void 0 ? void 0 : exists.label) || '');
        if (!isMenuVisible) {
            setSearchActive(false);
        }
    }, [value, items, isMenuVisible]);
    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {
        const filtered = !searchable
            ? items
            : items.filter((item) => !searchActive || item.label.toLowerCase().indexOf(searchText.toLowerCase()) > -1);
        const result = [];
        filtered.forEach((item, index) => {
            if (item.optgroup && (index === 0 || filtered[index - 1].optgroup !== item.optgroup) && item.optgroup.length > 0) {
                result.push(item.optgroup);
            }
            result.push(item);
        });
        setFilteredItems(result);
    }, [items, searchActive, searchable, searchText]);
    const onFilter = (e) => {
        setSearchText(e.target.value);
        setSearchActive(true);
    };
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(SelectWrapper, Object.assign({ open: isMenuVisible }, rest, { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", Object.assign({ ref: containerRef }, { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(_Menu__WEBPACK_IMPORTED_MODULE_4__/* .Menu */ .v, Object.assign({ trigger: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components_Input_Input__WEBPACK_IMPORTED_MODULE_5__/* .Input */ .II, { label: label, tooltip: tooltip, value: searchText, size: size, disabled: disabled, placeholder: placeholder, onChange: searchable ? onFilter : undefined, onKeyDown: onKeyDown, iconRight: _Icon__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z, error: error && (typeof error === 'string' || typeof error === 'boolean'), autoComplete: autoComplete, onClick: onToggle, readOnly: !autoComplete && !searchable, ref: forwardedRef }), visible: isMenuVisible, setVisible: setMenuVisible, matchWidth: true, maxHeight: 200, size: size === 'large' ? 'medium' : size, "data-testid": rest.id }, { children: [filteredItems.map((item) => typeof item === 'string' ? ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_Menu__WEBPACK_IMPORTED_MODULE_4__/* .Menu.Title */ .v.Title, { children: item }, `title-${item}`)) : ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_Menu__WEBPACK_IMPORTED_MODULE_4__/* .Menu.Item */ .v.Item, Object.assign({ badge: item.badge && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_Badge_Badge__WEBPACK_IMPORTED_MODULE_7__/* .Badge */ .C, Object.assign({ size: "small" }, item.badge)), disabled: item.disabled, active: value === item.value, onClick: onItemSelect(item) }, { children: RenderItem ? (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(RenderItem, { item: item }) : item.label }), item.value))), !filteredItems.length && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_Menu__WEBPACK_IMPORTED_MODULE_4__/* .Menu.Title */ .v.Title, { children: noItemsFound || 'No items found' })] })) })), typeof error === 'string' && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components_Input_Input__WEBPACK_IMPORTED_MODULE_5__/* .InputError */ .pd, { children: error }), description && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components_Input_Input__WEBPACK_IMPORTED_MODULE_5__/* .InputDescription */ .d2, Object.assign({ error: error }, { children: description }))] })));
});
Select.defaultProps = {
    size: 'medium',
    searchable: false
};


/***/ }),

/***/ 9146:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "r": () => (/* binding */ Switch)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38);
/* harmony import */ var styled_system__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4912);
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(8335);
/* harmony import */ var _theme__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3694);
/* harmony import */ var _theme_helpers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(3709);
var __rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};





const Label = _theme__WEBPACK_IMPORTED_MODULE_2__/* .styled.label */ .zo.label `
  position: relative;
  display: inline-flex;
  align-items: center;
  cursor: pointer;
  user-select: none;
  color: ${({ theme }) => theme.color('dark0')};
`;
const SwitchStyled = _theme__WEBPACK_IMPORTED_MODULE_2__/* .styled.input */ .zo.input `
  cursor: pointer;
  appearance: none;
  display: inline-block;

  background: ${({ theme }) => theme.color('dark40', 'light50')};
  transition: background ${({ theme }) => `${theme.transition.duration.fast}ms ${theme.transition.function.default}`};

  &:hover {
    box-shadow: inset 0px 0px 0px 1px ${({ theme }) => theme.color('dark30', 'light40')};
  }

  & + div {
    position: absolute;
    z-index: 2;
    pointer-events: none;
    background: ${({ theme }) => theme.color('white')};
    transition: left ${({ theme }) => `${theme.transition.duration.fast}ms ${theme.transition.function.default}`},
      background ${({ theme }) => `${theme.transition.duration.fast}ms ${theme.transition.function.default}`};
  }

  &:checked {
    background: ${({ theme }) => theme.color('purple50')};

    & + div {
      background: ${({ theme }) => theme.color('white')};
    }

    &:hover {
      box-shadow: inset 0px 0px 0px 1px ${({ theme }) => theme.color('purple60', 'purple40')};
    }
  }

  &:disabled {
    cursor: not-allowed;
    background: ${({ theme }) => theme.color('dark50', 'light60')};

    &:hover {
      box-shadow: none;
    }

    & + div {
      background: ${({ theme }) => theme.color('dark30', 'light80')};
    }

    &:checked {
      background: ${({ theme }) => theme.color('purple40', 'purple70')};

      & + div {
        background: ${({ theme }) => theme.color('purple70', 'purple90')};
      }
    }

    ~ span {
      color: ${({ theme }) => theme.color('dark20')};
      white-space: nowrap;
    }
  }

  ${_theme_helpers__WEBPACK_IMPORTED_MODULE_3__/* .styledFocus */ .By}

  ${({ theme }) => (0,styled_system__WEBPACK_IMPORTED_MODULE_1__/* .variant */ .bU)({
    prop: '$size',
    variants: {
        small: {
            height: theme.sizes.$20,
            width: theme.sizes.$40,
            borderRadius: theme.sizes.$12,
            '& + div': {
                top: theme.sizes.$2,
                left: theme.sizes.$2,
                height: theme.sizes.$16,
                width: theme.sizes.$16,
                borderRadius: theme.sizes.$16
            },
            '&:checked + div': {
                left: 22
            },
            '~ span': {
                marginLeft: theme.sizes.$8,
                fontSize: theme.fontSizes.$12
            }
        },
        medium: {
            height: theme.sizes.$20,
            width: theme.sizes.$40,
            borderRadius: theme.sizes.$12,
            '& + div': {
                top: theme.sizes.$2,
                left: theme.sizes.$2,
                height: theme.sizes.$16,
                width: theme.sizes.$16,
                borderRadius: theme.sizes.$16
            },
            '&:checked + div': {
                left: 22
            },
            '~ span': {
                marginLeft: theme.sizes.$8,
                fontSize: theme.fontSizes.$14
            }
        },
        large: {
            height: theme.sizes.$28,
            width: theme.sizes.$56,
            borderRadius: theme.sizes.$20,
            '& + div': {
                top: theme.sizes.$4,
                left: theme.sizes.$4,
                height: theme.sizes.$20,
                width: theme.sizes.$20,
                borderRadius: theme.sizes.$20
            },
            '&:checked + div': {
                left: theme.sizes.$32
            },
            '~ span': {
                marginLeft: theme.sizes.$12,
                fontSize: theme.fontSizes.$16
            }
        }
    }
})}
`;
/**
 * Switch toggles the state of a single setting on or off.
 * The setting it controls and the setting state should be made clear from the components inline `label`.
 *
 * @see
 * {@link https://design-system.solventek.com/component/switch}
 *
 * @example
 * <Switch label="Label" checked={checked} onChange={setChecked}/>
 */
const Switch = (0,_helpers__WEBPACK_IMPORTED_MODULE_4__/* .componentWithRef */ .w)((_a, forwardRef) => {
    var { label, size } = _a, rest = __rest(_a, ["label", "size"]);
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(Label, { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(SwitchStyled, Object.assign({ type: "checkbox", "$size": size, ref: forwardRef }, rest)), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", {}), label && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("span", { children: label })] }));
});
Switch.defaultProps = {
    size: 'medium'
};


/***/ }),

/***/ 4183:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4191);
/* harmony import */ var styled_system__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(4912);
/* harmony import */ var _hooks__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(8062);
/* harmony import */ var _theme__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(3694);
/* harmony import */ var _components_Transition__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(8159);
var __rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};






/**
 * Tooltip component
 */
const StyledTooltip = _theme__WEBPACK_IMPORTED_MODULE_3__/* .styled.div */ .zo.div `
  position: fixed;
  z-index: ${({ theme }) => theme.zIndex.tooltip};
  display: inline-block;
  pointer-events: none;

  line-height: 18px;
  padding: 4px 8px;
  background: ${({ theme }) => theme.color('dark20')};
  border-radius: 2px;
  width: max-content;
  max-width: ${({ maxWidth }) => maxWidth}px;
  word-wrap: break-word;
  white-space: pre-line;

  ${({ theme }) => (0,styled_system__WEBPACK_IMPORTED_MODULE_2__/* .variant */ .bU)({
    variants: {
        default: {
            color: theme.color('dark90')({ theme }),
            fontSize: '12px'
        },
        navigation: {
            background: theme.color('dark90')({ theme }),
            fontWeight: 600
        },
        arrow: {
            background: theme.color('dark90', 'light100')({ theme }),
            border: `1px solid ${theme.color('dark60')({ theme })}`,
            padding: '16px'
        }
    }
})}

  &[data-placement^='left'] > .popover-arrow {
    right: -7px;
    transform: rotate(45deg);
  }
  &[data-placement^='right'] > .popover-arrow {
    left: -7px;
    transform: rotate(-135deg);
  }
  &[data-placement^='top'] > .popover-arrow {
    bottom: -7px;
    transform: rotate(135deg);
  }
  &[data-placement^='bottom'] > .popover-arrow {
    top: -7px;
    transform: rotate(-45deg);
  }
`;
const TooltipWrapper = _theme__WEBPACK_IMPORTED_MODULE_3__/* .styled.div */ .zo.div `
  position: relative;
  display: inline-flex;
`;
const TooltipChildrenWrapper = _theme__WEBPACK_IMPORTED_MODULE_3__/* .styled.div */ .zo.div `
  flex: 1;
  z-index: 2;
`;
const Arrow = _theme__WEBPACK_IMPORTED_MODULE_3__/* .styled.span */ .zo.span `
  position: absolute;
  width: 14px;
  height: 14px;
  background-color: ${({ theme }) => theme.color('dark90', 'light100')};
  border-right: 1px solid ${({ theme }) => theme.color('dark60')};
  border-top: 1px solid ${({ theme }) => theme.color('dark60')};
  border-radius: 2px;
`;
const Tooltip = (_a) => {
    var { children, text, placement, offset } = _a, rest = __rest(_a, ["children", "text", "placement", "offset"]);
    const [hover, setHover] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);
    const wrapperRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);
    const tooltipRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);
    const arrowRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);
    const floatSettings = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => ({
        // Special case `bottomRight` for backwards compatibility
        placement: placement === 'bottomRight' ? 'bottom-end' : placement,
        offset,
        arrow: arrowRef
    }), [placement, offset]);
    (0,_hooks__WEBPACK_IMPORTED_MODULE_4__/* .useFloat */ .$)(wrapperRef, tooltipRef, hover, floatSettings);
    const onMouseEnter = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(() => {
        setHover(true);
    }, []);
    const onMouseLeave = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(() => {
        setHover(false);
    }, []);
    if (!text) {
        // eslint-disable-next-line react/jsx-no-useless-fragment
        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, { children: children });
    }
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(TooltipWrapper, Object.assign({ ref: wrapperRef }, { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components_Transition__WEBPACK_IMPORTED_MODULE_5__/* .Transition.Fade */ .u.Fade, Object.assign({ in: hover, exit: false }, { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(StyledTooltip, Object.assign({ ref: tooltipRef }, rest, { children: [text, rest.variant === 'arrow' && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Arrow, { ref: arrowRef, className: "popover-arrow" })] })) })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(TooltipChildrenWrapper, Object.assign({ onMouseEnter: onMouseEnter, onMouseLeave: onMouseLeave }, { children: children }))] })));
};
Tooltip.defaultProps = {
    placement: 'top',
    offset: 12,
    fadeIn: 100,
    variant: 'default',
    maxWidth: 240
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Tooltip);


/***/ }),

/***/ 8159:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "u": () => (/* binding */ Transition_Transition)
});

// EXTERNAL MODULE: ./node_modules/react/jsx-runtime.js
var jsx_runtime = __webpack_require__(38);
// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(4191);
// EXTERNAL MODULE: ./node_modules/styled-components/dist/styled-components.browser.esm.js + 2 modules
var styled_components_browser_esm = __webpack_require__(2294);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/extends.js
var esm_extends = __webpack_require__(2733);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js
var objectWithoutPropertiesLoose = __webpack_require__(3560);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/inheritsLoose.js + 1 modules
var inheritsLoose = __webpack_require__(3699);
;// CONCATENATED MODULE: ./node_modules/dom-helpers/esm/hasClass.js
/**
 * Checks if a given element has a CSS class.
 * 
 * @param element the element
 * @param className the CSS class name
 */
function hasClass(element, className) {
  if (element.classList) return !!className && element.classList.contains(className);
  return (" " + (element.className.baseVal || element.className) + " ").indexOf(" " + className + " ") !== -1;
}
;// CONCATENATED MODULE: ./node_modules/dom-helpers/esm/addClass.js

/**
 * Adds a CSS class to a given element.
 * 
 * @param element the element
 * @param className the CSS class name
 */

function addClass_addClass(element, className) {
  if (element.classList) element.classList.add(className);else if (!hasClass(element, className)) if (typeof element.className === 'string') element.className = element.className + " " + className;else element.setAttribute('class', (element.className && element.className.baseVal || '') + " " + className);
}
;// CONCATENATED MODULE: ./node_modules/dom-helpers/esm/removeClass.js
function replaceClassName(origClass, classToRemove) {
  return origClass.replace(new RegExp("(^|\\s)" + classToRemove + "(?:\\s|$)", 'g'), '$1').replace(/\s+/g, ' ').replace(/^\s*|\s*$/g, '');
}
/**
 * Removes a CSS class from a given element.
 * 
 * @param element the element
 * @param className the CSS class name
 */


function removeClass_removeClass(element, className) {
  if (element.classList) {
    element.classList.remove(className);
  } else if (typeof element.className === 'string') {
    element.className = replaceClassName(element.className, className);
  } else {
    element.setAttribute('class', replaceClassName(element.className && element.className.baseVal || '', className));
  }
}
// EXTERNAL MODULE: ./node_modules/react-transition-group/esm/Transition.js + 1 modules
var Transition = __webpack_require__(284);
// EXTERNAL MODULE: ./node_modules/react-transition-group/esm/utils/reflow.js
var reflow = __webpack_require__(5879);
;// CONCATENATED MODULE: ./node_modules/react-transition-group/esm/CSSTransition.js











var _addClass = function addClass(node, classes) {
  return node && classes && classes.split(' ').forEach(function (c) {
    return addClass_addClass(node, c);
  });
};

var removeClass = function removeClass(node, classes) {
  return node && classes && classes.split(' ').forEach(function (c) {
    return removeClass_removeClass(node, c);
  });
};
/**
 * A transition component inspired by the excellent
 * [ng-animate](https://docs.angularjs.org/api/ngAnimate) library, you should
 * use it if you're using CSS transitions or animations. It's built upon the
 * [`Transition`](https://reactcommunity.org/react-transition-group/transition)
 * component, so it inherits all of its props.
 *
 * `CSSTransition` applies a pair of class names during the `appear`, `enter`,
 * and `exit` states of the transition. The first class is applied and then a
 * second `*-active` class in order to activate the CSS transition. After the
 * transition, matching `*-done` class names are applied to persist the
 * transition state.
 *
 * ```jsx
 * function App() {
 *   const [inProp, setInProp] = useState(false);
 *   return (
 *     <div>
 *       <CSSTransition in={inProp} timeout={200} classNames="my-node">
 *         <div>
 *           {"I'll receive my-node-* classes"}
 *         </div>
 *       </CSSTransition>
 *       <button type="button" onClick={() => setInProp(true)}>
 *         Click to Enter
 *       </button>
 *     </div>
 *   );
 * }
 * ```
 *
 * When the `in` prop is set to `true`, the child component will first receive
 * the class `example-enter`, then the `example-enter-active` will be added in
 * the next tick. `CSSTransition` [forces a
 * reflow](https://github.com/reactjs/react-transition-group/blob/5007303e729a74be66a21c3e2205e4916821524b/src/CSSTransition.js#L208-L215)
 * between before adding the `example-enter-active`. This is an important trick
 * because it allows us to transition between `example-enter` and
 * `example-enter-active` even though they were added immediately one after
 * another. Most notably, this is what makes it possible for us to animate
 * _appearance_.
 *
 * ```css
 * .my-node-enter {
 *   opacity: 0;
 * }
 * .my-node-enter-active {
 *   opacity: 1;
 *   transition: opacity 200ms;
 * }
 * .my-node-exit {
 *   opacity: 1;
 * }
 * .my-node-exit-active {
 *   opacity: 0;
 *   transition: opacity 200ms;
 * }
 * ```
 *
 * `*-active` classes represent which styles you want to animate **to**, so it's
 * important to add `transition` declaration only to them, otherwise transitions
 * might not behave as intended! This might not be obvious when the transitions
 * are symmetrical, i.e. when `*-enter-active` is the same as `*-exit`, like in
 * the example above (minus `transition`), but it becomes apparent in more
 * complex transitions.
 *
 * **Note**: If you're using the
 * [`appear`](http://reactcommunity.org/react-transition-group/transition#Transition-prop-appear)
 * prop, make sure to define styles for `.appear-*` classes as well.
 */


var CSSTransition = /*#__PURE__*/function (_React$Component) {
  (0,inheritsLoose/* default */.Z)(CSSTransition, _React$Component);

  function CSSTransition() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.appliedClasses = {
      appear: {},
      enter: {},
      exit: {}
    };

    _this.onEnter = function (maybeNode, maybeAppearing) {
      var _this$resolveArgument = _this.resolveArguments(maybeNode, maybeAppearing),
          node = _this$resolveArgument[0],
          appearing = _this$resolveArgument[1];

      _this.removeClasses(node, 'exit');

      _this.addClass(node, appearing ? 'appear' : 'enter', 'base');

      if (_this.props.onEnter) {
        _this.props.onEnter(maybeNode, maybeAppearing);
      }
    };

    _this.onEntering = function (maybeNode, maybeAppearing) {
      var _this$resolveArgument2 = _this.resolveArguments(maybeNode, maybeAppearing),
          node = _this$resolveArgument2[0],
          appearing = _this$resolveArgument2[1];

      var type = appearing ? 'appear' : 'enter';

      _this.addClass(node, type, 'active');

      if (_this.props.onEntering) {
        _this.props.onEntering(maybeNode, maybeAppearing);
      }
    };

    _this.onEntered = function (maybeNode, maybeAppearing) {
      var _this$resolveArgument3 = _this.resolveArguments(maybeNode, maybeAppearing),
          node = _this$resolveArgument3[0],
          appearing = _this$resolveArgument3[1];

      var type = appearing ? 'appear' : 'enter';

      _this.removeClasses(node, type);

      _this.addClass(node, type, 'done');

      if (_this.props.onEntered) {
        _this.props.onEntered(maybeNode, maybeAppearing);
      }
    };

    _this.onExit = function (maybeNode) {
      var _this$resolveArgument4 = _this.resolveArguments(maybeNode),
          node = _this$resolveArgument4[0];

      _this.removeClasses(node, 'appear');

      _this.removeClasses(node, 'enter');

      _this.addClass(node, 'exit', 'base');

      if (_this.props.onExit) {
        _this.props.onExit(maybeNode);
      }
    };

    _this.onExiting = function (maybeNode) {
      var _this$resolveArgument5 = _this.resolveArguments(maybeNode),
          node = _this$resolveArgument5[0];

      _this.addClass(node, 'exit', 'active');

      if (_this.props.onExiting) {
        _this.props.onExiting(maybeNode);
      }
    };

    _this.onExited = function (maybeNode) {
      var _this$resolveArgument6 = _this.resolveArguments(maybeNode),
          node = _this$resolveArgument6[0];

      _this.removeClasses(node, 'exit');

      _this.addClass(node, 'exit', 'done');

      if (_this.props.onExited) {
        _this.props.onExited(maybeNode);
      }
    };

    _this.resolveArguments = function (maybeNode, maybeAppearing) {
      return _this.props.nodeRef ? [_this.props.nodeRef.current, maybeNode] // here `maybeNode` is actually `appearing`
      : [maybeNode, maybeAppearing];
    };

    _this.getClassNames = function (type) {
      var classNames = _this.props.classNames;
      var isStringClassNames = typeof classNames === 'string';
      var prefix = isStringClassNames && classNames ? classNames + "-" : '';
      var baseClassName = isStringClassNames ? "" + prefix + type : classNames[type];
      var activeClassName = isStringClassNames ? baseClassName + "-active" : classNames[type + "Active"];
      var doneClassName = isStringClassNames ? baseClassName + "-done" : classNames[type + "Done"];
      return {
        baseClassName: baseClassName,
        activeClassName: activeClassName,
        doneClassName: doneClassName
      };
    };

    return _this;
  }

  var _proto = CSSTransition.prototype;

  _proto.addClass = function addClass(node, type, phase) {
    var className = this.getClassNames(type)[phase + "ClassName"];

    var _this$getClassNames = this.getClassNames('enter'),
        doneClassName = _this$getClassNames.doneClassName;

    if (type === 'appear' && phase === 'done' && doneClassName) {
      className += " " + doneClassName;
    } // This is to force a repaint,
    // which is necessary in order to transition styles when adding a class name.


    if (phase === 'active') {
      if (node) (0,reflow/* forceReflow */.Q)(node);
    }

    if (className) {
      this.appliedClasses[type][phase] = className;

      _addClass(node, className);
    }
  };

  _proto.removeClasses = function removeClasses(node, type) {
    var _this$appliedClasses$ = this.appliedClasses[type],
        baseClassName = _this$appliedClasses$.base,
        activeClassName = _this$appliedClasses$.active,
        doneClassName = _this$appliedClasses$.done;
    this.appliedClasses[type] = {};

    if (baseClassName) {
      removeClass(node, baseClassName);
    }

    if (activeClassName) {
      removeClass(node, activeClassName);
    }

    if (doneClassName) {
      removeClass(node, doneClassName);
    }
  };

  _proto.render = function render() {
    var _this$props = this.props,
        _ = _this$props.classNames,
        props = (0,objectWithoutPropertiesLoose/* default */.Z)(_this$props, ["classNames"]);

    return /*#__PURE__*/react.createElement(Transition/* default */.ZP, (0,esm_extends/* default */.Z)({}, props, {
      onEnter: this.onEnter,
      onEntered: this.onEntered,
      onEntering: this.onEntering,
      onExit: this.onExit,
      onExiting: this.onExiting,
      onExited: this.onExited
    }));
  };

  return CSSTransition;
}(react.Component);

CSSTransition.defaultProps = {
  classNames: ''
};
CSSTransition.propTypes =  false ? 0 : {};
/* harmony default export */ const esm_CSSTransition = (CSSTransition);
;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Transition/Transition.js
var __rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};




const BaseCSSTransition = (0,react.forwardRef)((_a, forwardedRef) => {
    var { className } = _a, restProps = __rest(_a, ["className"]);
    return ((0,jsx_runtime.jsx)(esm_CSSTransition, Object.assign({ ref: forwardedRef, classNames: className, unmountOnExit: true, mountOnEnter: true }, restProps)));
});
const transitionHelper = ({ $transitionFunction, $transitionProperty, timeout = 0 }) => {
    var _a, _b, _c;
    const isSingleTimeout = typeof timeout === 'number';
    return styled_components_browser_esm.css `
    &-appear-active,
    &-appear-done {
      transition-property: ${$transitionProperty};
      transition-duration: ${isSingleTimeout ? timeout : (_a = timeout.appear) !== null && _a !== void 0 ? _a : 0}ms;
      transition-timing-function: ${$transitionFunction};
    }
    &-enter-active,
    &-enter-done {
      transition-property: ${$transitionProperty};
      transition-duration: ${isSingleTimeout ? timeout : (_b = timeout.enter) !== null && _b !== void 0 ? _b : 0}ms;
      transition-timing-function: ${$transitionFunction};
    }
    &-exit-active,
    &-exit-done {
      transition-property: ${$transitionProperty};
      transition-duration: ${isSingleTimeout ? timeout : (_c = timeout.exit) !== null && _c !== void 0 ? _c : 0}ms;
      transition-timing-function: ${$transitionFunction};
    }
  `;
};
const ScaleTransition = (0,styled_components_browser_esm["default"])(BaseCSSTransition).attrs((_a) => {
    var { theme } = _a, props = __rest(_a, ["theme"]);
    return (Object.assign({ $transitionFunction: theme.transition.function.default, $transitionProperty: 'transform, opacity', timeout: theme.transition.duration.fast }, props));
}) `
  &-enter,
  &-appear {
    transform: scale(0.94);
    opacity: 0.6;
  }

  &-appear-active,
  &-enter-active {
    transform: scale(1);
    opacity: 1;
  }

  &-exit {
    transform: scale(1);
    opacity: 0.6;
  }

  &-exit-active {
    transform: scale(0.94);
    opacity: 0;
  }

  ${transitionHelper}
`;
const FadeTransition = (0,styled_components_browser_esm["default"])(BaseCSSTransition).attrs((_a) => {
    var { theme } = _a, props = __rest(_a, ["theme"]);
    return (Object.assign({ $transitionFunction: theme.transition.function.linear, $transitionProperty: 'opacity', timeout: theme.transition.duration.instant }, props));
}) `
  &-enter,
  &-appear {
    opacity: 0;
  }

  &-appear-active,
  &-enter-active,
  &-exit {
    opacity: 1;
  }

  &-exit-active {
    opacity: 0;
  }

  ${transitionHelper}
`;
const SlideTransition = (0,styled_components_browser_esm["default"])(BaseCSSTransition).attrs((_a) => {
    var { theme } = _a, props = __rest(_a, ["theme"]);
    return (Object.assign({ $transitionFunction: theme.transition.function.default, $transitionProperty: 'transform, opacity', timeout: theme.transition.duration.normal, $y: '5px', $x: '0' }, props));
}) `
  &-enter,
  &-appear {
    transform: translate(${({ $x }) => $x}, ${({ $y }) => $y});
    opacity: 0.4;
  }

  &-appear-active,
  &-enter-active,
  &-exit {
    transform: translate(0, 0);
    opacity: 1;
  }

  &-exit-active {
    transform: translate(${({ $x }) => $x}, ${({ $y }) => $y});
    opacity: 0;
  }

  ${transitionHelper}
`;
const CollapseTransitionBase = (0,styled_components_browser_esm["default"])(BaseCSSTransition).attrs((_a) => {
    var { theme } = _a, props = __rest(_a, ["theme"]);
    return (Object.assign({ $transitionFunction: theme.transition.function.default, $transitionProperty: 'height, opacity', timeout: theme.transition.duration.fast }, props));
}) `
  &-enter,
  &-appear {
    height: 0;
    opacity: 0.4;
  }

  &-appear-active,
  &-enter-active,
  &-exit {
    overflow: hidden;
    height: ${({ $height }) => $height}px;
    opacity: 1;
  }

  &-exit-active {
    height: 0;
    opacity: 0;
  }

  ${transitionHelper}
`;
const CollapsibleWrapper = (0,styled_components_browser_esm["default"])('div') `
  display: inline-block;
  width: 100%;
`;
const CollapseTransition = (_a) => {
    var { children } = _a, props = __rest(_a, ["children"]);
    const transitionNodeRef = (0,react.useRef)(null);
    const childRef = (0,react.useRef)(null);
    const [height, setHeight] = (0,react.useState)(0);
    const onTransition = (0,react.useCallback)(() => { var _a, _b; return setHeight((_b = (_a = childRef.current) === null || _a === void 0 ? void 0 : _a.offsetHeight) !== null && _b !== void 0 ? _b : 0); }, []);
    (0,react.useEffect)(() => {
        var _a, _b;
        setHeight((_b = (_a = childRef.current) === null || _a === void 0 ? void 0 : _a.offsetHeight) !== null && _b !== void 0 ? _b : 0);
    }, []);
    return ((0,jsx_runtime.jsx)("div", Object.assign({ ref: transitionNodeRef }, { children: (0,jsx_runtime.jsx)(CollapseTransitionBase, Object.assign({ onEnter: onTransition, onExit: onTransition, nodeRef: transitionNodeRef, "$height": height }, props, { children: (0,jsx_runtime.jsx)(CollapsibleWrapper, Object.assign({ ref: childRef }, { children: children })) })) })));
};
/**
 * Transition is used to gracefully manage shown/hidden state for components by adding css transitions and delaying unmount until transitioning out has finished.
 *
 * @see
 * {@link https://design-system.solventek.com/component/transition}
 *
 * @example
 * <Transition.Fade in={isLoaded} onExited={() => cleanup()}>
 *   <div>Content</div>
 * </Transition.Fade>
 */
const Transition_Transition = BaseCSSTransition;
Transition_Transition.Fade = FadeTransition;
Transition_Transition.Slide = SlideTransition;
Transition_Transition.Scale = ScaleTransition;
Transition_Transition.Collapse = CollapseTransition;


/***/ }),

/***/ 2888:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (/* binding */ Typography)
/* harmony export */ });
/* harmony import */ var styled_system__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4912);
/* harmony import */ var _theme__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3694);
/* harmony import */ var _theme__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(3709);
/* harmony import */ var _theme_helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(9978);



/**
 * The Typography component makes it easy to apply custom set of font weights, sizes and line heights.
 * Use the `as` prop to define the semantically relevant HTML tag type.
 *
 * @see
 * {@link https://design-system.solventek.com/component/typography}
 *
 * @example
 * <Typography fontSize="$36" fontFamily="title" as="h1">
 *   My Title
 * </Typography>
 */
const Typography = (0,_theme__WEBPACK_IMPORTED_MODULE_1__/* .styled */ .zo)('p').withConfig({ shouldForwardProp: _theme_helpers__WEBPACK_IMPORTED_MODULE_2__/* .shouldForwardProp */ .x }) `
  ${(0,styled_system__WEBPACK_IMPORTED_MODULE_0__/* .compose */ .qC)(styled_system__WEBPACK_IMPORTED_MODULE_0__/* .space */ .Dh, styled_system__WEBPACK_IMPORTED_MODULE_0__/* .textAlign */ .yd, styled_system__WEBPACK_IMPORTED_MODULE_0__/* .fontSize */ .JB, styled_system__WEBPACK_IMPORTED_MODULE_0__/* .fontWeight */ .Ue, styled_system__WEBPACK_IMPORTED_MODULE_0__/* .fontFamily */ .I8, styled_system__WEBPACK_IMPORTED_MODULE_0__/* .lineHeight */ .Nv)}
  ${_theme__WEBPACK_IMPORTED_MODULE_3__/* .parseColorProps */ .sL}
`;
Typography.displayName = 'Typography';


/***/ }),

/***/ 1867:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "O2": () => (/* binding */ spin),
/* harmony export */   "uk": () => (/* binding */ LinearProgress),
/* harmony export */   "zD": () => (/* binding */ load)
/* harmony export */ });
/* harmony import */ var styled_components__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2294);

const load = styled_components__WEBPACK_IMPORTED_MODULE_0__.keyframes `
  0% {
    left: -80%;
    right: 120%;
  }
  40% {
    left: -20%;
    right: 20%;
  }
  60% {
    left: 20%;
    right: -20%;
  }
  100% {
    left: 120%;
    right: -80%;
  }
`;
const spin = styled_components__WEBPACK_IMPORTED_MODULE_0__.keyframes `
  0% {
    transform: rotate(0);
  }
  100% {
    transform: rotate(360deg);
  }
`;
const LinearProgress = styled_components__WEBPACK_IMPORTED_MODULE_0__["default"].div `
  position: relative;
  overflow: hidden;
  height: 1.25px;

  &:after {
    display: block;
    content: '';
    position: absolute;
    background-color: ${({ theme }) => theme.color('dark50', 'light70')};
    left: 0;
    bottom: 0;
    top: 0;
    transition: transform 0.2s linear;
    transform-origin: left;
    animation: ${load} 2s cubic-bezier(0.65, 0.815, 0.735, 0.395) infinite;
  }
`;


/***/ }),

/***/ 8335:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "w": () => (/* binding */ componentWithRef)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4191);

const componentWithRef = (target, childComponents) => {
    // eslint-disable-next-line prefer-object-spread
    return Object.assign({}, (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(target), childComponents);
};


/***/ }),

/***/ 3397:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ZK": () => (/* binding */ warn),
/* harmony export */   "eu": () => (/* binding */ initials),
/* harmony export */   "hQ": () => (/* binding */ uid),
/* harmony export */   "jU": () => (/* binding */ isBrowser)
/* harmony export */ });
/* unused harmony exports slug, unSlug, pickChild */
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4191);

const isBrowser = typeof window === 'object';
const slug = (input) => {
    if (!input) {
        return '';
    }
    let str = input.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
    const parts = str.split('/');
    str = parts[parts.length - 1];
    str = str
        .replace('.md', '')
        .replace('.tsx', '')
        .replace(/[^a-z0-9 -]/g, '')
        .replace(/\s+/g, '-')
        .replace(/-+/g, '-');
    return str;
};
const unSlug = (input) => {
    if (!input) {
        return '';
    }
    return input.replace(/-([a-z])/g, (g) => {
        return g[1].toUpperCase();
    });
};
/**
 * Display a warning message in the console only in development env
 * @param msg - Message to show
 */
const warn = (msg) => {
    if (false) {}
};
/**
 * Pick a child element based on the child type
 */
const pickChild = (children, targetChild) => {
    const nodes = Children.map(children, (item) => {
        return isValidElement(item) && item.type === targetChild ? item : null;
    });
    return Children.count(nodes) > 0 ? nodes : undefined;
};
/**
 * Generate random 11 character long string
 */
const uid = () => Math.random().toString(36).substring(2);
/**
 * Return formatted first letter of first and last word of the text splitted by spaces
 */
const initials = (text) => {
    const parts = text.trim().split(' ');
    const start = Array.from(parts[0]).slice(0, 1).join().toUpperCase();
    if (parts.length === 1) {
        return start;
    }
    const end = Array.from(parts[parts.length - 1])
        .slice(0, 1)
        .join()
        .toUpperCase();
    return `${start}${end}`;
};


/***/ }),

/***/ 926:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "b": () => (/* binding */ useAutoWidth)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4191);

/**
 * Matches an input element's width with its value's visual width. Placeholder value is used as a fallback if value is empty.
 *
 * @example
 * useAutoWidth(ref, [inputValue], enabledState);
 *
 * @param ref  Target input element
 * @param dependencies  Dependencies on which the width should be recalculated (usually the input value)
 * @param enabled  Flag for the auto width enabled state
 */
const useAutoWidth = (ref, dependencies, enabled) => {
    (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => {
        if (!ref.current) {
            return;
        }
        const target = ref.current;
        if (!enabled) {
            if (target.style.width && target.style.width !== '100%') {
                target.style.width = `100%`;
            }
            return;
        }
        const dummy = document.createElement('span');
        const refStyle = window.getComputedStyle(target);
        dummy.setAttribute('style', 'position: absolute, visibility: hidden; white-space: pre;');
        dummy.style.fontFamily = refStyle.getPropertyValue('font-family');
        dummy.style.fontSize = refStyle.getPropertyValue('font-size');
        dummy.style.letterSpacing = refStyle.getPropertyValue('letter-spacing');
        dummy.style.padding = refStyle.getPropertyValue('padding');
        dummy.style.border = refStyle.getPropertyValue('border');
        dummy.innerHTML = target.value || target.placeholder;
        document.body.appendChild(dummy);
        const box = dummy.getBoundingClientRect();
        document.body.removeChild(dummy);
        target.style.width = `${Math.ceil(box.width)}px`;
    }, [enabled, ...dependencies]);
};


/***/ }),

/***/ 8062:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "$": () => (/* binding */ useFloat)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4191);
/* harmony import */ var _floating_ui_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7680);
/* harmony import */ var _floating_ui_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(7555);
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};


/**
 * A helper hook to calculate position of fixed position floating elements.
 *
 * Note: targetRef element needs to have `position: fixed` css style set.
 *
 * @example
 * useFloat(targetRef, triggerRef, visibilityState, floatOptions);
 */
const useFloat = (
/**
 * Reference element
 */
referenceRef, 
/**
 * Target element
 */
targetRef, 
/**
 * Trigger flag to recalculate target element position
 */
shouldUpdate, 
/**
 * Additional optional settings
 */
settings) => {
    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
        const setPosition = () => __awaiter(void 0, void 0, void 0, function* () {
            var _a, _b, _c;
            if (!targetRef.current || !referenceRef.current) {
                return;
            }
            const middleware = [];
            if (settings === null || settings === void 0 ? void 0 : settings.offset) {
                middleware.push((0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_1__/* .offset */ .cv)(settings.offset));
            }
            if (settings === null || settings === void 0 ? void 0 : settings.flip) {
                middleware.push((0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_1__/* .flip */ .RR)());
            }
            if ((settings === null || settings === void 0 ? void 0 : settings.maxHeight) || (settings === null || settings === void 0 ? void 0 : settings.maxWidth)) {
                middleware.push((0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_1__/* .size */ .dp)({
                    apply({ availableHeight, availableWidth, elements }) {
                        if (settings === null || settings === void 0 ? void 0 : settings.maxHeight) {
                            Object.assign(elements.floating.style, {
                                height: `${settings === null || settings === void 0 ? void 0 : settings.maxHeight}px`,
                                maxHeight: `${Math.floor(availableHeight) - 24}px`
                            });
                        }
                        if (settings.maxWidth) {
                            Object.assign(elements.floating.style, {
                                width: `${settings === null || settings === void 0 ? void 0 : settings.maxWidth}px`,
                                maxWidth: `${Math.floor(availableWidth) - 24}px`
                            });
                        }
                    }
                }));
            }
            if ((_a = settings === null || settings === void 0 ? void 0 : settings.arrow) === null || _a === void 0 ? void 0 : _a.current) {
                middleware.push((0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_1__/* .arrow */ .x7)({
                    element: (_b = settings.arrow) === null || _b === void 0 ? void 0 : _b.current
                }));
            }
            if (settings === null || settings === void 0 ? void 0 : settings.matchWidth) {
                middleware.push((0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_1__/* .size */ .dp)({
                    apply({ elements: { reference } }) {
                        var _a;
                        if ((_a = targetRef.current) === null || _a === void 0 ? void 0 : _a.style) {
                            Object.assign(targetRef.current.style, {
                                width: `${reference.getBoundingClientRect().width}px`
                            });
                        }
                    }
                }));
            }
            const position = yield (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_2__/* .computePosition */ .oo)(referenceRef.current, targetRef.current, {
                strategy: 'fixed',
                placement: (settings === null || settings === void 0 ? void 0 : settings.placement) || 'bottom',
                middleware
            });
            targetRef.current.setAttribute('data-placement', (position === null || position === void 0 ? void 0 : position.placement) || 'bottom');
            Object.assign(targetRef.current.style, {
                left: `${position.x}px`,
                top: `${position.y}px`
            });
            if (((_c = settings === null || settings === void 0 ? void 0 : settings.arrow) === null || _c === void 0 ? void 0 : _c.current) && position.middlewareData.arrow) {
                const arrowPos = position.middlewareData.arrow;
                Object.assign(settings.arrow.current.style, {
                    left: arrowPos.x != null ? `${arrowPos.x}px` : null,
                    top: arrowPos.y != null ? `${arrowPos.y}px` : null
                });
            }
        });
        let cleanup = null;
        if (shouldUpdate && referenceRef.current && targetRef.current) {
            cleanup = (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_2__/* .autoUpdate */ .Me)(referenceRef.current, targetRef.current, setPosition);
        }
        return () => {
            cleanup === null || cleanup === void 0 ? void 0 : cleanup();
        };
    }, [settings, shouldUpdate]);
};
/* unused harmony default export */ var __WEBPACK_DEFAULT_EXPORT__ = ((/* unused pure expression or super */ null && (useFloat)));


/***/ }),

/***/ 5009:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "c": () => (/* binding */ useForkRef)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4191);

function setRef(ref, value) {
    if (typeof ref === 'function') {
        ref(value);
    }
    else if (ref) {
        // eslint-disable-next-line no-param-reassign
        ref.current = value;
    }
}
// Source: https://github.dev/mui-org/material-ui/blob/master/packages/mui-utils/src/useForkRef.ts
/**
 * A hook that can combine two refs(mutable or callbackRefs) into a single callbackRef.
 *
 * @example
 * const combinedRef = useForkRef(refA, refB);
 *
 * @param refA React.Ref
 * @param refB React.Ref
 * @returns callbackRef
 */
const useForkRef = (refA, refB) => {
    /**
     * This will create a new function if the ref props change and are defined.
     * This means react will call the old forkRef with `null` and the new forkRef
     * with the ref. Cleanup naturally emerges from this behavior.
     */
    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {
        if (refA == null && refB == null) {
            return null;
        }
        return (refValue) => {
            setRef(refA, refValue);
            setRef(refB, refValue);
        };
    }, [refA, refB]);
};


/***/ }),

/***/ 6501:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4191);

/**
 * Disables document body overflow to prevent scrolling when a fixed focus is requried on a surface component (e.g. a Dialog).
 *
 * @example
 * useLockScroll(lockState)
 *
 * @param lock - Current lock state
 */
const useLockScroll = (lock) => {
    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
        const existingOverflow = document.body.style.overflow;
        if (lock && existingOverflow !== 'hidden') {
            document.body.style.overflow = 'hidden';
        }
        return () => {
            if (lock && existingOverflow !== 'hidden') {
                document.body.style.overflow = existingOverflow;
            }
        };
    }, [lock]);
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (useLockScroll);


/***/ }),

/***/ 5593:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "v": () => (/* binding */ usePortal)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4191);
/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7668);


/**
 * A helper hook to create a React Portal at the document's body root.
 *
 * @example
 * const Portal = usePortal();
 */
const usePortal = () => {
    const element = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(document.createElement('div'));
    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
        document.body.appendChild(element.current);
        return () => {
            document.body.removeChild(element.current);
        };
    }, []);
    const Portal = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(({ children }) => {
        return (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.createPortal)(children, element.current);
    }, []);
    return Portal;
};


/***/ }),

/***/ 5050:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4191);
/* harmony import */ var _theme__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3694);


/**
 * Provides the current active Theme object.
 *
 * @example
 * const theme = useTheme();
 */
const useTheme = () => {
    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(_theme__WEBPACK_IMPORTED_MODULE_1__/* .ThemeContext */ .Ni);
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (useTheme);


/***/ }),

/***/ 9261:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "S": () => (/* binding */ useViewport),
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4191);
/* harmony import */ var _helpers_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3397);



const ViewportContext = (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)({ width: 0, height: 0 });
const ViewportProvider = ({ children }) => {
    const [width, setWidth] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(_helpers_utils__WEBPACK_IMPORTED_MODULE_2__/* .isBrowser */ .jU ? window.innerWidth : 0);
    const [height, setHeight] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(_helpers_utils__WEBPACK_IMPORTED_MODULE_2__/* .isBrowser */ .jU ? window.innerHeight : 0);
    const handleWindowResize = () => {
        setWidth(window.innerWidth);
        setHeight(window.innerHeight);
    };
    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {
        if (_helpers_utils__WEBPACK_IMPORTED_MODULE_2__/* .isBrowser */ .jU) {
            window.addEventListener('resize', handleWindowResize);
        }
        return () => {
            if (_helpers_utils__WEBPACK_IMPORTED_MODULE_2__/* .isBrowser */ .jU) {
                window.removeEventListener('resize', handleWindowResize);
            }
        };
    }, []);
    const contextValue = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => ({ height, width }), [height, width]);
    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ViewportContext.Provider, Object.assign({ value: contextValue }, { children: children }));
};
/**
 * Returns the current browser window width and height in pixels.
 *
 * @example
 * const { width, height } = useViewport();
 *
 * @returns - Window's size width and height in pixels
 */
const useViewport = () => {
    const { width, height } = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(ViewportContext);
    return { width, height };
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ViewportProvider);


/***/ }),

/***/ 8203:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "AddTextField": () => (/* reexport */ AddTextField/* default */.Z),
  "AppBar": () => (/* reexport */ AppBar_AppBar),
  "AppNav": () => (/* reexport */ AppBar_AppNav),
  "AppSideNav": () => (/* reexport */ AppSideNav_AppSideNav),
  "Autocomplete": () => (/* reexport */ Autocomplete),
  "Avatar": () => (/* reexport */ Avatar_Avatar),
  "Badge": () => (/* reexport */ Badge/* Badge */.C),
  "Box": () => (/* reexport */ Box/* default */.Z),
  "Breadcrumbs": () => (/* reexport */ Breadcrumbs_Breadcrumbs),
  "Button": () => (/* reexport */ Button/* Button */.z),
  "ButtonBase": () => (/* reexport */ Button/* ButtonBase */.X),
  "Cell": () => (/* reexport */ Cell),
  "Chart": () => (/* reexport */ components_Chart_Chart),
  "Checkbox": () => (/* reexport */ Checkbox/* Checkbox */.X),
  "CheckboxStyled": () => (/* reexport */ Checkbox/* CheckboxStyled */.U),
  "Chip": () => (/* reexport */ Chip_Chip),
  "ChipGroup": () => (/* reexport */ Chip_ChipGroup),
  "Code": () => (/* reexport */ Code/* Code */.EK),
  "Content": () => (/* reexport */ Content),
  "DateRangePicker": () => (/* reexport */ DateRangePicker_DateRangePicker),
  "Dialog": () => (/* reexport */ Dialog/* Dialog */.V),
  "Divider": () => (/* reexport */ Divider/* default */.Z),
  "Drawer": () => (/* reexport */ Drawer_Drawer),
  "Dropdown": () => (/* reexport */ Dropdown/* Dropdown */.L),
  "EditorView": () => (/* reexport */ Code/* EditorView */.tk),
  "Fieldset": () => (/* reexport */ Fieldset/* default */.Z),
  "FilterMenu": () => (/* reexport */ FilterMenu),
  "Form": () => (/* reexport */ Form/* default */.Z),
  "Grid": () => (/* reexport */ Grid_Grid),
  "Header": () => (/* reexport */ Header_Header),
  "Input": () => (/* reexport */ Input/* Input */.II),
  "InputDescription": () => (/* reexport */ Input/* InputDescription */.d2),
  "InputError": () => (/* reexport */ Input/* InputError */.pd),
  "Link": () => (/* reexport */ Link),
  "List": () => (/* reexport */ List/* default */.C),
  "ListContent": () => (/* reexport */ ListContent/* default */.Z),
  "ListHeading": () => (/* reexport */ List_ListHeading),
  "ListItem": () => (/* reexport */ ListItem/* default */.Z),
  "ListSkeleton": () => (/* reexport */ skeletons_ListSkeleton),
  "Menu": () => (/* reexport */ Menu_Menu/* Menu */.v),
  "Panel": () => (/* reexport */ Panel/* default */.Z),
  "Popover": () => (/* reexport */ Popover),
  "Progress": () => (/* reexport */ Progress/* default */.Z),
  "Radio": () => (/* reexport */ Radio/* Radio */.Y),
  "RadioStyled": () => (/* reexport */ Radio/* RadioStyled */.w),
  "Row": () => (/* reexport */ Row),
  "Scroll": () => (/* reexport */ Scroll/* default */.Z),
  "Select": () => (/* reexport */ Select/* Select */.P),
  "SideNavItem": () => (/* reexport */ SideNavItem),
  "SideNavigation": () => (/* reexport */ SideNavigation),
  "Sidebar": () => (/* reexport */ Sidebar),
  "Skeleton": () => (/* reexport */ components_Skeleton),
  "SkeletonLoader": () => (/* reexport */ Skeleton_SkeletonLoader),
  "Slider": () => (/* reexport */ Slider),
  "Snackbar": () => (/* reexport */ Snackbar_Snackbar),
  "Stat": () => (/* reexport */ Stat_Stat),
  "Switch": () => (/* reexport */ Switch/* Switch */.r),
  "SwitchTransition": () => (/* reexport */ esm_SwitchTransition),
  "Table": () => (/* reexport */ Table_Table),
  "TableSkeleton": () => (/* reexport */ skeletons_TableSkeleton),
  "Tabs": () => (/* reexport */ Tabs),
  "ThemeProvider": () => (/* reexport */ dist_theme/* ThemeProvider */.f6),
  "Timeline": () => (/* reexport */ Timeline_Timeline),
  "Tooltip": () => (/* reexport */ components_Tooltip_Tooltip/* default */.Z),
  "Transition": () => (/* reexport */ Transition/* Transition */.u),
  "TransitionGroup": () => (/* reexport */ esm_TransitionGroup),
  "Typography": () => (/* reexport */ Typography/* Typography */.Z),
  "ViewportProvider": () => (/* reexport */ useViewport/* default */.Z),
  "createShouldForwardProp": () => (/* reexport */ shouldForwardProp/* createShouldForwardProp */.M),
  "css": () => (/* reexport */ dist_theme/* css */.iv),
  "keyframes": () => (/* reexport */ dist_theme/* keyframes */.F4),
  "robotFramework": () => (/* reexport */ Code/* robotFramework */.qQ),
  "shouldForwardProp": () => (/* reexport */ shouldForwardProp/* shouldForwardProp */.x),
  "styled": () => (/* reexport */ dist_theme/* styled */.zo),
  "themeTokens": () => (/* reexport */ tokens),
  "useAutoWidth": () => (/* reexport */ useAutoWidth/* useAutoWidth */.b),
  "useComponentVisible": () => (/* reexport */ hooks_useComponentVisible),
  "useDropdown": () => (/* reexport */ Dropdown/* useDropdown */.x),
  "useFloat": () => (/* reexport */ useFloat/* useFloat */.$),
  "useForkRef": () => (/* reexport */ useForkRef/* useForkRef */.c),
  "useLockScroll": () => (/* reexport */ useLockScroll/* default */.Z),
  "usePagination": () => (/* reexport */ usePagination),
  "usePortal": () => (/* reexport */ usePortal/* usePortal */.v),
  "useSize": () => (/* reexport */ hooks_useSize),
  "useSnackbar": () => (/* reexport */ useSnackbar),
  "useSystemTheme": () => (/* reexport */ hooks_useSystemTheme),
  "useTheme": () => (/* reexport */ useTheme/* default */.Z),
  "useViewport": () => (/* reexport */ useViewport/* useViewport */.S),
  "withSnackbar": () => (/* reexport */ Snackbar_withSnackbar)
});

// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/theme/index.js + 2 modules
var dist_theme = __webpack_require__(3694);
// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/theme/tokens.json
var tokens = __webpack_require__(4083);
// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/theme/shouldForwardProp.js
var shouldForwardProp = __webpack_require__(9978);
// EXTERNAL MODULE: ./node_modules/react/jsx-runtime.js
var jsx_runtime = __webpack_require__(38);
// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(4191);
// EXTERNAL MODULE: ./node_modules/styled-system/dist/index.esm.js + 13 modules
var index_esm = __webpack_require__(4912);
// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/theme/helpers.js
var helpers = __webpack_require__(3709);
;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Avatar/Avatar.js
var __rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};




const AvatarStyled = (0,dist_theme/* styled */.zo)('span').withConfig({ shouldForwardProp: shouldForwardProp/* shouldForwardProp */.x })(helpers/* parseColorProps */.sL, (0,index_esm/* variant */.bU)({
    prop: 'shape',
    variants: {
        circle: {
            borderRadius: '50%'
        },
        rounded: {
            borderRadius: '20%'
        },
        square: {
            borderRadius: 0
        }
    }
}), (0,index_esm/* variant */.bU)({
    prop: 'size',
    variants: {
        tiny: {
            width: 16,
            height: 16,
            fontSize: 6
        },
        small: {
            width: 24,
            height: 24,
            fontSize: 8
        },
        medium: {
            width: 32,
            height: 32,
            fontSize: 12
        },
        large: {
            width: 36,
            height: 36,
            fontSize: 14
        },
        big: {
            width: 46,
            height: 46,
            fontSize: 16
        }
    }
}), index_esm/* width */.bf, index_esm/* height */.Cb, `display: inline-flex;
  align-items: center;
  justify-content: center;
  user-select: none;
  font-weight: 500;
  > span {
    display: block;
    width: 100%;
    height: 70%;
    line-height: 1em;
    svg {
      width: 100%;
      height: 100%;
    }
  };
  `);
/**
 * Avatar component
 */
const Avatar = (_a) => {
    var { children, src, alt, size, shape } = _a, rest = __rest(_a, ["children", "src", "alt", "size", "shape"]);
    return ((0,jsx_runtime.jsx)(AvatarStyled, Object.assign({ src: src, alt: alt, shape: shape, size: size, as: src ? 'img' : 'span' }, rest, { children: children })));
};
Avatar.defaultProps = {
    shape: 'circle',
    size: 'big',
    backgroundColor: 'dark60'
};
/* harmony default export */ const Avatar_Avatar = (Avatar);

// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/components/Button/Button.js + 1 modules
var Button = __webpack_require__(8100);
// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/components/Box/Box.js
var Box = __webpack_require__(6028);
// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconRobocorp.js
var IconRobocorp = __webpack_require__(5950);
// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconX.js
var IconX = __webpack_require__(845);
// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconMenu.js
var IconMenu = __webpack_require__(4557);
;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/hooks/useComponentVisible.js

/**
 * Handles the visibility of popout type components (e.g. Menu, Popover) that require to be hidden on click outside or keyboard events.
 *
 * @example
 * const [triggerRef, isVisible, setIsVisible] = useComponentVisible<HTMLDivElement>(initialVisibility);
 *
 * @param {boolean} initialIsVisible - Initial visibility of the component
 */
const useComponentVisible = (initialIsVisible, options = {}) => {
    const [isComponentVisible, setIsComponentVisible] = (0,react.useState)(initialIsVisible);
    const triggerRef = (0,react.useRef)(null);
    const containerRef = (0,react.useRef)(null);
    (0,react.useEffect)(() => {
        const handleHideDropdown = (event) => {
            var _a;
            if (event.key === 'Escape') {
                setIsComponentVisible(false);
                (_a = options.onClose) === null || _a === void 0 ? void 0 : _a.call(options);
            }
        };
        const handleClickOutside = (event) => {
            var _a, _b, _c;
            if (!((_a = triggerRef.current) === null || _a === void 0 ? void 0 : _a.contains(event.target)) && !((_b = containerRef.current) === null || _b === void 0 ? void 0 : _b.contains(event.target))) {
                setIsComponentVisible(false);
                (_c = options.onClose) === null || _c === void 0 ? void 0 : _c.call(options);
            }
        };
        if (isComponentVisible) {
            document.addEventListener('keydown', handleHideDropdown, true);
            document.addEventListener('click', handleClickOutside, true);
        }
        return () => {
            document.removeEventListener('keydown', handleHideDropdown, true);
            document.removeEventListener('click', handleClickOutside, true);
        };
    }, [isComponentVisible]);
    return [triggerRef, containerRef, isComponentVisible, setIsComponentVisible];
};
/* harmony default export */ const hooks_useComponentVisible = (useComponentVisible);

// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/hooks/usePortal.js
var usePortal = __webpack_require__(5593);
// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/hooks/useFloat.js
var useFloat = __webpack_require__(8062);
// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/helpers/component.js
var component = __webpack_require__(8335);
// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/components/Transition/Transition.js + 4 modules
var Transition = __webpack_require__(8159);
;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Popover/Popover.js
var Popover_rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};







const Container = dist_theme/* styled.div */.zo.div `
  position: relative;
  display: inline-block;
`;
const Trigger = dist_theme/* styled.span */.zo.span `
  display: flex;
`;
const Popper = (0,dist_theme/* styled */.zo)(Box/* default */.Z) `
  position: fixed;
  z-index: ${({ theme }) => theme.zIndex.tooltip};
  width: ${({ matchWidth, width }) => {
    if (matchWidth) {
        return '100%';
    }
    if (typeof width === 'number') {
        return `${width}px`;
    }
    return width;
}};
  padding: ${({ theme }) => theme.sizes.$16};

  > div {
    display: block;
    border: 1px solid ${({ theme }) => theme.color('dark60')};
    overflow: auto;
  }

  &[data-placement^='left'] {
    padding: ${({ matchWidth }) => (matchWidth ? 0 : 14)}px 14px;
    > .popover-arrow {
      right: 7px;
      border-right: 1px solid ${({ theme }) => theme.color('dark60')};
      border-top: 1px solid ${({ theme }) => theme.color('dark60')};
    }
  }
  &[data-placement^='right'] {
    padding: ${({ matchWidth }) => (matchWidth ? 0 : 14)}px 14px;
    > .popover-arrow {
      left: 7px;
      border-left: 1px solid ${({ theme }) => theme.color('dark60')};
      border-bottom: 1px solid ${({ theme }) => theme.color('dark60')};
    }
  }
  &[data-placement^='top'] {
    padding: 14px ${({ matchWidth }) => (matchWidth ? 0 : 14)}px;
    > .popover-arrow {
      bottom: 7px;
      border-bottom: 1px solid ${({ theme }) => theme.color('dark60')};
      border-right: 1px solid ${({ theme }) => theme.color('dark60')};
    }
  }
  &[data-placement^='bottom'] {
    padding: 14px ${({ matchWidth }) => (matchWidth ? 0 : 14)}px;
    > .popover-arrow {
      top: 7px;
      border-left: 1px solid ${({ theme }) => theme.color('dark60')};
      border-top: 1px solid ${({ theme }) => theme.color('dark60')};
    }
  }
`;
const Arrow = dist_theme/* styled.span */.zo.span `
  position: absolute;
  width: 14px;
  height: 14px;
  transform: rotate(45deg);

  background-color: ${({ theme }) => theme.color('dark90', 'light100')};
  border-radius: 2px;
`;
/**
 *  Popover can be used to display some content on top of another
 *
 * @see
 * {@link https://design-system.solventek.com/component/popover}
 *
 * @example
 * <Popover trigger={({ toggle }) => <Button onClick={toggle}>Show Popover</Button>}>Popover content</Popover>
 */
const Popover = (0,component/* componentWithRef */.w)((_a, forwardRef) => {
    var { children, width, trigger, hover, initialIsVisible, visible, matchWidth, maxHeight, maxWidth, placement, triggerRef } = _a, rest = Popover_rest(_a, ["children", "width", "trigger", "hover", "initialIsVisible", "visible", "matchWidth", "maxHeight", "maxWidth", "placement", "triggerRef"]);
    const [localTriggerRef, popperRef, isComponentVisible, setIsComponentVisible] = hooks_useComponentVisible(!!initialIsVisible);
    const [isHover, setIsHover] = (0,react.useState)(false);
    const arrowRef = (0,react.useRef)(null);
    const Portal = (0,usePortal/* usePortal */.v)();
    const floatSettings = (0,react.useMemo)(() => ({
        placement,
        arrow: arrowRef,
        matchWidth,
        flip: true,
        maxHeight,
        maxWidth
    }), [matchWidth, maxHeight, maxWidth, placement]);
    const open = typeof visible === 'boolean' ? visible : isComponentVisible || isHover;
    (0,useFloat/* useFloat */.$)(triggerRef || localTriggerRef, popperRef, open, floatSettings);
    const handleOpen = (0,react.useCallback)(() => {
        setIsComponentVisible(true);
        setIsHover(true);
    }, []);
    const handleClose = (0,react.useCallback)(() => {
        setIsComponentVisible(false);
        setIsHover(false);
    }, []);
    const handleMouseEnter = (0,react.useCallback)(() => {
        if (hover) {
            setIsHover(true);
        }
    }, [hover]);
    const handleMouseExit = (0,react.useCallback)(() => {
        if (hover) {
            setIsHover(false);
        }
    }, [hover]);
    const handleToggle = (0,react.useCallback)(() => {
        if (isHover) {
            setIsComponentVisible(false);
            setIsHover(false);
        }
        else {
            setIsComponentVisible(!isComponentVisible);
        }
    }, [isComponentVisible, isHover]);
    return ((0,jsx_runtime.jsxs)(Container, Object.assign({ onMouseEnter: handleMouseEnter, onMouseLeave: handleMouseExit }, { children: [trigger && ((0,jsx_runtime.jsx)(Trigger, Object.assign({ ref: localTriggerRef }, { children: trigger({ openPopover: handleOpen, closePopover: handleClose, toggle: handleToggle }) }))), (0,jsx_runtime.jsx)(Transition/* Transition.Fade */.u.Fade, Object.assign({ in: open, exit: false }, { children: (0,jsx_runtime.jsx)(Portal, { children: (0,jsx_runtime.jsxs)(Popper, Object.assign({ ref: popperRef, width: width, matchWidth: matchWidth }, { children: [(0,jsx_runtime.jsx)(Box/* default */.Z, Object.assign({ ref: forwardRef, height: "100%", p: "$16", backgrounds: ['dark90', 'light100'], borderRadius: "2px" }, rest, { children: children })), (0,jsx_runtime.jsx)(Arrow, { ref: arrowRef, className: "popover-arrow" })] })) }) }))] })));
});

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/AppBar/AppBar.js
var AppBar_rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};









const AppbarStyled = dist_theme/* styled.div */.zo.div `
  ${index_esm/* position */.FK}
  display: flex;
  align-items: center;
  z-index: ${({ theme }) => theme.zIndex.appBar};
  width: 100%;
  height: 56px;
  background: ${({ theme }) => theme.color('dark100', 'light80')};

  > span {
    position: relative;
    z-index: 150;
  }

  ${({ theme }) => theme.screen.m} {
    border-bottom: 1px solid ${({ theme }) => theme.color('dark60')};
    ${({ open }) => open &&
    dist_theme/* css */.iv `
        &:after {
          content: '';
          position: fixed;
          top: 0px;
          left: 0px;
          right: 0px;
          bottom: 0px;
          background: rgba(0, 0, 0, 0.75);
          pointer-events: none;
        }
      `}
  }
`;
const Menu = dist_theme/* styled.div */.zo.div `
  flex: 1;
  display: flex;
  align-items: center;
  border-bottom: 1px solid ${({ theme }) => theme.color('dark60')};
  padding-left: 10px;
  height: 100%;

  ${({ theme }) => theme.screen.m} {
    height: auto;
  }

  p,
  a,
  span,
  button {
    font-size: 14px;
    &:hover {
      color: ${({ theme }) => theme.color('dark0')};
    }
  }

  ${({ theme }) => theme.screen.m} {
    display: ${({ open }) => (open ? 'flex' : 'none')};
    position: fixed;
    z-index: 100;
    top: 0px;
    left: 0px;
    width: 100%;
    flex-direction: column;
    background: ${({ theme }) => theme.color('dark100')};
    padding: 60px 0;

    hr.vertical {
      display: none;
    }
  }

  hr.vertical {
    height: 24px;
    margin: 0 16px;
  }
`;
const MenuToggle = dist_theme/* styled.div */.zo.div `
  display: none;
  position: relative;
  z-index: 150;

  ${({ theme }) => theme.screen.m} {
    display: block;
    margin-left: auto;
  }
`;
const Logo = (0,dist_theme/* styled */.zo)(Box/* default */.Z) `
  display: flex;
  height: 56px;
  width: 64px;
  flex: 0 0 64px;
  background-color: ${({ theme }) => theme.color('dark80', 'light100')};
  border-bottom: ${({ withAppSideBar, theme }) => (withAppSideBar ? 'none' : `1px solid ${theme.color('dark60')({ theme })}`)};
  border-right: 1px solid ${({ hovered, theme }) => (hovered ? 'transparent' : theme.color('dark60')({ theme }))};
  transition: border-right ${({ theme }) => `${theme.transition.duration.slow}ms ${theme.transition.function.easeOut}`};

  ${({ theme }) => theme.screen.m} {
    border-right: 1px solid transparent;
    border-bottom: ${({ theme }) => `1px solid ${theme.color('transparent')({ theme })}`};
    background-color: ${({ hovered, theme }) => hovered ? theme.color('dark80', 'dark0')({ theme }) : theme.color('dark100', 'dark0')({ theme })};
    transition: background-color ${({ theme }) => `${theme.transition.duration.slow}ms ${theme.transition.function.easeOut}`};
  }
`;
const LogoTextWrapper = (0,dist_theme/* styled */.zo)(Box/* default */.Z) `
  display: flex;
  height: 56px;
  border-bottom: 1px solid ${({ theme }) => theme.color('dark60')};
  justify-content: center;
  align-items: center;

  border-right: 1px solid ${({ theme }) => theme.color('dark60')};

  ${({ theme }) => theme.screen.m} {
    border-bottom: ${({ theme }) => `1px solid ${theme.color('transparent')({ theme })}`};
  }
`;
const LogoText = dist_theme/* styled.p */.zo.p `
  width: 205px;

  padding: 5px 0;
  padding-right: 15px;
  padding-left: ${({ hovered }) => (hovered ? '0' : '25px')};
  transition: padding-left ${({ theme }) => `${theme.transition.duration.slow}ms ${theme.transition.function.easeOut}`};

  white-space: nowrap;
  text-overflow: ellipsis;
  overflow: hidden;

  &:first-letter {
    text-transform: capitalize;
  }
`;
const LogoButton = dist_theme/* styled.button */.zo.button `
  display: flex;
  white-space: nowrap;
  background: none;
  color: ${({ theme }) => theme.color('dark0')};

  transition: background-color ${({ theme }) => `${theme.transition.duration.slow}ms ${theme.transition.function.easeOut}`};

  ${({ hovered, theme }) => {
    if (!hovered)
        return null;
    return dist_theme/* css */.iv `
      background-color: ${theme.color('dark80', 'light100')({ theme })};
    `;
}}
`;
const WithPopover = ({ children, popoverContent }) => {
    const handleTrigger = (0,react.useCallback)(({ closePopover }) => {
        return (0,jsx_runtime.jsx)("div", Object.assign({ onMouseLeave: closePopover }, { children: children }));
    }, [children]);
    if (popoverContent) {
        return ((0,jsx_runtime.jsx)(Popover, Object.assign({ trigger: handleTrigger, placement: "bottom", hover: true }, { children: popoverContent })));
    }
    // eslint-disable-next-line react/jsx-no-useless-fragment
    return (0,jsx_runtime.jsx)(jsx_runtime.Fragment, { children: children });
};
/**
 * Appbar component
 */
const AppBar = (_a) => {
    var { children, logoText, logoIcon, logoPopover, onLogoClick, withAppSideBar, onHamburgerClick } = _a, rest = AppBar_rest(_a, ["children", "logoText", "logoIcon", "logoPopover", "onLogoClick", "withAppSideBar", "onHamburgerClick"]);
    const [menuOpen, setMenuOpen] = (0,react.useState)(false);
    const [isLogoHovered, setLogoHovered] = (0,react.useState)(false);
    const toggleMenu = (e) => {
        // allow use to do custom actions on the hamburger button click if defined
        if (onHamburgerClick) {
            onHamburgerClick(e);
            return;
        }
        setMenuOpen(!menuOpen);
    };
    const toggleLogoHover = () => {
        setLogoHovered(!isLogoHovered);
    };
    return ((0,jsx_runtime.jsxs)(AppbarStyled, Object.assign({ open: menuOpen }, rest, { children: [(0,jsx_runtime.jsx)(WithPopover, Object.assign({ popoverContent: logoPopover }, { children: (0,jsx_runtime.jsxs)(LogoButton, Object.assign({ "aria-label": "Logo", onClick: onLogoClick, onMouseEnter: toggleLogoHover, onMouseLeave: toggleLogoHover, hovered: isLogoHovered }, { children: [(0,jsx_runtime.jsx)(Logo, Object.assign({ justifyContent: "center", alignItems: "center", hovered: isLogoHovered, withAppSideBar: withAppSideBar }, { children: logoIcon || ((0,jsx_runtime.jsx)(Avatar_Avatar, Object.assign({ shape: "rounded", size: "medium", backgroundColor: "transparent" }, { children: (0,jsx_runtime.jsx)(IconRobocorp/* default */.Z, {}) }))) })), logoText && ((0,jsx_runtime.jsx)(LogoTextWrapper, Object.assign({ hovered: isLogoHovered, width: "206px" }, { children: (0,jsx_runtime.jsx)(LogoText, Object.assign({ hovered: isLogoHovered }, { children: logoText })) })))] })) })), (0,jsx_runtime.jsx)(Menu, Object.assign({ open: menuOpen }, { children: children })), (0,jsx_runtime.jsx)(MenuToggle, { children: (0,jsx_runtime.jsx)(Button/* Button */.z, { "aria-label": "Toggle menu", onClick: toggleMenu, icon: menuOpen ? IconX/* default */.Z : IconMenu/* default */.Z, variant: "ghost" }) })] })));
};
AppBar.defaultProps = {
    position: 'fixed',
    top: 0,
    left: 0
};
/* harmony default export */ const AppBar_AppBar = (AppBar);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/AppBar/AppNav.js
var AppNav_rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};


const StyledAppNav = dist_theme/* styled.nav */.zo.nav `
  display: flex;
  align-items: center;
  flex-grow: 1;

  ${({ theme }) => theme.screen.s} {
    flex-direction: column;
    width: 100%;
    margin-top: 32px;

    > * {
      flex-grow: 1;
    }
  }
`;
const AppNav = (_a) => {
    var { children } = _a, rest = AppNav_rest(_a, ["children"]);
    return (0,jsx_runtime.jsx)(StyledAppNav, Object.assign({}, rest, { children: children }));
};
/* harmony default export */ const AppBar_AppNav = (AppNav);

// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/components/AddTextField/AddTextField.js
var AddTextField = __webpack_require__(3826);
// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/hooks/useForkRef.js
var useForkRef = __webpack_require__(5009);
// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/components/Input/Input.js + 1 modules
var Input = __webpack_require__(3622);
// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/components/Menu/Menu.js + 7 modules
var Menu_Menu = __webpack_require__(9492);
;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Autocomplete/Autocomplete.js
var Autocomplete_rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};





/**
 * Autocomplete is a wrapped (Input)[https://design-system.solventek.com/component/input] component enhanced by a panel of suggested options.
 *
 * @see
 * {@link https://design-system.solventek.com/component/autocomplete}
 *
 * @example
 * <Autocomplete value={value} onChange={setValue} placeholder="Favourite color" options={colors} />
 */
const Autocomplete = (0,react.forwardRef)((_a, forwardedRef) => {
    var { options, renderOption: RenderOption, value, onChange, menuWidth } = _a, props = Autocomplete_rest(_a, ["options", "renderOption", "value", "onChange", "menuWidth"]);
    const [isMenuVisible, setMenuVisible] = (0,react.useState)(false);
    const localRef = (0,react.useRef)(null);
    const [unchanged, setUnchanged] = (0,react.useState)(true);
    const inputRef = (0,useForkRef/* useForkRef */.c)(localRef, forwardedRef);
    const onInputChange = (0,react.useCallback)((e) => {
        onChange(e.target.value);
        setUnchanged(false);
        setMenuVisible(true);
    }, [onChange]);
    const onOptionClick = (0,react.useCallback)((target) => () => {
        onChange(target, true);
        setMenuVisible(false);
    }, [onChange]);
    (0,react.useEffect)(() => {
        if (!isMenuVisible) {
            setUnchanged(true);
        }
    }, [isMenuVisible]);
    const filteredOptions = (0,react.useMemo)(() => {
        const filtered = value.length === 0 || unchanged
            ? options
            : options.filter((option) => option.value.toLowerCase().indexOf(value.toLowerCase()) > -1);
        const result = [];
        filtered.forEach((item, index) => {
            if (item.group && (index === 0 || filtered[index - 1].group !== item.group) && item.group.length > 0) {
                result.push(item.group);
            }
            result.push(item);
        });
        return result;
    }, [value, options, unchanged]);
    const onIndexChange = (0,react.useCallback)((index) => {
        const item = filteredOptions[index];
        if (typeof item !== 'string') {
            onChange(item.value, true);
        }
    }, [filteredOptions]);
    return ((0,jsx_runtime.jsx)(Menu_Menu/* Menu */.v, Object.assign({ trigger: (0,jsx_runtime.jsx)(Input/* Input */.II, Object.assign({ ref: inputRef, value: value, onChange: onInputChange }, props)), visible: isMenuVisible && filteredOptions.length > 0, activeIndex: 0, onVirtualChange: onIndexChange, setVisible: setMenuVisible, matchWidth: !menuWidth, width: menuWidth, size: props.size === 'large' ? 'medium' : props.size, maxHeight: 300, "data-testid": props.id }, { children: filteredOptions.map((option) => typeof option === 'string' ? ((0,jsx_runtime.jsx)(Menu_Menu/* Menu.Title */.v.Title, { children: option }, `group-${option}`)) : ((0,jsx_runtime.jsx)(Menu_Menu/* Menu.Item */.v.Item, Object.assign({ onClick: onOptionClick(option.value) }, { children: RenderOption ? (0,jsx_runtime.jsx)(RenderOption, { option: option }) : option.value }), `group-${option.value}`))) })));
});

// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/components/Badge/Badge.js
var Badge = __webpack_require__(6965);
;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Badge/index.js


;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Button/index.js


// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/components/Code/Code.js + 2 modules
var Code = __webpack_require__(6190);
;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Code/index.js


// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconChevronRight.js
var IconChevronRight = __webpack_require__(2554);
;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Breadcrumbs/Breadcrumbs.js
var Breadcrumbs_rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};




const CrumbItem = dist_theme/* styled.li */.zo.li `
  display: inline-flex;
  align-items: center;
  list-style: none;
`;
const CrumbDivider = dist_theme/* styled.div */.zo.div `
  margin: 0 4px;
  line-height: 12px;
  height: 12px;
`;
const addSeperators = (children) => {
    return react.Children.toArray(children).map((child, index) => {
        const key = `item-${index}`;
        return ((0,jsx_runtime.jsxs)(CrumbItem, { children: [child, (0,jsx_runtime.jsx)(CrumbDivider, { children: (0,jsx_runtime.jsx)(IconChevronRight/* default */.Z, { size: 12, color: "dark30" }) })] }, key));
    });
};
/**
 * Breadcrumbs component
 */
const Breadcrumbs = (_a) => {
    var { children } = _a, rest = Breadcrumbs_rest(_a, ["children"]);
    return ((0,jsx_runtime.jsx)("nav", Object.assign({}, rest, { children: (0,jsx_runtime.jsx)("ol", { children: addSeperators(children) }) })));
};
Breadcrumbs.defaultProps = {};
/* harmony default export */ const Breadcrumbs_Breadcrumbs = (Breadcrumbs);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Chart/types/gauge.js



const StyledCircle = dist_theme/* styled.circle */.zo.circle `
  stroke: ${({ strokeColor, theme }) => (typeof strokeColor === 'string' ? strokeColor : theme.color(...strokeColor))};
  stroke-width: 8px;
  stroke-linecap: round;
  fill: transparent;
  cx: 50px;
  cy: 50px;
  r: 46px;
  transform: rotate(-90deg);
  transform-origin: 50% 50%;
  transition: 0.4s cubic-bezier(0.4, 0, 0.2, 1) stroke-dashoffset;
`;
const StyledLabel = dist_theme/* styled.p */.zo.p `
  font-family: ${({ theme }) => theme.fonts.title};
  font-size: ${({ theme }) => theme.fontSizes.$24};
  font-weight: ${({ theme }) => theme.fontWeights.bold};
  position: absolute;
  top: 50%;
  transform: translate(0, -50%);
  margin-top: -4px;
  width: 100%;
  text-align: center;
`;
const Chart = ({ data, colors, features, labels }) => {
    const circumference = 92 * Math.PI;
    const percent = (0,react.useMemo)(() => {
        return data.length ? Object.entries(data[0]).filter(([key]) => key !== 'date')[0][1] : 0;
    }, [data]);
    const offset = Math.ceil(circumference - (percent / 100) * circumference);
    return ((0,jsx_runtime.jsxs)(jsx_runtime.Fragment, { children: [labels && (0,jsx_runtime.jsxs)(StyledLabel, { children: [percent, "%"] }), (0,jsx_runtime.jsxs)("svg", Object.assign({ width: "100%", height: "100%", viewBox: "0 0 100 100" }, { children: [(features === null || features === void 0 ? void 0 : features.emptyFill) && (0,jsx_runtime.jsx)(StyledCircle, { strokeColor: features === null || features === void 0 ? void 0 : features.emptyFill }), (0,jsx_runtime.jsx)(StyledCircle, { strokeDasharray: `${circumference} ${circumference}`, strokeDashoffset: offset, strokeColor: colors[0] })] }))] }));
};
/* harmony default export */ const gauge = (Chart);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Chart/types/bar.js

/* eslint-disable react/no-array-index-key */


const bar_Container = dist_theme/* styled.svg */.zo.svg `
  width: 100%;
  height: 100%;
  border-radius: 2px;
  background: ${({ theme }) => theme.color('dark90', 'light50')};
`;
const StyledRect = dist_theme/* styled.rect */.zo.rect `
  height: 50px;
  y: 0px;
  transition: 0.4s cubic-bezier(0.4, 0, 0.2, 1) width, 0.4s cubic-bezier(0.4, 0, 0.2, 1) x;
`;
const bar_Chart = ({ colors, data, features }) => {
    const { values, total } = (0,react.useMemo)(() => {
        const v = data.length ? Object.values(data[0]).filter((a) => typeof a === 'number') : [];
        const t = v.reduce((a, b) => a + b, 0);
        return { values: v, total: t };
    }, [data]);
    const gap = features && typeof features.gap === 'number' ? features.gap : 2;
    return ((0,jsx_runtime.jsx)(bar_Container, { children: values.map((item, index) => {
            if (!total)
                return null;
            return ((0,jsx_runtime.jsx)(StyledRect, { width: `calc(${Math.round((item / total) * 10000) / 100}% - ${gap}px)`, x: `calc(${Math.round((values.reduce((a, b, i) => (i < index ? a + b : a), 0) / total) * 10000) / 100}%)`, fill: colors[index] }, index));
        }) }));
};
/* harmony default export */ const bar = (bar_Chart);

// EXTERNAL MODULE: ./node_modules/classnames/index.js
var classnames = __webpack_require__(3497);
var classnames_default = /*#__PURE__*/__webpack_require__.n(classnames);
;// CONCATENATED MODULE: ./node_modules/@visx/shape/esm/util/setNumberOrNumberAccessor.js
/**
 * This is a workaround for TypeScript not inferring the correct
 * method overload/signature for some d3 shape methods.
 */
function setNumberOrNumberAccessor_setNumberOrNumberAccessor(func, value) {
  if (typeof value === 'number') func(value);else func(value);
}
;// CONCATENATED MODULE: ./node_modules/d3-path/src/path.js
var pi = Math.PI,
    tau = 2 * pi,
    epsilon = 1e-6,
    tauEpsilon = tau - epsilon;

function Path() {
  this._x0 = this._y0 = // start of current subpath
  this._x1 = this._y1 = null; // end of current subpath
  this._ = "";
}

function path() {
  return new Path;
}

Path.prototype = path.prototype = {
  constructor: Path,
  moveTo: function(x, y) {
    this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y);
  },
  closePath: function() {
    if (this._x1 !== null) {
      this._x1 = this._x0, this._y1 = this._y0;
      this._ += "Z";
    }
  },
  lineTo: function(x, y) {
    this._ += "L" + (this._x1 = +x) + "," + (this._y1 = +y);
  },
  quadraticCurveTo: function(x1, y1, x, y) {
    this._ += "Q" + (+x1) + "," + (+y1) + "," + (this._x1 = +x) + "," + (this._y1 = +y);
  },
  bezierCurveTo: function(x1, y1, x2, y2, x, y) {
    this._ += "C" + (+x1) + "," + (+y1) + "," + (+x2) + "," + (+y2) + "," + (this._x1 = +x) + "," + (this._y1 = +y);
  },
  arcTo: function(x1, y1, x2, y2, r) {
    x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;
    var x0 = this._x1,
        y0 = this._y1,
        x21 = x2 - x1,
        y21 = y2 - y1,
        x01 = x0 - x1,
        y01 = y0 - y1,
        l01_2 = x01 * x01 + y01 * y01;

    // Is the radius negative? Error.
    if (r < 0) throw new Error("negative radius: " + r);

    // Is this path empty? Move to (x1,y1).
    if (this._x1 === null) {
      this._ += "M" + (this._x1 = x1) + "," + (this._y1 = y1);
    }

    // Or, is (x1,y1) coincident with (x0,y0)? Do nothing.
    else if (!(l01_2 > epsilon));

    // Or, are (x0,y0), (x1,y1) and (x2,y2) collinear?
    // Equivalently, is (x1,y1) coincident with (x2,y2)?
    // Or, is the radius zero? Line to (x1,y1).
    else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon) || !r) {
      this._ += "L" + (this._x1 = x1) + "," + (this._y1 = y1);
    }

    // Otherwise, draw an arc!
    else {
      var x20 = x2 - x0,
          y20 = y2 - y0,
          l21_2 = x21 * x21 + y21 * y21,
          l20_2 = x20 * x20 + y20 * y20,
          l21 = Math.sqrt(l21_2),
          l01 = Math.sqrt(l01_2),
          l = r * Math.tan((pi - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2),
          t01 = l / l01,
          t21 = l / l21;

      // If the start tangent is not coincident with (x0,y0), line to.
      if (Math.abs(t01 - 1) > epsilon) {
        this._ += "L" + (x1 + t01 * x01) + "," + (y1 + t01 * y01);
      }

      this._ += "A" + r + "," + r + ",0,0," + (+(y01 * x20 > x01 * y20)) + "," + (this._x1 = x1 + t21 * x21) + "," + (this._y1 = y1 + t21 * y21);
    }
  },
  arc: function(x, y, r, a0, a1, ccw) {
    x = +x, y = +y, r = +r, ccw = !!ccw;
    var dx = r * Math.cos(a0),
        dy = r * Math.sin(a0),
        x0 = x + dx,
        y0 = y + dy,
        cw = 1 ^ ccw,
        da = ccw ? a0 - a1 : a1 - a0;

    // Is the radius negative? Error.
    if (r < 0) throw new Error("negative radius: " + r);

    // Is this path empty? Move to (x0,y0).
    if (this._x1 === null) {
      this._ += "M" + x0 + "," + y0;
    }

    // Or, is (x0,y0) not coincident with the previous point? Line to (x0,y0).
    else if (Math.abs(this._x1 - x0) > epsilon || Math.abs(this._y1 - y0) > epsilon) {
      this._ += "L" + x0 + "," + y0;
    }

    // Is this arc empty? Were done.
    if (!r) return;

    // Does the angle go the wrong way? Flip the direction.
    if (da < 0) da = da % tau + tau;

    // Is this a complete circle? Draw two arcs to complete the circle.
    if (da > tauEpsilon) {
      this._ += "A" + r + "," + r + ",0,1," + cw + "," + (x - dx) + "," + (y - dy) + "A" + r + "," + r + ",0,1," + cw + "," + (this._x1 = x0) + "," + (this._y1 = y0);
    }

    // Is this arc non-empty? Draw an arc!
    else if (da > epsilon) {
      this._ += "A" + r + "," + r + ",0," + (+(da >= pi)) + "," + cw + "," + (this._x1 = x + r * Math.cos(a1)) + "," + (this._y1 = y + r * Math.sin(a1));
    }
  },
  rect: function(x, y, w, h) {
    this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y) + "h" + (+w) + "v" + (+h) + "h" + (-w) + "Z";
  },
  toString: function() {
    return this._;
  }
};

/* harmony default export */ const src_path = (path);

;// CONCATENATED MODULE: ./node_modules/d3-shape/src/constant.js
/* harmony default export */ function src_constant(x) {
  return function constant() {
    return x;
  };
}

;// CONCATENATED MODULE: ./node_modules/d3-shape/src/curve/linear.js
function Linear(context) {
  this._context = context;
}

Linear.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; // proceed
      default: this._context.lineTo(x, y); break;
    }
  }
};

/* harmony default export */ function linear(context) {
  return new Linear(context);
}

;// CONCATENATED MODULE: ./node_modules/d3-shape/src/point.js
function point_x(p) {
  return p[0];
}

function point_y(p) {
  return p[1];
}

;// CONCATENATED MODULE: ./node_modules/d3-shape/src/line.js





/* harmony default export */ function line() {
  var x = point_x,
      y = point_y,
      defined = src_constant(true),
      context = null,
      curve = linear,
      output = null;

  function line(data) {
    var i,
        n = data.length,
        d,
        defined0 = false,
        buffer;

    if (context == null) output = curve(buffer = src_path());

    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
        if (defined0 = !defined0) output.lineStart();
        else output.lineEnd();
      }
      if (defined0) output.point(+x(d, i, data), +y(d, i, data));
    }

    if (buffer) return output = null, buffer + "" || null;
  }

  line.x = function(_) {
    return arguments.length ? (x = typeof _ === "function" ? _ : src_constant(+_), line) : x;
  };

  line.y = function(_) {
    return arguments.length ? (y = typeof _ === "function" ? _ : src_constant(+_), line) : y;
  };

  line.defined = function(_) {
    return arguments.length ? (defined = typeof _ === "function" ? _ : src_constant(!!_), line) : defined;
  };

  line.curve = function(_) {
    return arguments.length ? (curve = _, context != null && (output = curve(context)), line) : curve;
  };

  line.context = function(_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line) : context;
  };

  return line;
}

;// CONCATENATED MODULE: ./node_modules/d3-shape/src/area.js






/* harmony default export */ function src_area() {
  var x0 = point_x,
      x1 = null,
      y0 = src_constant(0),
      y1 = point_y,
      defined = src_constant(true),
      context = null,
      curve = linear,
      output = null;

  function area(data) {
    var i,
        j,
        k,
        n = data.length,
        d,
        defined0 = false,
        buffer,
        x0z = new Array(n),
        y0z = new Array(n);

    if (context == null) output = curve(buffer = src_path());

    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
        if (defined0 = !defined0) {
          j = i;
          output.areaStart();
          output.lineStart();
        } else {
          output.lineEnd();
          output.lineStart();
          for (k = i - 1; k >= j; --k) {
            output.point(x0z[k], y0z[k]);
          }
          output.lineEnd();
          output.areaEnd();
        }
      }
      if (defined0) {
        x0z[i] = +x0(d, i, data), y0z[i] = +y0(d, i, data);
        output.point(x1 ? +x1(d, i, data) : x0z[i], y1 ? +y1(d, i, data) : y0z[i]);
      }
    }

    if (buffer) return output = null, buffer + "" || null;
  }

  function arealine() {
    return line().defined(defined).curve(curve).context(context);
  }

  area.x = function(_) {
    return arguments.length ? (x0 = typeof _ === "function" ? _ : src_constant(+_), x1 = null, area) : x0;
  };

  area.x0 = function(_) {
    return arguments.length ? (x0 = typeof _ === "function" ? _ : src_constant(+_), area) : x0;
  };

  area.x1 = function(_) {
    return arguments.length ? (x1 = _ == null ? null : typeof _ === "function" ? _ : src_constant(+_), area) : x1;
  };

  area.y = function(_) {
    return arguments.length ? (y0 = typeof _ === "function" ? _ : src_constant(+_), y1 = null, area) : y0;
  };

  area.y0 = function(_) {
    return arguments.length ? (y0 = typeof _ === "function" ? _ : src_constant(+_), area) : y0;
  };

  area.y1 = function(_) {
    return arguments.length ? (y1 = _ == null ? null : typeof _ === "function" ? _ : src_constant(+_), area) : y1;
  };

  area.lineX0 =
  area.lineY0 = function() {
    return arealine().x(x0).y(y0);
  };

  area.lineY1 = function() {
    return arealine().x(x0).y(y1);
  };

  area.lineX1 = function() {
    return arealine().x(x1).y(y0);
  };

  area.defined = function(_) {
    return arguments.length ? (defined = typeof _ === "function" ? _ : src_constant(!!_), area) : defined;
  };

  area.curve = function(_) {
    return arguments.length ? (curve = _, context != null && (output = curve(context)), area) : curve;
  };

  area.context = function(_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), area) : context;
  };

  return area;
}

;// CONCATENATED MODULE: ./node_modules/@visx/shape/esm/util/D3ShapeFactories.js




function arc(_temp) {
  var _ref = _temp === void 0 ? {} : _temp,
    innerRadius = _ref.innerRadius,
    outerRadius = _ref.outerRadius,
    cornerRadius = _ref.cornerRadius,
    startAngle = _ref.startAngle,
    endAngle = _ref.endAngle,
    padAngle = _ref.padAngle,
    padRadius = _ref.padRadius;
  var path = d3Arc();
  if (innerRadius != null) setNumberOrNumberAccessor(path.innerRadius, innerRadius);
  if (outerRadius != null) setNumberOrNumberAccessor(path.outerRadius, outerRadius);
  if (cornerRadius != null) setNumberOrNumberAccessor(path.cornerRadius, cornerRadius);
  if (startAngle != null) setNumberOrNumberAccessor(path.startAngle, startAngle);
  if (endAngle != null) setNumberOrNumberAccessor(path.endAngle, endAngle);
  if (padAngle != null) setNumberOrNumberAccessor(path.padAngle, padAngle);
  if (padRadius != null) setNumberOrNumberAccessor(path.padRadius, padRadius);
  return path;
}
function D3ShapeFactories_area(_temp2) {
  var _ref2 = _temp2 === void 0 ? {} : _temp2,
    x = _ref2.x,
    x0 = _ref2.x0,
    x1 = _ref2.x1,
    y = _ref2.y,
    y0 = _ref2.y0,
    y1 = _ref2.y1,
    defined = _ref2.defined,
    curve = _ref2.curve;
  var path = src_area();
  if (x) setNumberOrNumberAccessor_setNumberOrNumberAccessor(path.x, x);
  if (x0) setNumberOrNumberAccessor_setNumberOrNumberAccessor(path.x0, x0);
  if (x1) setNumberOrNumberAccessor_setNumberOrNumberAccessor(path.x1, x1);
  if (y) setNumberOrNumberAccessor_setNumberOrNumberAccessor(path.y, y);
  if (y0) setNumberOrNumberAccessor_setNumberOrNumberAccessor(path.y0, y0);
  if (y1) setNumberOrNumberAccessor_setNumberOrNumberAccessor(path.y1, y1);
  if (defined) path.defined(defined);
  if (curve) path.curve(curve);
  return path;
}
function D3ShapeFactories_line(_temp3) {
  var _ref3 = _temp3 === void 0 ? {} : _temp3,
    x = _ref3.x,
    y = _ref3.y,
    defined = _ref3.defined,
    curve = _ref3.curve;
  var path = line();
  if (x) setNumberOrNumberAccessor_setNumberOrNumberAccessor(path.x, x);
  if (y) setNumberOrNumberAccessor_setNumberOrNumberAccessor(path.y, y);
  if (defined) path.defined(defined);
  if (curve) path.curve(curve);
  return path;
}
function pie(_temp4) {
  var _ref4 = _temp4 === void 0 ? {} : _temp4,
    startAngle = _ref4.startAngle,
    endAngle = _ref4.endAngle,
    padAngle = _ref4.padAngle,
    value = _ref4.value,
    sort = _ref4.sort,
    sortValues = _ref4.sortValues;
  var path = d3Pie();

  // ts can't distinguish between these method overloads
  if (sort === null) path.sort(sort);else if (sort != null) path.sort(sort);
  if (sortValues === null) path.sortValues(sortValues);else if (sortValues != null) path.sortValues(sortValues);
  if (value != null) path.value(value);
  if (padAngle != null) setNumberOrNumberAccessor(path.padAngle, padAngle);
  if (startAngle != null) setNumberOrNumberAccessor(path.startAngle, startAngle);
  if (endAngle != null) setNumberOrNumberAccessor(path.endAngle, endAngle);
  return path;
}
function radialLine(_temp5) {
  var _ref5 = _temp5 === void 0 ? {} : _temp5,
    angle = _ref5.angle,
    radius = _ref5.radius,
    defined = _ref5.defined,
    curve = _ref5.curve;
  var path = d3RadialLine();
  if (angle) setNumberOrNumberAccessor(path.angle, angle);
  if (radius) setNumberOrNumberAccessor(path.radius, radius);
  if (defined) path.defined(defined);
  if (curve) path.curve(curve);
  return path;
}
function stack(_ref6) {
  var keys = _ref6.keys,
    value = _ref6.value,
    order = _ref6.order,
    offset = _ref6.offset;
  var path = d3Stack();
  if (keys) path.keys(keys);
  if (value) setNumberOrNumberAccessor(path.value, value);
  if (order) path.order(stackOrder(order));
  if (offset) path.offset(stackOffset(offset));
  return path;
}
;// CONCATENATED MODULE: ./node_modules/@visx/shape/esm/shapes/AreaClosed.js
var _excluded = ["x", "x0", "x1", "y", "y1", "y0", "yScale", "data", "defined", "className", "curve", "innerRef", "children"];
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }




function AreaClosed(_ref) {
  var x = _ref.x,
    x0 = _ref.x0,
    x1 = _ref.x1,
    y = _ref.y,
    y1 = _ref.y1,
    y0 = _ref.y0,
    yScale = _ref.yScale,
    _ref$data = _ref.data,
    data = _ref$data === void 0 ? [] : _ref$data,
    _ref$defined = _ref.defined,
    defined = _ref$defined === void 0 ? function () {
      return true;
    } : _ref$defined,
    className = _ref.className,
    curve = _ref.curve,
    innerRef = _ref.innerRef,
    children = _ref.children,
    restProps = _objectWithoutPropertiesLoose(_ref, _excluded);
  var path = D3ShapeFactories_area({
    x: x,
    x0: x0,
    x1: x1,
    defined: defined,
    curve: curve
  });
  if (y0 == null) {
    /**
     * by default set the baseline to the first element of the yRange
     * @TODO take the minimum instead?
     */
    path.y0(yScale.range()[0]);
  } else {
    setNumberOrNumberAccessor_setNumberOrNumberAccessor(path.y0, y0);
  }
  if (y && !y1) setNumberOrNumberAccessor_setNumberOrNumberAccessor(path.y1, y);
  if (y1 && !y) setNumberOrNumberAccessor_setNumberOrNumberAccessor(path.y1, y1);
  if (children) return /*#__PURE__*/react.createElement(react.Fragment, null, children({
    path: path
  }));
  return /*#__PURE__*/react.createElement("path", _extends({
    ref: innerRef,
    className: classnames_default()('visx-area-closed', className),
    d: path(data) || ''
  }, restProps));
}
;// CONCATENATED MODULE: ./node_modules/@visx/shape/esm/shapes/LinePath.js
var LinePath_excluded = ["children", "data", "x", "y", "fill", "className", "curve", "innerRef", "defined"];
function LinePath_extends() { LinePath_extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return LinePath_extends.apply(this, arguments); }
function LinePath_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }



function LinePath(_ref) {
  var children = _ref.children,
    _ref$data = _ref.data,
    data = _ref$data === void 0 ? [] : _ref$data,
    x = _ref.x,
    y = _ref.y,
    _ref$fill = _ref.fill,
    fill = _ref$fill === void 0 ? 'transparent' : _ref$fill,
    className = _ref.className,
    curve = _ref.curve,
    innerRef = _ref.innerRef,
    _ref$defined = _ref.defined,
    defined = _ref$defined === void 0 ? function () {
      return true;
    } : _ref$defined,
    restProps = LinePath_objectWithoutPropertiesLoose(_ref, LinePath_excluded);
  var path = D3ShapeFactories_line({
    x: x,
    y: y,
    defined: defined,
    curve: curve
  });
  if (children) return /*#__PURE__*/react.createElement(react.Fragment, null, children({
    path: path
  }));
  return /*#__PURE__*/react.createElement("path", LinePath_extends({
    ref: innerRef,
    className: classnames_default()('visx-linepath', className),
    d: path(data) || '',
    fill: fill
    // without this a datum surrounded by nulls will not be visible
    // https://github.com/d3/d3-shape#line_defined
    ,
    strokeLinecap: "round"
  }, restProps));
}
;// CONCATENATED MODULE: ./node_modules/d3-time/node_modules/d3-array/src/ascending.js
/* harmony default export */ function ascending(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}

;// CONCATENATED MODULE: ./node_modules/d3-time/node_modules/d3-array/src/bisector.js


/* harmony default export */ function bisector(f) {
  let delta = f;
  let compare = f;

  if (f.length === 1) {
    delta = (d, x) => f(d) - x;
    compare = ascendingComparator(f);
  }

  function left(a, x, lo, hi) {
    if (lo == null) lo = 0;
    if (hi == null) hi = a.length;
    while (lo < hi) {
      const mid = (lo + hi) >>> 1;
      if (compare(a[mid], x) < 0) lo = mid + 1;
      else hi = mid;
    }
    return lo;
  }

  function right(a, x, lo, hi) {
    if (lo == null) lo = 0;
    if (hi == null) hi = a.length;
    while (lo < hi) {
      const mid = (lo + hi) >>> 1;
      if (compare(a[mid], x) > 0) hi = mid;
      else lo = mid + 1;
    }
    return lo;
  }

  function center(a, x, lo, hi) {
    if (lo == null) lo = 0;
    if (hi == null) hi = a.length;
    const i = left(a, x, lo, hi - 1);
    return i > lo && delta(a[i - 1], x) > -delta(a[i], x) ? i - 1 : i;
  }

  return {left, center, right};
}

function ascendingComparator(f) {
  return (d, x) => ascending(f(d), x);
}

;// CONCATENATED MODULE: ./node_modules/d3-time/node_modules/d3-array/src/ticks.js
var e10 = Math.sqrt(50),
    e5 = Math.sqrt(10),
    e2 = Math.sqrt(2);

/* harmony default export */ function ticks(start, stop, count) {
  var reverse,
      i = -1,
      n,
      ticks,
      step;

  stop = +stop, start = +start, count = +count;
  if (start === stop && count > 0) return [start];
  if (reverse = stop < start) n = start, start = stop, stop = n;
  if ((step = tickIncrement(start, stop, count)) === 0 || !isFinite(step)) return [];

  if (step > 0) {
    let r0 = Math.round(start / step), r1 = Math.round(stop / step);
    if (r0 * step < start) ++r0;
    if (r1 * step > stop) --r1;
    ticks = new Array(n = r1 - r0 + 1);
    while (++i < n) ticks[i] = (r0 + i) * step;
  } else {
    step = -step;
    let r0 = Math.round(start * step), r1 = Math.round(stop * step);
    if (r0 / step < start) ++r0;
    if (r1 / step > stop) --r1;
    ticks = new Array(n = r1 - r0 + 1);
    while (++i < n) ticks[i] = (r0 + i) / step;
  }

  if (reverse) ticks.reverse();

  return ticks;
}

function tickIncrement(start, stop, count) {
  var step = (stop - start) / Math.max(0, count),
      power = Math.floor(Math.log(step) / Math.LN10),
      error = step / Math.pow(10, power);
  return power >= 0
      ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power)
      : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);
}

function tickStep(start, stop, count) {
  var step0 = Math.abs(stop - start) / Math.max(0, count),
      step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)),
      error = step0 / step1;
  if (error >= e10) step1 *= 10;
  else if (error >= e5) step1 *= 5;
  else if (error >= e2) step1 *= 2;
  return stop < start ? -step1 : step1;
}

;// CONCATENATED MODULE: ./node_modules/d3-time/src/duration.js
const durationSecond = 1000;
const durationMinute = durationSecond * 60;
const durationHour = durationMinute * 60;
const durationDay = durationHour * 24;
const durationWeek = durationDay * 7;
const durationMonth = durationDay * 30;
const durationYear = durationDay * 365;

;// CONCATENATED MODULE: ./node_modules/d3-time/src/interval.js
var t0 = new Date,
    t1 = new Date;

function newInterval(floori, offseti, count, field) {

  function interval(date) {
    return floori(date = arguments.length === 0 ? new Date : new Date(+date)), date;
  }

  interval.floor = function(date) {
    return floori(date = new Date(+date)), date;
  };

  interval.ceil = function(date) {
    return floori(date = new Date(date - 1)), offseti(date, 1), floori(date), date;
  };

  interval.round = function(date) {
    var d0 = interval(date),
        d1 = interval.ceil(date);
    return date - d0 < d1 - date ? d0 : d1;
  };

  interval.offset = function(date, step) {
    return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;
  };

  interval.range = function(start, stop, step) {
    var range = [], previous;
    start = interval.ceil(start);
    step = step == null ? 1 : Math.floor(step);
    if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date
    do range.push(previous = new Date(+start)), offseti(start, step), floori(start);
    while (previous < start && start < stop);
    return range;
  };

  interval.filter = function(test) {
    return newInterval(function(date) {
      if (date >= date) while (floori(date), !test(date)) date.setTime(date - 1);
    }, function(date, step) {
      if (date >= date) {
        if (step < 0) while (++step <= 0) {
          while (offseti(date, -1), !test(date)) {} // eslint-disable-line no-empty
        } else while (--step >= 0) {
          while (offseti(date, +1), !test(date)) {} // eslint-disable-line no-empty
        }
      }
    });
  };

  if (count) {
    interval.count = function(start, end) {
      t0.setTime(+start), t1.setTime(+end);
      floori(t0), floori(t1);
      return Math.floor(count(t0, t1));
    };

    interval.every = function(step) {
      step = Math.floor(step);
      return !isFinite(step) || !(step > 0) ? null
          : !(step > 1) ? interval
          : interval.filter(field
              ? function(d) { return field(d) % step === 0; }
              : function(d) { return interval.count(0, d) % step === 0; });
    };
  }

  return interval;
}

;// CONCATENATED MODULE: ./node_modules/d3-time/src/millisecond.js


var millisecond = newInterval(function() {
  // noop
}, function(date, step) {
  date.setTime(+date + step);
}, function(start, end) {
  return end - start;
});

// An optimized implementation for this simple case.
millisecond.every = function(k) {
  k = Math.floor(k);
  if (!isFinite(k) || !(k > 0)) return null;
  if (!(k > 1)) return millisecond;
  return newInterval(function(date) {
    date.setTime(Math.floor(date / k) * k);
  }, function(date, step) {
    date.setTime(+date + step * k);
  }, function(start, end) {
    return (end - start) / k;
  });
};

/* harmony default export */ const src_millisecond = (millisecond);
var milliseconds = millisecond.range;

;// CONCATENATED MODULE: ./node_modules/d3-time/src/second.js



var second = newInterval(function(date) {
  date.setTime(date - date.getMilliseconds());
}, function(date, step) {
  date.setTime(+date + step * durationSecond);
}, function(start, end) {
  return (end - start) / durationSecond;
}, function(date) {
  return date.getUTCSeconds();
});

/* harmony default export */ const src_second = (second);
var seconds = second.range;

;// CONCATENATED MODULE: ./node_modules/d3-time/src/minute.js



var minute = newInterval(function(date) {
  date.setTime(date - date.getMilliseconds() - date.getSeconds() * durationSecond);
}, function(date, step) {
  date.setTime(+date + step * durationMinute);
}, function(start, end) {
  return (end - start) / durationMinute;
}, function(date) {
  return date.getMinutes();
});

/* harmony default export */ const src_minute = (minute);
var minutes = minute.range;

;// CONCATENATED MODULE: ./node_modules/d3-time/src/hour.js



var hour = newInterval(function(date) {
  date.setTime(date - date.getMilliseconds() - date.getSeconds() * durationSecond - date.getMinutes() * durationMinute);
}, function(date, step) {
  date.setTime(+date + step * durationHour);
}, function(start, end) {
  return (end - start) / durationHour;
}, function(date) {
  return date.getHours();
});

/* harmony default export */ const src_hour = (hour);
var hours = hour.range;

;// CONCATENATED MODULE: ./node_modules/d3-time/src/day.js



var day = newInterval(
  date => date.setHours(0, 0, 0, 0),
  (date, step) => date.setDate(date.getDate() + step),
  (start, end) => (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationDay,
  date => date.getDate() - 1
);

/* harmony default export */ const src_day = (day);
var days = day.range;

;// CONCATENATED MODULE: ./node_modules/d3-time/src/week.js



function weekday(i) {
  return newInterval(function(date) {
    date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);
    date.setHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setDate(date.getDate() + step * 7);
  }, function(start, end) {
    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationWeek;
  });
}

var sunday = weekday(0);
var monday = weekday(1);
var tuesday = weekday(2);
var wednesday = weekday(3);
var thursday = weekday(4);
var friday = weekday(5);
var saturday = weekday(6);

var sundays = sunday.range;
var mondays = monday.range;
var tuesdays = tuesday.range;
var wednesdays = wednesday.range;
var thursdays = thursday.range;
var fridays = friday.range;
var saturdays = saturday.range;

;// CONCATENATED MODULE: ./node_modules/d3-time/src/month.js


var month = newInterval(function(date) {
  date.setDate(1);
  date.setHours(0, 0, 0, 0);
}, function(date, step) {
  date.setMonth(date.getMonth() + step);
}, function(start, end) {
  return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;
}, function(date) {
  return date.getMonth();
});

/* harmony default export */ const src_month = (month);
var months = month.range;

;// CONCATENATED MODULE: ./node_modules/d3-time/src/year.js


var year = newInterval(function(date) {
  date.setMonth(0, 1);
  date.setHours(0, 0, 0, 0);
}, function(date, step) {
  date.setFullYear(date.getFullYear() + step);
}, function(start, end) {
  return end.getFullYear() - start.getFullYear();
}, function(date) {
  return date.getFullYear();
});

// An optimized implementation for this simple case.
year.every = function(k) {
  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date) {
    date.setFullYear(Math.floor(date.getFullYear() / k) * k);
    date.setMonth(0, 1);
    date.setHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setFullYear(date.getFullYear() + step * k);
  });
};

/* harmony default export */ const src_year = (year);
var years = year.range;

;// CONCATENATED MODULE: ./node_modules/d3-time/src/utcMinute.js



var utcMinute = newInterval(function(date) {
  date.setUTCSeconds(0, 0);
}, function(date, step) {
  date.setTime(+date + step * durationMinute);
}, function(start, end) {
  return (end - start) / durationMinute;
}, function(date) {
  return date.getUTCMinutes();
});

/* harmony default export */ const src_utcMinute = (utcMinute);
var utcMinutes = utcMinute.range;

;// CONCATENATED MODULE: ./node_modules/d3-time/src/utcHour.js



var utcHour = newInterval(function(date) {
  date.setUTCMinutes(0, 0, 0);
}, function(date, step) {
  date.setTime(+date + step * durationHour);
}, function(start, end) {
  return (end - start) / durationHour;
}, function(date) {
  return date.getUTCHours();
});

/* harmony default export */ const src_utcHour = (utcHour);
var utcHours = utcHour.range;

;// CONCATENATED MODULE: ./node_modules/d3-time/src/utcDay.js



var utcDay = newInterval(function(date) {
  date.setUTCHours(0, 0, 0, 0);
}, function(date, step) {
  date.setUTCDate(date.getUTCDate() + step);
}, function(start, end) {
  return (end - start) / durationDay;
}, function(date) {
  return date.getUTCDate() - 1;
});

/* harmony default export */ const src_utcDay = (utcDay);
var utcDays = utcDay.range;

;// CONCATENATED MODULE: ./node_modules/d3-time/src/utcWeek.js



function utcWeekday(i) {
  return newInterval(function(date) {
    date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);
    date.setUTCHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setUTCDate(date.getUTCDate() + step * 7);
  }, function(start, end) {
    return (end - start) / durationWeek;
  });
}

var utcSunday = utcWeekday(0);
var utcMonday = utcWeekday(1);
var utcTuesday = utcWeekday(2);
var utcWednesday = utcWeekday(3);
var utcThursday = utcWeekday(4);
var utcFriday = utcWeekday(5);
var utcSaturday = utcWeekday(6);

var utcSundays = utcSunday.range;
var utcMondays = utcMonday.range;
var utcTuesdays = utcTuesday.range;
var utcWednesdays = utcWednesday.range;
var utcThursdays = utcThursday.range;
var utcFridays = utcFriday.range;
var utcSaturdays = utcSaturday.range;

;// CONCATENATED MODULE: ./node_modules/d3-time/src/utcMonth.js


var utcMonth = newInterval(function(date) {
  date.setUTCDate(1);
  date.setUTCHours(0, 0, 0, 0);
}, function(date, step) {
  date.setUTCMonth(date.getUTCMonth() + step);
}, function(start, end) {
  return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;
}, function(date) {
  return date.getUTCMonth();
});

/* harmony default export */ const src_utcMonth = (utcMonth);
var utcMonths = utcMonth.range;

;// CONCATENATED MODULE: ./node_modules/d3-time/src/utcYear.js


var utcYear = newInterval(function(date) {
  date.setUTCMonth(0, 1);
  date.setUTCHours(0, 0, 0, 0);
}, function(date, step) {
  date.setUTCFullYear(date.getUTCFullYear() + step);
}, function(start, end) {
  return end.getUTCFullYear() - start.getUTCFullYear();
}, function(date) {
  return date.getUTCFullYear();
});

// An optimized implementation for this simple case.
utcYear.every = function(k) {
  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date) {
    date.setUTCFullYear(Math.floor(date.getUTCFullYear() / k) * k);
    date.setUTCMonth(0, 1);
    date.setUTCHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setUTCFullYear(date.getUTCFullYear() + step * k);
  });
};

/* harmony default export */ const src_utcYear = (utcYear);
var utcYears = utcYear.range;

;// CONCATENATED MODULE: ./node_modules/d3-time/src/ticks.js

















function ticker(year, month, week, day, hour, minute) {

  const tickIntervals = [
    [src_second,  1,      durationSecond],
    [src_second,  5,  5 * durationSecond],
    [src_second, 15, 15 * durationSecond],
    [src_second, 30, 30 * durationSecond],
    [minute,  1,      durationMinute],
    [minute,  5,  5 * durationMinute],
    [minute, 15, 15 * durationMinute],
    [minute, 30, 30 * durationMinute],
    [  hour,  1,      durationHour  ],
    [  hour,  3,  3 * durationHour  ],
    [  hour,  6,  6 * durationHour  ],
    [  hour, 12, 12 * durationHour  ],
    [   day,  1,      durationDay   ],
    [   day,  2,  2 * durationDay   ],
    [  week,  1,      durationWeek  ],
    [ month,  1,      durationMonth ],
    [ month,  3,  3 * durationMonth ],
    [  year,  1,      durationYear  ]
  ];

  function ticks(start, stop, count) {
    const reverse = stop < start;
    if (reverse) [start, stop] = [stop, start];
    const interval = count && typeof count.range === "function" ? count : tickInterval(start, stop, count);
    const ticks = interval ? interval.range(start, +stop + 1) : []; // inclusive stop
    return reverse ? ticks.reverse() : ticks;
  }

  function tickInterval(start, stop, count) {
    const target = Math.abs(stop - start) / count;
    const i = bisector(([,, step]) => step).right(tickIntervals, target);
    if (i === tickIntervals.length) return year.every(tickStep(start / durationYear, stop / durationYear, count));
    if (i === 0) return src_millisecond.every(Math.max(tickStep(start, stop, count), 1));
    const [t, step] = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i];
    return t.every(step);
  }

  return [ticks, tickInterval];
}

const [utcTicks, utcTickInterval] = ticker(src_utcYear, src_utcMonth, utcSunday, src_utcDay, src_utcHour, src_utcMinute);
const [timeTicks, timeTickInterval] = ticker(src_year, src_month, sunday, src_day, src_hour, src_minute);



;// CONCATENATED MODULE: ./node_modules/@visx/scale/node_modules/d3-time-format/src/locale.js


function localDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
    date.setFullYear(d.y);
    return date;
  }
  return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
}

function utcDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
    date.setUTCFullYear(d.y);
    return date;
  }
  return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
}

function newDate(y, m, d) {
  return {y: y, m: m, d: d, H: 0, M: 0, S: 0, L: 0};
}

function formatLocale(locale) {
  var locale_dateTime = locale.dateTime,
      locale_date = locale.date,
      locale_time = locale.time,
      locale_periods = locale.periods,
      locale_weekdays = locale.days,
      locale_shortWeekdays = locale.shortDays,
      locale_months = locale.months,
      locale_shortMonths = locale.shortMonths;

  var periodRe = formatRe(locale_periods),
      periodLookup = formatLookup(locale_periods),
      weekdayRe = formatRe(locale_weekdays),
      weekdayLookup = formatLookup(locale_weekdays),
      shortWeekdayRe = formatRe(locale_shortWeekdays),
      shortWeekdayLookup = formatLookup(locale_shortWeekdays),
      monthRe = formatRe(locale_months),
      monthLookup = formatLookup(locale_months),
      shortMonthRe = formatRe(locale_shortMonths),
      shortMonthLookup = formatLookup(locale_shortMonths);

  var formats = {
    "a": formatShortWeekday,
    "A": formatWeekday,
    "b": formatShortMonth,
    "B": formatMonth,
    "c": null,
    "d": formatDayOfMonth,
    "e": formatDayOfMonth,
    "f": formatMicroseconds,
    "g": formatYearISO,
    "G": formatFullYearISO,
    "H": formatHour24,
    "I": formatHour12,
    "j": formatDayOfYear,
    "L": formatMilliseconds,
    "m": formatMonthNumber,
    "M": formatMinutes,
    "p": formatPeriod,
    "q": formatQuarter,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatSeconds,
    "u": formatWeekdayNumberMonday,
    "U": formatWeekNumberSunday,
    "V": formatWeekNumberISO,
    "w": formatWeekdayNumberSunday,
    "W": formatWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatYear,
    "Y": formatFullYear,
    "Z": formatZone,
    "%": formatLiteralPercent
  };

  var utcFormats = {
    "a": formatUTCShortWeekday,
    "A": formatUTCWeekday,
    "b": formatUTCShortMonth,
    "B": formatUTCMonth,
    "c": null,
    "d": formatUTCDayOfMonth,
    "e": formatUTCDayOfMonth,
    "f": formatUTCMicroseconds,
    "g": formatUTCYearISO,
    "G": formatUTCFullYearISO,
    "H": formatUTCHour24,
    "I": formatUTCHour12,
    "j": formatUTCDayOfYear,
    "L": formatUTCMilliseconds,
    "m": formatUTCMonthNumber,
    "M": formatUTCMinutes,
    "p": formatUTCPeriod,
    "q": formatUTCQuarter,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatUTCSeconds,
    "u": formatUTCWeekdayNumberMonday,
    "U": formatUTCWeekNumberSunday,
    "V": formatUTCWeekNumberISO,
    "w": formatUTCWeekdayNumberSunday,
    "W": formatUTCWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatUTCYear,
    "Y": formatUTCFullYear,
    "Z": formatUTCZone,
    "%": formatLiteralPercent
  };

  var parses = {
    "a": parseShortWeekday,
    "A": parseWeekday,
    "b": parseShortMonth,
    "B": parseMonth,
    "c": parseLocaleDateTime,
    "d": parseDayOfMonth,
    "e": parseDayOfMonth,
    "f": parseMicroseconds,
    "g": parseYear,
    "G": parseFullYear,
    "H": parseHour24,
    "I": parseHour24,
    "j": parseDayOfYear,
    "L": parseMilliseconds,
    "m": parseMonthNumber,
    "M": parseMinutes,
    "p": parsePeriod,
    "q": parseQuarter,
    "Q": parseUnixTimestamp,
    "s": parseUnixTimestampSeconds,
    "S": parseSeconds,
    "u": parseWeekdayNumberMonday,
    "U": parseWeekNumberSunday,
    "V": parseWeekNumberISO,
    "w": parseWeekdayNumberSunday,
    "W": parseWeekNumberMonday,
    "x": parseLocaleDate,
    "X": parseLocaleTime,
    "y": parseYear,
    "Y": parseFullYear,
    "Z": parseZone,
    "%": parseLiteralPercent
  };

  // These recursive directive definitions must be deferred.
  formats.x = newFormat(locale_date, formats);
  formats.X = newFormat(locale_time, formats);
  formats.c = newFormat(locale_dateTime, formats);
  utcFormats.x = newFormat(locale_date, utcFormats);
  utcFormats.X = newFormat(locale_time, utcFormats);
  utcFormats.c = newFormat(locale_dateTime, utcFormats);

  function newFormat(specifier, formats) {
    return function(date) {
      var string = [],
          i = -1,
          j = 0,
          n = specifier.length,
          c,
          pad,
          format;

      if (!(date instanceof Date)) date = new Date(+date);

      while (++i < n) {
        if (specifier.charCodeAt(i) === 37) {
          string.push(specifier.slice(j, i));
          if ((pad = pads[c = specifier.charAt(++i)]) != null) c = specifier.charAt(++i);
          else pad = c === "e" ? " " : "0";
          if (format = formats[c]) c = format(date, pad);
          string.push(c);
          j = i + 1;
        }
      }

      string.push(specifier.slice(j, i));
      return string.join("");
    };
  }

  function newParse(specifier, Z) {
    return function(string) {
      var d = newDate(1900, undefined, 1),
          i = parseSpecifier(d, specifier, string += "", 0),
          week, day;
      if (i != string.length) return null;

      // If a UNIX timestamp is specified, return it.
      if ("Q" in d) return new Date(d.Q);
      if ("s" in d) return new Date(d.s * 1000 + ("L" in d ? d.L : 0));

      // If this is utcParse, never use the local timezone.
      if (Z && !("Z" in d)) d.Z = 0;

      // The am-pm flag is 0 for AM, and 1 for PM.
      if ("p" in d) d.H = d.H % 12 + d.p * 12;

      // If the month was not specified, inherit from the quarter.
      if (d.m === undefined) d.m = "q" in d ? d.q : 0;

      // Convert day-of-week and week-of-year to day-of-year.
      if ("V" in d) {
        if (d.V < 1 || d.V > 53) return null;
        if (!("w" in d)) d.w = 1;
        if ("Z" in d) {
          week = utcDate(newDate(d.y, 0, 1)), day = week.getUTCDay();
          week = day > 4 || day === 0 ? utcMonday.ceil(week) : utcMonday(week);
          week = src_utcDay.offset(week, (d.V - 1) * 7);
          d.y = week.getUTCFullYear();
          d.m = week.getUTCMonth();
          d.d = week.getUTCDate() + (d.w + 6) % 7;
        } else {
          week = localDate(newDate(d.y, 0, 1)), day = week.getDay();
          week = day > 4 || day === 0 ? monday.ceil(week) : monday(week);
          week = src_day.offset(week, (d.V - 1) * 7);
          d.y = week.getFullYear();
          d.m = week.getMonth();
          d.d = week.getDate() + (d.w + 6) % 7;
        }
      } else if ("W" in d || "U" in d) {
        if (!("w" in d)) d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0;
        day = "Z" in d ? utcDate(newDate(d.y, 0, 1)).getUTCDay() : localDate(newDate(d.y, 0, 1)).getDay();
        d.m = 0;
        d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day + 5) % 7 : d.w + d.U * 7 - (day + 6) % 7;
      }

      // If a time zone is specified, all fields are interpreted as UTC and then
      // offset according to the specified time zone.
      if ("Z" in d) {
        d.H += d.Z / 100 | 0;
        d.M += d.Z % 100;
        return utcDate(d);
      }

      // Otherwise, all fields are in local time.
      return localDate(d);
    };
  }

  function parseSpecifier(d, specifier, string, j) {
    var i = 0,
        n = specifier.length,
        m = string.length,
        c,
        parse;

    while (i < n) {
      if (j >= m) return -1;
      c = specifier.charCodeAt(i++);
      if (c === 37) {
        c = specifier.charAt(i++);
        parse = parses[c in pads ? specifier.charAt(i++) : c];
        if (!parse || ((j = parse(d, string, j)) < 0)) return -1;
      } else if (c != string.charCodeAt(j++)) {
        return -1;
      }
    }

    return j;
  }

  function parsePeriod(d, string, i) {
    var n = periodRe.exec(string.slice(i));
    return n ? (d.p = periodLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }

  function parseShortWeekday(d, string, i) {
    var n = shortWeekdayRe.exec(string.slice(i));
    return n ? (d.w = shortWeekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }

  function parseWeekday(d, string, i) {
    var n = weekdayRe.exec(string.slice(i));
    return n ? (d.w = weekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }

  function parseShortMonth(d, string, i) {
    var n = shortMonthRe.exec(string.slice(i));
    return n ? (d.m = shortMonthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }

  function parseMonth(d, string, i) {
    var n = monthRe.exec(string.slice(i));
    return n ? (d.m = monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }

  function parseLocaleDateTime(d, string, i) {
    return parseSpecifier(d, locale_dateTime, string, i);
  }

  function parseLocaleDate(d, string, i) {
    return parseSpecifier(d, locale_date, string, i);
  }

  function parseLocaleTime(d, string, i) {
    return parseSpecifier(d, locale_time, string, i);
  }

  function formatShortWeekday(d) {
    return locale_shortWeekdays[d.getDay()];
  }

  function formatWeekday(d) {
    return locale_weekdays[d.getDay()];
  }

  function formatShortMonth(d) {
    return locale_shortMonths[d.getMonth()];
  }

  function formatMonth(d) {
    return locale_months[d.getMonth()];
  }

  function formatPeriod(d) {
    return locale_periods[+(d.getHours() >= 12)];
  }

  function formatQuarter(d) {
    return 1 + ~~(d.getMonth() / 3);
  }

  function formatUTCShortWeekday(d) {
    return locale_shortWeekdays[d.getUTCDay()];
  }

  function formatUTCWeekday(d) {
    return locale_weekdays[d.getUTCDay()];
  }

  function formatUTCShortMonth(d) {
    return locale_shortMonths[d.getUTCMonth()];
  }

  function formatUTCMonth(d) {
    return locale_months[d.getUTCMonth()];
  }

  function formatUTCPeriod(d) {
    return locale_periods[+(d.getUTCHours() >= 12)];
  }

  function formatUTCQuarter(d) {
    return 1 + ~~(d.getUTCMonth() / 3);
  }

  return {
    format: function(specifier) {
      var f = newFormat(specifier += "", formats);
      f.toString = function() { return specifier; };
      return f;
    },
    parse: function(specifier) {
      var p = newParse(specifier += "", false);
      p.toString = function() { return specifier; };
      return p;
    },
    utcFormat: function(specifier) {
      var f = newFormat(specifier += "", utcFormats);
      f.toString = function() { return specifier; };
      return f;
    },
    utcParse: function(specifier) {
      var p = newParse(specifier += "", true);
      p.toString = function() { return specifier; };
      return p;
    }
  };
}

var pads = {"-": "", "_": " ", "0": "0"},
    numberRe = /^\s*\d+/, // note: ignores next directive
    percentRe = /^%/,
    requoteRe = /[\\^$*+?|[\]().{}]/g;

function pad(value, fill, width) {
  var sign = value < 0 ? "-" : "",
      string = (sign ? -value : value) + "",
      length = string.length;
  return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
}

function requote(s) {
  return s.replace(requoteRe, "\\$&");
}

function formatRe(names) {
  return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
}

function formatLookup(names) {
  return new Map(names.map((name, i) => [name.toLowerCase(), i]));
}

function parseWeekdayNumberSunday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.w = +n[0], i + n[0].length) : -1;
}

function parseWeekdayNumberMonday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.u = +n[0], i + n[0].length) : -1;
}

function parseWeekNumberSunday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.U = +n[0], i + n[0].length) : -1;
}

function parseWeekNumberISO(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.V = +n[0], i + n[0].length) : -1;
}

function parseWeekNumberMonday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.W = +n[0], i + n[0].length) : -1;
}

function parseFullYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 4));
  return n ? (d.y = +n[0], i + n[0].length) : -1;
}

function parseYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2000), i + n[0].length) : -1;
}

function parseZone(d, string, i) {
  var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string.slice(i, i + 6));
  return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
}

function parseQuarter(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.q = n[0] * 3 - 3, i + n[0].length) : -1;
}

function parseMonthNumber(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
}

function parseDayOfMonth(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.d = +n[0], i + n[0].length) : -1;
}

function parseDayOfYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 3));
  return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
}

function parseHour24(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.H = +n[0], i + n[0].length) : -1;
}

function parseMinutes(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.M = +n[0], i + n[0].length) : -1;
}

function parseSeconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.S = +n[0], i + n[0].length) : -1;
}

function parseMilliseconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 3));
  return n ? (d.L = +n[0], i + n[0].length) : -1;
}

function parseMicroseconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 6));
  return n ? (d.L = Math.floor(n[0] / 1000), i + n[0].length) : -1;
}

function parseLiteralPercent(d, string, i) {
  var n = percentRe.exec(string.slice(i, i + 1));
  return n ? i + n[0].length : -1;
}

function parseUnixTimestamp(d, string, i) {
  var n = numberRe.exec(string.slice(i));
  return n ? (d.Q = +n[0], i + n[0].length) : -1;
}

function parseUnixTimestampSeconds(d, string, i) {
  var n = numberRe.exec(string.slice(i));
  return n ? (d.s = +n[0], i + n[0].length) : -1;
}

function formatDayOfMonth(d, p) {
  return pad(d.getDate(), p, 2);
}

function formatHour24(d, p) {
  return pad(d.getHours(), p, 2);
}

function formatHour12(d, p) {
  return pad(d.getHours() % 12 || 12, p, 2);
}

function formatDayOfYear(d, p) {
  return pad(1 + src_day.count(src_year(d), d), p, 3);
}

function formatMilliseconds(d, p) {
  return pad(d.getMilliseconds(), p, 3);
}

function formatMicroseconds(d, p) {
  return formatMilliseconds(d, p) + "000";
}

function formatMonthNumber(d, p) {
  return pad(d.getMonth() + 1, p, 2);
}

function formatMinutes(d, p) {
  return pad(d.getMinutes(), p, 2);
}

function formatSeconds(d, p) {
  return pad(d.getSeconds(), p, 2);
}

function formatWeekdayNumberMonday(d) {
  var day = d.getDay();
  return day === 0 ? 7 : day;
}

function formatWeekNumberSunday(d, p) {
  return pad(sunday.count(src_year(d) - 1, d), p, 2);
}

function dISO(d) {
  var day = d.getDay();
  return (day >= 4 || day === 0) ? thursday(d) : thursday.ceil(d);
}

function formatWeekNumberISO(d, p) {
  d = dISO(d);
  return pad(thursday.count(src_year(d), d) + (src_year(d).getDay() === 4), p, 2);
}

function formatWeekdayNumberSunday(d) {
  return d.getDay();
}

function formatWeekNumberMonday(d, p) {
  return pad(monday.count(src_year(d) - 1, d), p, 2);
}

function formatYear(d, p) {
  return pad(d.getFullYear() % 100, p, 2);
}

function formatYearISO(d, p) {
  d = dISO(d);
  return pad(d.getFullYear() % 100, p, 2);
}

function formatFullYear(d, p) {
  return pad(d.getFullYear() % 10000, p, 4);
}

function formatFullYearISO(d, p) {
  var day = d.getDay();
  d = (day >= 4 || day === 0) ? thursday(d) : thursday.ceil(d);
  return pad(d.getFullYear() % 10000, p, 4);
}

function formatZone(d) {
  var z = d.getTimezoneOffset();
  return (z > 0 ? "-" : (z *= -1, "+"))
      + pad(z / 60 | 0, "0", 2)
      + pad(z % 60, "0", 2);
}

function formatUTCDayOfMonth(d, p) {
  return pad(d.getUTCDate(), p, 2);
}

function formatUTCHour24(d, p) {
  return pad(d.getUTCHours(), p, 2);
}

function formatUTCHour12(d, p) {
  return pad(d.getUTCHours() % 12 || 12, p, 2);
}

function formatUTCDayOfYear(d, p) {
  return pad(1 + src_utcDay.count(src_utcYear(d), d), p, 3);
}

function formatUTCMilliseconds(d, p) {
  return pad(d.getUTCMilliseconds(), p, 3);
}

function formatUTCMicroseconds(d, p) {
  return formatUTCMilliseconds(d, p) + "000";
}

function formatUTCMonthNumber(d, p) {
  return pad(d.getUTCMonth() + 1, p, 2);
}

function formatUTCMinutes(d, p) {
  return pad(d.getUTCMinutes(), p, 2);
}

function formatUTCSeconds(d, p) {
  return pad(d.getUTCSeconds(), p, 2);
}

function formatUTCWeekdayNumberMonday(d) {
  var dow = d.getUTCDay();
  return dow === 0 ? 7 : dow;
}

function formatUTCWeekNumberSunday(d, p) {
  return pad(utcSunday.count(src_utcYear(d) - 1, d), p, 2);
}

function UTCdISO(d) {
  var day = d.getUTCDay();
  return (day >= 4 || day === 0) ? utcThursday(d) : utcThursday.ceil(d);
}

function formatUTCWeekNumberISO(d, p) {
  d = UTCdISO(d);
  return pad(utcThursday.count(src_utcYear(d), d) + (src_utcYear(d).getUTCDay() === 4), p, 2);
}

function formatUTCWeekdayNumberSunday(d) {
  return d.getUTCDay();
}

function formatUTCWeekNumberMonday(d, p) {
  return pad(utcMonday.count(src_utcYear(d) - 1, d), p, 2);
}

function formatUTCYear(d, p) {
  return pad(d.getUTCFullYear() % 100, p, 2);
}

function formatUTCYearISO(d, p) {
  d = UTCdISO(d);
  return pad(d.getUTCFullYear() % 100, p, 2);
}

function formatUTCFullYear(d, p) {
  return pad(d.getUTCFullYear() % 10000, p, 4);
}

function formatUTCFullYearISO(d, p) {
  var day = d.getUTCDay();
  d = (day >= 4 || day === 0) ? utcThursday(d) : utcThursday.ceil(d);
  return pad(d.getUTCFullYear() % 10000, p, 4);
}

function formatUTCZone() {
  return "+0000";
}

function formatLiteralPercent() {
  return "%";
}

function formatUnixTimestamp(d) {
  return +d;
}

function formatUnixTimestampSeconds(d) {
  return Math.floor(+d / 1000);
}

;// CONCATENATED MODULE: ./node_modules/@visx/scale/node_modules/d3-time-format/src/defaultLocale.js


var locale;
var timeFormat;
var timeParse;
var utcFormat;
var utcParse;

defaultLocale({
  dateTime: "%x, %X",
  date: "%-m/%-d/%Y",
  time: "%-I:%M:%S %p",
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});

function defaultLocale(definition) {
  locale = formatLocale(definition);
  timeFormat = locale.format;
  timeParse = locale.parse;
  utcFormat = locale.utcFormat;
  utcParse = locale.utcParse;
  return locale;
}

;// CONCATENATED MODULE: ./node_modules/@visx/scale/node_modules/d3-array/src/ascending.js
/* harmony default export */ function src_ascending(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}

;// CONCATENATED MODULE: ./node_modules/@visx/scale/node_modules/d3-array/src/bisector.js


/* harmony default export */ function src_bisector(f) {
  let delta = f;
  let compare = f;

  if (f.length === 1) {
    delta = (d, x) => f(d) - x;
    compare = bisector_ascendingComparator(f);
  }

  function left(a, x, lo, hi) {
    if (lo == null) lo = 0;
    if (hi == null) hi = a.length;
    while (lo < hi) {
      const mid = (lo + hi) >>> 1;
      if (compare(a[mid], x) < 0) lo = mid + 1;
      else hi = mid;
    }
    return lo;
  }

  function right(a, x, lo, hi) {
    if (lo == null) lo = 0;
    if (hi == null) hi = a.length;
    while (lo < hi) {
      const mid = (lo + hi) >>> 1;
      if (compare(a[mid], x) > 0) hi = mid;
      else lo = mid + 1;
    }
    return lo;
  }

  function center(a, x, lo, hi) {
    if (lo == null) lo = 0;
    if (hi == null) hi = a.length;
    const i = left(a, x, lo, hi - 1);
    return i > lo && delta(a[i - 1], x) > -delta(a[i], x) ? i - 1 : i;
  }

  return {left, center, right};
}

function bisector_ascendingComparator(f) {
  return (d, x) => src_ascending(f(d), x);
}

;// CONCATENATED MODULE: ./node_modules/@visx/scale/node_modules/d3-array/src/number.js
/* harmony default export */ function number(x) {
  return x === null ? NaN : +x;
}

function* numbers(values, valueof) {
  if (valueof === undefined) {
    for (let value of values) {
      if (value != null && (value = +value) >= value) {
        yield value;
      }
    }
  } else {
    let index = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) {
        yield value;
      }
    }
  }
}

;// CONCATENATED MODULE: ./node_modules/@visx/scale/node_modules/d3-array/src/bisect.js




const ascendingBisect = src_bisector(src_ascending);
const bisectRight = ascendingBisect.right;
const bisectLeft = ascendingBisect.left;
const bisectCenter = src_bisector(number).center;
/* harmony default export */ const bisect = (bisectRight);

;// CONCATENATED MODULE: ./node_modules/d3-color/src/define.js
/* harmony default export */ function src_define(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
}

function extend(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key in definition) prototype[key] = definition[key];
  return prototype;
}

;// CONCATENATED MODULE: ./node_modules/d3-color/src/color.js


function Color() {}

var darker = 0.7;
var brighter = 1 / darker;

var reI = "\\s*([+-]?\\d+)\\s*",
    reN = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*",
    reP = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
    reHex = /^#([0-9a-f]{3,8})$/,
    reRgbInteger = new RegExp("^rgb\\(" + [reI, reI, reI] + "\\)$"),
    reRgbPercent = new RegExp("^rgb\\(" + [reP, reP, reP] + "\\)$"),
    reRgbaInteger = new RegExp("^rgba\\(" + [reI, reI, reI, reN] + "\\)$"),
    reRgbaPercent = new RegExp("^rgba\\(" + [reP, reP, reP, reN] + "\\)$"),
    reHslPercent = new RegExp("^hsl\\(" + [reN, reP, reP] + "\\)$"),
    reHslaPercent = new RegExp("^hsla\\(" + [reN, reP, reP, reN] + "\\)$");

var named = {
  aliceblue: 0xf0f8ff,
  antiquewhite: 0xfaebd7,
  aqua: 0x00ffff,
  aquamarine: 0x7fffd4,
  azure: 0xf0ffff,
  beige: 0xf5f5dc,
  bisque: 0xffe4c4,
  black: 0x000000,
  blanchedalmond: 0xffebcd,
  blue: 0x0000ff,
  blueviolet: 0x8a2be2,
  brown: 0xa52a2a,
  burlywood: 0xdeb887,
  cadetblue: 0x5f9ea0,
  chartreuse: 0x7fff00,
  chocolate: 0xd2691e,
  coral: 0xff7f50,
  cornflowerblue: 0x6495ed,
  cornsilk: 0xfff8dc,
  crimson: 0xdc143c,
  cyan: 0x00ffff,
  darkblue: 0x00008b,
  darkcyan: 0x008b8b,
  darkgoldenrod: 0xb8860b,
  darkgray: 0xa9a9a9,
  darkgreen: 0x006400,
  darkgrey: 0xa9a9a9,
  darkkhaki: 0xbdb76b,
  darkmagenta: 0x8b008b,
  darkolivegreen: 0x556b2f,
  darkorange: 0xff8c00,
  darkorchid: 0x9932cc,
  darkred: 0x8b0000,
  darksalmon: 0xe9967a,
  darkseagreen: 0x8fbc8f,
  darkslateblue: 0x483d8b,
  darkslategray: 0x2f4f4f,
  darkslategrey: 0x2f4f4f,
  darkturquoise: 0x00ced1,
  darkviolet: 0x9400d3,
  deeppink: 0xff1493,
  deepskyblue: 0x00bfff,
  dimgray: 0x696969,
  dimgrey: 0x696969,
  dodgerblue: 0x1e90ff,
  firebrick: 0xb22222,
  floralwhite: 0xfffaf0,
  forestgreen: 0x228b22,
  fuchsia: 0xff00ff,
  gainsboro: 0xdcdcdc,
  ghostwhite: 0xf8f8ff,
  gold: 0xffd700,
  goldenrod: 0xdaa520,
  gray: 0x808080,
  green: 0x008000,
  greenyellow: 0xadff2f,
  grey: 0x808080,
  honeydew: 0xf0fff0,
  hotpink: 0xff69b4,
  indianred: 0xcd5c5c,
  indigo: 0x4b0082,
  ivory: 0xfffff0,
  khaki: 0xf0e68c,
  lavender: 0xe6e6fa,
  lavenderblush: 0xfff0f5,
  lawngreen: 0x7cfc00,
  lemonchiffon: 0xfffacd,
  lightblue: 0xadd8e6,
  lightcoral: 0xf08080,
  lightcyan: 0xe0ffff,
  lightgoldenrodyellow: 0xfafad2,
  lightgray: 0xd3d3d3,
  lightgreen: 0x90ee90,
  lightgrey: 0xd3d3d3,
  lightpink: 0xffb6c1,
  lightsalmon: 0xffa07a,
  lightseagreen: 0x20b2aa,
  lightskyblue: 0x87cefa,
  lightslategray: 0x778899,
  lightslategrey: 0x778899,
  lightsteelblue: 0xb0c4de,
  lightyellow: 0xffffe0,
  lime: 0x00ff00,
  limegreen: 0x32cd32,
  linen: 0xfaf0e6,
  magenta: 0xff00ff,
  maroon: 0x800000,
  mediumaquamarine: 0x66cdaa,
  mediumblue: 0x0000cd,
  mediumorchid: 0xba55d3,
  mediumpurple: 0x9370db,
  mediumseagreen: 0x3cb371,
  mediumslateblue: 0x7b68ee,
  mediumspringgreen: 0x00fa9a,
  mediumturquoise: 0x48d1cc,
  mediumvioletred: 0xc71585,
  midnightblue: 0x191970,
  mintcream: 0xf5fffa,
  mistyrose: 0xffe4e1,
  moccasin: 0xffe4b5,
  navajowhite: 0xffdead,
  navy: 0x000080,
  oldlace: 0xfdf5e6,
  olive: 0x808000,
  olivedrab: 0x6b8e23,
  orange: 0xffa500,
  orangered: 0xff4500,
  orchid: 0xda70d6,
  palegoldenrod: 0xeee8aa,
  palegreen: 0x98fb98,
  paleturquoise: 0xafeeee,
  palevioletred: 0xdb7093,
  papayawhip: 0xffefd5,
  peachpuff: 0xffdab9,
  peru: 0xcd853f,
  pink: 0xffc0cb,
  plum: 0xdda0dd,
  powderblue: 0xb0e0e6,
  purple: 0x800080,
  rebeccapurple: 0x663399,
  red: 0xff0000,
  rosybrown: 0xbc8f8f,
  royalblue: 0x4169e1,
  saddlebrown: 0x8b4513,
  salmon: 0xfa8072,
  sandybrown: 0xf4a460,
  seagreen: 0x2e8b57,
  seashell: 0xfff5ee,
  sienna: 0xa0522d,
  silver: 0xc0c0c0,
  skyblue: 0x87ceeb,
  slateblue: 0x6a5acd,
  slategray: 0x708090,
  slategrey: 0x708090,
  snow: 0xfffafa,
  springgreen: 0x00ff7f,
  steelblue: 0x4682b4,
  tan: 0xd2b48c,
  teal: 0x008080,
  thistle: 0xd8bfd8,
  tomato: 0xff6347,
  turquoise: 0x40e0d0,
  violet: 0xee82ee,
  wheat: 0xf5deb3,
  white: 0xffffff,
  whitesmoke: 0xf5f5f5,
  yellow: 0xffff00,
  yellowgreen: 0x9acd32
};

src_define(Color, color, {
  copy: function(channels) {
    return Object.assign(new this.constructor, this, channels);
  },
  displayable: function() {
    return this.rgb().displayable();
  },
  hex: color_formatHex, // Deprecated! Use color.formatHex.
  formatHex: color_formatHex,
  formatHsl: color_formatHsl,
  formatRgb: color_formatRgb,
  toString: color_formatRgb
});

function color_formatHex() {
  return this.rgb().formatHex();
}

function color_formatHsl() {
  return hslConvert(this).formatHsl();
}

function color_formatRgb() {
  return this.rgb().formatRgb();
}

function color(format) {
  var m, l;
  format = (format + "").trim().toLowerCase();
  return (m = reHex.exec(format)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) // #ff0000
      : l === 3 ? new Rgb((m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), ((m & 0xf) << 4) | (m & 0xf), 1) // #f00
      : l === 8 ? rgba(m >> 24 & 0xff, m >> 16 & 0xff, m >> 8 & 0xff, (m & 0xff) / 0xff) // #ff000000
      : l === 4 ? rgba((m >> 12 & 0xf) | (m >> 8 & 0xf0), (m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), (((m & 0xf) << 4) | (m & 0xf)) / 0xff) // #f000
      : null) // invalid hex
      : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
      : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
      : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
      : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
      : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
      : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
      : named.hasOwnProperty(format) ? rgbn(named[format]) // eslint-disable-line no-prototype-builtins
      : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0)
      : null;
}

function rgbn(n) {
  return new Rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
}

function rgba(r, g, b, a) {
  if (a <= 0) r = g = b = NaN;
  return new Rgb(r, g, b, a);
}

function rgbConvert(o) {
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Rgb;
  o = o.rgb();
  return new Rgb(o.r, o.g, o.b, o.opacity);
}

function color_rgb(r, g, b, opacity) {
  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
}

function Rgb(r, g, b, opacity) {
  this.r = +r;
  this.g = +g;
  this.b = +b;
  this.opacity = +opacity;
}

src_define(Rgb, color_rgb, extend(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  rgb: function() {
    return this;
  },
  displayable: function() {
    return (-0.5 <= this.r && this.r < 255.5)
        && (-0.5 <= this.g && this.g < 255.5)
        && (-0.5 <= this.b && this.b < 255.5)
        && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: rgb_formatHex, // Deprecated! Use color.formatHex.
  formatHex: rgb_formatHex,
  formatRgb: rgb_formatRgb,
  toString: rgb_formatRgb
}));

function rgb_formatHex() {
  return "#" + hex(this.r) + hex(this.g) + hex(this.b);
}

function rgb_formatRgb() {
  var a = this.opacity; a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
  return (a === 1 ? "rgb(" : "rgba(")
      + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", "
      + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", "
      + Math.max(0, Math.min(255, Math.round(this.b) || 0))
      + (a === 1 ? ")" : ", " + a + ")");
}

function hex(value) {
  value = Math.max(0, Math.min(255, Math.round(value) || 0));
  return (value < 16 ? "0" : "") + value.toString(16);
}

function hsla(h, s, l, a) {
  if (a <= 0) h = s = l = NaN;
  else if (l <= 0 || l >= 1) h = s = NaN;
  else if (s <= 0) h = NaN;
  return new Hsl(h, s, l, a);
}

function hslConvert(o) {
  if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Hsl;
  if (o instanceof Hsl) return o;
  o = o.rgb();
  var r = o.r / 255,
      g = o.g / 255,
      b = o.b / 255,
      min = Math.min(r, g, b),
      max = Math.max(r, g, b),
      h = NaN,
      s = max - min,
      l = (max + min) / 2;
  if (s) {
    if (r === max) h = (g - b) / s + (g < b) * 6;
    else if (g === max) h = (b - r) / s + 2;
    else h = (r - g) / s + 4;
    s /= l < 0.5 ? max + min : 2 - max - min;
    h *= 60;
  } else {
    s = l > 0 && l < 1 ? 0 : h;
  }
  return new Hsl(h, s, l, o.opacity);
}

function hsl(h, s, l, opacity) {
  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
}

function Hsl(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}

src_define(Hsl, hsl, extend(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  rgb: function() {
    var h = this.h % 360 + (this.h < 0) * 360,
        s = isNaN(h) || isNaN(this.s) ? 0 : this.s,
        l = this.l,
        m2 = l + (l < 0.5 ? l : 1 - l) * s,
        m1 = 2 * l - m2;
    return new Rgb(
      hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
      hsl2rgb(h, m1, m2),
      hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
      this.opacity
    );
  },
  displayable: function() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s))
        && (0 <= this.l && this.l <= 1)
        && (0 <= this.opacity && this.opacity <= 1);
  },
  formatHsl: function() {
    var a = this.opacity; a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
    return (a === 1 ? "hsl(" : "hsla(")
        + (this.h || 0) + ", "
        + (this.s || 0) * 100 + "%, "
        + (this.l || 0) * 100 + "%"
        + (a === 1 ? ")" : ", " + a + ")");
  }
}));

/* From FvD 13.37, CSS Color Module Level 3 */
function hsl2rgb(h, m1, m2) {
  return (h < 60 ? m1 + (m2 - m1) * h / 60
      : h < 180 ? m2
      : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60
      : m1) * 255;
}

;// CONCATENATED MODULE: ./node_modules/@visx/scale/node_modules/d3-scale/node_modules/d3-interpolate/src/basis.js
function basis(t1, v0, v1, v2, v3) {
  var t2 = t1 * t1, t3 = t2 * t1;
  return ((1 - 3 * t1 + 3 * t2 - t3) * v0
      + (4 - 6 * t2 + 3 * t3) * v1
      + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2
      + t3 * v3) / 6;
}

/* harmony default export */ function src_basis(values) {
  var n = values.length - 1;
  return function(t) {
    var i = t <= 0 ? (t = 0) : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n),
        v1 = values[i],
        v2 = values[i + 1],
        v0 = i > 0 ? values[i - 1] : 2 * v1 - v2,
        v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
}

;// CONCATENATED MODULE: ./node_modules/@visx/scale/node_modules/d3-scale/node_modules/d3-interpolate/src/basisClosed.js


/* harmony default export */ function basisClosed(values) {
  var n = values.length;
  return function(t) {
    var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n),
        v0 = values[(i + n - 1) % n],
        v1 = values[i % n],
        v2 = values[(i + 1) % n],
        v3 = values[(i + 2) % n];
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
}

;// CONCATENATED MODULE: ./node_modules/@visx/scale/node_modules/d3-scale/node_modules/d3-interpolate/src/constant.js
/* harmony default export */ const d3_interpolate_src_constant = (x => () => x);

;// CONCATENATED MODULE: ./node_modules/@visx/scale/node_modules/d3-scale/node_modules/d3-interpolate/src/color.js


function color_linear(a, d) {
  return function(t) {
    return a + t * d;
  };
}

function exponential(a, b, y) {
  return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
    return Math.pow(a + t * b, y);
  };
}

function hue(a, b) {
  var d = b - a;
  return d ? color_linear(a, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : constant(isNaN(a) ? b : a);
}

function gamma(y) {
  return (y = +y) === 1 ? nogamma : function(a, b) {
    return b - a ? exponential(a, b, y) : d3_interpolate_src_constant(isNaN(a) ? b : a);
  };
}

function nogamma(a, b) {
  var d = b - a;
  return d ? color_linear(a, d) : d3_interpolate_src_constant(isNaN(a) ? b : a);
}

;// CONCATENATED MODULE: ./node_modules/@visx/scale/node_modules/d3-scale/node_modules/d3-interpolate/src/rgb.js





/* harmony default export */ const rgb = ((function rgbGamma(y) {
  var color = gamma(y);

  function rgb(start, end) {
    var r = color((start = color_rgb(start)).r, (end = color_rgb(end)).r),
        g = color(start.g, end.g),
        b = color(start.b, end.b),
        opacity = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.r = r(t);
      start.g = g(t);
      start.b = b(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }

  rgb.gamma = rgbGamma;

  return rgb;
})(1));

function rgbSpline(spline) {
  return function(colors) {
    var n = colors.length,
        r = new Array(n),
        g = new Array(n),
        b = new Array(n),
        i, color;
    for (i = 0; i < n; ++i) {
      color = color_rgb(colors[i]);
      r[i] = color.r || 0;
      g[i] = color.g || 0;
      b[i] = color.b || 0;
    }
    r = spline(r);
    g = spline(g);
    b = spline(b);
    color.opacity = 1;
    return function(t) {
      color.r = r(t);
      color.g = g(t);
      color.b = b(t);
      return color + "";
    };
  };
}

var rgbBasis = rgbSpline(src_basis);
var rgbBasisClosed = rgbSpline(basisClosed);

;// CONCATENATED MODULE: ./node_modules/@visx/scale/node_modules/d3-scale/node_modules/d3-interpolate/src/array.js



/* harmony default export */ function array(a, b) {
  return (isNumberArray(b) ? numberArray : genericArray)(a, b);
}

function genericArray(a, b) {
  var nb = b ? b.length : 0,
      na = a ? Math.min(nb, a.length) : 0,
      x = new Array(na),
      c = new Array(nb),
      i;

  for (i = 0; i < na; ++i) x[i] = value(a[i], b[i]);
  for (; i < nb; ++i) c[i] = b[i];

  return function(t) {
    for (i = 0; i < na; ++i) c[i] = x[i](t);
    return c;
  };
}

;// CONCATENATED MODULE: ./node_modules/@visx/scale/node_modules/d3-scale/node_modules/d3-interpolate/src/date.js
/* harmony default export */ function date(a, b) {
  var d = new Date;
  return a = +a, b = +b, function(t) {
    return d.setTime(a * (1 - t) + b * t), d;
  };
}

;// CONCATENATED MODULE: ./node_modules/@visx/scale/node_modules/d3-scale/node_modules/d3-interpolate/src/number.js
/* harmony default export */ function src_number(a, b) {
  return a = +a, b = +b, function(t) {
    return a * (1 - t) + b * t;
  };
}

;// CONCATENATED MODULE: ./node_modules/@visx/scale/node_modules/d3-scale/node_modules/d3-interpolate/src/object.js


/* harmony default export */ function object(a, b) {
  var i = {},
      c = {},
      k;

  if (a === null || typeof a !== "object") a = {};
  if (b === null || typeof b !== "object") b = {};

  for (k in b) {
    if (k in a) {
      i[k] = value(a[k], b[k]);
    } else {
      c[k] = b[k];
    }
  }

  return function(t) {
    for (k in i) c[k] = i[k](t);
    return c;
  };
}

;// CONCATENATED MODULE: ./node_modules/@visx/scale/node_modules/d3-scale/node_modules/d3-interpolate/src/string.js


var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
    reB = new RegExp(reA.source, "g");

function zero(b) {
  return function() {
    return b;
  };
}

function one(b) {
  return function(t) {
    return b(t) + "";
  };
}

/* harmony default export */ function string(a, b) {
  var bi = reA.lastIndex = reB.lastIndex = 0, // scan index for next number in b
      am, // current match in a
      bm, // current match in b
      bs, // string preceding current number in b, if any
      i = -1, // index in s
      s = [], // string constants and placeholders
      q = []; // number interpolators

  // Coerce inputs to strings.
  a = a + "", b = b + "";

  // Interpolate pairs of numbers in a & b.
  while ((am = reA.exec(a))
      && (bm = reB.exec(b))) {
    if ((bs = bm.index) > bi) { // a string precedes the next number in b
      bs = b.slice(bi, bs);
      if (s[i]) s[i] += bs; // coalesce with previous string
      else s[++i] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) { // numbers in a & b match
      if (s[i]) s[i] += bm; // coalesce with previous string
      else s[++i] = bm;
    } else { // interpolate non-matching numbers
      s[++i] = null;
      q.push({i: i, x: src_number(am, bm)});
    }
    bi = reB.lastIndex;
  }

  // Add remains of b.
  if (bi < b.length) {
    bs = b.slice(bi);
    if (s[i]) s[i] += bs; // coalesce with previous string
    else s[++i] = bs;
  }

  // Special optimization for only a single match.
  // Otherwise, interpolate each of the numbers and rejoin the string.
  return s.length < 2 ? (q[0]
      ? one(q[0].x)
      : zero(b))
      : (b = q.length, function(t) {
          for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
          return s.join("");
        });
}

;// CONCATENATED MODULE: ./node_modules/@visx/scale/node_modules/d3-scale/node_modules/d3-interpolate/src/numberArray.js
/* harmony default export */ function src_numberArray(a, b) {
  if (!b) b = [];
  var n = a ? Math.min(b.length, a.length) : 0,
      c = b.slice(),
      i;
  return function(t) {
    for (i = 0; i < n; ++i) c[i] = a[i] * (1 - t) + b[i] * t;
    return c;
  };
}

function numberArray_isNumberArray(x) {
  return ArrayBuffer.isView(x) && !(x instanceof DataView);
}

;// CONCATENATED MODULE: ./node_modules/@visx/scale/node_modules/d3-scale/node_modules/d3-interpolate/src/value.js










/* harmony default export */ function value(a, b) {
  var t = typeof b, c;
  return b == null || t === "boolean" ? d3_interpolate_src_constant(b)
      : (t === "number" ? src_number
      : t === "string" ? ((c = color(b)) ? (b = c, rgb) : string)
      : b instanceof color ? rgb
      : b instanceof Date ? date
      : numberArray_isNumberArray(b) ? src_numberArray
      : Array.isArray(b) ? genericArray
      : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object
      : src_number)(a, b);
}

;// CONCATENATED MODULE: ./node_modules/@visx/scale/node_modules/d3-scale/node_modules/d3-interpolate/src/round.js
/* harmony default export */ function round(a, b) {
  return a = +a, b = +b, function(t) {
    return Math.round(a * (1 - t) + b * t);
  };
}

;// CONCATENATED MODULE: ./node_modules/@visx/scale/node_modules/d3-scale/src/constant.js
function constants(x) {
  return function() {
    return x;
  };
}

;// CONCATENATED MODULE: ./node_modules/@visx/scale/node_modules/d3-scale/src/number.js
function number_number(x) {
  return +x;
}

;// CONCATENATED MODULE: ./node_modules/@visx/scale/node_modules/d3-scale/src/continuous.js





var unit = [0, 1];

function identity(x) {
  return x;
}

function normalize(a, b) {
  return (b -= (a = +a))
      ? function(x) { return (x - a) / b; }
      : constants(isNaN(b) ? NaN : 0.5);
}

function clamper(a, b) {
  var t;
  if (a > b) t = a, a = b, b = t;
  return function(x) { return Math.max(a, Math.min(b, x)); };
}

// normalize(a, b)(x) takes a domain value x in [a,b] and returns the corresponding parameter t in [0,1].
// interpolate(a, b)(t) takes a parameter t in [0,1] and returns the corresponding range value x in [a,b].
function bimap(domain, range, interpolate) {
  var d0 = domain[0], d1 = domain[1], r0 = range[0], r1 = range[1];
  if (d1 < d0) d0 = normalize(d1, d0), r0 = interpolate(r1, r0);
  else d0 = normalize(d0, d1), r0 = interpolate(r0, r1);
  return function(x) { return r0(d0(x)); };
}

function polymap(domain, range, interpolate) {
  var j = Math.min(domain.length, range.length) - 1,
      d = new Array(j),
      r = new Array(j),
      i = -1;

  // Reverse descending domains.
  if (domain[j] < domain[0]) {
    domain = domain.slice().reverse();
    range = range.slice().reverse();
  }

  while (++i < j) {
    d[i] = normalize(domain[i], domain[i + 1]);
    r[i] = interpolate(range[i], range[i + 1]);
  }

  return function(x) {
    var i = bisect(domain, x, 1, j) - 1;
    return r[i](d[i](x));
  };
}

function copy(source, target) {
  return target
      .domain(source.domain())
      .range(source.range())
      .interpolate(source.interpolate())
      .clamp(source.clamp())
      .unknown(source.unknown());
}

function transformer() {
  var domain = unit,
      range = unit,
      interpolate = value,
      transform,
      untransform,
      unknown,
      clamp = identity,
      piecewise,
      output,
      input;

  function rescale() {
    var n = Math.min(domain.length, range.length);
    if (clamp !== identity) clamp = clamper(domain[0], domain[n - 1]);
    piecewise = n > 2 ? polymap : bimap;
    output = input = null;
    return scale;
  }

  function scale(x) {
    return x == null || isNaN(x = +x) ? unknown : (output || (output = piecewise(domain.map(transform), range, interpolate)))(transform(clamp(x)));
  }

  scale.invert = function(y) {
    return clamp(untransform((input || (input = piecewise(range, domain.map(transform), src_number)))(y)));
  };

  scale.domain = function(_) {
    return arguments.length ? (domain = Array.from(_, number_number), rescale()) : domain.slice();
  };

  scale.range = function(_) {
    return arguments.length ? (range = Array.from(_), rescale()) : range.slice();
  };

  scale.rangeRound = function(_) {
    return range = Array.from(_), interpolate = round, rescale();
  };

  scale.clamp = function(_) {
    return arguments.length ? (clamp = _ ? true : identity, rescale()) : clamp !== identity;
  };

  scale.interpolate = function(_) {
    return arguments.length ? (interpolate = _, rescale()) : interpolate;
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  return function(t, u) {
    transform = t, untransform = u;
    return rescale();
  };
}

function continuous() {
  return transformer()(identity, identity);
}

;// CONCATENATED MODULE: ./node_modules/@visx/scale/node_modules/d3-scale/src/init.js
function initRange(domain, range) {
  switch (arguments.length) {
    case 0: break;
    case 1: this.range(domain); break;
    default: this.range(range).domain(domain); break;
  }
  return this;
}

function initInterpolator(domain, interpolator) {
  switch (arguments.length) {
    case 0: break;
    case 1: {
      if (typeof domain === "function") this.interpolator(domain);
      else this.range(domain);
      break;
    }
    default: {
      this.domain(domain);
      if (typeof interpolator === "function") this.interpolator(interpolator);
      else this.range(interpolator);
      break;
    }
  }
  return this;
}

;// CONCATENATED MODULE: ./node_modules/@visx/scale/node_modules/d3-scale/src/nice.js
function nice(domain, interval) {
  domain = domain.slice();

  var i0 = 0,
      i1 = domain.length - 1,
      x0 = domain[i0],
      x1 = domain[i1],
      t;

  if (x1 < x0) {
    t = i0, i0 = i1, i1 = t;
    t = x0, x0 = x1, x1 = t;
  }

  domain[i0] = interval.floor(x0);
  domain[i1] = interval.ceil(x1);
  return domain;
}

;// CONCATENATED MODULE: ./node_modules/@visx/scale/node_modules/d3-scale/src/time.js






function time_date(t) {
  return new Date(t);
}

function time_number(t) {
  return t instanceof Date ? +t : +new Date(+t);
}

function calendar(ticks, tickInterval, year, month, week, day, hour, minute, second, format) {
  var scale = continuous(),
      invert = scale.invert,
      domain = scale.domain;

  var formatMillisecond = format(".%L"),
      formatSecond = format(":%S"),
      formatMinute = format("%I:%M"),
      formatHour = format("%I %p"),
      formatDay = format("%a %d"),
      formatWeek = format("%b %d"),
      formatMonth = format("%B"),
      formatYear = format("%Y");

  function tickFormat(date) {
    return (second(date) < date ? formatMillisecond
        : minute(date) < date ? formatSecond
        : hour(date) < date ? formatMinute
        : day(date) < date ? formatHour
        : month(date) < date ? (week(date) < date ? formatDay : formatWeek)
        : year(date) < date ? formatMonth
        : formatYear)(date);
  }

  scale.invert = function(y) {
    return new Date(invert(y));
  };

  scale.domain = function(_) {
    return arguments.length ? domain(Array.from(_, time_number)) : domain().map(time_date);
  };

  scale.ticks = function(interval) {
    var d = domain();
    return ticks(d[0], d[d.length - 1], interval == null ? 10 : interval);
  };

  scale.tickFormat = function(count, specifier) {
    return specifier == null ? tickFormat : format(specifier);
  };

  scale.nice = function(interval) {
    var d = domain();
    if (!interval || typeof interval.range !== "function") interval = tickInterval(d[0], d[d.length - 1], interval == null ? 10 : interval);
    return interval ? domain(nice(d, interval)) : scale;
  };

  scale.copy = function() {
    return copy(scale, calendar(ticks, tickInterval, year, month, week, day, hour, minute, second, format));
  };

  return scale;
}

function time() {
  return initRange.apply(calendar(timeTicks, timeTickInterval, src_year, src_month, sunday, src_day, src_hour, src_minute, src_second, timeFormat).domain([new Date(2000, 0, 1), new Date(2000, 0, 2)]), arguments);
}

;// CONCATENATED MODULE: ./node_modules/@visx/scale/esm/operators/domain.js
function applyDomain(scale, config) {
  if (config.domain) {
    if ('nice' in scale || 'quantiles' in scale) {
      // continuous input scales
      scale.domain(config.domain);
    } else if ('padding' in scale) {
      // point and band scales
      scale.domain(config.domain);
    } else {
      // ordinal and threshold scale
      scale.domain(config.domain);
    }
  }
}
;// CONCATENATED MODULE: ./node_modules/@visx/scale/esm/operators/range.js
function applyRange(scale, config) {
  if (config.range) {
    if ('padding' in scale) {
      // point and band scales
      scale.range(config.range);
    } else {
      // the rest
      scale.range(config.range);
    }
  }
}
;// CONCATENATED MODULE: ./node_modules/@visx/scale/esm/operators/align.js
function applyAlign(scale, config) {
  if ('align' in scale && 'align' in config && typeof config.align !== 'undefined') {
    scale.align(config.align);
  }
}
;// CONCATENATED MODULE: ./node_modules/@visx/scale/esm/operators/base.js
function applyBase(scale, config) {
  if ('base' in scale && 'base' in config && typeof config.base !== 'undefined') {
    scale.base(config.base);
  }
}
;// CONCATENATED MODULE: ./node_modules/@visx/scale/esm/operators/clamp.js
function applyClamp(scale, config) {
  if ('clamp' in scale && 'clamp' in config && typeof config.clamp !== 'undefined') {
    scale.clamp(config.clamp);
  }
}
;// CONCATENATED MODULE: ./node_modules/@visx/scale/esm/operators/constant.js
function applyConstant(scale, config) {
  if ('constant' in scale && 'constant' in config && typeof config.constant !== 'undefined') {
    scale.constant(config.constant);
  }
}
;// CONCATENATED MODULE: ./node_modules/@visx/scale/esm/operators/exponent.js
function applyExponent(scale, config) {
  if ('exponent' in scale && 'exponent' in config && typeof config.exponent !== 'undefined') {
    scale.exponent(config.exponent);
  }
}
;// CONCATENATED MODULE: ./node_modules/d3-color/src/math.js
var deg2rad = Math.PI / 180;
var rad2deg = 180 / Math.PI;

;// CONCATENATED MODULE: ./node_modules/d3-color/src/lab.js




// https://observablehq.com/@mbostock/lab-and-rgb
var K = 18,
    Xn = 0.96422,
    Yn = 1,
    Zn = 0.82521,
    lab_t0 = 4 / 29,
    lab_t1 = 6 / 29,
    t2 = 3 * lab_t1 * lab_t1,
    t3 = lab_t1 * lab_t1 * lab_t1;

function labConvert(o) {
  if (o instanceof Lab) return new Lab(o.l, o.a, o.b, o.opacity);
  if (o instanceof Hcl) return hcl2lab(o);
  if (!(o instanceof Rgb)) o = rgbConvert(o);
  var r = rgb2lrgb(o.r),
      g = rgb2lrgb(o.g),
      b = rgb2lrgb(o.b),
      y = xyz2lab((0.2225045 * r + 0.7168786 * g + 0.0606169 * b) / Yn), x, z;
  if (r === g && g === b) x = z = y; else {
    x = xyz2lab((0.4360747 * r + 0.3850649 * g + 0.1430804 * b) / Xn);
    z = xyz2lab((0.0139322 * r + 0.0971045 * g + 0.7141733 * b) / Zn);
  }
  return new Lab(116 * y - 16, 500 * (x - y), 200 * (y - z), o.opacity);
}

function gray(l, opacity) {
  return new Lab(l, 0, 0, opacity == null ? 1 : opacity);
}

function lab(l, a, b, opacity) {
  return arguments.length === 1 ? labConvert(l) : new Lab(l, a, b, opacity == null ? 1 : opacity);
}

function Lab(l, a, b, opacity) {
  this.l = +l;
  this.a = +a;
  this.b = +b;
  this.opacity = +opacity;
}

src_define(Lab, lab, extend(Color, {
  brighter: function(k) {
    return new Lab(this.l + K * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  darker: function(k) {
    return new Lab(this.l - K * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  rgb: function() {
    var y = (this.l + 16) / 116,
        x = isNaN(this.a) ? y : y + this.a / 500,
        z = isNaN(this.b) ? y : y - this.b / 200;
    x = Xn * lab2xyz(x);
    y = Yn * lab2xyz(y);
    z = Zn * lab2xyz(z);
    return new Rgb(
      lrgb2rgb( 3.1338561 * x - 1.6168667 * y - 0.4906146 * z),
      lrgb2rgb(-0.9787684 * x + 1.9161415 * y + 0.0334540 * z),
      lrgb2rgb( 0.0719453 * x - 0.2289914 * y + 1.4052427 * z),
      this.opacity
    );
  }
}));

function xyz2lab(t) {
  return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + lab_t0;
}

function lab2xyz(t) {
  return t > lab_t1 ? t * t * t : t2 * (t - lab_t0);
}

function lrgb2rgb(x) {
  return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);
}

function rgb2lrgb(x) {
  return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
}

function hclConvert(o) {
  if (o instanceof Hcl) return new Hcl(o.h, o.c, o.l, o.opacity);
  if (!(o instanceof Lab)) o = labConvert(o);
  if (o.a === 0 && o.b === 0) return new Hcl(NaN, 0 < o.l && o.l < 100 ? 0 : NaN, o.l, o.opacity);
  var h = Math.atan2(o.b, o.a) * rad2deg;
  return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
}

function lch(l, c, h, opacity) {
  return arguments.length === 1 ? hclConvert(l) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
}

function hcl(h, c, l, opacity) {
  return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
}

function Hcl(h, c, l, opacity) {
  this.h = +h;
  this.c = +c;
  this.l = +l;
  this.opacity = +opacity;
}

function hcl2lab(o) {
  if (isNaN(o.h)) return new Lab(o.l, 0, 0, o.opacity);
  var h = o.h * deg2rad;
  return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
}

src_define(Hcl, hcl, extend(Color, {
  brighter: function(k) {
    return new Hcl(this.h, this.c, this.l + K * (k == null ? 1 : k), this.opacity);
  },
  darker: function(k) {
    return new Hcl(this.h, this.c, this.l - K * (k == null ? 1 : k), this.opacity);
  },
  rgb: function() {
    return hcl2lab(this).rgb();
  }
}));

;// CONCATENATED MODULE: ./node_modules/d3-interpolate/src/constant.js
/* harmony default export */ function node_modules_d3_interpolate_src_constant(x) {
  return function() {
    return x;
  };
}

;// CONCATENATED MODULE: ./node_modules/d3-interpolate/src/color.js


function src_color_linear(a, d) {
  return function(t) {
    return a + t * d;
  };
}

function color_exponential(a, b, y) {
  return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
    return Math.pow(a + t * b, y);
  };
}

function color_hue(a, b) {
  var d = b - a;
  return d ? src_color_linear(a, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : node_modules_d3_interpolate_src_constant(isNaN(a) ? b : a);
}

function color_gamma(y) {
  return (y = +y) === 1 ? color_nogamma : function(a, b) {
    return b - a ? color_exponential(a, b, y) : node_modules_d3_interpolate_src_constant(isNaN(a) ? b : a);
  };
}

function color_nogamma(a, b) {
  var d = b - a;
  return d ? src_color_linear(a, d) : node_modules_d3_interpolate_src_constant(isNaN(a) ? b : a);
}

;// CONCATENATED MODULE: ./node_modules/d3-interpolate/src/lab.js



function lab_lab(start, end) {
  var l = color_nogamma((start = lab(start)).l, (end = lab(end)).l),
      a = color_nogamma(start.a, end.a),
      b = color_nogamma(start.b, end.b),
      opacity = color_nogamma(start.opacity, end.opacity);
  return function(t) {
    start.l = l(t);
    start.a = a(t);
    start.b = b(t);
    start.opacity = opacity(t);
    return start + "";
  };
}

;// CONCATENATED MODULE: ./node_modules/d3-interpolate/src/hcl.js



function hcl_hcl(hue) {
  return function(start, end) {
    var h = hue((start = hcl(start)).h, (end = hcl(end)).h),
        c = color_nogamma(start.c, end.c),
        l = color_nogamma(start.l, end.l),
        opacity = color_nogamma(start.opacity, end.opacity);
    return function(t) {
      start.h = h(t);
      start.c = c(t);
      start.l = l(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }
}

/* harmony default export */ const src_hcl = (hcl_hcl(color_hue));
var hclLong = hcl_hcl(color_nogamma);

;// CONCATENATED MODULE: ./node_modules/d3-interpolate/src/hsl.js



function hsl_hsl(hue) {
  return function(start, end) {
    var h = hue((start = hsl(start)).h, (end = hsl(end)).h),
        s = color_nogamma(start.s, end.s),
        l = color_nogamma(start.l, end.l),
        opacity = color_nogamma(start.opacity, end.opacity);
    return function(t) {
      start.h = h(t);
      start.s = s(t);
      start.l = l(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }
}

/* harmony default export */ const src_hsl = (hsl_hsl(color_hue));
var hslLong = hsl_hsl(color_nogamma);

;// CONCATENATED MODULE: ./node_modules/d3-color/src/cubehelix.js




var A = -0.14861,
    B = +1.78277,
    C = -0.29227,
    D = -0.90649,
    E = +1.97294,
    ED = E * D,
    EB = E * B,
    BC_DA = B * C - D * A;

function cubehelixConvert(o) {
  if (o instanceof Cubehelix) return new Cubehelix(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Rgb)) o = rgbConvert(o);
  var r = o.r / 255,
      g = o.g / 255,
      b = o.b / 255,
      l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB),
      bl = b - l,
      k = (E * (g - l) - C * bl) / D,
      s = Math.sqrt(k * k + bl * bl) / (E * l * (1 - l)), // NaN if l=0 or l=1
      h = s ? Math.atan2(k, bl) * rad2deg - 120 : NaN;
  return new Cubehelix(h < 0 ? h + 360 : h, s, l, o.opacity);
}

function cubehelix_cubehelix(h, s, l, opacity) {
  return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s, l, opacity == null ? 1 : opacity);
}

function Cubehelix(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}

src_define(Cubehelix, cubehelix_cubehelix, extend(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  rgb: function() {
    var h = isNaN(this.h) ? 0 : (this.h + 120) * deg2rad,
        l = +this.l,
        a = isNaN(this.s) ? 0 : this.s * l * (1 - l),
        cosh = Math.cos(h),
        sinh = Math.sin(h);
    return new Rgb(
      255 * (l + a * (A * cosh + B * sinh)),
      255 * (l + a * (C * cosh + D * sinh)),
      255 * (l + a * (E * cosh)),
      this.opacity
    );
  }
}));

;// CONCATENATED MODULE: ./node_modules/d3-interpolate/src/cubehelix.js



function cubehelix(hue) {
  return (function cubehelixGamma(y) {
    y = +y;

    function cubehelix(start, end) {
      var h = hue((start = cubehelix_cubehelix(start)).h, (end = cubehelix_cubehelix(end)).h),
          s = color_nogamma(start.s, end.s),
          l = color_nogamma(start.l, end.l),
          opacity = color_nogamma(start.opacity, end.opacity);
      return function(t) {
        start.h = h(t);
        start.s = s(t);
        start.l = l(Math.pow(t, y));
        start.opacity = opacity(t);
        return start + "";
      };
    }

    cubehelix.gamma = cubehelixGamma;

    return cubehelix;
  })(1);
}

/* harmony default export */ const src_cubehelix = (cubehelix(color_hue));
var cubehelixLong = cubehelix(color_nogamma);

;// CONCATENATED MODULE: ./node_modules/d3-interpolate/src/basis.js
function basis_basis(t1, v0, v1, v2, v3) {
  var t2 = t1 * t1, t3 = t2 * t1;
  return ((1 - 3 * t1 + 3 * t2 - t3) * v0
      + (4 - 6 * t2 + 3 * t3) * v1
      + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2
      + t3 * v3) / 6;
}

/* harmony default export */ function d3_interpolate_src_basis(values) {
  var n = values.length - 1;
  return function(t) {
    var i = t <= 0 ? (t = 0) : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n),
        v1 = values[i],
        v2 = values[i + 1],
        v0 = i > 0 ? values[i - 1] : 2 * v1 - v2,
        v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;
    return basis_basis((t - i / n) * n, v0, v1, v2, v3);
  };
}

;// CONCATENATED MODULE: ./node_modules/d3-interpolate/src/basisClosed.js


/* harmony default export */ function src_basisClosed(values) {
  var n = values.length;
  return function(t) {
    var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n),
        v0 = values[(i + n - 1) % n],
        v1 = values[i % n],
        v2 = values[(i + 1) % n],
        v3 = values[(i + 2) % n];
    return basis_basis((t - i / n) * n, v0, v1, v2, v3);
  };
}

;// CONCATENATED MODULE: ./node_modules/d3-interpolate/src/rgb.js





/* harmony default export */ const src_rgb = ((function rgbGamma(y) {
  var color = color_gamma(y);

  function rgb(start, end) {
    var r = color((start = color_rgb(start)).r, (end = color_rgb(end)).r),
        g = color(start.g, end.g),
        b = color(start.b, end.b),
        opacity = color_nogamma(start.opacity, end.opacity);
    return function(t) {
      start.r = r(t);
      start.g = g(t);
      start.b = b(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }

  rgb.gamma = rgbGamma;

  return rgb;
})(1));

function rgb_rgbSpline(spline) {
  return function(colors) {
    var n = colors.length,
        r = new Array(n),
        g = new Array(n),
        b = new Array(n),
        i, color;
    for (i = 0; i < n; ++i) {
      color = color_rgb(colors[i]);
      r[i] = color.r || 0;
      g[i] = color.g || 0;
      b[i] = color.b || 0;
    }
    r = spline(r);
    g = spline(g);
    b = spline(b);
    color.opacity = 1;
    return function(t) {
      color.r = r(t);
      color.g = g(t);
      color.b = b(t);
      return color + "";
    };
  };
}

var rgb_rgbBasis = rgb_rgbSpline(d3_interpolate_src_basis);
var rgb_rgbBasisClosed = rgb_rgbSpline(src_basisClosed);

;// CONCATENATED MODULE: ./node_modules/@visx/scale/esm/utils/createColorInterpolator.js

var interpolatorMap = {
  lab: lab_lab,
  hcl: src_hcl,
  'hcl-long': hclLong,
  hsl: src_hsl,
  'hsl-long': hslLong,
  cubehelix: src_cubehelix,
  'cubehelix-long': cubehelixLong,
  rgb: src_rgb
};
function createColorInterpolator(interpolate) {
  switch (interpolate) {
    case 'lab':
    case 'hcl':
    case 'hcl-long':
    case 'hsl':
    case 'hsl-long':
    case 'cubehelix':
    case 'cubehelix-long':
    case 'rgb':
      return interpolatorMap[interpolate];
    default:
  }
  var type = interpolate.type,
    gamma = interpolate.gamma;
  var interpolator = interpolatorMap[type];
  return typeof gamma === 'undefined' ? interpolator : interpolator.gamma(gamma);
}
;// CONCATENATED MODULE: ./node_modules/@visx/scale/esm/operators/interpolate.js

function applyInterpolate(scale, config) {
  if ('interpolate' in config && 'interpolate' in scale && typeof config.interpolate !== 'undefined') {
    var interpolator = createColorInterpolator(config.interpolate);
    scale.interpolate(interpolator);
  }
}
;// CONCATENATED MODULE: ./node_modules/@visx/scale/esm/utils/isUtcScale.js
var TEST_TIME = new Date(Date.UTC(2020, 1, 2, 3, 4, 5));
var TEST_FORMAT = '%Y-%m-%d %H:%M';

/**
 * Check if the scale is UTC or Time scale
 * When local time is equal to UTC, always return true
 * @param scale time or utc scale
 */
function isUtcScale(scale) {
  // The only difference between time and utc scale is
  // whether the tick format function is utcFormat or timeFormat
  var output = scale.tickFormat(1, TEST_FORMAT)(TEST_TIME);
  return output === '2020-02-02 03:04';
}
;// CONCATENATED MODULE: ./node_modules/@visx/scale/esm/operators/nice.js


var localTimeIntervals = {
  day: src_day,
  hour: src_hour,
  minute: src_minute,
  month: src_month,
  second: src_second,
  week: sunday,
  year: src_year
};
var utcIntervals = {
  day: src_utcDay,
  hour: src_utcHour,
  minute: src_utcMinute,
  month: src_utcMonth,
  second: src_second,
  week: utcSunday,
  year: src_utcYear
};
function applyNice(scale, config) {
  if ('nice' in config && typeof config.nice !== 'undefined' && 'nice' in scale) {
    var nice = config.nice;
    if (typeof nice === 'boolean') {
      if (nice) {
        scale.nice();
      }
    } else if (typeof nice === 'number') {
      scale.nice(nice);
    } else {
      var timeScale = scale;
      var isUtc = isUtcScale(timeScale);
      if (typeof nice === 'string') {
        timeScale.nice(isUtc ? utcIntervals[nice] : localTimeIntervals[nice]);
      } else {
        var interval = nice.interval,
          step = nice.step;
        var parsedInterval = (isUtc ? utcIntervals[interval] : localTimeIntervals[interval]).every(step);
        if (parsedInterval != null) {
          timeScale.nice(parsedInterval);
        }
      }
    }
  }
}
;// CONCATENATED MODULE: ./node_modules/@visx/scale/esm/operators/padding.js
function applyPadding(scale, config) {
  if ('padding' in scale && 'padding' in config && typeof config.padding !== 'undefined') {
    scale.padding(config.padding);
  }
  if ('paddingInner' in scale && 'paddingInner' in config && typeof config.paddingInner !== 'undefined') {
    scale.paddingInner(config.paddingInner);
  }
  if ('paddingOuter' in scale && 'paddingOuter' in config && typeof config.paddingOuter !== 'undefined') {
    scale.paddingOuter(config.paddingOuter);
  }
}
;// CONCATENATED MODULE: ./node_modules/@visx/scale/esm/operators/reverse.js
function applyReverse(scale, config) {
  if (config.reverse) {
    var reversedRange = scale.range().slice().reverse();
    if ('padding' in scale) {
      // point and band scales
      scale.range(reversedRange);
    } else {
      // the rest
      scale.range(reversedRange);
    }
  }
}
;// CONCATENATED MODULE: ./node_modules/d3-interpolate/src/round.js
/* harmony default export */ function src_round(a, b) {
  return a = +a, b = +b, function(t) {
    return Math.round(a * (1 - t) + b * t);
  };
}

;// CONCATENATED MODULE: ./node_modules/@visx/scale/esm/operators/round.js

function applyRound(scale, config) {
  if ('round' in config && typeof config.round !== 'undefined') {
    if (config.round && 'interpolate' in config && typeof config.interpolate !== 'undefined') {
      console.warn("[visx/scale/applyRound] ignoring round: scale config contains round and interpolate. only applying interpolate. config:", config);
    } else if ('round' in scale) {
      // for point and band scales
      scale.round(config.round);
    } else if ('interpolate' in scale && config.round) {
      // for continuous output scales
      // setting config.round = true
      // is actually setting interpolator to interpolateRound
      // as these scales do not have scale.round() function
      scale.interpolate(src_round);
    }
  }
}
;// CONCATENATED MODULE: ./node_modules/@visx/scale/esm/operators/unknown.js
function applyUnknown(scale, config) {
  if ('unknown' in scale && 'unknown' in config && typeof config.unknown !== 'undefined') {
    scale.unknown(config.unknown);
  }
}
;// CONCATENATED MODULE: ./node_modules/@visx/scale/esm/operators/zero.js
function applyZero(scale, config) {
  if ('zero' in config && config.zero === true) {
    var domain = scale.domain();
    var a = domain[0],
      b = domain[1];
    var isDescending = b < a;
    var _ref = isDescending ? [b, a] : [a, b],
      min = _ref[0],
      max = _ref[1];
    var domainWithZero = [Math.min(0, min), Math.max(0, max)];
    scale.domain(isDescending ? domainWithZero.reverse() : domainWithZero);
  }
}
;// CONCATENATED MODULE: ./node_modules/@visx/scale/esm/operators/scaleOperator.js















/**
 * List of all operators, in order of execution
 */
var ALL_OPERATORS = [
// domain => nice => zero
'domain', 'nice', 'zero',
// interpolate before round
'interpolate', 'round',
// set range then reverse
'range', 'reverse',
// Order does not matter for these operators
'align', 'base', 'clamp', 'constant', 'exponent', 'padding', 'unknown'];
// Use Record to enforce that all keys in OperatorType must exist.
var operators = {
  domain: applyDomain,
  nice: applyNice,
  zero: applyZero,
  interpolate: applyInterpolate,
  round: applyRound,
  align: applyAlign,
  base: applyBase,
  clamp: applyClamp,
  constant: applyConstant,
  exponent: applyExponent,
  padding: applyPadding,
  range: applyRange,
  reverse: applyReverse,
  unknown: applyUnknown
};
function scaleOperator() {
  for (var _len = arguments.length, ops = new Array(_len), _key = 0; _key < _len; _key++) {
    ops[_key] = arguments[_key];
  }
  var selection = new Set(ops);
  var selectedOps = ALL_OPERATORS.filter(function (o) {
    return selection.has(o);
  });
  return function applyOperators(scale, config) {
    if (typeof config !== 'undefined') {
      selectedOps.forEach(function (op) {
        operators[op](scale, config);
      });
    }
    return scale;
  };
}
;// CONCATENATED MODULE: ./node_modules/@visx/scale/esm/scales/time.js


var updateTimeScale = scaleOperator('domain', 'range', 'reverse', 'clamp', 'interpolate', 'nice', 'round');
function createTimeScale(config) {
  return updateTimeScale(time(), config);
}
;// CONCATENATED MODULE: ./node_modules/@visx/scale/node_modules/d3-array/src/ticks.js
var ticks_e10 = Math.sqrt(50),
    ticks_e5 = Math.sqrt(10),
    ticks_e2 = Math.sqrt(2);

/* harmony default export */ function src_ticks(start, stop, count) {
  var reverse,
      i = -1,
      n,
      ticks,
      step;

  stop = +stop, start = +start, count = +count;
  if (start === stop && count > 0) return [start];
  if (reverse = stop < start) n = start, start = stop, stop = n;
  if ((step = ticks_tickIncrement(start, stop, count)) === 0 || !isFinite(step)) return [];

  if (step > 0) {
    let r0 = Math.round(start / step), r1 = Math.round(stop / step);
    if (r0 * step < start) ++r0;
    if (r1 * step > stop) --r1;
    ticks = new Array(n = r1 - r0 + 1);
    while (++i < n) ticks[i] = (r0 + i) * step;
  } else {
    step = -step;
    let r0 = Math.round(start * step), r1 = Math.round(stop * step);
    if (r0 / step < start) ++r0;
    if (r1 / step > stop) --r1;
    ticks = new Array(n = r1 - r0 + 1);
    while (++i < n) ticks[i] = (r0 + i) / step;
  }

  if (reverse) ticks.reverse();

  return ticks;
}

function ticks_tickIncrement(start, stop, count) {
  var step = (stop - start) / Math.max(0, count),
      power = Math.floor(Math.log(step) / Math.LN10),
      error = step / Math.pow(10, power);
  return power >= 0
      ? (error >= ticks_e10 ? 10 : error >= ticks_e5 ? 5 : error >= ticks_e2 ? 2 : 1) * Math.pow(10, power)
      : -Math.pow(10, -power) / (error >= ticks_e10 ? 10 : error >= ticks_e5 ? 5 : error >= ticks_e2 ? 2 : 1);
}

function ticks_tickStep(start, stop, count) {
  var step0 = Math.abs(stop - start) / Math.max(0, count),
      step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)),
      error = step0 / step1;
  if (error >= ticks_e10) step1 *= 10;
  else if (error >= ticks_e5) step1 *= 5;
  else if (error >= ticks_e2) step1 *= 2;
  return stop < start ? -step1 : step1;
}

;// CONCATENATED MODULE: ./node_modules/@visx/scale/node_modules/d3-format/src/formatSpecifier.js
// [[fill]align][sign][symbol][0][width][,][.precision][~][type]
var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;

function formatSpecifier(specifier) {
  if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);
  var match;
  return new FormatSpecifier({
    fill: match[1],
    align: match[2],
    sign: match[3],
    symbol: match[4],
    zero: match[5],
    width: match[6],
    comma: match[7],
    precision: match[8] && match[8].slice(1),
    trim: match[9],
    type: match[10]
  });
}

formatSpecifier.prototype = FormatSpecifier.prototype; // instanceof

function FormatSpecifier(specifier) {
  this.fill = specifier.fill === undefined ? " " : specifier.fill + "";
  this.align = specifier.align === undefined ? ">" : specifier.align + "";
  this.sign = specifier.sign === undefined ? "-" : specifier.sign + "";
  this.symbol = specifier.symbol === undefined ? "" : specifier.symbol + "";
  this.zero = !!specifier.zero;
  this.width = specifier.width === undefined ? undefined : +specifier.width;
  this.comma = !!specifier.comma;
  this.precision = specifier.precision === undefined ? undefined : +specifier.precision;
  this.trim = !!specifier.trim;
  this.type = specifier.type === undefined ? "" : specifier.type + "";
}

FormatSpecifier.prototype.toString = function() {
  return this.fill
      + this.align
      + this.sign
      + this.symbol
      + (this.zero ? "0" : "")
      + (this.width === undefined ? "" : Math.max(1, this.width | 0))
      + (this.comma ? "," : "")
      + (this.precision === undefined ? "" : "." + Math.max(0, this.precision | 0))
      + (this.trim ? "~" : "")
      + this.type;
};

;// CONCATENATED MODULE: ./node_modules/@visx/scale/node_modules/d3-format/src/formatDecimal.js
/* harmony default export */ function formatDecimal(x) {
  return Math.abs(x = Math.round(x)) >= 1e21
      ? x.toLocaleString("en").replace(/,/g, "")
      : x.toString(10);
}

// Computes the decimal coefficient and exponent of the specified number x with
// significant digits p, where x is positive and p is in [1, 21] or undefined.
// For example, formatDecimalParts(1.23) returns ["123", 0].
function formatDecimalParts(x, p) {
  if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0) return null; // NaN, Infinity
  var i, coefficient = x.slice(0, i);

  // The string returned by toExponential either has the form \d\.\d+e[-+]\d+
  // (e.g., 1.2e+3) or the form \de[-+]\d+ (e.g., 1e+3).
  return [
    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
    +x.slice(i + 1)
  ];
}

;// CONCATENATED MODULE: ./node_modules/@visx/scale/node_modules/d3-format/src/exponent.js


/* harmony default export */ function exponent(x) {
  return x = formatDecimalParts(Math.abs(x)), x ? x[1] : NaN;
}

;// CONCATENATED MODULE: ./node_modules/@visx/scale/node_modules/d3-format/src/precisionPrefix.js


/* harmony default export */ function precisionPrefix(step, value) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3 - exponent(Math.abs(step)));
}

;// CONCATENATED MODULE: ./node_modules/@visx/scale/node_modules/d3-format/src/formatGroup.js
/* harmony default export */ function formatGroup(grouping, thousands) {
  return function(value, width) {
    var i = value.length,
        t = [],
        j = 0,
        g = grouping[0],
        length = 0;

    while (i > 0 && g > 0) {
      if (length + g + 1 > width) g = Math.max(1, width - length);
      t.push(value.substring(i -= g, i + g));
      if ((length += g + 1) > width) break;
      g = grouping[j = (j + 1) % grouping.length];
    }

    return t.reverse().join(thousands);
  };
}

;// CONCATENATED MODULE: ./node_modules/@visx/scale/node_modules/d3-format/src/formatNumerals.js
/* harmony default export */ function formatNumerals(numerals) {
  return function(value) {
    return value.replace(/[0-9]/g, function(i) {
      return numerals[+i];
    });
  };
}

;// CONCATENATED MODULE: ./node_modules/@visx/scale/node_modules/d3-format/src/formatTrim.js
// Trims insignificant zeros, e.g., replaces 1.2000k with 1.2k.
/* harmony default export */ function formatTrim(s) {
  out: for (var n = s.length, i = 1, i0 = -1, i1; i < n; ++i) {
    switch (s[i]) {
      case ".": i0 = i1 = i; break;
      case "0": if (i0 === 0) i0 = i; i1 = i; break;
      default: if (!+s[i]) break out; if (i0 > 0) i0 = 0; break;
    }
  }
  return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
}

;// CONCATENATED MODULE: ./node_modules/@visx/scale/node_modules/d3-format/src/formatPrefixAuto.js


var prefixExponent;

/* harmony default export */ function formatPrefixAuto(x, p) {
  var d = formatDecimalParts(x, p);
  if (!d) return x + "";
  var coefficient = d[0],
      exponent = d[1],
      i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,
      n = coefficient.length;
  return i === n ? coefficient
      : i > n ? coefficient + new Array(i - n + 1).join("0")
      : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i)
      : "0." + new Array(1 - i).join("0") + formatDecimalParts(x, Math.max(0, p + i - 1))[0]; // less than 1y!
}

;// CONCATENATED MODULE: ./node_modules/@visx/scale/node_modules/d3-format/src/formatRounded.js


/* harmony default export */ function formatRounded(x, p) {
  var d = formatDecimalParts(x, p);
  if (!d) return x + "";
  var coefficient = d[0],
      exponent = d[1];
  return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient
      : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1)
      : coefficient + new Array(exponent - coefficient.length + 2).join("0");
}

;// CONCATENATED MODULE: ./node_modules/@visx/scale/node_modules/d3-format/src/formatTypes.js




/* harmony default export */ const formatTypes = ({
  "%": (x, p) => (x * 100).toFixed(p),
  "b": (x) => Math.round(x).toString(2),
  "c": (x) => x + "",
  "d": formatDecimal,
  "e": (x, p) => x.toExponential(p),
  "f": (x, p) => x.toFixed(p),
  "g": (x, p) => x.toPrecision(p),
  "o": (x) => Math.round(x).toString(8),
  "p": (x, p) => formatRounded(x * 100, p),
  "r": formatRounded,
  "s": formatPrefixAuto,
  "X": (x) => Math.round(x).toString(16).toUpperCase(),
  "x": (x) => Math.round(x).toString(16)
});

;// CONCATENATED MODULE: ./node_modules/@visx/scale/node_modules/d3-format/src/identity.js
/* harmony default export */ function src_identity(x) {
  return x;
}

;// CONCATENATED MODULE: ./node_modules/@visx/scale/node_modules/d3-format/src/locale.js









var map = Array.prototype.map,
    prefixes = ["y","z","a","f","p","n","","m","","k","M","G","T","P","E","Z","Y"];

/* harmony default export */ function src_locale(locale) {
  var group = locale.grouping === undefined || locale.thousands === undefined ? src_identity : formatGroup(map.call(locale.grouping, Number), locale.thousands + ""),
      currencyPrefix = locale.currency === undefined ? "" : locale.currency[0] + "",
      currencySuffix = locale.currency === undefined ? "" : locale.currency[1] + "",
      decimal = locale.decimal === undefined ? "." : locale.decimal + "",
      numerals = locale.numerals === undefined ? src_identity : formatNumerals(map.call(locale.numerals, String)),
      percent = locale.percent === undefined ? "%" : locale.percent + "",
      minus = locale.minus === undefined ? "" : locale.minus + "",
      nan = locale.nan === undefined ? "NaN" : locale.nan + "";

  function newFormat(specifier) {
    specifier = formatSpecifier(specifier);

    var fill = specifier.fill,
        align = specifier.align,
        sign = specifier.sign,
        symbol = specifier.symbol,
        zero = specifier.zero,
        width = specifier.width,
        comma = specifier.comma,
        precision = specifier.precision,
        trim = specifier.trim,
        type = specifier.type;

    // The "n" type is an alias for ",g".
    if (type === "n") comma = true, type = "g";

    // The "" type, and any invalid type, is an alias for ".12~g".
    else if (!formatTypes[type]) precision === undefined && (precision = 12), trim = true, type = "g";

    // If zero fill is specified, padding goes after sign and before digits.
    if (zero || (fill === "0" && align === "=")) zero = true, fill = "0", align = "=";

    // Compute the prefix and suffix.
    // For SI-prefix, the suffix is lazily computed.
    var prefix = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "",
        suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type) ? percent : "";

    // What format function should we use?
    // Is this an integer type?
    // Can this type generate exponential notation?
    var formatType = formatTypes[type],
        maybeSuffix = /[defgprs%]/.test(type);

    // Set the default precision if not specified,
    // or clamp the specified precision to the supported range.
    // For significant precision, it must be in [1, 21].
    // For fixed precision, it must be in [0, 20].
    precision = precision === undefined ? 6
        : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))
        : Math.max(0, Math.min(20, precision));

    function format(value) {
      var valuePrefix = prefix,
          valueSuffix = suffix,
          i, n, c;

      if (type === "c") {
        valueSuffix = formatType(value) + valueSuffix;
        value = "";
      } else {
        value = +value;

        // Determine the sign. -0 is not less than 0, but 1 / -0 is!
        var valueNegative = value < 0 || 1 / value < 0;

        // Perform the initial formatting.
        value = isNaN(value) ? nan : formatType(Math.abs(value), precision);

        // Trim insignificant zeros.
        if (trim) value = formatTrim(value);

        // If a negative value rounds to zero after formatting, and no explicit positive sign is requested, hide the sign.
        if (valueNegative && +value === 0 && sign !== "+") valueNegative = false;

        // Compute the prefix and suffix.
        valuePrefix = (valueNegative ? (sign === "(" ? sign : minus) : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
        valueSuffix = (type === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : "");

        // Break the formatted value into the integer value part that can be
        // grouped, and fractional or exponential suffix part that is not.
        if (maybeSuffix) {
          i = -1, n = value.length;
          while (++i < n) {
            if (c = value.charCodeAt(i), 48 > c || c > 57) {
              valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
              value = value.slice(0, i);
              break;
            }
          }
        }
      }

      // If the fill character is not "0", grouping is applied before padding.
      if (comma && !zero) value = group(value, Infinity);

      // Compute the padding.
      var length = valuePrefix.length + value.length + valueSuffix.length,
          padding = length < width ? new Array(width - length + 1).join(fill) : "";

      // If the fill character is "0", grouping is applied after padding.
      if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";

      // Reconstruct the final output based on the desired alignment.
      switch (align) {
        case "<": value = valuePrefix + value + valueSuffix + padding; break;
        case "=": value = valuePrefix + padding + value + valueSuffix; break;
        case "^": value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length); break;
        default: value = padding + valuePrefix + value + valueSuffix; break;
      }

      return numerals(value);
    }

    format.toString = function() {
      return specifier + "";
    };

    return format;
  }

  function formatPrefix(specifier, value) {
    var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)),
        e = Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3,
        k = Math.pow(10, -e),
        prefix = prefixes[8 + e / 3];
    return function(value) {
      return f(k * value) + prefix;
    };
  }

  return {
    format: newFormat,
    formatPrefix: formatPrefix
  };
}

;// CONCATENATED MODULE: ./node_modules/@visx/scale/node_modules/d3-format/src/defaultLocale.js


var defaultLocale_locale;
var defaultLocale_format;
var formatPrefix;

defaultLocale_defaultLocale({
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});

function defaultLocale_defaultLocale(definition) {
  defaultLocale_locale = src_locale(definition);
  defaultLocale_format = defaultLocale_locale.format;
  formatPrefix = defaultLocale_locale.formatPrefix;
  return defaultLocale_locale;
}

;// CONCATENATED MODULE: ./node_modules/@visx/scale/node_modules/d3-format/src/precisionRound.js


/* harmony default export */ function precisionRound(step, max) {
  step = Math.abs(step), max = Math.abs(max) - step;
  return Math.max(0, exponent(max) - exponent(step)) + 1;
}

;// CONCATENATED MODULE: ./node_modules/@visx/scale/node_modules/d3-format/src/precisionFixed.js


/* harmony default export */ function precisionFixed(step) {
  return Math.max(0, -exponent(Math.abs(step)));
}

;// CONCATENATED MODULE: ./node_modules/@visx/scale/node_modules/d3-scale/src/tickFormat.js



function tickFormat(start, stop, count, specifier) {
  var step = ticks_tickStep(start, stop, count),
      precision;
  specifier = formatSpecifier(specifier == null ? ",f" : specifier);
  switch (specifier.type) {
    case "s": {
      var value = Math.max(Math.abs(start), Math.abs(stop));
      if (specifier.precision == null && !isNaN(precision = precisionPrefix(step, value))) specifier.precision = precision;
      return formatPrefix(specifier, value);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      if (specifier.precision == null && !isNaN(precision = precisionRound(step, Math.max(Math.abs(start), Math.abs(stop))))) specifier.precision = precision - (specifier.type === "e");
      break;
    }
    case "f":
    case "%": {
      if (specifier.precision == null && !isNaN(precision = precisionFixed(step))) specifier.precision = precision - (specifier.type === "%") * 2;
      break;
    }
  }
  return defaultLocale_format(specifier);
}

;// CONCATENATED MODULE: ./node_modules/@visx/scale/node_modules/d3-scale/src/linear.js





function linearish(scale) {
  var domain = scale.domain;

  scale.ticks = function(count) {
    var d = domain();
    return src_ticks(d[0], d[d.length - 1], count == null ? 10 : count);
  };

  scale.tickFormat = function(count, specifier) {
    var d = domain();
    return tickFormat(d[0], d[d.length - 1], count == null ? 10 : count, specifier);
  };

  scale.nice = function(count) {
    if (count == null) count = 10;

    var d = domain();
    var i0 = 0;
    var i1 = d.length - 1;
    var start = d[i0];
    var stop = d[i1];
    var prestep;
    var step;
    var maxIter = 10;

    if (stop < start) {
      step = start, start = stop, stop = step;
      step = i0, i0 = i1, i1 = step;
    }
    
    while (maxIter-- > 0) {
      step = ticks_tickIncrement(start, stop, count);
      if (step === prestep) {
        d[i0] = start
        d[i1] = stop
        return domain(d);
      } else if (step > 0) {
        start = Math.floor(start / step) * step;
        stop = Math.ceil(stop / step) * step;
      } else if (step < 0) {
        start = Math.ceil(start * step) / step;
        stop = Math.floor(stop * step) / step;
      } else {
        break;
      }
      prestep = step;
    }

    return scale;
  };

  return scale;
}

function linear_linear() {
  var scale = continuous();

  scale.copy = function() {
    return copy(scale, linear_linear());
  };

  initRange.apply(scale, arguments);

  return linearish(scale);
}

;// CONCATENATED MODULE: ./node_modules/@visx/scale/esm/scales/linear.js


var updateLinearScale = scaleOperator('domain', 'range', 'reverse', 'clamp', 'interpolate', 'nice', 'round', 'zero');
function createLinearScale(config) {
  return updateLinearScale(linear_linear(), config);
}
// EXTERNAL MODULE: ./node_modules/prop-types/index.js
var prop_types = __webpack_require__(9724);
var prop_types_default = /*#__PURE__*/__webpack_require__.n(prop_types);
;// CONCATENATED MODULE: ./node_modules/@visx/group/esm/Group.js

var Group_excluded = ["top", "left", "transform", "className", "children", "innerRef"];
function Group_extends() { Group_extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return Group_extends.apply(this, arguments); }
function Group_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }


function Group(_ref) {
  var _ref$top = _ref.top,
    top = _ref$top === void 0 ? 0 : _ref$top,
    _ref$left = _ref.left,
    left = _ref$left === void 0 ? 0 : _ref$left,
    transform = _ref.transform,
    className = _ref.className,
    children = _ref.children,
    innerRef = _ref.innerRef,
    restProps = Group_objectWithoutPropertiesLoose(_ref, Group_excluded);
  return /*#__PURE__*/react.createElement("g", Group_extends({
    ref: innerRef,
    className: classnames_default()('visx-group', className),
    transform: transform || "translate(" + left + ", " + top + ")"
  }, restProps), children);
}
Group.propTypes = {
  top: (prop_types_default()).number,
  left: (prop_types_default()).number,
  transform: (prop_types_default()).string,
  className: (prop_types_default()).string,
  children: (prop_types_default()).node,
  innerRef: prop_types_default().oneOfType([(prop_types_default()).string, (prop_types_default()).func, (prop_types_default()).object])
};
;// CONCATENATED MODULE: ./node_modules/@visx/scale/esm/utils/getTicks.js
function getTicks(scale, numTicks) {
  // Because `Scale` is generic type which maybe a subset of AnyD3Scale
  // that may not have `ticks` field,
  // TypeScript will not let us do the `'ticks' in scale` check directly.
  // Have to manually cast and expand type first.
  var s = scale;
  if ('ticks' in s) {
    return s.ticks(numTicks);
  }
  return s.domain().filter(function (_, index, arr) {
    return numTicks == null || arr.length <= numTicks || index % Math.round((arr.length - 1) / numTicks) === 0;
  });
}
;// CONCATENATED MODULE: ./node_modules/@visx/scale/esm/utils/coerceNumber.js
function coerceNumber(val) {
  if ((typeof val === 'function' || typeof val === 'object' && !!val) && 'valueOf' in val) {
    var num = val.valueOf();
    if (typeof num === 'number') return num;
  }
  return val;
}
;// CONCATENATED MODULE: ./node_modules/@visx/shape/esm/shapes/Line.js
var Line_excluded = ["from", "to", "fill", "className", "innerRef"];
function Line_extends() { Line_extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return Line_extends.apply(this, arguments); }
function Line_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }


function Line(_ref) {
  var _ref$from = _ref.from,
    from = _ref$from === void 0 ? {
      x: 0,
      y: 0
    } : _ref$from,
    _ref$to = _ref.to,
    to = _ref$to === void 0 ? {
      x: 1,
      y: 1
    } : _ref$to,
    _ref$fill = _ref.fill,
    fill = _ref$fill === void 0 ? 'transparent' : _ref$fill,
    className = _ref.className,
    innerRef = _ref.innerRef,
    restProps = Line_objectWithoutPropertiesLoose(_ref, Line_excluded);
  var isRectilinear = from.x === to.x || from.y === to.y;
  return /*#__PURE__*/react.createElement("line", Line_extends({
    ref: innerRef,
    className: classnames_default()('visx-line', className),
    x1: from.x,
    y1: from.y,
    x2: to.x,
    y2: to.y,
    fill: fill,
    shapeRendering: isRectilinear ? 'crispEdges' : 'auto'
  }, restProps));
}
// EXTERNAL MODULE: ./node_modules/reduce-css-calc/index.js
var reduce_css_calc = __webpack_require__(4495);
var reduce_css_calc_default = /*#__PURE__*/__webpack_require__.n(reduce_css_calc);
// EXTERNAL MODULE: ./node_modules/lodash/memoize.js
var memoize = __webpack_require__(5210);
var memoize_default = /*#__PURE__*/__webpack_require__.n(memoize);
;// CONCATENATED MODULE: ./node_modules/@visx/text/esm/util/getStringWidth.js

var MEASUREMENT_ELEMENT_ID = '__react_svg_text_measurement_id';
function getStringWidth(str, style) {
  try {
    // Calculate length of each word to be used to determine number of words per line
    var textEl = document.getElementById(MEASUREMENT_ELEMENT_ID);
    if (!textEl) {
      var svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
      svg.setAttribute('aria-hidden', 'true');
      svg.style.width = '0';
      svg.style.height = '0';
      svg.style.position = 'absolute';
      svg.style.top = '-100%';
      svg.style.left = '-100%';
      textEl = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      textEl.setAttribute('id', MEASUREMENT_ELEMENT_ID);
      svg.appendChild(textEl);
      document.body.appendChild(svg);
    }
    Object.assign(textEl.style, style);
    textEl.textContent = str;
    return textEl.getComputedTextLength();
  } catch (e) {
    return null;
  }
}
/* harmony default export */ const util_getStringWidth = (memoize_default()(getStringWidth, function (str, style) {
  return str + "_" + JSON.stringify(style);
}));
;// CONCATENATED MODULE: ./node_modules/@visx/text/esm/hooks/useText.js
var useText_excluded = ["verticalAnchor", "scaleToFit", "angle", "width", "lineHeight", "capHeight", "children", "style"];
function useText_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }



function isNumber(val) {
  return typeof val === 'number';
}
function isXOrYInValid(xOrY) {
  return (
    // number that is not NaN or Infinity
    typeof xOrY === 'number' && Number.isFinite(xOrY) ||
    // for percentage
    typeof xOrY === 'string'
  );
}
function useText(props) {
  var _props$verticalAnchor = props.verticalAnchor,
    verticalAnchor = _props$verticalAnchor === void 0 ? 'end' : _props$verticalAnchor,
    _props$scaleToFit = props.scaleToFit,
    scaleToFit = _props$scaleToFit === void 0 ? false : _props$scaleToFit,
    angle = props.angle,
    width = props.width,
    _props$lineHeight = props.lineHeight,
    lineHeight = _props$lineHeight === void 0 ? '1em' : _props$lineHeight,
    _props$capHeight = props.capHeight,
    capHeight = _props$capHeight === void 0 ? '0.71em' : _props$capHeight,
    children = props.children,
    style = props.style,
    textProps = useText_objectWithoutPropertiesLoose(props, useText_excluded);
  var _textProps$x = textProps.x,
    x = _textProps$x === void 0 ? 0 : _textProps$x,
    _textProps$y = textProps.y,
    y = _textProps$y === void 0 ? 0 : _textProps$y;
  var isXOrYNotValid = !isXOrYInValid(x) || !isXOrYInValid(y);
  var _useMemo = (0,react.useMemo)(function () {
      var words = children == null ? [] : children.toString().split(/(?:(?!\u00A0+)\s+)/);
      return {
        wordsWithWidth: words.map(function (word) {
          return {
            word: word,
            wordWidth: util_getStringWidth(word, style) || 0
          };
        }),
        spaceWidth: util_getStringWidth("\xA0", style) || 0
      };
    }, [children, style]),
    wordsWithWidth = _useMemo.wordsWithWidth,
    spaceWidth = _useMemo.spaceWidth;
  var wordsByLines = (0,react.useMemo)(function () {
    if (isXOrYNotValid) {
      return [];
    }

    // Only perform calculations if using features that require them (multiline, scaleToFit)
    if (width || scaleToFit) {
      return wordsWithWidth.reduce(function (result, _ref) {
        var word = _ref.word,
          wordWidth = _ref.wordWidth;
        var currentLine = result[result.length - 1];
        if (currentLine && (width == null || scaleToFit || (currentLine.width || 0) + wordWidth + spaceWidth < width)) {
          // Word can be added to an existing line
          currentLine.words.push(word);
          currentLine.width = currentLine.width || 0;
          currentLine.width += wordWidth + spaceWidth;
        } else {
          // Add first word to line or word is too long to scaleToFit on existing line
          var newLine = {
            words: [word],
            width: wordWidth
          };
          result.push(newLine);
        }
        return result;
      }, []);
    }
    return [{
      words: children == null ? [] : children.toString().split(/(?:(?!\u00A0+)\s+)/)
    }];
  }, [isXOrYNotValid, width, scaleToFit, children, wordsWithWidth, spaceWidth]);
  var startDy = (0,react.useMemo)(function () {
    var startDyStr = isXOrYNotValid ? '' : verticalAnchor === 'start' ? reduce_css_calc_default()("calc(" + capHeight + ")") : verticalAnchor === 'middle' ? reduce_css_calc_default()("calc(" + (wordsByLines.length - 1) / 2 + " * -" + lineHeight + " + (" + capHeight + " / 2))") : reduce_css_calc_default()("calc(" + (wordsByLines.length - 1) + " * -" + lineHeight + ")");
    return startDyStr;
  }, [isXOrYNotValid, verticalAnchor, capHeight, wordsByLines.length, lineHeight]);
  var transform = (0,react.useMemo)(function () {
    var transforms = [];
    if (isXOrYNotValid) {
      return '';
    }
    if (isNumber(x) && isNumber(y) && isNumber(width) && scaleToFit && wordsByLines.length > 0) {
      var lineWidth = wordsByLines[0].width || 1;
      var sx = scaleToFit === 'shrink-only' ? Math.min(width / lineWidth, 1) : width / lineWidth;
      var sy = sx;
      var originX = x - sx * x;
      var originY = y - sy * y;
      transforms.push("matrix(" + sx + ", 0, 0, " + sy + ", " + originX + ", " + originY + ")");
    }
    if (angle) {
      transforms.push("rotate(" + angle + ", " + x + ", " + y + ")");
    }
    return transforms.length > 0 ? transforms.join(' ') : '';
  }, [isXOrYNotValid, x, y, width, scaleToFit, wordsByLines, angle]);
  return {
    wordsByLines: wordsByLines,
    startDy: startDy,
    transform: transform
  };
}
;// CONCATENATED MODULE: ./node_modules/@visx/text/esm/Text.js
var Text_excluded = ["dx", "dy", "textAnchor", "innerRef", "innerTextRef", "verticalAnchor", "angle", "lineHeight", "scaleToFit", "capHeight", "width"];
function Text_extends() { Text_extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return Text_extends.apply(this, arguments); }
function Text_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }


var SVG_STYLE = {
  overflow: 'visible'
};
function Text(props) {
  var _props$dx = props.dx,
    dx = _props$dx === void 0 ? 0 : _props$dx,
    _props$dy = props.dy,
    dy = _props$dy === void 0 ? 0 : _props$dy,
    _props$textAnchor = props.textAnchor,
    textAnchor = _props$textAnchor === void 0 ? 'start' : _props$textAnchor,
    innerRef = props.innerRef,
    innerTextRef = props.innerTextRef,
    verticalAnchor = props.verticalAnchor,
    angle = props.angle,
    _props$lineHeight = props.lineHeight,
    lineHeight = _props$lineHeight === void 0 ? '1em' : _props$lineHeight,
    _props$scaleToFit = props.scaleToFit,
    scaleToFit = _props$scaleToFit === void 0 ? false : _props$scaleToFit,
    capHeight = props.capHeight,
    width = props.width,
    textProps = Text_objectWithoutPropertiesLoose(props, Text_excluded);
  var _textProps$x = textProps.x,
    x = _textProps$x === void 0 ? 0 : _textProps$x,
    fontSize = textProps.fontSize;
  var _useText = useText(props),
    wordsByLines = _useText.wordsByLines,
    startDy = _useText.startDy,
    transform = _useText.transform;
  return /*#__PURE__*/react.createElement("svg", {
    ref: innerRef,
    x: dx,
    y: dy,
    fontSize: fontSize,
    style: SVG_STYLE
  }, wordsByLines.length > 0 ? /*#__PURE__*/react.createElement("text", Text_extends({
    ref: innerTextRef,
    transform: transform
  }, textProps, {
    textAnchor: textAnchor
  }), wordsByLines.map(function (line, index) {
    return /*#__PURE__*/react.createElement("tspan", {
      key: index,
      x: x,
      dy: index === 0 ? startDy : lineHeight
    }, line.words.join(' '));
  })) : null);
}
;// CONCATENATED MODULE: ./node_modules/@visx/axis/esm/constants/orientation.js
var Orientation = {
  top: 'top',
  left: 'left',
  right: 'right',
  bottom: 'bottom'
};
/* harmony default export */ const constants_orientation = (Orientation);
;// CONCATENATED MODULE: ./node_modules/@visx/axis/esm/utils/getLabelTransform.js

function getLabelTransform(_ref) {
  var labelOffset = _ref.labelOffset,
    labelProps = _ref.labelProps,
    orientation = _ref.orientation,
    range = _ref.range,
    tickLabelFontSize = _ref.tickLabelFontSize,
    tickLength = _ref.tickLength;
  var sign = orientation === constants_orientation.left || orientation === constants_orientation.top ? -1 : 1;
  var x;
  var y;
  var transform;
  if (orientation === constants_orientation.top || orientation === constants_orientation.bottom) {
    var yBottomOffset = orientation === constants_orientation.bottom && typeof labelProps.fontSize === 'number' ? labelProps.fontSize : 0;
    x = (Number(range[0]) + Number(range[range.length - 1])) / 2;
    y = sign * (tickLength + labelOffset + tickLabelFontSize + yBottomOffset);
  } else {
    x = sign * ((Number(range[0]) + Number(range[range.length - 1])) / 2);
    y = -(tickLength + labelOffset);
    transform = "rotate(" + sign * 90 + ")";
  }
  return {
    x: x,
    y: y,
    transform: transform
  };
}
;// CONCATENATED MODULE: ./node_modules/@visx/axis/esm/axis/Ticks.js
function Ticks_extends() { Ticks_extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return Ticks_extends.apply(this, arguments); }






function Ticks(_ref) {
  var hideTicks = _ref.hideTicks,
    horizontal = _ref.horizontal,
    orientation = _ref.orientation,
    tickClassName = _ref.tickClassName,
    tickComponent = _ref.tickComponent,
    allTickLabelProps = _ref.tickLabelProps,
    _ref$tickStroke = _ref.tickStroke,
    tickStroke = _ref$tickStroke === void 0 ? '#222' : _ref$tickStroke,
    tickTransform = _ref.tickTransform,
    ticks = _ref.ticks,
    strokeWidth = _ref.strokeWidth,
    tickLineProps = _ref.tickLineProps;
  return ticks.map(function (_ref2) {
    var _allTickLabelProps$in;
    var value = _ref2.value,
      index = _ref2.index,
      from = _ref2.from,
      to = _ref2.to,
      formattedValue = _ref2.formattedValue;
    var tickLabelProps = (_allTickLabelProps$in = allTickLabelProps[index]) != null ? _allTickLabelProps$in : {};
    var tickLabelFontSize = Math.max(10, typeof tickLabelProps.fontSize === 'number' && tickLabelProps.fontSize || 0);
    var tickYCoord = to.y + (horizontal && orientation !== constants_orientation.top ? tickLabelFontSize : 0);
    return /*#__PURE__*/react.createElement(Group, {
      key: "visx-tick-" + value + "-" + index,
      className: classnames_default()('visx-axis-tick', tickClassName),
      transform: tickTransform
    }, !hideTicks && /*#__PURE__*/react.createElement(Line, Ticks_extends({
      from: from,
      to: to,
      stroke: tickStroke,
      strokeWidth: strokeWidth,
      strokeLinecap: "square"
    }, tickLineProps)), tickComponent ? tickComponent(Ticks_extends({}, tickLabelProps, {
      x: to.x,
      y: tickYCoord,
      formattedValue: formattedValue
    })) : /*#__PURE__*/react.createElement(Text, Ticks_extends({
      x: to.x,
      y: tickYCoord
    }, tickLabelProps), formattedValue));
  });
}
;// CONCATENATED MODULE: ./node_modules/@visx/axis/esm/axis/AxisRenderer.js
function AxisRenderer_extends() { AxisRenderer_extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return AxisRenderer_extends.apply(this, arguments); }







var defaultTextProps = {
  textAnchor: 'middle',
  fontFamily: 'Arial',
  fontSize: 10,
  fill: '#222'
};
function AxisRenderer(_ref) {
  var axisFromPoint = _ref.axisFromPoint,
    axisLineClassName = _ref.axisLineClassName,
    axisToPoint = _ref.axisToPoint,
    hideAxisLine = _ref.hideAxisLine,
    hideTicks = _ref.hideTicks,
    horizontal = _ref.horizontal,
    _ref$label = _ref.label,
    label = _ref$label === void 0 ? '' : _ref$label,
    labelClassName = _ref.labelClassName,
    _ref$labelOffset = _ref.labelOffset,
    labelOffset = _ref$labelOffset === void 0 ? 14 : _ref$labelOffset,
    _ref$labelProps = _ref.labelProps,
    labelProps = _ref$labelProps === void 0 ? defaultTextProps : _ref$labelProps,
    _ref$orientation = _ref.orientation,
    orientation = _ref$orientation === void 0 ? constants_orientation.bottom : _ref$orientation,
    scale = _ref.scale,
    _ref$stroke = _ref.stroke,
    stroke = _ref$stroke === void 0 ? '#222' : _ref$stroke,
    strokeDasharray = _ref.strokeDasharray,
    _ref$strokeWidth = _ref.strokeWidth,
    strokeWidth = _ref$strokeWidth === void 0 ? 1 : _ref$strokeWidth,
    tickClassName = _ref.tickClassName,
    tickComponent = _ref.tickComponent,
    tickLineProps = _ref.tickLineProps,
    _ref$tickLabelProps = _ref.tickLabelProps,
    tickLabelProps = _ref$tickLabelProps === void 0 ? function /** tickValue, index, tickValues */ () {
      return defaultTextProps;
    } : _ref$tickLabelProps,
    _ref$tickLength = _ref.tickLength,
    tickLength = _ref$tickLength === void 0 ? 8 : _ref$tickLength,
    _ref$tickStroke = _ref.tickStroke,
    tickStroke = _ref$tickStroke === void 0 ? '#222' : _ref$tickStroke,
    tickTransform = _ref.tickTransform,
    ticks = _ref.ticks,
    _ref$ticksComponent = _ref.ticksComponent,
    ticksComponent = _ref$ticksComponent === void 0 ? Ticks : _ref$ticksComponent;
  // compute the max tick label size to compute label offset
  var allTickLabelProps = ticks.map(function (_ref2) {
    var value = _ref2.value,
      index = _ref2.index;
    return tickLabelProps(value, index, ticks);
  });
  var maxTickLabelFontSize = Math.max.apply(Math, [10].concat(allTickLabelProps.map(function (props) {
    return typeof props.fontSize === 'number' ? props.fontSize : 0;
  })));
  return /*#__PURE__*/react.createElement(react.Fragment, null, ticksComponent({
    hideTicks: hideTicks,
    horizontal: horizontal,
    orientation: orientation,
    scale: scale,
    tickClassName: tickClassName,
    tickComponent: tickComponent,
    tickLabelProps: allTickLabelProps,
    tickStroke: tickStroke,
    tickTransform: tickTransform,
    ticks: ticks,
    strokeWidth: strokeWidth,
    tickLineProps: tickLineProps
  }), !hideAxisLine && /*#__PURE__*/react.createElement(Line, {
    className: classnames_default()('visx-axis-line', axisLineClassName),
    from: axisFromPoint,
    to: axisToPoint,
    stroke: stroke,
    strokeWidth: strokeWidth,
    strokeDasharray: strokeDasharray
  }), label && /*#__PURE__*/react.createElement(Text, AxisRenderer_extends({
    className: classnames_default()('visx-axis-label', labelClassName)
  }, getLabelTransform({
    labelOffset: labelOffset,
    labelProps: labelProps,
    orientation: orientation,
    range: scale.range(),
    tickLabelFontSize: maxTickLabelFontSize,
    tickLength: tickLength
  }), labelProps), label));
}
;// CONCATENATED MODULE: ./node_modules/@visx/axis/esm/utils/getTickPosition.js
/**
 * Create a function that returns a tick position for the given tick value
 */
function getTickPosition(scale, align) {
  if (align === void 0) {
    align = 'center';
  }
  // Broaden type before using 'xxx' in s as typeguard.
  var s = scale;

  // For point or band scales,
  // have to add offset to make the tick at center or end.
  if (align !== 'start' && 'bandwidth' in s) {
    var offset = s.bandwidth();
    if (align === 'center') offset /= 2;
    if (s.round()) offset = Math.round(offset);
    return function (d) {
      var scaledValue = s(d);
      return typeof scaledValue === 'number' ? scaledValue + offset : scaledValue;
    };
  }
  return scale;
}
;// CONCATENATED MODULE: ./node_modules/@visx/scale/esm/utils/toString.js
function toString_toString(x) {
  return x == null ? void 0 : x.toString();
}
;// CONCATENATED MODULE: ./node_modules/@visx/axis/esm/utils/getTickFormatter.js

/**
 * Returns a tick position for the given tick value
 */
function getTickFormatter(scale) {
  // Broaden type before using 'xxx' in s as typeguard.
  var s = scale;

  // For point or band scales,
  // have to add offset to make the tick centered.
  if ('tickFormat' in s) {
    return s.tickFormat();
  }
  return toString_toString;
}
;// CONCATENATED MODULE: ./node_modules/@visx/axis/node_modules/@visx/point/esm/Point.js
var Point = /*#__PURE__*/function () {
  function Point(_ref) {
    var _ref$x = _ref.x,
      x = _ref$x === void 0 ? 0 : _ref$x,
      _ref$y = _ref.y,
      y = _ref$y === void 0 ? 0 : _ref$y;
    this.x = 0;
    this.y = 0;
    this.x = x;
    this.y = y;
  }
  var _proto = Point.prototype;
  _proto.value = function value() {
    return {
      x: this.x,
      y: this.y
    };
  };
  _proto.toArray = function toArray() {
    return [this.x, this.y];
  };
  return Point;
}();

;// CONCATENATED MODULE: ./node_modules/@visx/axis/esm/utils/createPoint.js

function createPoint(_ref, horizontal) {
  var x = _ref.x,
    y = _ref.y;
  return new Point(horizontal ? {
    x: x,
    y: y
  } : {
    x: y,
    y: x
  });
}
;// CONCATENATED MODULE: ./node_modules/@visx/axis/esm/utils/getAxisRangePaddingConfig.js
function getAxisRangePaddingConfig_extends() { getAxisRangePaddingConfig_extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return getAxisRangePaddingConfig_extends.apply(this, arguments); }
var defaultAxisRangePadding = 0;
function getAxisRangePaddingConfig(originalRangePadding) {
  if (originalRangePadding === void 0) {
    originalRangePadding = defaultAxisRangePadding;
  }
  return typeof originalRangePadding === 'number' ? {
    start: originalRangePadding,
    end: originalRangePadding
  } : getAxisRangePaddingConfig_extends({
    start: defaultAxisRangePadding,
    end: defaultAxisRangePadding
  }, originalRangePadding);
}
;// CONCATENATED MODULE: ./node_modules/@visx/axis/esm/axis/Axis.js

var Axis_excluded = ["children", "axisClassName", "hideAxisLine", "hideTicks", "hideZero", "left", "numTicks", "orientation", "rangePadding", "scale", "tickFormat", "tickLength", "tickValues", "top"];
function Axis_extends() { Axis_extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return Axis_extends.apply(this, arguments); }
function Axis_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }










function Axis(_ref) {
  var _ref$children = _ref.children,
    children = _ref$children === void 0 ? AxisRenderer : _ref$children,
    axisClassName = _ref.axisClassName,
    _ref$hideAxisLine = _ref.hideAxisLine,
    hideAxisLine = _ref$hideAxisLine === void 0 ? false : _ref$hideAxisLine,
    _ref$hideTicks = _ref.hideTicks,
    hideTicks = _ref$hideTicks === void 0 ? false : _ref$hideTicks,
    _ref$hideZero = _ref.hideZero,
    hideZero = _ref$hideZero === void 0 ? false : _ref$hideZero,
    _ref$left = _ref.left,
    left = _ref$left === void 0 ? 0 : _ref$left,
    _ref$numTicks = _ref.numTicks,
    numTicks = _ref$numTicks === void 0 ? 10 : _ref$numTicks,
    _ref$orientation = _ref.orientation,
    orientation = _ref$orientation === void 0 ? constants_orientation.bottom : _ref$orientation,
    _ref$rangePadding = _ref.rangePadding,
    rangePadding = _ref$rangePadding === void 0 ? 0 : _ref$rangePadding,
    scale = _ref.scale,
    tickFormat = _ref.tickFormat,
    _ref$tickLength = _ref.tickLength,
    tickLength = _ref$tickLength === void 0 ? 8 : _ref$tickLength,
    tickValues = _ref.tickValues,
    _ref$top = _ref.top,
    top = _ref$top === void 0 ? 0 : _ref$top,
    restProps = Axis_objectWithoutPropertiesLoose(_ref, Axis_excluded);
  var format = tickFormat != null ? tickFormat : getTickFormatter(scale);
  var isLeft = orientation === constants_orientation.left;
  var isTop = orientation === constants_orientation.top;
  var horizontal = isTop || orientation === constants_orientation.bottom;
  var tickPosition = getTickPosition(scale);
  var tickSign = isLeft || isTop ? -1 : 1;
  var range = scale.range();
  var rangePaddingConfig = getAxisRangePaddingConfig(rangePadding);
  var axisFromPoint = createPoint({
    x: Number(range[0]) + 0.5 - rangePaddingConfig.start,
    y: 0
  }, horizontal);
  var axisToPoint = createPoint({
    x: Number(range[range.length - 1]) + 0.5 + rangePaddingConfig.end,
    y: 0
  }, horizontal);
  var filteredTickValues = (tickValues != null ? tickValues : getTicks(scale, numTicks)).filter(function (value) {
    return !hideZero || value !== 0 && value !== '0';
  }).map(function (value, index) {
    return {
      value: value,
      index: index
    };
  });
  var ticks = filteredTickValues.map(function (_ref2) {
    var value = _ref2.value,
      index = _ref2.index;
    var scaledValue = coerceNumber(tickPosition(value));
    return {
      value: value,
      index: index,
      from: createPoint({
        x: scaledValue,
        y: 0
      }, horizontal),
      to: createPoint({
        x: scaledValue,
        y: tickLength * tickSign
      }, horizontal),
      formattedValue: format(value, index, filteredTickValues)
    };
  });
  return /*#__PURE__*/react.createElement(Group, {
    className: classnames_default()('visx-axis', axisClassName),
    top: top,
    left: left
  }, children(Axis_extends({}, restProps, {
    axisFromPoint: axisFromPoint,
    axisToPoint: axisToPoint,
    hideAxisLine: hideAxisLine,
    hideTicks: hideTicks,
    hideZero: hideZero,
    horizontal: horizontal,
    numTicks: numTicks,
    orientation: orientation,
    rangePadding: rangePadding,
    scale: scale,
    tickFormat: format,
    tickLength: tickLength,
    tickPosition: tickPosition,
    tickSign: tickSign,
    ticks: ticks
  })));
}
;// CONCATENATED MODULE: ./node_modules/@visx/axis/esm/axis/AxisRight.js
var AxisRight_excluded = ["axisClassName", "labelOffset", "tickLabelProps", "tickLength"];
function AxisRight_extends() { AxisRight_extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return AxisRight_extends.apply(this, arguments); }
function AxisRight_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }




var rightTickLabelProps = function rightTickLabelProps( /** tickValue, index */
) {
  return {
    dx: '0.25em',
    dy: '0.25em',
    fill: '#222',
    fontFamily: 'Arial',
    fontSize: 10,
    textAnchor: 'start'
  };
};
function AxisRight(_ref) {
  var axisClassName = _ref.axisClassName,
    _ref$labelOffset = _ref.labelOffset,
    labelOffset = _ref$labelOffset === void 0 ? 36 : _ref$labelOffset,
    _ref$tickLabelProps = _ref.tickLabelProps,
    tickLabelProps = _ref$tickLabelProps === void 0 ? rightTickLabelProps : _ref$tickLabelProps,
    _ref$tickLength = _ref.tickLength,
    tickLength = _ref$tickLength === void 0 ? 8 : _ref$tickLength,
    restProps = AxisRight_objectWithoutPropertiesLoose(_ref, AxisRight_excluded);
  return /*#__PURE__*/react.createElement(Axis, AxisRight_extends({
    axisClassName: classnames_default()('visx-axis-right', axisClassName),
    labelOffset: labelOffset,
    orientation: constants_orientation.right,
    tickLabelProps: tickLabelProps,
    tickLength: tickLength
  }, restProps));
}
// EXTERNAL MODULE: ./node_modules/@visx/shape/lib/shapes/Line.js
var shapes_Line = __webpack_require__(1862);
;// CONCATENATED MODULE: ./node_modules/@visx/grid/node_modules/@visx/point/esm/Point.js
var Point_Point = /*#__PURE__*/function () {
  function Point(_ref) {
    var _ref$x = _ref.x,
      x = _ref$x === void 0 ? 0 : _ref$x,
      _ref$y = _ref.y,
      y = _ref$y === void 0 ? 0 : _ref$y;
    this.x = 0;
    this.y = 0;
    this.x = x;
    this.y = y;
  }
  var _proto = Point.prototype;
  _proto.value = function value() {
    return {
      x: this.x,
      y: this.y
    };
  };
  _proto.toArray = function toArray() {
    return [this.x, this.y];
  };
  return Point;
}();

;// CONCATENATED MODULE: ./node_modules/@visx/grid/esm/utils/getScaleBandwidth.js
function getScaleBandwidth(scale) {
  return 'bandwidth' in scale ? scale.bandwidth() : 0;
}
;// CONCATENATED MODULE: ./node_modules/@visx/grid/esm/grids/GridRows.js

var GridRows_excluded = ["top", "left", "scale", "width", "stroke", "strokeWidth", "strokeDasharray", "className", "children", "numTicks", "lineStyle", "offset", "tickValues"];
function GridRows_extends() { GridRows_extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return GridRows_extends.apply(this, arguments); }
function GridRows_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }







function GridRows(_ref) {
  var _ref$top = _ref.top,
    top = _ref$top === void 0 ? 0 : _ref$top,
    _ref$left = _ref.left,
    left = _ref$left === void 0 ? 0 : _ref$left,
    scale = _ref.scale,
    width = _ref.width,
    _ref$stroke = _ref.stroke,
    stroke = _ref$stroke === void 0 ? '#eaf0f6' : _ref$stroke,
    _ref$strokeWidth = _ref.strokeWidth,
    strokeWidth = _ref$strokeWidth === void 0 ? 1 : _ref$strokeWidth,
    strokeDasharray = _ref.strokeDasharray,
    className = _ref.className,
    children = _ref.children,
    _ref$numTicks = _ref.numTicks,
    numTicks = _ref$numTicks === void 0 ? 10 : _ref$numTicks,
    lineStyle = _ref.lineStyle,
    offset = _ref.offset,
    tickValues = _ref.tickValues,
    restProps = GridRows_objectWithoutPropertiesLoose(_ref, GridRows_excluded);
  var ticks = tickValues != null ? tickValues : getTicks(scale, numTicks);
  var scaleOffset = (offset != null ? offset : 0) + getScaleBandwidth(scale) / 2;
  var tickLines = ticks.map(function (d, index) {
    var _coerceNumber;
    var y = ((_coerceNumber = coerceNumber(scale(d))) != null ? _coerceNumber : 0) + scaleOffset;
    return {
      index: index,
      from: new Point_Point({
        x: 0,
        y: y
      }),
      to: new Point_Point({
        x: width,
        y: y
      })
    };
  });
  return /*#__PURE__*/react.createElement(Group, {
    className: classnames_default()('visx-rows', className),
    top: top,
    left: left
  }, children ? children({
    lines: tickLines
  }) : tickLines.map(function (_ref2) {
    var from = _ref2.from,
      to = _ref2.to,
      index = _ref2.index;
    return /*#__PURE__*/react.createElement(shapes_Line/* default */.Z, GridRows_extends({
      key: "row-line-" + index,
      from: from,
      to: to,
      stroke: stroke,
      strokeWidth: strokeWidth,
      strokeDasharray: strokeDasharray,
      style: lineStyle
    }, restProps));
  }));
}
GridRows.propTypes = {
  tickValues: (prop_types_default()).array,
  width: (prop_types_default()).number.isRequired
};
;// CONCATENATED MODULE: ./node_modules/@visx/gradient/esm/gradients/LinearGradient.js

var LinearGradient_excluded = ["children", "id", "from", "to", "x1", "y1", "x2", "y2", "fromOffset", "fromOpacity", "toOffset", "toOpacity", "rotate", "transform", "vertical"];

function LinearGradient_extends() { LinearGradient_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return LinearGradient_extends.apply(this, arguments); }

function LinearGradient_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }


function LinearGradient(_ref) {
  var children = _ref.children,
      id = _ref.id,
      from = _ref.from,
      to = _ref.to,
      _x1 = _ref.x1,
      _y1 = _ref.y1,
      _x2 = _ref.x2,
      _y2 = _ref.y2,
      _ref$fromOffset = _ref.fromOffset,
      fromOffset = _ref$fromOffset === void 0 ? '0%' : _ref$fromOffset,
      _ref$fromOpacity = _ref.fromOpacity,
      fromOpacity = _ref$fromOpacity === void 0 ? 1 : _ref$fromOpacity,
      _ref$toOffset = _ref.toOffset,
      toOffset = _ref$toOffset === void 0 ? '100%' : _ref$toOffset,
      _ref$toOpacity = _ref.toOpacity,
      toOpacity = _ref$toOpacity === void 0 ? 1 : _ref$toOpacity,
      rotate = _ref.rotate,
      transform = _ref.transform,
      _ref$vertical = _ref.vertical,
      vertical = _ref$vertical === void 0 ? true : _ref$vertical,
      restProps = LinearGradient_objectWithoutPropertiesLoose(_ref, LinearGradient_excluded);

  var x1 = _x1;
  var x2 = _x2;
  var y1 = _y1;
  var y2 = _y2;

  if (vertical && !x1 && !x2 && !y1 && !y2) {
    x1 = '0';
    x2 = '0';
    y1 = '0';
    y2 = '1';
  }

  return /*#__PURE__*/react.createElement("defs", null, /*#__PURE__*/react.createElement("linearGradient", LinearGradient_extends({
    id: id,
    x1: x1,
    y1: y1,
    x2: x2,
    y2: y2,
    gradientTransform: rotate ? "rotate(" + rotate + ")" : transform
  }, restProps), !!children && children, !children && /*#__PURE__*/react.createElement("stop", {
    offset: fromOffset,
    stopColor: from,
    stopOpacity: fromOpacity
  }), !children && /*#__PURE__*/react.createElement("stop", {
    offset: toOffset,
    stopColor: to,
    stopOpacity: toOpacity
  })));
}
LinearGradient.propTypes = {
  id: (prop_types_default()).string.isRequired,
  from: (prop_types_default()).string,
  to: (prop_types_default()).string,
  x1: prop_types_default().oneOfType([(prop_types_default()).string, (prop_types_default()).number]),
  x2: prop_types_default().oneOfType([(prop_types_default()).string, (prop_types_default()).number]),
  y1: prop_types_default().oneOfType([(prop_types_default()).string, (prop_types_default()).number]),
  y2: prop_types_default().oneOfType([(prop_types_default()).string, (prop_types_default()).number]),
  fromOffset: prop_types_default().oneOfType([(prop_types_default()).string, (prop_types_default()).number]),
  fromOpacity: prop_types_default().oneOfType([(prop_types_default()).string, (prop_types_default()).number]),
  toOffset: prop_types_default().oneOfType([(prop_types_default()).string, (prop_types_default()).number]),
  toOpacity: prop_types_default().oneOfType([(prop_types_default()).string, (prop_types_default()).number]),
  rotate: prop_types_default().oneOfType([(prop_types_default()).string, (prop_types_default()).number]),
  transform: (prop_types_default()).string,
  children: (prop_types_default()).node,
  vertical: (prop_types_default()).bool
};
;// CONCATENATED MODULE: ./node_modules/d3-array/src/ascending.js
function ascending_ascending(a, b) {
  return a == null || b == null ? NaN : a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}

;// CONCATENATED MODULE: ./node_modules/d3-array/src/descending.js
function descending(a, b) {
  return a == null || b == null ? NaN
    : b < a ? -1
    : b > a ? 1
    : b >= a ? 0
    : NaN;
}

;// CONCATENATED MODULE: ./node_modules/d3-array/src/bisector.js



function bisector_bisector(f) {
  let compare1, compare2, delta;

  // If an accessor is specified, promote it to a comparator. In this case we
  // can test whether the search value is (self-) comparable. We cant do this
  // for a comparator (except for specific, known comparators) because we cant
  // tell if the comparator is symmetric, and an asymmetric comparator cant be
  // used to test whether a single value is comparable.
  if (f.length !== 2) {
    compare1 = ascending_ascending;
    compare2 = (d, x) => ascending_ascending(f(d), x);
    delta = (d, x) => f(d) - x;
  } else {
    compare1 = f === ascending_ascending || f === descending ? f : bisector_zero;
    compare2 = f;
    delta = f;
  }

  function left(a, x, lo = 0, hi = a.length) {
    if (lo < hi) {
      if (compare1(x, x) !== 0) return hi;
      do {
        const mid = (lo + hi) >>> 1;
        if (compare2(a[mid], x) < 0) lo = mid + 1;
        else hi = mid;
      } while (lo < hi);
    }
    return lo;
  }

  function right(a, x, lo = 0, hi = a.length) {
    if (lo < hi) {
      if (compare1(x, x) !== 0) return hi;
      do {
        const mid = (lo + hi) >>> 1;
        if (compare2(a[mid], x) <= 0) lo = mid + 1;
        else hi = mid;
      } while (lo < hi);
    }
    return lo;
  }

  function center(a, x, lo = 0, hi = a.length) {
    const i = left(a, x, lo, hi - 1);
    return i > lo && delta(a[i - 1], x) > -delta(a[i], x) ? i - 1 : i;
  }

  return {left, center, right};
}

function bisector_zero() {
  return 0;
}

;// CONCATENATED MODULE: ./node_modules/@visx/point/esm/Point.js
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var esm_Point_Point = /*#__PURE__*/function () {
  function Point(_ref) {
    var _ref$x = _ref.x,
        x = _ref$x === void 0 ? 0 : _ref$x,
        _ref$y = _ref.y,
        y = _ref$y === void 0 ? 0 : _ref$y;

    _defineProperty(this, "x", 0);

    _defineProperty(this, "y", 0);

    this.x = x;
    this.y = y;
  }

  var _proto = Point.prototype;

  _proto.value = function value() {
    return {
      x: this.x,
      y: this.y
    };
  };

  _proto.toArray = function toArray() {
    return [this.x, this.y];
  };

  return Point;
}();


;// CONCATENATED MODULE: ./node_modules/@visx/event/esm/typeGuards.js
function isElement(elem) {
  return !!elem && elem instanceof Element;
} // functional definition of isSVGElement. Note that SVGSVGElements are HTMLElements

function isSVGElement(elem) {
  return !!elem && (elem instanceof SVGElement || 'ownerSVGElement' in elem);
} // functional definition of SVGGElement

function isSVGSVGElement(elem) {
  return !!elem && 'createSVGPoint' in elem;
}
function isSVGGraphicsElement(elem) {
  return !!elem && 'getScreenCTM' in elem;
} // functional definition of TouchEvent

function isTouchEvent(event) {
  return !!event && 'changedTouches' in event;
} // functional definition of MouseEvent

function isMouseEvent(event) {
  return !!event && 'clientX' in event;
} // functional definition of event

function isEvent(event) {
  return !!event && (event instanceof Event || 'nativeEvent' in event && event.nativeEvent instanceof Event);
}
;// CONCATENATED MODULE: ./node_modules/@visx/event/esm/getXAndYFromEvent.js
function getXAndYFromEvent_extends() { getXAndYFromEvent_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return getXAndYFromEvent_extends.apply(this, arguments); }


var DEFAULT_POINT = {
  x: 0,
  y: 0
};
function getXAndYFromEvent(event) {
  if (!event) return getXAndYFromEvent_extends({}, DEFAULT_POINT);

  if (isTouchEvent(event)) {
    return event.changedTouches.length > 0 ? {
      x: event.changedTouches[0].clientX,
      y: event.changedTouches[0].clientY
    } : getXAndYFromEvent_extends({}, DEFAULT_POINT);
  }

  if (isMouseEvent(event)) {
    return {
      x: event.clientX,
      y: event.clientY
    };
  } // for focus events try to extract the center position of the target element


  var target = event == null ? void 0 : event.target;
  var boundingClientRect = target && 'getBoundingClientRect' in target ? target.getBoundingClientRect() : null;
  if (!boundingClientRect) return getXAndYFromEvent_extends({}, DEFAULT_POINT);
  return {
    x: boundingClientRect.x + boundingClientRect.width / 2,
    y: boundingClientRect.y + boundingClientRect.height / 2
  };
}
;// CONCATENATED MODULE: ./node_modules/@visx/event/esm/localPointGeneric.js



function localPoint(node, event) {
  if (!node || !event) return null;
  var coords = getXAndYFromEvent(event); // find top-most SVG

  var svg = isSVGElement(node) ? node.ownerSVGElement : node;
  var screenCTM = isSVGGraphicsElement(svg) ? svg.getScreenCTM() : null;

  if (isSVGSVGElement(svg) && screenCTM) {
    var point = svg.createSVGPoint();
    point.x = coords.x;
    point.y = coords.y;
    point = point.matrixTransform(screenCTM.inverse());
    return new esm_Point_Point({
      x: point.x,
      y: point.y
    });
  } // fall back to bounding box


  var rect = node.getBoundingClientRect();
  return new esm_Point_Point({
    x: coords.x - rect.left - node.clientLeft,
    y: coords.y - rect.top - node.clientTop
  });
}
;// CONCATENATED MODULE: ./node_modules/@visx/event/esm/localPoint.js


/** Handles two signatures for backwards compatibility. */

function localPoint_localPoint(nodeOrEvent, maybeEvent) {
  // localPoint(node, event)
  if (isElement(nodeOrEvent) && maybeEvent) {
    return localPoint(nodeOrEvent, maybeEvent);
  } // localPoint(event)


  if (isEvent(nodeOrEvent)) {
    var event = nodeOrEvent;
    var node = event.target;
    if (node) return localPoint(node, event);
  }

  return null;
}
;// CONCATENATED MODULE: ./node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js
/**
 * A collection of shims that provide minimal functionality of the ES6 collections.
 *
 * These implementations are not meant to be used outside of the ResizeObserver
 * modules as they cover only a limited range of use cases.
 */
/* eslint-disable require-jsdoc, valid-jsdoc */
var MapShim = (function () {
    if (typeof Map !== 'undefined') {
        return Map;
    }
    /**
     * Returns index in provided array that matches the specified key.
     *
     * @param {Array<Array>} arr
     * @param {*} key
     * @returns {number}
     */
    function getIndex(arr, key) {
        var result = -1;
        arr.some(function (entry, index) {
            if (entry[0] === key) {
                result = index;
                return true;
            }
            return false;
        });
        return result;
    }
    return /** @class */ (function () {
        function class_1() {
            this.__entries__ = [];
        }
        Object.defineProperty(class_1.prototype, "size", {
            /**
             * @returns {boolean}
             */
            get: function () {
                return this.__entries__.length;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {*} key
         * @returns {*}
         */
        class_1.prototype.get = function (key) {
            var index = getIndex(this.__entries__, key);
            var entry = this.__entries__[index];
            return entry && entry[1];
        };
        /**
         * @param {*} key
         * @param {*} value
         * @returns {void}
         */
        class_1.prototype.set = function (key, value) {
            var index = getIndex(this.__entries__, key);
            if (~index) {
                this.__entries__[index][1] = value;
            }
            else {
                this.__entries__.push([key, value]);
            }
        };
        /**
         * @param {*} key
         * @returns {void}
         */
        class_1.prototype.delete = function (key) {
            var entries = this.__entries__;
            var index = getIndex(entries, key);
            if (~index) {
                entries.splice(index, 1);
            }
        };
        /**
         * @param {*} key
         * @returns {void}
         */
        class_1.prototype.has = function (key) {
            return !!~getIndex(this.__entries__, key);
        };
        /**
         * @returns {void}
         */
        class_1.prototype.clear = function () {
            this.__entries__.splice(0);
        };
        /**
         * @param {Function} callback
         * @param {*} [ctx=null]
         * @returns {void}
         */
        class_1.prototype.forEach = function (callback, ctx) {
            if (ctx === void 0) { ctx = null; }
            for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {
                var entry = _a[_i];
                callback.call(ctx, entry[1], entry[0]);
            }
        };
        return class_1;
    }());
})();

/**
 * Detects whether window and document objects are available in current environment.
 */
var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && window.document === document;

// Returns global object of a current environment.
var global$1 = (function () {
    if (typeof __webpack_require__.g !== 'undefined' && __webpack_require__.g.Math === Math) {
        return __webpack_require__.g;
    }
    if (typeof self !== 'undefined' && self.Math === Math) {
        return self;
    }
    if (typeof window !== 'undefined' && window.Math === Math) {
        return window;
    }
    // eslint-disable-next-line no-new-func
    return Function('return this')();
})();

/**
 * A shim for the requestAnimationFrame which falls back to the setTimeout if
 * first one is not supported.
 *
 * @returns {number} Requests' identifier.
 */
var requestAnimationFrame$1 = (function () {
    if (typeof requestAnimationFrame === 'function') {
        // It's required to use a bounded function because IE sometimes throws
        // an "Invalid calling object" error if rAF is invoked without the global
        // object on the left hand side.
        return requestAnimationFrame.bind(global$1);
    }
    return function (callback) { return setTimeout(function () { return callback(Date.now()); }, 1000 / 60); };
})();

// Defines minimum timeout before adding a trailing call.
var trailingTimeout = 2;
/**
 * Creates a wrapper function which ensures that provided callback will be
 * invoked only once during the specified delay period.
 *
 * @param {Function} callback - Function to be invoked after the delay period.
 * @param {number} delay - Delay after which to invoke callback.
 * @returns {Function}
 */
function throttle (callback, delay) {
    var leadingCall = false, trailingCall = false, lastCallTime = 0;
    /**
     * Invokes the original callback function and schedules new invocation if
     * the "proxy" was called during current request.
     *
     * @returns {void}
     */
    function resolvePending() {
        if (leadingCall) {
            leadingCall = false;
            callback();
        }
        if (trailingCall) {
            proxy();
        }
    }
    /**
     * Callback invoked after the specified delay. It will further postpone
     * invocation of the original function delegating it to the
     * requestAnimationFrame.
     *
     * @returns {void}
     */
    function timeoutCallback() {
        requestAnimationFrame$1(resolvePending);
    }
    /**
     * Schedules invocation of the original function.
     *
     * @returns {void}
     */
    function proxy() {
        var timeStamp = Date.now();
        if (leadingCall) {
            // Reject immediately following calls.
            if (timeStamp - lastCallTime < trailingTimeout) {
                return;
            }
            // Schedule new call to be in invoked when the pending one is resolved.
            // This is important for "transitions" which never actually start
            // immediately so there is a chance that we might miss one if change
            // happens amids the pending invocation.
            trailingCall = true;
        }
        else {
            leadingCall = true;
            trailingCall = false;
            setTimeout(timeoutCallback, delay);
        }
        lastCallTime = timeStamp;
    }
    return proxy;
}

// Minimum delay before invoking the update of observers.
var REFRESH_DELAY = 20;
// A list of substrings of CSS properties used to find transition events that
// might affect dimensions of observed elements.
var transitionKeys = ['top', 'right', 'bottom', 'left', 'width', 'height', 'size', 'weight'];
// Check if MutationObserver is available.
var mutationObserverSupported = typeof MutationObserver !== 'undefined';
/**
 * Singleton controller class which handles updates of ResizeObserver instances.
 */
var ResizeObserverController = /** @class */ (function () {
    /**
     * Creates a new instance of ResizeObserverController.
     *
     * @private
     */
    function ResizeObserverController() {
        /**
         * Indicates whether DOM listeners have been added.
         *
         * @private {boolean}
         */
        this.connected_ = false;
        /**
         * Tells that controller has subscribed for Mutation Events.
         *
         * @private {boolean}
         */
        this.mutationEventsAdded_ = false;
        /**
         * Keeps reference to the instance of MutationObserver.
         *
         * @private {MutationObserver}
         */
        this.mutationsObserver_ = null;
        /**
         * A list of connected observers.
         *
         * @private {Array<ResizeObserverSPI>}
         */
        this.observers_ = [];
        this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);
        this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);
    }
    /**
     * Adds observer to observers list.
     *
     * @param {ResizeObserverSPI} observer - Observer to be added.
     * @returns {void}
     */
    ResizeObserverController.prototype.addObserver = function (observer) {
        if (!~this.observers_.indexOf(observer)) {
            this.observers_.push(observer);
        }
        // Add listeners if they haven't been added yet.
        if (!this.connected_) {
            this.connect_();
        }
    };
    /**
     * Removes observer from observers list.
     *
     * @param {ResizeObserverSPI} observer - Observer to be removed.
     * @returns {void}
     */
    ResizeObserverController.prototype.removeObserver = function (observer) {
        var observers = this.observers_;
        var index = observers.indexOf(observer);
        // Remove observer if it's present in registry.
        if (~index) {
            observers.splice(index, 1);
        }
        // Remove listeners if controller has no connected observers.
        if (!observers.length && this.connected_) {
            this.disconnect_();
        }
    };
    /**
     * Invokes the update of observers. It will continue running updates insofar
     * it detects changes.
     *
     * @returns {void}
     */
    ResizeObserverController.prototype.refresh = function () {
        var changesDetected = this.updateObservers_();
        // Continue running updates if changes have been detected as there might
        // be future ones caused by CSS transitions.
        if (changesDetected) {
            this.refresh();
        }
    };
    /**
     * Updates every observer from observers list and notifies them of queued
     * entries.
     *
     * @private
     * @returns {boolean} Returns "true" if any observer has detected changes in
     *      dimensions of it's elements.
     */
    ResizeObserverController.prototype.updateObservers_ = function () {
        // Collect observers that have active observations.
        var activeObservers = this.observers_.filter(function (observer) {
            return observer.gatherActive(), observer.hasActive();
        });
        // Deliver notifications in a separate cycle in order to avoid any
        // collisions between observers, e.g. when multiple instances of
        // ResizeObserver are tracking the same element and the callback of one
        // of them changes content dimensions of the observed target. Sometimes
        // this may result in notifications being blocked for the rest of observers.
        activeObservers.forEach(function (observer) { return observer.broadcastActive(); });
        return activeObservers.length > 0;
    };
    /**
     * Initializes DOM listeners.
     *
     * @private
     * @returns {void}
     */
    ResizeObserverController.prototype.connect_ = function () {
        // Do nothing if running in a non-browser environment or if listeners
        // have been already added.
        if (!isBrowser || this.connected_) {
            return;
        }
        // Subscription to the "Transitionend" event is used as a workaround for
        // delayed transitions. This way it's possible to capture at least the
        // final state of an element.
        document.addEventListener('transitionend', this.onTransitionEnd_);
        window.addEventListener('resize', this.refresh);
        if (mutationObserverSupported) {
            this.mutationsObserver_ = new MutationObserver(this.refresh);
            this.mutationsObserver_.observe(document, {
                attributes: true,
                childList: true,
                characterData: true,
                subtree: true
            });
        }
        else {
            document.addEventListener('DOMSubtreeModified', this.refresh);
            this.mutationEventsAdded_ = true;
        }
        this.connected_ = true;
    };
    /**
     * Removes DOM listeners.
     *
     * @private
     * @returns {void}
     */
    ResizeObserverController.prototype.disconnect_ = function () {
        // Do nothing if running in a non-browser environment or if listeners
        // have been already removed.
        if (!isBrowser || !this.connected_) {
            return;
        }
        document.removeEventListener('transitionend', this.onTransitionEnd_);
        window.removeEventListener('resize', this.refresh);
        if (this.mutationsObserver_) {
            this.mutationsObserver_.disconnect();
        }
        if (this.mutationEventsAdded_) {
            document.removeEventListener('DOMSubtreeModified', this.refresh);
        }
        this.mutationsObserver_ = null;
        this.mutationEventsAdded_ = false;
        this.connected_ = false;
    };
    /**
     * "Transitionend" event handler.
     *
     * @private
     * @param {TransitionEvent} event
     * @returns {void}
     */
    ResizeObserverController.prototype.onTransitionEnd_ = function (_a) {
        var _b = _a.propertyName, propertyName = _b === void 0 ? '' : _b;
        // Detect whether transition may affect dimensions of an element.
        var isReflowProperty = transitionKeys.some(function (key) {
            return !!~propertyName.indexOf(key);
        });
        if (isReflowProperty) {
            this.refresh();
        }
    };
    /**
     * Returns instance of the ResizeObserverController.
     *
     * @returns {ResizeObserverController}
     */
    ResizeObserverController.getInstance = function () {
        if (!this.instance_) {
            this.instance_ = new ResizeObserverController();
        }
        return this.instance_;
    };
    /**
     * Holds reference to the controller's instance.
     *
     * @private {ResizeObserverController}
     */
    ResizeObserverController.instance_ = null;
    return ResizeObserverController;
}());

/**
 * Defines non-writable/enumerable properties of the provided target object.
 *
 * @param {Object} target - Object for which to define properties.
 * @param {Object} props - Properties to be defined.
 * @returns {Object} Target object.
 */
var defineConfigurable = (function (target, props) {
    for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {
        var key = _a[_i];
        Object.defineProperty(target, key, {
            value: props[key],
            enumerable: false,
            writable: false,
            configurable: true
        });
    }
    return target;
});

/**
 * Returns the global object associated with provided element.
 *
 * @param {Object} target
 * @returns {Object}
 */
var getWindowOf = (function (target) {
    // Assume that the element is an instance of Node, which means that it
    // has the "ownerDocument" property from which we can retrieve a
    // corresponding global object.
    var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;
    // Return the local global object if it's not possible extract one from
    // provided element.
    return ownerGlobal || global$1;
});

// Placeholder of an empty content rectangle.
var emptyRect = createRectInit(0, 0, 0, 0);
/**
 * Converts provided string to a number.
 *
 * @param {number|string} value
 * @returns {number}
 */
function toFloat(value) {
    return parseFloat(value) || 0;
}
/**
 * Extracts borders size from provided styles.
 *
 * @param {CSSStyleDeclaration} styles
 * @param {...string} positions - Borders positions (top, right, ...)
 * @returns {number}
 */
function getBordersSize(styles) {
    var positions = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        positions[_i - 1] = arguments[_i];
    }
    return positions.reduce(function (size, position) {
        var value = styles['border-' + position + '-width'];
        return size + toFloat(value);
    }, 0);
}
/**
 * Extracts paddings sizes from provided styles.
 *
 * @param {CSSStyleDeclaration} styles
 * @returns {Object} Paddings box.
 */
function getPaddings(styles) {
    var positions = ['top', 'right', 'bottom', 'left'];
    var paddings = {};
    for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {
        var position = positions_1[_i];
        var value = styles['padding-' + position];
        paddings[position] = toFloat(value);
    }
    return paddings;
}
/**
 * Calculates content rectangle of provided SVG element.
 *
 * @param {SVGGraphicsElement} target - Element content rectangle of which needs
 *      to be calculated.
 * @returns {DOMRectInit}
 */
function getSVGContentRect(target) {
    var bbox = target.getBBox();
    return createRectInit(0, 0, bbox.width, bbox.height);
}
/**
 * Calculates content rectangle of provided HTMLElement.
 *
 * @param {HTMLElement} target - Element for which to calculate the content rectangle.
 * @returns {DOMRectInit}
 */
function getHTMLElementContentRect(target) {
    // Client width & height properties can't be
    // used exclusively as they provide rounded values.
    var clientWidth = target.clientWidth, clientHeight = target.clientHeight;
    // By this condition we can catch all non-replaced inline, hidden and
    // detached elements. Though elements with width & height properties less
    // than 0.5 will be discarded as well.
    //
    // Without it we would need to implement separate methods for each of
    // those cases and it's not possible to perform a precise and performance
    // effective test for hidden elements. E.g. even jQuery's ':visible' filter
    // gives wrong results for elements with width & height less than 0.5.
    if (!clientWidth && !clientHeight) {
        return emptyRect;
    }
    var styles = getWindowOf(target).getComputedStyle(target);
    var paddings = getPaddings(styles);
    var horizPad = paddings.left + paddings.right;
    var vertPad = paddings.top + paddings.bottom;
    // Computed styles of width & height are being used because they are the
    // only dimensions available to JS that contain non-rounded values. It could
    // be possible to utilize the getBoundingClientRect if only it's data wasn't
    // affected by CSS transformations let alone paddings, borders and scroll bars.
    var width = toFloat(styles.width), height = toFloat(styles.height);
    // Width & height include paddings and borders when the 'border-box' box
    // model is applied (except for IE).
    if (styles.boxSizing === 'border-box') {
        // Following conditions are required to handle Internet Explorer which
        // doesn't include paddings and borders to computed CSS dimensions.
        //
        // We can say that if CSS dimensions + paddings are equal to the "client"
        // properties then it's either IE, and thus we don't need to subtract
        // anything, or an element merely doesn't have paddings/borders styles.
        if (Math.round(width + horizPad) !== clientWidth) {
            width -= getBordersSize(styles, 'left', 'right') + horizPad;
        }
        if (Math.round(height + vertPad) !== clientHeight) {
            height -= getBordersSize(styles, 'top', 'bottom') + vertPad;
        }
    }
    // Following steps can't be applied to the document's root element as its
    // client[Width/Height] properties represent viewport area of the window.
    // Besides, it's as well not necessary as the <html> itself neither has
    // rendered scroll bars nor it can be clipped.
    if (!isDocumentElement(target)) {
        // In some browsers (only in Firefox, actually) CSS width & height
        // include scroll bars size which can be removed at this step as scroll
        // bars are the only difference between rounded dimensions + paddings
        // and "client" properties, though that is not always true in Chrome.
        var vertScrollbar = Math.round(width + horizPad) - clientWidth;
        var horizScrollbar = Math.round(height + vertPad) - clientHeight;
        // Chrome has a rather weird rounding of "client" properties.
        // E.g. for an element with content width of 314.2px it sometimes gives
        // the client width of 315px and for the width of 314.7px it may give
        // 314px. And it doesn't happen all the time. So just ignore this delta
        // as a non-relevant.
        if (Math.abs(vertScrollbar) !== 1) {
            width -= vertScrollbar;
        }
        if (Math.abs(horizScrollbar) !== 1) {
            height -= horizScrollbar;
        }
    }
    return createRectInit(paddings.left, paddings.top, width, height);
}
/**
 * Checks whether provided element is an instance of the SVGGraphicsElement.
 *
 * @param {Element} target - Element to be checked.
 * @returns {boolean}
 */
var ResizeObserver_es_isSVGGraphicsElement = (function () {
    // Some browsers, namely IE and Edge, don't have the SVGGraphicsElement
    // interface.
    if (typeof SVGGraphicsElement !== 'undefined') {
        return function (target) { return target instanceof getWindowOf(target).SVGGraphicsElement; };
    }
    // If it's so, then check that element is at least an instance of the
    // SVGElement and that it has the "getBBox" method.
    // eslint-disable-next-line no-extra-parens
    return function (target) { return (target instanceof getWindowOf(target).SVGElement &&
        typeof target.getBBox === 'function'); };
})();
/**
 * Checks whether provided element is a document element (<html>).
 *
 * @param {Element} target - Element to be checked.
 * @returns {boolean}
 */
function isDocumentElement(target) {
    return target === getWindowOf(target).document.documentElement;
}
/**
 * Calculates an appropriate content rectangle for provided html or svg element.
 *
 * @param {Element} target - Element content rectangle of which needs to be calculated.
 * @returns {DOMRectInit}
 */
function getContentRect(target) {
    if (!isBrowser) {
        return emptyRect;
    }
    if (ResizeObserver_es_isSVGGraphicsElement(target)) {
        return getSVGContentRect(target);
    }
    return getHTMLElementContentRect(target);
}
/**
 * Creates rectangle with an interface of the DOMRectReadOnly.
 * Spec: https://drafts.fxtf.org/geometry/#domrectreadonly
 *
 * @param {DOMRectInit} rectInit - Object with rectangle's x/y coordinates and dimensions.
 * @returns {DOMRectReadOnly}
 */
function createReadOnlyRect(_a) {
    var x = _a.x, y = _a.y, width = _a.width, height = _a.height;
    // If DOMRectReadOnly is available use it as a prototype for the rectangle.
    var Constr = typeof DOMRectReadOnly !== 'undefined' ? DOMRectReadOnly : Object;
    var rect = Object.create(Constr.prototype);
    // Rectangle's properties are not writable and non-enumerable.
    defineConfigurable(rect, {
        x: x, y: y, width: width, height: height,
        top: y,
        right: x + width,
        bottom: height + y,
        left: x
    });
    return rect;
}
/**
 * Creates DOMRectInit object based on the provided dimensions and the x/y coordinates.
 * Spec: https://drafts.fxtf.org/geometry/#dictdef-domrectinit
 *
 * @param {number} x - X coordinate.
 * @param {number} y - Y coordinate.
 * @param {number} width - Rectangle's width.
 * @param {number} height - Rectangle's height.
 * @returns {DOMRectInit}
 */
function createRectInit(x, y, width, height) {
    return { x: x, y: y, width: width, height: height };
}

/**
 * Class that is responsible for computations of the content rectangle of
 * provided DOM element and for keeping track of it's changes.
 */
var ResizeObservation = /** @class */ (function () {
    /**
     * Creates an instance of ResizeObservation.
     *
     * @param {Element} target - Element to be observed.
     */
    function ResizeObservation(target) {
        /**
         * Broadcasted width of content rectangle.
         *
         * @type {number}
         */
        this.broadcastWidth = 0;
        /**
         * Broadcasted height of content rectangle.
         *
         * @type {number}
         */
        this.broadcastHeight = 0;
        /**
         * Reference to the last observed content rectangle.
         *
         * @private {DOMRectInit}
         */
        this.contentRect_ = createRectInit(0, 0, 0, 0);
        this.target = target;
    }
    /**
     * Updates content rectangle and tells whether it's width or height properties
     * have changed since the last broadcast.
     *
     * @returns {boolean}
     */
    ResizeObservation.prototype.isActive = function () {
        var rect = getContentRect(this.target);
        this.contentRect_ = rect;
        return (rect.width !== this.broadcastWidth ||
            rect.height !== this.broadcastHeight);
    };
    /**
     * Updates 'broadcastWidth' and 'broadcastHeight' properties with a data
     * from the corresponding properties of the last observed content rectangle.
     *
     * @returns {DOMRectInit} Last observed content rectangle.
     */
    ResizeObservation.prototype.broadcastRect = function () {
        var rect = this.contentRect_;
        this.broadcastWidth = rect.width;
        this.broadcastHeight = rect.height;
        return rect;
    };
    return ResizeObservation;
}());

var ResizeObserverEntry = /** @class */ (function () {
    /**
     * Creates an instance of ResizeObserverEntry.
     *
     * @param {Element} target - Element that is being observed.
     * @param {DOMRectInit} rectInit - Data of the element's content rectangle.
     */
    function ResizeObserverEntry(target, rectInit) {
        var contentRect = createReadOnlyRect(rectInit);
        // According to the specification following properties are not writable
        // and are also not enumerable in the native implementation.
        //
        // Property accessors are not being used as they'd require to define a
        // private WeakMap storage which may cause memory leaks in browsers that
        // don't support this type of collections.
        defineConfigurable(this, { target: target, contentRect: contentRect });
    }
    return ResizeObserverEntry;
}());

var ResizeObserverSPI = /** @class */ (function () {
    /**
     * Creates a new instance of ResizeObserver.
     *
     * @param {ResizeObserverCallback} callback - Callback function that is invoked
     *      when one of the observed elements changes it's content dimensions.
     * @param {ResizeObserverController} controller - Controller instance which
     *      is responsible for the updates of observer.
     * @param {ResizeObserver} callbackCtx - Reference to the public
     *      ResizeObserver instance which will be passed to callback function.
     */
    function ResizeObserverSPI(callback, controller, callbackCtx) {
        /**
         * Collection of resize observations that have detected changes in dimensions
         * of elements.
         *
         * @private {Array<ResizeObservation>}
         */
        this.activeObservations_ = [];
        /**
         * Registry of the ResizeObservation instances.
         *
         * @private {Map<Element, ResizeObservation>}
         */
        this.observations_ = new MapShim();
        if (typeof callback !== 'function') {
            throw new TypeError('The callback provided as parameter 1 is not a function.');
        }
        this.callback_ = callback;
        this.controller_ = controller;
        this.callbackCtx_ = callbackCtx;
    }
    /**
     * Starts observing provided element.
     *
     * @param {Element} target - Element to be observed.
     * @returns {void}
     */
    ResizeObserverSPI.prototype.observe = function (target) {
        if (!arguments.length) {
            throw new TypeError('1 argument required, but only 0 present.');
        }
        // Do nothing if current environment doesn't have the Element interface.
        if (typeof Element === 'undefined' || !(Element instanceof Object)) {
            return;
        }
        if (!(target instanceof getWindowOf(target).Element)) {
            throw new TypeError('parameter 1 is not of type "Element".');
        }
        var observations = this.observations_;
        // Do nothing if element is already being observed.
        if (observations.has(target)) {
            return;
        }
        observations.set(target, new ResizeObservation(target));
        this.controller_.addObserver(this);
        // Force the update of observations.
        this.controller_.refresh();
    };
    /**
     * Stops observing provided element.
     *
     * @param {Element} target - Element to stop observing.
     * @returns {void}
     */
    ResizeObserverSPI.prototype.unobserve = function (target) {
        if (!arguments.length) {
            throw new TypeError('1 argument required, but only 0 present.');
        }
        // Do nothing if current environment doesn't have the Element interface.
        if (typeof Element === 'undefined' || !(Element instanceof Object)) {
            return;
        }
        if (!(target instanceof getWindowOf(target).Element)) {
            throw new TypeError('parameter 1 is not of type "Element".');
        }
        var observations = this.observations_;
        // Do nothing if element is not being observed.
        if (!observations.has(target)) {
            return;
        }
        observations.delete(target);
        if (!observations.size) {
            this.controller_.removeObserver(this);
        }
    };
    /**
     * Stops observing all elements.
     *
     * @returns {void}
     */
    ResizeObserverSPI.prototype.disconnect = function () {
        this.clearActive();
        this.observations_.clear();
        this.controller_.removeObserver(this);
    };
    /**
     * Collects observation instances the associated element of which has changed
     * it's content rectangle.
     *
     * @returns {void}
     */
    ResizeObserverSPI.prototype.gatherActive = function () {
        var _this = this;
        this.clearActive();
        this.observations_.forEach(function (observation) {
            if (observation.isActive()) {
                _this.activeObservations_.push(observation);
            }
        });
    };
    /**
     * Invokes initial callback function with a list of ResizeObserverEntry
     * instances collected from active resize observations.
     *
     * @returns {void}
     */
    ResizeObserverSPI.prototype.broadcastActive = function () {
        // Do nothing if observer doesn't have active observations.
        if (!this.hasActive()) {
            return;
        }
        var ctx = this.callbackCtx_;
        // Create ResizeObserverEntry instance for every active observation.
        var entries = this.activeObservations_.map(function (observation) {
            return new ResizeObserverEntry(observation.target, observation.broadcastRect());
        });
        this.callback_.call(ctx, entries, ctx);
        this.clearActive();
    };
    /**
     * Clears the collection of active observations.
     *
     * @returns {void}
     */
    ResizeObserverSPI.prototype.clearActive = function () {
        this.activeObservations_.splice(0);
    };
    /**
     * Tells whether observer has active observations.
     *
     * @returns {boolean}
     */
    ResizeObserverSPI.prototype.hasActive = function () {
        return this.activeObservations_.length > 0;
    };
    return ResizeObserverSPI;
}());

// Registry of internal observers. If WeakMap is not available use current shim
// for the Map collection as it has all required methods and because WeakMap
// can't be fully polyfilled anyway.
var observers = typeof WeakMap !== 'undefined' ? new WeakMap() : new MapShim();
/**
 * ResizeObserver API. Encapsulates the ResizeObserver SPI implementation
 * exposing only those methods and properties that are defined in the spec.
 */
var ResizeObserver = /** @class */ (function () {
    /**
     * Creates a new instance of ResizeObserver.
     *
     * @param {ResizeObserverCallback} callback - Callback that is invoked when
     *      dimensions of the observed elements change.
     */
    function ResizeObserver(callback) {
        if (!(this instanceof ResizeObserver)) {
            throw new TypeError('Cannot call a class as a function.');
        }
        if (!arguments.length) {
            throw new TypeError('1 argument required, but only 0 present.');
        }
        var controller = ResizeObserverController.getInstance();
        var observer = new ResizeObserverSPI(callback, controller, this);
        observers.set(this, observer);
    }
    return ResizeObserver;
}());
// Expose public methods of ResizeObserver.
[
    'observe',
    'unobserve',
    'disconnect'
].forEach(function (method) {
    ResizeObserver.prototype[method] = function () {
        var _a;
        return (_a = observers.get(this))[method].apply(_a, arguments);
    };
});

var index = (function () {
    // Export existing implementation if available.
    if (typeof global$1.ResizeObserver !== 'undefined') {
        return global$1.ResizeObserver;
    }
    return ResizeObserver;
})();

/* harmony default export */ const ResizeObserver_es = (index);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/hooks/useSize.js


const getSize = (el) => {
    if (!el) {
        return {
            width: 0,
            height: 0
        };
    }
    return {
        width: el.offsetWidth,
        height: el.offsetHeight
    };
};
/**
 * Returns the current HTML Element size by creating a resize osberver for the target element.
 *
 * @example
 * const { width, height } = useSize(elementRef);
 *
 * @param ref - Target HTML element reference
 * @returns - Element's width and height in pixels
 */
const useSize = (ref) => {
    const [size, setSize] = (0,react.useState)(getSize(ref === null || ref === void 0 ? void 0 : ref.current));
    const onResize = (0,react.useCallback)(() => setSize(getSize(ref.current)), [ref]);
    (0,react.useLayoutEffect)(() => {
        onResize();
        const resizeObserver = new ResizeObserver_es(() => {
            onResize();
        });
        if (ref.current) {
            resizeObserver.observe(ref.current);
        }
        return () => {
            resizeObserver.disconnect();
        };
    }, [ref.current]);
    return size;
};
/* harmony default export */ const hooks_useSize = (useSize);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/helpers/style.js
/* eslint-disable import/prefer-default-export */
/**
 * Add opacity to a rgb(X,Y,Z) color
 *
 * @example
 * const color = transparentize('rgb(255, 255, 255)', 0.5);
 */
const transparentize = (color, opacity) => {
    return color === null || color === void 0 ? void 0 : color.replace(')', `,${opacity})`);
};

// EXTERNAL MODULE: ./node_modules/react-dom/index.js
var react_dom = __webpack_require__(7668);
;// CONCATENATED MODULE: ./node_modules/@visx/bounds/esm/enhancers/withBoundingRects.js
function withBoundingRects_extends() { withBoundingRects_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return withBoundingRects_extends.apply(this, arguments); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function withBoundingRects_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/* eslint react/no-did-mount-set-state: 0, react/no-find-dom-node: 0 */


var withBoundingRects_emptyRect = {
  top: 0,
  right: 0,
  bottom: 0,
  left: 0,
  width: 0,
  height: 0
};
function withBoundingRects(BaseComponent) {
  var _class, _temp;

  return _temp = _class = /*#__PURE__*/function (_React$PureComponent) {
    _inheritsLoose(WrappedComponent, _React$PureComponent);

    function WrappedComponent(props) {
      var _this;

      _this = _React$PureComponent.call(this, props) || this;

      withBoundingRects_defineProperty(_assertThisInitialized(_this), "node", void 0);

      _this.state = {
        rect: undefined,
        parentRect: undefined
      };
      _this.getRects = _this.getRects.bind(_assertThisInitialized(_this));
      return _this;
    }

    var _proto = WrappedComponent.prototype;

    _proto.componentDidMount = function componentDidMount() {
      var _this2 = this;

      this.node = react_dom.findDOMNode(this);
      this.setState(function () {
        return _this2.getRects();
      });
    };

    _proto.getRects = function getRects() {
      if (!this.node) return this.state;
      var node = this.node;
      var parentNode = node.parentNode;
      var rect = node.getBoundingClientRect ? node.getBoundingClientRect() : withBoundingRects_emptyRect;
      var parentRect = parentNode != null && parentNode.getBoundingClientRect ? parentNode.getBoundingClientRect() : withBoundingRects_emptyRect;
      return {
        rect: rect,
        parentRect: parentRect
      };
    };

    _proto.render = function render() {
      return /*#__PURE__*/react.createElement(BaseComponent, withBoundingRects_extends({
        getRects: this.getRects
      }, this.state, this.props));
    };

    return WrappedComponent;
  }(react.PureComponent), withBoundingRects_defineProperty(_class, "displayName", "withBoundingRects(" + (BaseComponent.displayName || '') + ")"), _temp;
}
;// CONCATENATED MODULE: ./node_modules/@visx/tooltip/esm/tooltips/Tooltip.js

var Tooltip_excluded = ["className", "top", "left", "offsetLeft", "offsetTop", "style", "children", "unstyled", "applyPositionStyle"];

function Tooltip_extends() { Tooltip_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return Tooltip_extends.apply(this, arguments); }

function Tooltip_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }



var defaultStyles = {
  position: 'absolute',
  backgroundColor: 'white',
  color: '#666666',
  padding: '.3rem .5rem',
  borderRadius: '3px',
  fontSize: '14px',
  boxShadow: '0 1px 2px rgba(33,33,33,0.2)',
  lineHeight: '1em',
  pointerEvents: 'none'
};
function Tooltip(_ref) {
  var className = _ref.className,
      top = _ref.top,
      left = _ref.left,
      _ref$offsetLeft = _ref.offsetLeft,
      offsetLeft = _ref$offsetLeft === void 0 ? 10 : _ref$offsetLeft,
      _ref$offsetTop = _ref.offsetTop,
      offsetTop = _ref$offsetTop === void 0 ? 10 : _ref$offsetTop,
      _ref$style = _ref.style,
      style = _ref$style === void 0 ? defaultStyles : _ref$style,
      children = _ref.children,
      _ref$unstyled = _ref.unstyled,
      unstyled = _ref$unstyled === void 0 ? false : _ref$unstyled,
      _ref$applyPositionSty = _ref.applyPositionStyle,
      applyPositionStyle = _ref$applyPositionSty === void 0 ? false : _ref$applyPositionSty,
      restProps = Tooltip_objectWithoutPropertiesLoose(_ref, Tooltip_excluded);

  return /*#__PURE__*/react.createElement("div", Tooltip_extends({
    className: classnames_default()('visx-tooltip', className),
    style: Tooltip_extends({
      top: top == null || offsetTop == null ? top : top + offsetTop,
      left: left == null || offsetLeft == null ? left : left + offsetLeft
    }, applyPositionStyle && {
      position: 'absolute'
    }, !unstyled && style)
  }, restProps), children);
}
Tooltip.propTypes = {
  children: (prop_types_default()).node,
  className: (prop_types_default()).string,
  left: (prop_types_default()).number,
  offsetLeft: (prop_types_default()).number,
  offsetTop: (prop_types_default()).number,
  top: (prop_types_default()).number,
  applyPositionStyle: (prop_types_default()).bool,
  unstyled: (prop_types_default()).bool
};
;// CONCATENATED MODULE: ./node_modules/@visx/tooltip/esm/tooltips/TooltipWithBounds.js
var TooltipWithBounds_excluded = ["children", "getRects", "left", "offsetLeft", "offsetTop", "parentRect", "rect", "style", "top", "unstyled"];

function TooltipWithBounds_extends() { TooltipWithBounds_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return TooltipWithBounds_extends.apply(this, arguments); }

function TooltipWithBounds_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }





function TooltipWithBounds(_ref) {
  var children = _ref.children,
      getRects = _ref.getRects,
      _ref$left = _ref.left,
      initialLeft = _ref$left === void 0 ? 0 : _ref$left,
      _ref$offsetLeft = _ref.offsetLeft,
      offsetLeft = _ref$offsetLeft === void 0 ? 10 : _ref$offsetLeft,
      _ref$offsetTop = _ref.offsetTop,
      offsetTop = _ref$offsetTop === void 0 ? 10 : _ref$offsetTop,
      parentBounds = _ref.parentRect,
      ownBounds = _ref.rect,
      _ref$style = _ref.style,
      style = _ref$style === void 0 ? defaultStyles : _ref$style,
      _ref$top = _ref.top,
      initialTop = _ref$top === void 0 ? 0 : _ref$top,
      _ref$unstyled = _ref.unstyled,
      unstyled = _ref$unstyled === void 0 ? false : _ref$unstyled,
      otherProps = TooltipWithBounds_objectWithoutPropertiesLoose(_ref, TooltipWithBounds_excluded);

  var transform;

  if (ownBounds && parentBounds) {
    var left = initialLeft;
    var top = initialTop;
    var placeTooltipLeft = false;
    var placeTooltipUp = false;

    if (parentBounds.width) {
      var rightPlacementClippedPx = left + offsetLeft + ownBounds.width - parentBounds.width;
      var leftPlacementClippedPx = ownBounds.width - left - offsetLeft;
      placeTooltipLeft = rightPlacementClippedPx > 0 && rightPlacementClippedPx > leftPlacementClippedPx;
    } else {
      var _rightPlacementClippedPx = left + offsetLeft + ownBounds.width - window.innerWidth;

      var _leftPlacementClippedPx = ownBounds.width - left - offsetLeft;

      placeTooltipLeft = _rightPlacementClippedPx > 0 && _rightPlacementClippedPx > _leftPlacementClippedPx;
    }

    if (parentBounds.height) {
      var bottomPlacementClippedPx = top + offsetTop + ownBounds.height - parentBounds.height;
      var topPlacementClippedPx = ownBounds.height - top - offsetTop;
      placeTooltipUp = bottomPlacementClippedPx > 0 && bottomPlacementClippedPx > topPlacementClippedPx;
    } else {
      placeTooltipUp = top + offsetTop + ownBounds.height > window.innerHeight;
    }

    left = placeTooltipLeft ? left - ownBounds.width - offsetLeft : left + offsetLeft;
    top = placeTooltipUp ? top - ownBounds.height - offsetTop : top + offsetTop;
    left = Math.round(left);
    top = Math.round(top);
    transform = "translate(" + left + "px, " + top + "px)";
  }

  return /*#__PURE__*/react.createElement(Tooltip, TooltipWithBounds_extends({
    style: TooltipWithBounds_extends({
      left: 0,
      top: 0,
      transform: transform
    }, !unstyled && style)
  }, otherProps), children);
}

/* harmony default export */ const tooltips_TooltipWithBounds = (withBoundingRects(TooltipWithBounds));
;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Chart/types/components/Tooltip.js




function applyAxisFormatter(data, formatter) {
    return Object.entries(data).reduce((acc, [key, value]) => {
        return Object.assign(Object.assign({}, acc), { [key]: formatter(value) });
    }, {});
}
const Tooltip_Container = (0,dist_theme/* styled */.zo)(tooltips_TooltipWithBounds) `
  margin-left: 6px;
  background: ${({ theme }) => theme.color('dark100')};
  color: ${({ theme }) => theme.color('dark0')};
  box-shadow: 0px 4px 16px 0px rgba(0, 0, 0, ${({ theme }) => (theme.name === 'light' ? '0.09' : '0.5')});
  font-size: 12px;
  border-radius: 3px;
  padding: 8px;
  pointer-events: none;
  z-index: ${({ theme }) => theme.zIndex.tooltip};
`;
const Title = dist_theme/* styled.strong */.zo.strong `
  display: block;
  font-weight: 600;
  margin-bottom: 4px;
`;
const Item = dist_theme/* styled.li */.zo.li `
  display: flex;
  list-style: none;
  line-height: 21px;
  white-space: nowrap;

  strong {
    font-weight: 600;
    margin-right: 8px;
  }
`;
// eslint-disable-next-line react/function-component-definition
function Tooltip_Tooltip({ as, colors, data, x, y }) {
    const items = (0,react.useMemo)(() => {
        return data
            ? Object.entries(data)
                .filter(([key]) => !['label', 'data'].includes(key))
                .map(([key, value]) => ({ label: key, value }))
            : [];
    }, [data]);
    if (!data) {
        return null;
    }
    return ((0,jsx_runtime.jsxs)(Tooltip_Container, Object.assign({ as: as, left: x, top: y, unstyled: true, applyPositionStyle: true }, { children: [data.label ? (0,jsx_runtime.jsx)(Title, { children: data.label }) : null, items.map(({ label, value }, index) => ((0,jsx_runtime.jsx)(Item, { children: (0,jsx_runtime.jsxs)(jsx_runtime.Fragment, { children: [(0,jsx_runtime.jsx)("strong", Object.assign({ style: { color: colors[index] } }, { children: label })), value] }) }, label)))] })));
}
/* harmony default export */ const components_Tooltip = (Tooltip_Tooltip);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Chart/types/components/Points.js


const Points = ({ colors, data, xScale, yScale }) => {
    const xPosition = (0,react.useMemo)(() => {
        return !(data === null || data === void 0 ? void 0 : data.date) ? 0 : xScale(data === null || data === void 0 ? void 0 : data.date);
    }, [data, xScale]);
    const points = (0,react.useMemo)(() => {
        return data ? Object.entries(data).filter(([key]) => key !== 'date') : [];
    }, [data]);
    return ((0,jsx_runtime.jsx)(jsx_runtime.Fragment, { children: points.map(([key, value], index) => ((0,jsx_runtime.jsx)("circle", { r: 3.5, cx: xPosition, cy: yScale(value), fill: colors[index] }, key))) }));
};
/* harmony default export */ const components_Points = (Points);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Chart/types/components/Legend.js


const Legend_Container = dist_theme/* styled.ul */.zo.ul `
  display: flex;
  flex-wrap: wrap;
  width: 100%;
  justify-content: center;
  padding: 50px 8px 0;
`;
const Label = dist_theme/* styled.li */.zo.li `
  display: inline-flex;
  align-items: center;
  white-space: nowrap;
  margin: 4px 12px;
  &:before {
    content: '';
    display: block;
    width: 16px;
    height: 3px;
    border-radius: 3px;
    background: ${({ fill }) => fill};
    margin-right: 8px;
  }
`;
const Legend = ({ colors, labels }) => {
    return ((0,jsx_runtime.jsx)(Legend_Container, { children: labels.map((label, index) => ((0,jsx_runtime.jsx)(Label, Object.assign({ fill: colors[index] }, { children: label }), label))) }));
};
/* harmony default export */ const components_Legend = (Legend);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Chart/types/components/helpers.js
/* eslint-disable import/prefer-default-export */
/**
 * Default axis label formatter
 */
const axisLabel = (value) => {
    if (typeof value === 'number') {
        return `${value}`;
    }
    const month = new Intl.DateTimeFormat('en', { month: 'short' }).format(value);
    const day = new Intl.DateTimeFormat('en', { day: '2-digit' }).format(value);
    return `${day} ${month}`;
};
const defaultTextLabelOptions = {
    trucateAfter: 20
};
const textLabel = ({ trucateAfter } = defaultTextLabelOptions) => (value) => {
    if (!trucateAfter || value.length < trucateAfter)
        return value;
    return `${value.slice(0, trucateAfter)}...`;
};
const numberLabel = ({ trucateAfter } = defaultTextLabelOptions) => (value) => {
    if (!trucateAfter || value.length < trucateAfter)
        return value;
    return `${value.slice(0, trucateAfter)}...`;
};

// EXTERNAL MODULE: ./node_modules/debounce/index.js
var node_modules_debounce = __webpack_require__(4353);
var debounce_default = /*#__PURE__*/__webpack_require__.n(node_modules_debounce);
;// CONCATENATED MODULE: ./node_modules/react-use-measure/dist/web.js



function useMeasure(_temp) {
  let {
    debounce,
    scroll,
    polyfill,
    offsetSize
  } = _temp === void 0 ? {
    debounce: 0,
    scroll: false,
    offsetSize: false
  } : _temp;
  const ResizeObserver = polyfill || (typeof window === 'undefined' ? class ResizeObserver {} : window.ResizeObserver);

  if (!ResizeObserver) {
    throw new Error('This browser does not support ResizeObserver out of the box. See: https://github.com/react-spring/react-use-measure/#resize-observer-polyfills');
  }

  const [bounds, set] = (0,react.useState)({
    left: 0,
    top: 0,
    width: 0,
    height: 0,
    bottom: 0,
    right: 0,
    x: 0,
    y: 0
  }); // keep all state in a ref

  const state = (0,react.useRef)({
    element: null,
    scrollContainers: null,
    resizeObserver: null,
    lastBounds: bounds
  }); // set actual debounce values early, so effects know if they should react accordingly

  const scrollDebounce = debounce ? typeof debounce === 'number' ? debounce : debounce.scroll : null;
  const resizeDebounce = debounce ? typeof debounce === 'number' ? debounce : debounce.resize : null; // make sure to update state only as long as the component is truly mounted

  const mounted = (0,react.useRef)(false);
  (0,react.useEffect)(() => {
    mounted.current = true;
    return () => void (mounted.current = false);
  }); // memoize handlers, so event-listeners know when they should update

  const [forceRefresh, resizeChange, scrollChange] = (0,react.useMemo)(() => {
    const callback = () => {
      if (!state.current.element) return;
      const {
        left,
        top,
        width,
        height,
        bottom,
        right,
        x,
        y
      } = state.current.element.getBoundingClientRect();
      const size = {
        left,
        top,
        width,
        height,
        bottom,
        right,
        x,
        y
      };

      if (state.current.element instanceof HTMLElement && offsetSize) {
        size.height = state.current.element.offsetHeight;
        size.width = state.current.element.offsetWidth;
      }

      Object.freeze(size);
      if (mounted.current && !areBoundsEqual(state.current.lastBounds, size)) set(state.current.lastBounds = size);
    };

    return [callback, resizeDebounce ? debounce_default()(callback, resizeDebounce) : callback, scrollDebounce ? debounce_default()(callback, scrollDebounce) : callback];
  }, [set, offsetSize, scrollDebounce, resizeDebounce]); // cleanup current scroll-listeners / observers

  function removeListeners() {
    if (state.current.scrollContainers) {
      state.current.scrollContainers.forEach(element => element.removeEventListener('scroll', scrollChange, true));
      state.current.scrollContainers = null;
    }

    if (state.current.resizeObserver) {
      state.current.resizeObserver.disconnect();
      state.current.resizeObserver = null;
    }
  } // add scroll-listeners / observers


  function addListeners() {
    if (!state.current.element) return;
    state.current.resizeObserver = new ResizeObserver(scrollChange);
    state.current.resizeObserver.observe(state.current.element);

    if (scroll && state.current.scrollContainers) {
      state.current.scrollContainers.forEach(scrollContainer => scrollContainer.addEventListener('scroll', scrollChange, {
        capture: true,
        passive: true
      }));
    }
  } // the ref we expose to the user


  const ref = node => {
    if (!node || node === state.current.element) return;
    removeListeners();
    state.current.element = node;
    state.current.scrollContainers = findScrollContainers(node);
    addListeners();
  }; // add general event listeners


  useOnWindowScroll(scrollChange, Boolean(scroll));
  useOnWindowResize(resizeChange); // respond to changes that are relevant for the listeners

  (0,react.useEffect)(() => {
    removeListeners();
    addListeners();
  }, [scroll, scrollChange, resizeChange]); // remove all listeners when the components unmounts

  (0,react.useEffect)(() => removeListeners, []);
  return [ref, bounds, forceRefresh];
} // Adds native resize listener to window


function useOnWindowResize(onWindowResize) {
  (0,react.useEffect)(() => {
    const cb = onWindowResize;
    window.addEventListener('resize', cb);
    return () => void window.removeEventListener('resize', cb);
  }, [onWindowResize]);
}

function useOnWindowScroll(onScroll, enabled) {
  (0,react.useEffect)(() => {
    if (enabled) {
      const cb = onScroll;
      window.addEventListener('scroll', cb, {
        capture: true,
        passive: true
      });
      return () => void window.removeEventListener('scroll', cb, true);
    }
  }, [onScroll, enabled]);
} // Returns a list of scroll offsets


function findScrollContainers(element) {
  const result = [];
  if (!element || element === document.body) return result;
  const {
    overflow,
    overflowX,
    overflowY
  } = window.getComputedStyle(element);
  if ([overflow, overflowX, overflowY].some(prop => prop === 'auto' || prop === 'scroll')) result.push(element);
  return [...result, ...findScrollContainers(element.parentElement)];
} // Checks if element boundaries are equal


const keys = ['x', 'y', 'top', 'bottom', 'left', 'right', 'width', 'height'];

const areBoundsEqual = (a, b) => keys.every(key => a[key] === b[key]);



;// CONCATENATED MODULE: ./node_modules/@visx/tooltip/esm/Portal.js


function Portal_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function Portal_inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; Portal_setPrototypeOf(subClass, superClass); }

function Portal_setPrototypeOf(o, p) { Portal_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Portal_setPrototypeOf(o, p); }

function Portal_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




/** Render within a portal using a declarative component API. */
var Portal = /*#__PURE__*/function (_React$PureComponent) {
  Portal_inheritsLoose(Portal, _React$PureComponent);

  function Portal() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _React$PureComponent.call.apply(_React$PureComponent, [this].concat(args)) || this;

    Portal_defineProperty(Portal_assertThisInitialized(_this), "node", void 0);

    return _this;
  }

  var _proto = Portal.prototype;

  _proto.componentWillUnmount = function componentWillUnmount() {
    if (this.node && document.body) {
      document.body.removeChild(this.node);
      delete this.node;
    }
  };

  _proto.render = function render() {
    // SSR check
    if (!this.node && typeof document !== 'undefined') {
      this.node = document.createElement('div');
      if (this.props.zIndex != null) this.node.style.zIndex = "" + this.props.zIndex;
      document.body.append(this.node);
    }

    if (!this.node) {
      return null;
    }

    return /*#__PURE__*/react_dom.createPortal(this.props.children, this.node);
  };

  return Portal;
}(react.PureComponent);

Portal_defineProperty(Portal, "propTypes", {
  zIndex: prop_types_default().oneOfType([(prop_types_default()).number, (prop_types_default()).string])
});


;// CONCATENATED MODULE: ./node_modules/@visx/tooltip/esm/hooks/useTooltipInPortal.js
var useTooltipInPortal_excluded = ["detectBounds", "zIndex"],
    _excluded2 = ["left", "top", "detectBounds", "zIndex"];

function useTooltipInPortal_extends() { useTooltipInPortal_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return useTooltipInPortal_extends.apply(this, arguments); }

function useTooltipInPortal_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }







/**
 * Hook that handles rendering of a Tooltip or TooltipWithBounds in a Portal.
 * Handles conversion of container coordinates to page coordinates using the container bounds.
 */
function useTooltipInPortal(_temp) {
  var _ref = _temp === void 0 ? {} : _temp,
      _ref$detectBounds = _ref.detectBounds,
      detectBoundsOption = _ref$detectBounds === void 0 ? true : _ref$detectBounds,
      zIndexOption = _ref.zIndex,
      useMeasureOptions = useTooltipInPortal_objectWithoutPropertiesLoose(_ref, useTooltipInPortal_excluded);

  var _useMeasure = useMeasure(useMeasureOptions),
      containerRef = _useMeasure[0],
      containerBounds = _useMeasure[1],
      forceRefreshBounds = _useMeasure[2];

  var TooltipInPortal = (0,react.useMemo)(function () {
    return function (_ref2) {
      var _ref2$left = _ref2.left,
          containerLeft = _ref2$left === void 0 ? 0 : _ref2$left,
          _ref2$top = _ref2.top,
          containerTop = _ref2$top === void 0 ? 0 : _ref2$top,
          detectBoundsProp = _ref2.detectBounds,
          zIndexProp = _ref2.zIndex,
          tooltipProps = useTooltipInPortal_objectWithoutPropertiesLoose(_ref2, _excluded2);

      var detectBounds = detectBoundsProp == null ? detectBoundsOption : detectBoundsProp;
      var zIndex = zIndexProp == null ? zIndexOption : zIndexProp;
      var TooltipComponent = detectBounds ? tooltips_TooltipWithBounds : Tooltip; // convert container coordinates to page coordinates

      var portalLeft = containerLeft + (containerBounds.left || 0) + window.scrollX;
      var portalTop = containerTop + (containerBounds.top || 0) + window.scrollY;
      return /*#__PURE__*/react.createElement(Portal, {
        zIndex: zIndex
      }, /*#__PURE__*/react.createElement(TooltipComponent, useTooltipInPortal_extends({
        left: portalLeft,
        top: portalTop
      }, tooltipProps)));
    };
  }, [detectBoundsOption, zIndexOption, containerBounds.left, containerBounds.top]);
  return {
    // react-use-measure doesn't currently accept SVGElement refs
    // @ts-ignore fixed here https://github.com/react-spring/react-use-measure/pull/17
    containerRef: containerRef,
    containerBounds: containerBounds,
    forceRefreshBounds: forceRefreshBounds,
    TooltipInPortal: TooltipInPortal
  };
}
;// CONCATENATED MODULE: ./node_modules/@visx/tooltip/esm/hooks/useTooltip.js
var useTooltip_excluded = ["tooltipOpen"];

function useTooltip_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function useTooltip_extends() { useTooltip_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return useTooltip_extends.apply(this, arguments); }


function useTooltip(
/** Optional initial TooltipState. */
initialTooltipState) {
  var _useState = (0,react.useState)(useTooltip_extends({
    tooltipOpen: false
  }, initialTooltipState)),
      tooltipState = _useState[0],
      setTooltipState = _useState[1];

  var showTooltip = (0,react.useCallback)(function (showArgs) {
    return setTooltipState(typeof showArgs === 'function' ? function (_ref) {
      var tooltipOpen = _ref.tooltipOpen,
          show = useTooltip_objectWithoutPropertiesLoose(_ref, useTooltip_excluded);

      return useTooltip_extends({}, showArgs(show), {
        tooltipOpen: true
      });
    } : {
      tooltipOpen: true,
      tooltipLeft: showArgs.tooltipLeft,
      tooltipTop: showArgs.tooltipTop,
      tooltipData: showArgs.tooltipData
    });
  }, [setTooltipState]);
  var hideTooltip = (0,react.useCallback)(function () {
    return setTooltipState({
      tooltipOpen: false,
      tooltipLeft: undefined,
      tooltipTop: undefined,
      tooltipData: undefined
    });
  }, [setTooltipState]);
  return {
    tooltipOpen: tooltipState.tooltipOpen,
    tooltipLeft: tooltipState.tooltipLeft,
    tooltipTop: tooltipState.tooltipTop,
    tooltipData: tooltipState.tooltipData,
    updateTooltip: setTooltipState,
    showTooltip: showTooltip,
    hideTooltip: hideTooltip
  };
}
;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Chart/hooks/useTooltip.js

function useTooltip_useTooltip() {
    const portalProps = useTooltipInPortal({
        scroll: true,
        detectBounds: true
    });
    const tooltipProps = useTooltip();
    return Object.assign(Object.assign({}, tooltipProps), portalProps);
}
/* harmony default export */ const hooks_useTooltip = (useTooltip_useTooltip);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Chart/types/line.js
var line_rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};

















const bisectDate = bisector_bisector((d) => d.date).left;
const line_Container = dist_theme/* styled.div */.zo.div `
  width: 100%;
  height: 100%;

  path {
    transition: d 0.4s cubic-bezier(0.4, 0, 0.2, 1);
  }

  .axis text {
    font-family: ${({ theme }) => theme.fonts.default};
    fill: ${({ theme }) => theme.color('dark20')};
    font-size: 12px;
  }

  .grid line {
    stroke: ${({ theme }) => theme.color('dark60')};
    pointer-events: none;
  }
`;
const Helper = dist_theme/* styled.line */.zo.line `
  stroke: ${({ theme }) => theme.color('dark60')};
`;
const line_Chart = ({ data, colors, xAxisLabel = axisLabel, yAxisLabel = axisLabel, features }) => {
    const { legend, labelCount } = features || {};
    const container = (0,react.useRef)(null);
    const { height, width } = hooks_useSize(container);
    const { showTooltip, hideTooltip, tooltipData, tooltipLeft, tooltipTop, TooltipInPortal, containerRef } = hooks_useTooltip();
    const [currentPoint, setCurrentPoint] = (0,react.useState)(null);
    const keys = (0,react.useMemo)(() => {
        return data.length ? Object.keys(data[0]).filter((key) => key !== 'date') : [];
    }, [data]);
    const dates = (0,react.useMemo)(() => {
        if (labelCount === 0) {
            return [];
        }
        const items = data.length ? data.map((item) => (item.date ? item.date : 0)) : [];
        if (labelCount) {
            const ratio = Math.ceil(items.length / (labelCount - 1));
            return items.filter((_item, index) => index === 0 || index === items.length - 1 || (index + 1) % ratio === 0);
        }
        return items;
    }, [data, labelCount]);
    const [xScale, yScale] = (0,react.useMemo)(() => {
        const dateValues = data.length ? data.map((item) => (item.date ? item.date.valueOf() : 0)) : [];
        const max = data.reduce((totalMax, item) => {
            const values = Object.entries(item)
                .filter(([key]) => key !== 'date')
                .map(([, value]) => value);
            const currentMax = Math.max(...values);
            return currentMax > totalMax ? currentMax : totalMax;
        }, 0);
        return [
            createTimeScale({
                range: [40, width - 80],
                domain: [Math.min(...dateValues), Math.max(...dateValues)]
            }),
            createLinearScale({
                range: [height - 30, 10],
                domain: [0, max],
                nice: true
            })
        ];
    }, [data, width, height]);
    const onHover = (0,react.useCallback)((event) => {
        const point = localPoint_localPoint(event) || { x: 20, y: 0 };
        setCurrentPoint(point);
    }, [setCurrentPoint]);
    const onBlur = (0,react.useCallback)(() => {
        setCurrentPoint(null);
    }, [setCurrentPoint]);
    (0,react.useEffect)(() => {
        if (!currentPoint) {
            if (tooltipData) {
                hideTooltip();
            }
            return;
        }
        const { x, y } = currentPoint;
        const xScaled = xScale.invert(x);
        const index = bisectDate(data, xScaled, 1, data.length - 1);
        const d0 = data[index - 1];
        const d1 = data[index];
        if (d0 === null || d0 === void 0 ? void 0 : d0.date) {
            let dataItem = d0;
            if (d1 === null || d1 === void 0 ? void 0 : d1.date) {
                dataItem = Math.abs(xScaled.valueOf() - d0.date.valueOf()) > Math.abs(xScaled.valueOf() - d1.date.valueOf()) ? d1 : d0;
            }
            if (dataItem.date) {
                const { date } = dataItem, datum = line_rest(dataItem, ["date"]);
                showTooltip({
                    tooltipData: Object.assign({ label: xAxisLabel(date), data: dataItem }, applyAxisFormatter(datum, yAxisLabel)),
                    tooltipLeft: xScale(dataItem.date),
                    tooltipTop: y
                });
            }
        }
    }, [data, currentPoint, showTooltip, yScale, xScale]);
    return ((0,jsx_runtime.jsxs)(jsx_runtime.Fragment, { children: [(0,jsx_runtime.jsx)(line_Container, Object.assign({ ref: container, legend: legend }, { children: (0,jsx_runtime.jsxs)("svg", Object.assign({ width: "100%", height: "100%", ref: containerRef }, { children: [(0,jsx_runtime.jsx)(GridRows, { left: 0, scale: yScale, width: width - 45, className: "grid", numTicks: 6 }), (0,jsx_runtime.jsx)(AxisRight, { scale: yScale, hideAxisLine: true, hideTicks: true, left: width - 40, tickFormat: (yAxisLabel || axisLabel), numTicks: 6, axisClassName: "axis" }), (0,jsx_runtime.jsx)(Axis, { scale: xScale, top: height - 24, tickValues: dates, hideAxisLine: true, hideTicks: true, tickFormat: (xAxisLabel || axisLabel), axisClassName: "axis" }), colors.map((color, index) => ((0,jsx_runtime.jsx)(LinearGradient, { id: `gradient-${index}`, from: transparentize(color, 0.1), to: transparentize(color, 0) }, color))), keys.map((key, index) => ((0,jsx_runtime.jsxs)(react.Fragment, { children: [(0,jsx_runtime.jsx)(AreaClosed, { fill: `url('#gradient-${index}')`, data: data, x: (d) => xScale(d.date || 0), y: (d) => { var _a; return (_a = yScale(d[key])) !== null && _a !== void 0 ? _a : 0; }, yScale: yScale }, key), (0,jsx_runtime.jsx)(LinePath, { stroke: colors[index], strokeWidth: 1.5, data: data, x: (d) => xScale(d.date || 0), y: (d) => { var _a; return (_a = yScale(d[key])) !== null && _a !== void 0 ? _a : 0; } })] }, key))), tooltipData && (0,jsx_runtime.jsx)(Helper, { x1: tooltipLeft, strokeDasharray: "4", y1: 10, x2: tooltipLeft, y2: height - 30 }), (0,jsx_runtime.jsx)(components_Points, { colors: colors, data: tooltipData === null || tooltipData === void 0 ? void 0 : tooltipData.data, xScale: xScale, yScale: yScale }), (0,jsx_runtime.jsx)("rect", { width: `${width - 120}px`, height: `${height - 40}px`, onTouchStart: onHover, onTouchMove: onHover, onMouseMove: onHover, onMouseLeave: onBlur, fill: "transparent", x: 40, y: 10 }), (0,jsx_runtime.jsx)(components_Tooltip, { as: TooltipInPortal, x: tooltipLeft, y: tooltipTop, data: tooltipData, colors: colors })] })) })), legend === false ? null : (0,jsx_runtime.jsx)(components_Legend, { colors: colors, labels: keys })] }));
};
/* harmony default export */ const types_line = (line_Chart);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Chart/types/statLine.js
var statLine_rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};














const config = {
    paddingTop: 4,
    paddingBottom: 4,
    paddingLeft: 4,
    paddingRight: 4
};
const statLine_bisectDate = bisector_bisector((d) => d.date).left;
const statLine_Container = dist_theme/* styled.div */.zo.div `
  width: 100%;
  height: ${({ height }) => (height ? `${height}px` : '100%')};

  path {
    transition: d 0.4s cubic-bezier(0.4, 0, 0.2, 1);
  }

  .axis text {
    font-family: ${({ theme }) => theme.fonts.default};
    fill: ${({ theme }) => theme.color('dark20')};
    font-size: 12px;
  }

  .grid line {
    stroke: ${({ theme }) => theme.color('dark60')};
    pointer-events: none;
  }
`;
const statLine_Helper = dist_theme/* styled.line */.zo.line `
  stroke: ${({ theme }) => theme.color('dark60')};
`;
const statLine_Chart = ({ data, colors, xAxisLabel = axisLabel, yAxisLabel = axisLabel, features = {} }) => {
    const { showGradient, highlightColors, highlightSlice } = features;
    const theme = (0,react.useContext)(dist_theme/* ThemeContext */.Ni);
    const container = (0,react.useRef)(null);
    const { height, width } = hooks_useSize(container);
    const { showTooltip, hideTooltip, tooltipData, tooltipLeft, tooltipTop, TooltipInPortal, containerRef: svgRef } = hooks_useTooltip();
    const [currentPoint, setCurrentPoint] = (0,react.useState)(null);
    const keys = (0,react.useMemo)(() => {
        return data.length ? Object.keys(data[0]).filter((key) => key !== 'date') : [];
    }, [data]);
    const [xScale, yScale] = (0,react.useMemo)(() => {
        const dateValues = data.length ? data.map((item) => (item.date ? item.date.valueOf() : 0)) : [];
        const max = data.reduce((totalMax, item) => {
            const values = Object.entries(item)
                .filter(([key]) => key !== 'date')
                .map(([, value]) => value);
            const currentMax = Math.max(...values);
            return currentMax > totalMax ? currentMax : totalMax;
        }, 0);
        return [
            createTimeScale({
                range: [config.paddingLeft, width - config.paddingRight],
                domain: [Math.min(...dateValues), Math.max(...dateValues)]
            }),
            createLinearScale({
                range: [height - config.paddingBottom, config.paddingTop],
                domain: [0, max],
                nice: true
            })
        ];
    }, [data, width, height]);
    const onHover = (0,react.useCallback)((event) => {
        const point = localPoint_localPoint(event) || { x: 20, y: 0 };
        setCurrentPoint(point);
    }, [setCurrentPoint]);
    const onBlur = (0,react.useCallback)(() => {
        setCurrentPoint(null);
    }, [setCurrentPoint]);
    (0,react.useEffect)(() => {
        if (!currentPoint) {
            if (tooltipData) {
                hideTooltip();
            }
            return;
        }
        const { x, y } = currentPoint;
        const xScaled = xScale.invert(x);
        const index = statLine_bisectDate(data, xScaled, 1, data.length - 1);
        const d0 = data[index - 1];
        const d1 = data[index];
        if ((d0 === null || d0 === void 0 ? void 0 : d0.date) || (d1 === null || d1 === void 0 ? void 0 : d1.date)) {
            let dataItem;
            if ((d0 === null || d0 === void 0 ? void 0 : d0.date) && (d1 === null || d1 === void 0 ? void 0 : d1.date)) {
                dataItem = Math.abs(xScaled.valueOf() - d0.date.valueOf()) > Math.abs(xScaled.valueOf() - d1.date.valueOf()) ? d1 : d0;
            }
            else {
                dataItem = (d0 === null || d0 === void 0 ? void 0 : d0.date) ? d0 : d1;
            }
            if (dataItem.date) {
                const { date } = dataItem, datum = statLine_rest(dataItem, ["date"]);
                showTooltip({
                    tooltipData: Object.assign({ label: xAxisLabel(date), data: dataItem }, applyAxisFormatter(datum, yAxisLabel)),
                    tooltipLeft: xScale(dataItem.date),
                    tooltipTop: y
                });
            }
        }
    }, [data, currentPoint, showTooltip, yScale, xScale]);
    const highlightedData = (0,react.useMemo)(() => {
        if (!(highlightSlice === null || highlightSlice === void 0 ? void 0 : highlightSlice.length))
            return [];
        return highlightSlice.map((sliceParams) => data.slice(...sliceParams));
    }, [highlightSlice]);
    const highlightColor = highlightColors && theme.color(...highlightColors)({ theme });
    return ((0,jsx_runtime.jsxs)(statLine_Container, Object.assign({ ref: container }, { children: [(0,jsx_runtime.jsxs)("svg", Object.assign({ width: "100%", height: "100%", ref: svgRef }, { children: [colors.map((gradientColor, index) => ((0,jsx_runtime.jsx)(LinearGradient, { id: `gradient-${index}`, from: transparentize(gradientColor, 0.1), to: transparentize(gradientColor, 0) }, gradientColor))), keys.map((key, index) => ((0,jsx_runtime.jsxs)(react.Fragment, { children: [showGradient ? ((0,jsx_runtime.jsx)(AreaClosed, { fill: `url('#gradient-${index}')`, data: data, x: (d) => xScale(d.date || 0), y: (d) => { var _a; return (_a = yScale(d[key])) !== null && _a !== void 0 ? _a : 0; }, yScale: yScale }, key)) : null, (0,jsx_runtime.jsx)(LinePath, { stroke: colors[index], strokeWidth: 1.5, data: data, x: (d) => xScale(d.date || 0), y: (d) => { var _a; return (_a = yScale(d[key])) !== null && _a !== void 0 ? _a : 0; } }), highlightedData === null || highlightedData === void 0 ? void 0 : highlightedData.map((highlightedSlice) => {
                                var _a;
                                const slicesFlat = (_a = highlightedSlice.flat()) !== null && _a !== void 0 ? _a : [];
                                if (!(slicesFlat === null || slicesFlat === void 0 ? void 0 : slicesFlat.length))
                                    return null;
                                return ((0,jsx_runtime.jsxs)(react.Fragment, { children: [(0,jsx_runtime.jsx)(LinePath, { stroke: highlightColor, strokeWidth: 1.5, data: highlightedSlice, x: (d) => xScale(d.date || 0), y: (d) => { var _a; return (_a = yScale(d[key])) !== null && _a !== void 0 ? _a : 0; } }), (0,jsx_runtime.jsx)(components_Points, { colors: highlightColor ? [highlightColor] : [], data: highlightedSlice[highlightedData.length - 1], xScale: xScale, yScale: yScale })] }, slicesFlat.join(',')));
                            })] }, key))), tooltipData && (0,jsx_runtime.jsx)(statLine_Helper, { x1: tooltipLeft, strokeDasharray: "4", y1: 10, x2: tooltipLeft, y2: height - 30 }), (0,jsx_runtime.jsx)(components_Points, { colors: colors, data: tooltipData === null || tooltipData === void 0 ? void 0 : tooltipData.data, xScale: xScale, yScale: yScale }), (0,jsx_runtime.jsx)("rect", { width: "100%", height: "100%", onTouchStart: onHover, onTouchMove: onHover, onMouseMove: onHover, onMouseLeave: onBlur, fill: "transparent", x: 0, y: 0 })] })), (0,jsx_runtime.jsx)(components_Tooltip, { as: TooltipInPortal, x: tooltipLeft, y: tooltipTop, data: tooltipData, colors: colors })] })));
};
/* harmony default export */ const statLine = (statLine_Chart);

;// CONCATENATED MODULE: ./node_modules/@visx/axis/esm/axis/AxisLeft.js
var AxisLeft_excluded = ["axisClassName", "labelOffset", "tickLabelProps", "tickLength"];
function AxisLeft_extends() { AxisLeft_extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return AxisLeft_extends.apply(this, arguments); }
function AxisLeft_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }




var leftTickLabelProps = function leftTickLabelProps( /** tickValue, index */
) {
  return {
    dx: '-0.25em',
    dy: '0.25em',
    fill: '#222',
    fontFamily: 'Arial',
    fontSize: 10,
    textAnchor: 'end'
  };
};
function AxisLeft(_ref) {
  var axisClassName = _ref.axisClassName,
    _ref$labelOffset = _ref.labelOffset,
    labelOffset = _ref$labelOffset === void 0 ? 36 : _ref$labelOffset,
    _ref$tickLabelProps = _ref.tickLabelProps,
    tickLabelProps = _ref$tickLabelProps === void 0 ? leftTickLabelProps : _ref$tickLabelProps,
    _ref$tickLength = _ref.tickLength,
    tickLength = _ref$tickLength === void 0 ? 8 : _ref$tickLength,
    restProps = AxisLeft_objectWithoutPropertiesLoose(_ref, AxisLeft_excluded);
  return /*#__PURE__*/react.createElement(Axis, AxisLeft_extends({
    axisClassName: classnames_default()('visx-axis-left', axisClassName),
    labelOffset: labelOffset,
    orientation: constants_orientation.left,
    tickLabelProps: tickLabelProps,
    tickLength: tickLength
  }, restProps));
}
;// CONCATENATED MODULE: ./node_modules/@visx/axis/esm/axis/AxisBottom.js
var AxisBottom_excluded = ["axisClassName", "labelOffset", "tickLabelProps", "tickLength"];
function AxisBottom_extends() { AxisBottom_extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return AxisBottom_extends.apply(this, arguments); }
function AxisBottom_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }




var bottomTickLabelProps = function bottomTickLabelProps( /** tickValue, index */
) {
  return {
    dy: '0.25em',
    fill: '#222',
    fontFamily: 'Arial',
    fontSize: 10,
    textAnchor: 'middle'
  };
};
function AxisBottom(_ref) {
  var axisClassName = _ref.axisClassName,
    _ref$labelOffset = _ref.labelOffset,
    labelOffset = _ref$labelOffset === void 0 ? 8 : _ref$labelOffset,
    _ref$tickLabelProps = _ref.tickLabelProps,
    tickLabelProps = _ref$tickLabelProps === void 0 ? bottomTickLabelProps : _ref$tickLabelProps,
    _ref$tickLength = _ref.tickLength,
    tickLength = _ref$tickLength === void 0 ? 8 : _ref$tickLength,
    restProps = AxisBottom_objectWithoutPropertiesLoose(_ref, AxisBottom_excluded);
  return /*#__PURE__*/react.createElement(Axis, AxisBottom_extends({
    axisClassName: classnames_default()('visx-axis-bottom', axisClassName),
    labelOffset: labelOffset,
    orientation: constants_orientation.bottom,
    tickLabelProps: tickLabelProps,
    tickLength: tickLength
  }, restProps));
}
;// CONCATENATED MODULE: ./node_modules/@visx/grid/esm/grids/GridColumns.js

var GridColumns_excluded = ["top", "left", "scale", "height", "stroke", "strokeWidth", "strokeDasharray", "className", "numTicks", "lineStyle", "offset", "tickValues", "children"];
function GridColumns_extends() { GridColumns_extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return GridColumns_extends.apply(this, arguments); }
function GridColumns_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }







function GridColumns(_ref) {
  var _ref$top = _ref.top,
    top = _ref$top === void 0 ? 0 : _ref$top,
    _ref$left = _ref.left,
    left = _ref$left === void 0 ? 0 : _ref$left,
    scale = _ref.scale,
    height = _ref.height,
    _ref$stroke = _ref.stroke,
    stroke = _ref$stroke === void 0 ? '#eaf0f6' : _ref$stroke,
    _ref$strokeWidth = _ref.strokeWidth,
    strokeWidth = _ref$strokeWidth === void 0 ? 1 : _ref$strokeWidth,
    strokeDasharray = _ref.strokeDasharray,
    className = _ref.className,
    _ref$numTicks = _ref.numTicks,
    numTicks = _ref$numTicks === void 0 ? 10 : _ref$numTicks,
    lineStyle = _ref.lineStyle,
    offset = _ref.offset,
    tickValues = _ref.tickValues,
    children = _ref.children,
    restProps = GridColumns_objectWithoutPropertiesLoose(_ref, GridColumns_excluded);
  var ticks = tickValues != null ? tickValues : getTicks(scale, numTicks);
  var scaleOffset = (offset != null ? offset : 0) + getScaleBandwidth(scale) / 2;
  var tickLines = ticks.map(function (d, index) {
    var _coerceNumber;
    var x = ((_coerceNumber = coerceNumber(scale(d))) != null ? _coerceNumber : 0) + scaleOffset;
    return {
      index: index,
      from: new Point_Point({
        x: x,
        y: 0
      }),
      to: new Point_Point({
        x: x,
        y: height
      })
    };
  });
  return /*#__PURE__*/react.createElement(Group, {
    className: classnames_default()('visx-columns', className),
    top: top,
    left: left
  }, children ? children({
    lines: tickLines
  }) : tickLines.map(function (_ref2) {
    var from = _ref2.from,
      to = _ref2.to,
      index = _ref2.index;
    return /*#__PURE__*/react.createElement(shapes_Line/* default */.Z, GridColumns_extends({
      key: "column-line-" + index,
      from: from,
      to: to,
      stroke: stroke,
      strokeWidth: strokeWidth,
      strokeDasharray: strokeDasharray,
      style: lineStyle
    }, restProps));
  }));
}
GridColumns.propTypes = {
  tickValues: (prop_types_default()).array,
  height: (prop_types_default()).number.isRequired
};
;// CONCATENATED MODULE: ./node_modules/@visx/scale/node_modules/d3-array/src/range.js
/* harmony default export */ function range(start, stop, step) {
  start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;

  var i = -1,
      n = Math.max(0, Math.ceil((stop - start) / step)) | 0,
      range = new Array(n);

  while (++i < n) {
    range[i] = start + i * step;
  }

  return range;
}

;// CONCATENATED MODULE: ./node_modules/@visx/scale/node_modules/d3-scale/src/ordinal.js


const implicit = Symbol("implicit");

function ordinal() {
  var index = new Map(),
      domain = [],
      range = [],
      unknown = implicit;

  function scale(d) {
    var key = d + "", i = index.get(key);
    if (!i) {
      if (unknown !== implicit) return unknown;
      index.set(key, i = domain.push(d));
    }
    return range[(i - 1) % range.length];
  }

  scale.domain = function(_) {
    if (!arguments.length) return domain.slice();
    domain = [], index = new Map();
    for (const value of _) {
      const key = value + "";
      if (index.has(key)) continue;
      index.set(key, domain.push(value));
    }
    return scale;
  };

  scale.range = function(_) {
    return arguments.length ? (range = Array.from(_), scale) : range.slice();
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  scale.copy = function() {
    return ordinal(domain, range).unknown(unknown);
  };

  initRange.apply(scale, arguments);

  return scale;
}

;// CONCATENATED MODULE: ./node_modules/@visx/scale/node_modules/d3-scale/src/band.js




function band() {
  var scale = ordinal().unknown(undefined),
      domain = scale.domain,
      ordinalRange = scale.range,
      r0 = 0,
      r1 = 1,
      step,
      bandwidth,
      round = false,
      paddingInner = 0,
      paddingOuter = 0,
      align = 0.5;

  delete scale.unknown;

  function rescale() {
    var n = domain().length,
        reverse = r1 < r0,
        start = reverse ? r1 : r0,
        stop = reverse ? r0 : r1;
    step = (stop - start) / Math.max(1, n - paddingInner + paddingOuter * 2);
    if (round) step = Math.floor(step);
    start += (stop - start - step * (n - paddingInner)) * align;
    bandwidth = step * (1 - paddingInner);
    if (round) start = Math.round(start), bandwidth = Math.round(bandwidth);
    var values = range(n).map(function(i) { return start + step * i; });
    return ordinalRange(reverse ? values.reverse() : values);
  }

  scale.domain = function(_) {
    return arguments.length ? (domain(_), rescale()) : domain();
  };

  scale.range = function(_) {
    return arguments.length ? ([r0, r1] = _, r0 = +r0, r1 = +r1, rescale()) : [r0, r1];
  };

  scale.rangeRound = function(_) {
    return [r0, r1] = _, r0 = +r0, r1 = +r1, round = true, rescale();
  };

  scale.bandwidth = function() {
    return bandwidth;
  };

  scale.step = function() {
    return step;
  };

  scale.round = function(_) {
    return arguments.length ? (round = !!_, rescale()) : round;
  };

  scale.padding = function(_) {
    return arguments.length ? (paddingInner = Math.min(1, paddingOuter = +_), rescale()) : paddingInner;
  };

  scale.paddingInner = function(_) {
    return arguments.length ? (paddingInner = Math.min(1, _), rescale()) : paddingInner;
  };

  scale.paddingOuter = function(_) {
    return arguments.length ? (paddingOuter = +_, rescale()) : paddingOuter;
  };

  scale.align = function(_) {
    return arguments.length ? (align = Math.max(0, Math.min(1, _)), rescale()) : align;
  };

  scale.copy = function() {
    return band(domain(), [r0, r1])
        .round(round)
        .paddingInner(paddingInner)
        .paddingOuter(paddingOuter)
        .align(align);
  };

  return initRange.apply(rescale(), arguments);
}

function pointish(scale) {
  var copy = scale.copy;

  scale.padding = scale.paddingOuter;
  delete scale.paddingInner;
  delete scale.paddingOuter;

  scale.copy = function() {
    return pointish(copy());
  };

  return scale;
}

function point() {
  return pointish(band.apply(null, arguments).paddingInner(1));
}

;// CONCATENATED MODULE: ./node_modules/@visx/scale/esm/scales/band.js


var updateBandScale = scaleOperator('domain', 'range', 'reverse', 'align', 'padding', 'round');
function createBandScale(config) {
  return updateBandScale(band(), config);
}
;// CONCATENATED MODULE: ./node_modules/@visx/scale/esm/scales/ordinal.js


var updateOrdinalScale = scaleOperator('domain', 'range', 'reverse', 'unknown');
function createOrdinalScale(config) {
  return updateOrdinalScale(ordinal(), config);
}
;// CONCATENATED MODULE: ./node_modules/@visx/shape/esm/shapes/Bar.js
var Bar_excluded = ["className", "innerRef"];
function Bar_extends() { Bar_extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return Bar_extends.apply(this, arguments); }
function Bar_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }


function Bar(_ref) {
  var className = _ref.className,
    innerRef = _ref.innerRef,
    restProps = Bar_objectWithoutPropertiesLoose(_ref, Bar_excluded);
  return /*#__PURE__*/react.createElement("rect", Bar_extends({
    ref: innerRef,
    className: classnames_default()('visx-bar', className)
  }, restProps));
}
;// CONCATENATED MODULE: ./node_modules/@visx/shape/esm/util/getBandwidth.js
function getBandwidth(scale) {
  if ('bandwidth' in scale) {
    return scale.bandwidth();
  }
  var range = scale.range();
  var domain = scale.domain();
  return Math.abs(range[range.length - 1] - range[0]) / domain.length;
}
;// CONCATENATED MODULE: ./node_modules/@visx/shape/esm/shapes/BarGroupHorizontal.js
var BarGroupHorizontal_excluded = ["data", "className", "top", "left", "x", "y0", "y0Scale", "y1Scale", "xScale", "color", "keys", "width", "children"];
function BarGroupHorizontal_extends() { BarGroupHorizontal_extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return BarGroupHorizontal_extends.apply(this, arguments); }
function BarGroupHorizontal_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }





function BarGroupHorizontal(_ref) {
  var data = _ref.data,
    className = _ref.className,
    top = _ref.top,
    left = _ref.left,
    _ref$x = _ref.x,
    x = _ref$x === void 0 ? function /** val */ () {
      return 0;
    } : _ref$x,
    y0 = _ref.y0,
    y0Scale = _ref.y0Scale,
    y1Scale = _ref.y1Scale,
    xScale = _ref.xScale,
    color = _ref.color,
    keys = _ref.keys,
    width = _ref.width,
    children = _ref.children,
    restProps = BarGroupHorizontal_objectWithoutPropertiesLoose(_ref, BarGroupHorizontal_excluded);
  var barHeight = getBandwidth(y1Scale);
  var barGroups = data.map(function (group, i) {
    return {
      index: i,
      y0: y0Scale(y0(group)) || 0,
      bars: keys.map(function (key, j) {
        var value = group[key];
        return {
          index: j,
          key: key,
          value: value,
          height: barHeight,
          x: x(value) || 0,
          y: y1Scale(key) || 0,
          color: color(key, j),
          width: xScale(value) || 0
        };
      })
    };
  });
  if (children) return /*#__PURE__*/react.createElement(react.Fragment, null, children(barGroups));
  return /*#__PURE__*/react.createElement(Group, {
    className: classnames_default()('visx-bar-group-horizontal', className),
    top: top,
    left: left
  }, barGroups.map(function (barGroup) {
    return /*#__PURE__*/react.createElement(Group, {
      key: "bar-group-" + barGroup.index + "-" + barGroup.y0,
      top: barGroup.y0
    }, barGroup.bars.map(function (bar) {
      return /*#__PURE__*/react.createElement(Bar, BarGroupHorizontal_extends({
        key: "bar-group-bar-" + barGroup.index + "-" + bar.index + "-" + bar.value + "-" + bar.key,
        x: bar.x,
        y: bar.y,
        width: bar.width,
        height: bar.height,
        fill: bar.color
      }, restProps));
    }));
  }));
}
;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Chart/types/barGroupHorizontal.js
var barGroupHorizontal_rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};














const barGroupHorizontal_Container = dist_theme/* styled.div */.zo.div `
  width: 100%;
  height: 100%;

  rect {
    transition: width 0.4s cubic-bezier(0.4, 0, 0.2, 1);
  }

  .axis text {
    font-family: ${({ theme }) => theme.fonts.default};
    fill: ${({ theme }) => theme.color('dark20')};
    font-size: 12px;
  }

  .grid line {
    stroke: ${({ theme }) => theme.color('dark60')};
    pointer-events: none;
  }
`;
const defaultMargins = {
    top: 20,
    bottom: 25,
    left: 200,
    right: 20
};
const barGroupHorizontal_Chart = ({ data, colors, features, xAxisLabel = axisLabel, yAxisLabel = textLabel({ trucateAfter: 20 }) }) => {
    const container = (0,react.useRef)(null);
    const { height, width } = hooks_useSize(container);
    const { showTooltip, hideTooltip, tooltipData, tooltipLeft, tooltipTop, TooltipInPortal, containerRef: svgRef } = hooks_useTooltip();
    const { groups = [], legend, labelCount } = features || {};
    const margins = (features === null || features === void 0 ? void 0 : features.margins) ? Object.assign(Object.assign({}, defaultMargins), features.margins) : defaultMargins;
    const keys = (0,react.useMemo)(() => {
        return Array.from(new Set(data.flatMap((d) => Object.keys(d))));
    }, [data]);
    const dataGrouped = (0,react.useMemo)(() => {
        return groups.map(({ label }, idx) => {
            var _a;
            const d = (_a = data[idx]) !== null && _a !== void 0 ? _a : {};
            return Object.assign({ label }, d);
        });
    }, [data, groups]);
    const [xMin, xMax] = (0,react.useMemo)(() => {
        const values = data.flatMap((d) => Object.values(d).map(Number));
        const min = Math.min(...values, 0);
        const max = Math.max(...values, 0);
        return [min, Math.max(max, min + 1)];
    }, [data]);
    const yScale = (0,react.useMemo)(() => {
        return createBandScale({ domain: groups.map(({ label }) => label), range: [margins.top, height - margins.top - margins.bottom] });
    }, [height, groups]);
    const xScale = (0,react.useMemo)(() => {
        return createLinearScale({ domain: [xMin, xMax], range: [0, width - margins.left - margins.right], nice: true });
    }, [width, xMin, xMax]);
    const colorScale = (0,react.useMemo)(() => {
        return createOrdinalScale({
            domain: keys,
            range: colors
        });
    }, [keys]);
    const innerScale = (0,react.useMemo)(() => {
        return createBandScale({
            domain: keys,
            padding: 0.2,
            paddingOuter: 1,
            range: [0, yScale.bandwidth()]
        });
    }, [keys, yScale]);
    const onHover = (0,react.useCallback)((groupIdx) => (event) => {
        const { x, y } = localPoint_localPoint(event) || { x: 20, y: 0 };
        const _a = dataGrouped[groupIdx], { label } = _a, datum = barGroupHorizontal_rest(_a, ["label"]);
        showTooltip({
            tooltipData: Object.assign({ label, data: datum }, applyAxisFormatter(datum, xAxisLabel)),
            tooltipLeft: x,
            tooltipTop: y
        });
    }, [dataGrouped]);
    const onBlur = (0,react.useCallback)(() => {
        hideTooltip();
    }, []);
    return ((0,jsx_runtime.jsxs)(jsx_runtime.Fragment, { children: [(0,jsx_runtime.jsx)(barGroupHorizontal_Container, Object.assign({ ref: container, legend: legend }, { children: (0,jsx_runtime.jsxs)("svg", Object.assign({ width: "100%", height: "100%", ref: svgRef }, { children: [(0,jsx_runtime.jsx)(Group, Object.assign({ left: margins.left, top: margins.top }, { children: (0,jsx_runtime.jsx)(GridColumns, { className: "grid", scale: xScale, width: width, height: height - margins.top - margins.bottom - 20 }) })), (0,jsx_runtime.jsxs)(Group, Object.assign({ left: margins.left }, { children: [(0,jsx_runtime.jsx)(BarGroupHorizontal, Object.assign({ data: dataGrouped, height: height, width: width, y0: (d) => d.label, y0Scale: yScale, y1Scale: innerScale, xScale: xScale, color: colorScale, keys: keys }, { children: (barGroups) => {
                                        return barGroups.map((barGroup, groupIdx) => {
                                            const firstBar = barGroup.bars.find(Boolean);
                                            const lastBar = firstBar ? barGroup.bars[barGroup.bars.length - 1] : null;
                                            let hotZoneStart = 0;
                                            let hotZoneHeight = 0;
                                            if (firstBar && lastBar) {
                                                hotZoneStart = firstBar.y + barGroup.y0;
                                                hotZoneHeight = lastBar.y + lastBar.height - firstBar.y;
                                            }
                                            return ((0,jsx_runtime.jsxs)(react.Fragment, { children: [(0,jsx_runtime.jsx)(Group, Object.assign({ top: barGroup.y0 }, { children: barGroup.bars.map((bar) => {
                                                            return ((0,jsx_runtime.jsx)(Bar, { x: bar.x, y: bar.y, width: Math.max(bar.width, 0), height: bar.height, fill: bar.color }, `${barGroup.index}-${bar.index}-${bar.key}`));
                                                        }) })), (0,jsx_runtime.jsx)(Group, { children: (0,jsx_runtime.jsx)("rect", { width: Math.max(width - margins.left - margins.right, 0), height: hotZoneHeight, onTouchStart: onHover(groupIdx), onTouchMove: onHover(groupIdx), onMouseMove: onHover(groupIdx), onMouseLeave: onBlur, fill: "transparent", x: 0, y: hotZoneStart }) })] }, `bar-group-${barGroup.index}-${barGroup.y0}`));
                                        });
                                    } })), (0,jsx_runtime.jsx)(Group, Object.assign({ left: -20 }, { children: (0,jsx_runtime.jsx)(AxisLeft, { scale: yScale, hideAxisLine: true, hideTicks: true, tickFormat: yAxisLabel, axisClassName: "axis", tickLabelProps: () => ({
                                            textAnchor: 'end',
                                            dy: '0.33em'
                                        }) }) })), (0,jsx_runtime.jsx)(Group, Object.assign({ top: height - margins.bottom - margins.top }, { children: (0,jsx_runtime.jsx)(AxisBottom, { scale: xScale, hideAxisLine: true, hideTicks: true, numTicks: labelCount, tickFormat: xAxisLabel, axisClassName: "axis", tickLabelProps: () => ({
                                            textAnchor: 'middle',
                                            fontSize: 14,
                                            dy: '0.33em'
                                        }) }) }))] })), (0,jsx_runtime.jsx)(components_Tooltip, { as: TooltipInPortal, x: tooltipLeft, y: tooltipTop, data: tooltipData, colors: colors })] })) })), legend ? (0,jsx_runtime.jsx)(components_Legend, { colors: colors, labels: keys }) : null] }));
};
/* harmony default export */ const barGroupHorizontal = (barGroupHorizontal_Chart);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Chart/Chart.js
var Chart_rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};









const chartTypes = {
    gauge: gauge,
    bar: bar,
    line: types_line,
    statLine: statLine,
    barGroupHorizontal: barGroupHorizontal
};
const ChartStyled = dist_theme/* styled.div */.zo.div `
  display: flex;
  flex-direction: column;
  width: 100%;
  height: 100%;
  position: relative;
`;
const Chart_Title = dist_theme/* styled.h3 */.zo.h3 `
  text-align: center;
  font-weight: ${({ theme }) => theme.fontWeights.semibold};
  margin-bottom: 24px;
`;
/**
 * Chart component
 */
const Chart_Chart = (_a) => {
    var { data, fills, height, labels, type, width, features, xAxisLabel, yAxisLabel, title } = _a, rest = Chart_rest(_a, ["data", "fills", "height", "labels", "type", "width", "features", "xAxisLabel", "yAxisLabel", "title"]);
    const { colors: themeColors } = (0,react.useContext)(dist_theme/* ThemeContext */.Ni);
    const colors = (0,react.useMemo)(() => (fills || ['yellow30', 'purple30', 'red50', 'teal30']).map((fill) => themeColors[fill]), [fills, themeColors]);
    const ChartTypeComponent = (0,react.useMemo)(() => chartTypes[type], [type]);
    return ((0,jsx_runtime.jsxs)(jsx_runtime.Fragment, { children: [title && (0,jsx_runtime.jsx)(Chart_Title, { children: title }), (0,jsx_runtime.jsx)(Box/* default */.Z, Object.assign({ height: height, width: width || '100%' }, rest, { children: (0,jsx_runtime.jsx)(ChartStyled, { children: (0,jsx_runtime.jsx)(ChartTypeComponent, { data: data, colors: colors, labels: labels || false, features: features, xAxisLabel: xAxisLabel, yAxisLabel: yAxisLabel }) }) }))] }));
};
Chart_Chart.defaultProps = {
    type: 'gauge'
};
/* harmony default export */ const components_Chart_Chart = (Chart_Chart);

// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/components/Checkbox/Checkbox.js
var Checkbox = __webpack_require__(5477);
;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Checkbox/index.js


// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/components/Dialog/Dialog.js + 2 modules
var Dialog = __webpack_require__(7802);
;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Dialog/index.js


// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/components/Divider/Divider.js
var Divider = __webpack_require__(1493);
// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/components/Dropdown/Dropdown.js + 1 modules
var Dropdown = __webpack_require__(3853);
;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Dropdown/index.js


// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/components/Form/Form.js
var Form = __webpack_require__(9427);
// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/components/Form/Fieldset.js
var Fieldset = __webpack_require__(6967);
;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Grid/Grid.js
var Grid_rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};





const StyledGrid = dist_theme/* styled.section */.zo.section `
  width: ${({ inline }) => (inline ? 'auto' : '100%')};
  display: ${({ inline }) => (inline ? 'inline-grid' : 'grid')};
  grid-template-columns: repeat(${({ columns }) => columns[0]}, 1fr);
  grid-gap: ${({ gaps }) => gaps[0]}px;
  grid-auto-rows: auto;
  ${({ columns, theme }) => columns.map((value, index) => `
  @media only screen and (min-width: ${theme.breakpoints[index]}) {
    grid-template-columns: repeat(${value}, 1fr);
  }`)}
  ${({ gaps, theme }) => gaps.map((value, index) => `
    @media only screen and (min-width: ${theme.breakpoints[index]}) {
      grid-gap: ${value}px;
    }`)}
  ${index_esm/* space */.Dh}
`;
/**
 * Layout component for grid like content
 *
 * @example
 * <Grid columns={[1, 2]} gap={20}>
 *    <Box>
 *      Column 1
 *    </Box>
 *    <Box>
 *      Column 2
 *    </Box>
 * </Grid>
 */
const Grid = (0,component/* componentWithRef */.w)((_a, forwardRef) => {
    var { gap, children, columns, inline } = _a, rest = Grid_rest(_a, ["gap", "children", "columns", "inline"]);
    const columnsArray = (0,react.useMemo)(() => (typeof columns === 'number' ? [columns] : columns || [1]), [columns]);
    const gapsArray = (0,react.useMemo)(() => (typeof gap === 'number' ? [gap] : gap || [24]), [gap]);
    return ((0,jsx_runtime.jsx)(StyledGrid, Object.assign({ columns: columnsArray, gaps: gapsArray, inline: inline, ref: forwardRef }, rest, { children: children })));
});
/* harmony default export */ const Grid_Grid = (Grid);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Input/index.js


;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Link/Link.js
var Link_rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};





const StyledLink = dist_theme/* styled.a */.zo.a `
  background: transparent;
  text-decoration: ${({ underline }) => (underline ? 'underline' : 'none')};
  &:hover {
    color: ${({ theme }) => theme.color('purple50', 'purple70')};
    text-decoration: none;
  }
  &:focus {
    border-radius: 2px;
  }
  ${({ icon }) => icon &&
    `
    .icon {
      float: left;
      margin-right: 8px;
    }
  `}
  color: ${({ theme }) => theme.color('purple70', 'purple50')};
  ${helpers/* styledFocus */.By}
  ${helpers/* parseColorProps */.sL}
  ${({ theme }) => (0,index_esm/* variant */.bU)({
    variants: {
        nav: {
            color: theme.color('dark20')({ theme }),
            fontSize: 12,
            ':hover': {
                color: theme.color('dark0')({ theme })
            },
            ':active': {
                color: theme.color('dark0')({ theme })
            },
            '&[aria-current="page"]': {
                color: theme.color('dark10')({ theme })
            },
            '&[aria-current="page"]:hover': {
                color: theme.color('dark0')({ theme })
            }
        },
        blank: {
            color: 'inherit',
            ':hover': {
                color: 'inherit'
            }
        },
        appBar: {
            color: theme.color('dark20')({ theme }),
            height: '100%',
            padding: '16px 0',
            margin: '0 15px',
            display: 'flex',
            alignSelf: 'center',
            ':hover': {
                color: theme.color('dark0')({ theme })
            },
            ':active': {
                color: theme.color('dark0')({ theme })
            },
            '&[aria-current="page"]': {
                color: theme.color('dark0')({ theme }),
                borderBottom: `3px solid ${theme.colors.purple50}`,
                marginBottom: '-3px'
            },
            fontWeight: '400',
            fontSize: '14px'
        },
        'nav-side': {
            color: theme.color('dark0', 'purple50')({ theme }),
            width: '63px',
            height: '64px',
            display: 'flex',
            justifyContent: 'center',
            alignItems: 'center',
            ':hover': {
                color: theme.color('dark0', 'purple30')({ theme }),
                bg: theme.color('dark60', 'light80')({ theme })
            }
        }
    }
})}

    ${({ stretch }) => stretch &&
    `
      &:after{
        position: absolute;
        top: 0;
        right: 0;
        bottom: 0;
        left: 0;
        z-index: 1;
        pointer-events: auto;
        content: "";
      }
    `}
`;
/**
 * Link is used to navigation through pages. Styled to resemble a hyperlink and semantically renders as `<a>`.
 *
 * @see
 * {@link https://design-system.solventek.com/component/link}
 *
 * @example
 * <Link href="/">
 *   Home
 * </Link>
 */
const Link = (0,component/* componentWithRef */.w)((_a, ref) => {
    var { icon: Icon, children } = _a, rest = Link_rest(_a, ["icon", "children"]);
    return ((0,jsx_runtime.jsxs)(StyledLink, Object.assign({ ref: ref, icon: Icon }, rest, { children: [!!Icon && (0,jsx_runtime.jsx)(Icon, { size: "small" }), children] })));
});
Link.defaultProps = {
    underline: false
};

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Link/index.js


// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/components/List/List.js
var List = __webpack_require__(5645);
;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/List/ListHeading.js
var ListHeading_rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};





/**
 * Link component
 */
const ListHeadingStyled = dist_theme/* styled.h5 */.zo.h5 `
  color: ${({ theme }) => theme.color('dark20')};
  font-size: ${({ theme }) => theme.fontSizes.$16};
  text-transform: uppercase;
  letter-spacing: 0.06em;
  padding: ${({ dense }) => (dense ? '16px' : '20px')} ${({ dense }) => (dense ? '16px' : '20px')};
`;
const ListHeading = (_a) => {
    var { children } = _a, rest = ListHeading_rest(_a, ["children"]);
    const { divider, dense } = (0,react.useContext)(List/* ListContext */.Z);
    return ((0,jsx_runtime.jsxs)(jsx_runtime.Fragment, { children: [(0,jsx_runtime.jsx)(ListHeadingStyled, Object.assign({ dense: dense }, rest, { children: children })), divider && (0,jsx_runtime.jsx)(Divider/* default */.Z, {})] }));
};
/* harmony default export */ const List_ListHeading = (ListHeading);

// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/components/List/ListItem.js
var ListItem = __webpack_require__(1090);
// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/components/List/ListContent.js
var ListContent = __webpack_require__(5343);
// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/components/Panel/Panel.js
var Panel = __webpack_require__(1739);
// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/components/Progress/Progress.js
var Progress = __webpack_require__(2702);
// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/components/Radio/Radio.js + 1 modules
var Radio = __webpack_require__(5452);
;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Radio/index.js


// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/components/Scroll/Scroll.js
var Scroll = __webpack_require__(3270);
// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/components/Switch/Switch.js
var Switch = __webpack_require__(9146);
;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Switch/index.js


;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Table/components/Cell.js


const ellipsisCss = dist_theme/* css */.iv `
  word-break: normal;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
`;
const BodyCell = (0,dist_theme/* styled */.zo)('td') `
  position: relative;
  text-align: left;
  vertical-align: middle;
  padding: 12px 16px;
  height: 42px;
  border-bottom: 1px solid ${({ theme }) => theme.color('dark70', 'light70')};
  cursor: ${({ onClick }) => (onClick ? 'pointer' : 'auto')};
  ${({ ellipsis }) => ellipsis && ellipsisCss}
  ${(0,index_esm/* compose */.qC)(index_esm/* padding */.o3, index_esm/* width */.bf, index_esm/* maxWidth */.kk, index_esm/* minWidth */.ih)}
  ${(0,index_esm/* system */.By)({ align: { property: 'textAlign' }, cellWrap: { property: 'whiteSpace' } })}
`;
const HeaderCell = (0,dist_theme/* styled */.zo)('th') `
  position: relative;
  text-align: left;
  vertical-align: middle;
  padding: 12px 16px;
  text-transform: uppercase;
  font-size: 12px;
  line-height: 14px;
  color: ${({ theme }) => theme.color('dark30')};
  border-bottom: ${({ borderBottomColor }) => (borderBottomColor ? '2px' : '1px')} solid
    ${({ theme, borderBottomColor }) => (borderBottomColor ? theme.colors[borderBottomColor] : theme.color('dark70', 'light70'))};
  ${({ ellipsis }) => ellipsis && ellipsisCss}
  ${(0,index_esm/* compose */.qC)(index_esm/* padding */.o3, index_esm/* width */.bf, index_esm/* maxWidth */.kk, index_esm/* minWidth */.ih)}
  ${(0,index_esm/* system */.By)({ align: { property: 'textAlign' } })}
`;
const TableBodyCell = BodyCell;
const TableHeaderCell = HeaderCell;

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Table/context.js

// eslint-disable-next-line import/prefer-default-export
const TableContext = (0,react.createContext)({
    columns: [],
    onSelectRow: () => null,
    variant: 'default',
    expandableRows: false
});
const RowContext = (0,react.createContext)({ index: -1, isExpanded: false, columnGroups: [] });

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Table/Cell.js
var Cell_rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};





const onControlClick = (event) => event.stopPropagation();
const onControlKeyDown = (event) => event.preventDefault();
const Cell_BodyCell = (0,dist_theme/* styled */.zo)(TableBodyCell) `
  ${({ isList }) => isList && 'border-bottom-color: transparent;'};
`;
const Cell = (_a) => {
    var { children, controls, wrapper: WrapComponentLocal, WrapComponent = react.Fragment } = _a, 
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _b = _a.column, 
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _c = _b === void 0 ? {} : _b, 
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    { title } = _c, column = Cell_rest(_c, ["title"]), { cellWrap } = _a, rest = Cell_rest(_a, ["children", "controls", "wrapper", "WrapComponent", "column", "cellWrap"]);
    const { variant } = (0,react.useContext)(TableContext);
    const Wrapper = WrapComponentLocal !== null && WrapComponentLocal !== void 0 ? WrapComponentLocal : (controls ? react.Fragment : WrapComponent);
    return ((0,jsx_runtime.jsx)(Cell_BodyCell, Object.assign({ role: "gridcell", onClick: controls ? onControlClick : undefined, onKeyDown: controls ? onControlKeyDown : undefined, isList: variant === 'list', tabIndex: 0, cellWrap: cellWrap, py: controls ? 0 : undefined }, column, rest, { children: (0,jsx_runtime.jsx)(Wrapper, { children: children }) })));
};

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Table/hooks/useScrollIntersection.js

function useScrollIntersection({ containerRef, leftTriggerRef, rightTriggerRef }) {
    const [scrollIntersection, setScrollIntersection] = (0,react.useState)({ left: true, right: true });
    const observer = (0,react.useRef)(null);
    (0,react.useEffect)(() => {
        if (!(containerRef === null || containerRef === void 0 ? void 0 : containerRef.current) || !(leftTriggerRef === null || leftTriggerRef === void 0 ? void 0 : leftTriggerRef.current) || !(rightTriggerRef === null || rightTriggerRef === void 0 ? void 0 : rightTriggerRef.current))
            return;
        if (!observer.current) {
            observer.current = new IntersectionObserver((entries) => {
                entries.forEach((entry) => {
                    if (entry.target && entry.target === leftTriggerRef.current) {
                        setScrollIntersection((old) => (Object.assign(Object.assign({}, old), { left: entry.isIntersecting })));
                    }
                    if (entry.target && entry.target === rightTriggerRef.current) {
                        setScrollIntersection((old) => (Object.assign(Object.assign({}, old), { right: entry.isIntersecting })));
                    }
                });
            }, {
                root: containerRef.current,
                rootMargin: '10px'
            });
        }
        if (leftTriggerRef.current) {
            observer.current.observe(leftTriggerRef.current);
        }
        if (rightTriggerRef.current) {
            observer.current.observe(rightTriggerRef.current);
        }
        // eslint-disable-next-line consistent-return
        return () => {
            var _a;
            (_a = observer.current) === null || _a === void 0 ? void 0 : _a.disconnect();
        };
    }, [containerRef, leftTriggerRef, rightTriggerRef]);
    return scrollIntersection;
}

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Table/components/Scroll.js


const TableScroll = (0,dist_theme/* styled */.zo)(Scroll/* default */.Z) `
  &::before {
    left: 0;
    right: auto;
    opacity: ${({ sticky, intersectingLeft }) => (intersectingLeft || sticky ? 0 : 0.6)};
    background: radial-gradient(
      farthest-side at 0 50%,
      ${({ theme }) => theme.color('dark100', 'light50', 0.8)},
      ${({ theme }) => theme.color('dark100', 'light50', 0)}
    );
  }
  &::after {
    right: 0;
    left: auto;
    opacity: ${({ intersectingRight }) => (intersectingRight ? 0 : 0.6)};
    background: radial-gradient(
      farthest-side at 100% 50%,
      ${({ theme }) => theme.color('dark100', 'light50', 0.8)},
      ${({ theme }) => theme.color('dark100', 'light50', 0)} 100% 0
    );
  }
  &::before,
  &::after {
    content: '';
    position: absolute;
    bottom: 0;
    top: 0;
    border: none;
    width: 18px;
    z-index: 2;
    pointer-events: none;
    transition: opacity ${({ theme }) => `${theme.transition.duration.slow}ms ${theme.transition.function.default}`};
  }
`;

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Table/components/Table.js


const Table = (0,dist_theme/* styled */.zo)('table') `
  border-spacing: 0;
  width: 100%;
  position: relative;
  table-layout: ${({ layoutMode }) => layoutMode !== null && layoutMode !== void 0 ? layoutMode : 'auto'};
  overflow: ${({ stickyColumn }) => (stickyColumn ? 'auto' : 'hidden')};
  ${({ theme, stickyColumn, intersectingLeft, backgroundColor = ['transparent'] }) => !!stickyColumn &&
    dist_theme/* css */.iv `
      th,
      td {
        background-color: ${theme.color(...(backgroundColor !== null && backgroundColor !== void 0 ? backgroundColor : ['transparent']))};
        border-right: 1px solid ${!intersectingLeft ? theme.color('dark70', 'light70') : 'transparent'};
        transition: border-color ${theme.transition.duration.slow}ms ${theme.transition.function.default};
        position: sticky;
        z-index: 3;
        left: 60px;
      }
      th:first-of-type,
      td:first-of-type {
        left: 0px;
        border-right-color: transparent;
      }
      td[role='gridcell'] ~ td[role='gridcell'],
      th[role='columnheader'] ~ th[role='columnheader'] {
        border-right-color: transparent;
        position: relative;
        z-index: auto;
        left: 0;
      }
    `}
  ${(0,index_esm/* compose */.qC)(index_esm/* minWidth */.ih)}
`;

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Table/components/Container.js
var Container_rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};







const IntersectionTrigger = (0,dist_theme/* styled */.zo)('caption') `
  right: ${({ right }) => (right ? 0 : 'auto')};
  position: absolute;
  bottom: 0;
  top: 0;
  width: 1px;
`;
const TableContainer = (0,react.forwardRef)((_a, forwardedRef) => {
    var { children, layoutMode, minWidth, stickyColumn, backgroundColor } = _a, rest = Container_rest(_a, ["children", "layoutMode", "minWidth", "stickyColumn", "backgroundColor"]);
    const containerRef = (0,react.useRef)(null);
    const leftTriggerRef = (0,react.useRef)(null);
    const rightTriggerRef = (0,react.useRef)(null);
    const combinedRef = (0,useForkRef/* useForkRef */.c)(containerRef, forwardedRef);
    const { left, right } = useScrollIntersection({ containerRef, leftTriggerRef, rightTriggerRef });
    return ((0,jsx_runtime.jsx)(TableScroll, Object.assign({ sticky: !!stickyColumn, intersectingRight: right, intersectingLeft: left, variant: "custom", ref: combinedRef, vertical: true, horizontal: true }, rest, { children: (0,jsx_runtime.jsxs)(Table, Object.assign({ role: "grid", layoutMode: layoutMode, minWidth: minWidth, stickyColumn: stickyColumn, backgroundColor: backgroundColor, intersectingLeft: left }, { children: [(0,jsx_runtime.jsx)(IntersectionTrigger, { ref: leftTriggerRef }), children, (0,jsx_runtime.jsx)(IntersectionTrigger, { ref: rightTriggerRef, right: true })] })) })));
});

// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconLeft.js
var IconLeft = __webpack_require__(563);
// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconLoader.js
var IconLoader = __webpack_require__(8530);
// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconRight.js
var IconRight = __webpack_require__(8746);
;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Table/components/Pagination.js




const Pagination_Container = (0,dist_theme/* styled */.zo)('div') `
  width: 100%;
  display: flex;
  justify-content: flex-end;
  align-items: center;
  padding: 12px 16px;
  color: ${({ theme }) => theme.color('dark30')};
  button {
    margin-left: 16px;
  }
  button:last-of-type {
    margin-left: 8px;
  }
`;
const TablePagination = ({ nextPage, previousPage, nextButtonDisabled, previousButtonDisabled, pageStart, pageEnd, totalEntries, isLoadingNext }) => ((0,jsx_runtime.jsxs)(Pagination_Container, { children: [totalEntries ? `${pageStart}-${pageEnd} of ${totalEntries}` : null, (0,jsx_runtime.jsx)(Button/* Button */.z, { variant: "secondary", icon: IconLeft/* default */.Z, onClick: previousPage, disabled: previousButtonDisabled }), (0,jsx_runtime.jsx)(Button/* Button */.z, { variant: "secondary", icon: isLoadingNext ? IconLoader/* default */.Z : IconRight/* default */.Z, onClick: nextPage, disabled: nextButtonDisabled || isLoadingNext })] }));

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Table/components/ColumnSelect.js







const ColumnSelect_Title = (0,dist_theme/* styled */.zo)(Box/* default */.Z) `
  display: block;
  text-transform: uppercase;
  font-weight: 500;
  letter-spacing: 0.06em;
  text-transform: uppercase;
  color: ${({ theme }) => theme.color('dark20')};
`;
const ColumnCheckbox = (0,dist_theme/* styled */.zo)(Checkbox/* Checkbox */.X) `
  margin: 4px 0;
`;
/**
 * Table column customization popover component
 */
const ColumnSelect = ({ columns, setColumns, trigger, title }) => {
    const onChange = (0,react.useCallback)((index) => () => {
        setColumns((state) => {
            const result = [...state];
            result[index] = Object.assign(Object.assign({}, state[index]), { hidden: !state[index].hidden });
            return result;
        });
    }, []);
    const groups = (0,react.useMemo)(() => [...new Set(columns.map((col) => col.groupName))], [columns]);
    return ((0,jsx_runtime.jsx)(Popover, Object.assign({ hover: true, width: 280, trigger: trigger }, { children: (0,jsx_runtime.jsxs)(Box/* default */.Z, Object.assign({ m: -16, width: "calc(100% + 32px)" }, { children: [(0,jsx_runtime.jsx)(ColumnSelect_Title, Object.assign({ p: 16 }, { children: title })), (0,jsx_runtime.jsx)(Divider/* default */.Z, {}), (0,jsx_runtime.jsx)(Box/* default */.Z, Object.assign({ display: "flex", flexDirection: "column", px: 16, py: 12 }, { children: groups.map((group) => {
                        return ((0,jsx_runtime.jsxs)(react.Fragment, { children: [group && ((0,jsx_runtime.jsx)(ColumnSelect_Title, Object.assign({ mt: 8, pb: 10 }, { children: group }))), columns.map((column, index) => {
                                    var _a;
                                    const columnTitle = (_a = column.title) === null || _a === void 0 ? void 0 : _a.toString();
                                    return (columnTitle &&
                                        columnTitle.length > 0 &&
                                        column.groupName === group && ((0,jsx_runtime.jsx)(ColumnCheckbox, { onChange: onChange(index), checked: !column.hidden, label: column.title, disabled: column.required }, column.id)));
                                })] }, group !== null && group !== void 0 ? group : 'unnamed'));
                    }) }))] })) })));
};

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Table/hooks/usePagination.js

function usePagination({ isLoading, total = 0, startsFrom = 0, pageSize = 10 } = {}) {
    const [from, setFrom] = (0,react.useState)(startsFrom);
    const to = (0,react.useMemo)(() => Math.min(from + pageSize, total), [from, pageSize, total]);
    const handleNextPage = (0,react.useCallback)(() => {
        setFrom((oldFrom) => Math.min(oldFrom + pageSize, total));
    }, [pageSize, total]);
    const handlePreviousPage = (0,react.useCallback)(() => {
        setFrom((oldFrom) => Math.max(oldFrom - pageSize, 0));
    }, [pageSize]);
    const pageIndex = (0,react.useMemo)(() => {
        if (total === 0 || from === 0)
            return 0;
        return Math.max(Math.floor(from / pageSize) - 1, 0);
    }, [total, from, pageSize]);
    return {
        paginationProps: {
            nextPage: handleNextPage,
            previousPage: handlePreviousPage,
            pageStart: from,
            pageEnd: to,
            totalEntries: total,
            nextButtonDisabled: to === total,
            previousButtonDisabled: from === 0,
            isLoadingNext: isLoading
        },
        from,
        setFrom,
        to,
        pageIndex
    };
}

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Table/hooks/useTable.js

function useTable({ items: data = [], selected, onSelect }) {
    /**
     * Selection stuff
     */
    const isSomeSelected = selected && selected.length > 0;
    const isAllSelected = selected && selected.length === data.length;
    const handleSelectAll = (0,react.useCallback)(() => {
        if (!onSelect)
            return;
        if (isAllSelected) {
            onSelect([]);
            return;
        }
        onSelect(data.map((_item, i) => i));
    }, [onSelect, isAllSelected]);
    const handleSelectRow = (index) => {
        if (!selected || !onSelect) {
            return;
        }
        const indexes = selected.indexOf(index) > -1 ? selected.filter((item) => item !== index) : [...selected, index];
        onSelect(indexes);
    };
    return {
        isSomeSelected,
        isAllSelected,
        handleSelectAll,
        handleSelectRow
    };
}

// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/helpers/utils.js
var utils = __webpack_require__(3397);
;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Table/hooks/useSortByColumn.js


const getNextDirection = (direction) => {
    if (!direction)
        return 'desc';
    if (direction === 'desc')
        return 'asc';
    return undefined;
};
function useSortByColumn(
// eslint-disable-next-line default-param-last
columns = [], onSortByColumn) {
    const [sortState, setSortState] = (0,react.useState)(null);
    (0,react.useEffect)(() => {
        const sortStateBasedOnColumnsInitialState = columns.flatMap((column) => {
            if (!column.sortable || !column.initialSort)
                return [];
            return [[column.id, column.initialSort]];
        });
        if (!sortStateBasedOnColumnsInitialState.length)
            return;
        if (sortStateBasedOnColumnsInitialState.length > 1) {
            (0,utils/* warn */.ZK)('Table supports sorting by one column at the time. Table will show initial sort only for the first column it is defined for.');
        }
        setSortState(sortStateBasedOnColumnsInitialState[0]);
    }, [columns]);
    const handleSort = (0,react.useCallback)((id) => {
        if (!(sortState === null || sortState === void 0 ? void 0 : sortState.length) || sortState[0] !== id) {
            setSortState([id, getNextDirection()]);
            return;
        }
        const [columnId, direction] = sortState;
        const nextDirection = getNextDirection(direction);
        if (!nextDirection) {
            setSortState(null);
            return;
        }
        setSortState([columnId, nextDirection]);
    }, [sortState]);
    (0,react.useEffect)(() => onSortByColumn === null || onSortByColumn === void 0 ? void 0 : onSortByColumn(sortState), [sortState]);
    return [sortState, handleSort];
}

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Table/Row.js
var Row_rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};








const ExpandButton = (0,dist_theme/* styled */.zo)(Button/* Button */.z) `
  transform: rotate(${({ expanded }) => (expanded ? '90deg' : '0deg')});
  transition: transform ${({ theme }) => `${theme.transition.duration.normal}ms ${theme.transition.function.default}`};
`;
const StyledRow = (0,dist_theme/* styled */.zo)('tr') `
  cursor: ${({ onClick }) => (onClick ? 'pointer' : 'auto')};
  ${({ active, disabled, empty, theme }) => !disabled &&
    !empty &&
    !active &&
    dist_theme/* css */.iv `
      &:hover > td,
      &:hover > td[role='gridcell'] ~ td[role='gridcell'] {
        background-color: ${theme.color('dark70', 'light100')};
      }
    `}

  ${({ active, theme }) => active &&
    dist_theme/* css */.iv `
      background: ${theme.color('dark60')};
    `}

  ${({ active, asList, theme }) => asList &&
    dist_theme/* css */.iv `
      td {
        font-weight: 600;
      }
      td:first-of-type {
        border-left: 4px solid ${theme.color(active ? 'purple30' : 'transparent')};
      }
    `}

  ${({ isSelected, theme }) => isSelected &&
    `
    background-color: ${theme.color('dark70')};
  `}
`;
const onControlsClick = (event) => event.stopPropagation();
// eslint-disable-next-line react/function-component-definition
function Row(_a) {
    var { empty, children, wrapper, selectable, getExpandedChildren, expandedRow: ExpandedRow } = _a, rest = Row_rest(_a, ["empty", "children", "wrapper", "selectable", "getExpandedChildren", "expandedRow"]);
    const { index: rowIndex, isExpanded, columnGroups } = (0,react.useContext)(RowContext);
    const { selected, onSelectRow, expandableRows } = (0,react.useContext)(TableContext);
    const cells = () => {
        let colIndex = 0;
        return react.Children.map(children, (child) => {
            const column = columnGroups[colIndex];
            if (!child) {
                return child;
            }
            colIndex += 1;
            if (column.hidden) {
                return null;
            }
            if ((0,react.isValidElement)(child)) {
                return (0,react.cloneElement)(child, { column, WrapComponent: wrapper });
            }
            return child;
        });
    };
    const rowSelected = selected && (selected === null || selected === void 0 ? void 0 : selected.indexOf(rowIndex)) > -1;
    const [expandedRows, setExpandedRows] = (0,react.useState)([]);
    const expandRow = () => {
        var _a;
        setExpandedRows(expandedRows.length ? [] : (_a = getExpandedChildren === null || getExpandedChildren === void 0 ? void 0 : getExpandedChildren()) !== null && _a !== void 0 ? _a : []);
    };
    const controlsCells = () => {
        const nodes = [];
        if (empty) {
            return null;
        }
        // don't show controls for expanded rows
        if (isExpanded) {
            if (selected)
                nodes.push((0,jsx_runtime.jsx)(TableBodyCell, { width: 60 }, "selected-hide"));
            if (expandableRows)
                nodes.push((0,jsx_runtime.jsx)(TableBodyCell, { width: 60 }, "expandedRows-hide"));
            return nodes;
        }
        if (selected)
            nodes.push((0,jsx_runtime.jsx)(TableBodyCell, Object.assign({ minWidth: 60, width: 60, onClick: onControlsClick, py: 0 }, { children: (0,jsx_runtime.jsx)(Checkbox/* Checkbox */.X, { size: "small", checked: rowSelected, disabled: selectable === false, onChange: typeof rowIndex === 'number' ? () => onSelectRow(rowIndex) : undefined }) }), "selected"));
        if (expandableRows)
            nodes.push(getExpandedChildren ? ((0,jsx_runtime.jsx)(TableBodyCell, Object.assign({ width: 60, onClick: expandRow, py: 0, pr: 11 }, { children: (0,jsx_runtime.jsx)(ExpandButton, { variant: "ghost", color: "dark30", icon: IconChevronRight/* default */.Z, onClick: expandRow, expanded: !!(expandedRows === null || expandedRows === void 0 ? void 0 : expandedRows.length) }) }), "expand")) : ((0,jsx_runtime.jsx)(TableBodyCell, { width: 60 }, "expanded")));
        return nodes;
    };
    return ((0,jsx_runtime.jsxs)(jsx_runtime.Fragment, { children: [(0,jsx_runtime.jsxs)(StyledRow, Object.assign({ empty: empty, isSelected: rowSelected }, rest, { children: [controlsCells(), cells()] })), ExpandedRow &&
                expandedRows.map(({ rowData, props }, index) => ((0,jsx_runtime.jsx)(RowContext.Provider
                // eslint-disable-next-line react/no-array-index-key
                , Object.assign({ 
                    // eslint-disable-next-line react/jsx-no-constructed-context-values
                    value: { isExpanded: true, index, columnGroups } }, { children: (0,jsx_runtime.jsx)(ExpandedRow, { rowData: rowData, props: props, isExpanded: true }) }), `expanded-${index}`)))] }));
}

// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconSortFilled.js
var IconSortFilled = __webpack_require__(7060);
// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconSortArrow.js
var IconSortArrow = __webpack_require__(530);
;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Table/components/Sort.js



const ButtonWrapper = (0,dist_theme/* styled */.zo)('button') `
  display: flex;
  align-items: center;
  cursor: pointer;
  position: relative;
  text-align: inherit;
  vertical-align: inherit;
  word-break: inherit;
  text-transform: inherit;
  font-size: inherit;
  line-height: inherit;
  color: inherit;
  background-color: transparent;
  width: 100%;
  overflow: inherit;
  text-overflow: inherit;
  white-space: inherit;
  > span {
    overflow: inherit;
    text-overflow: inherit;
    white-space: inherit;
  }
  ${({ align }) => align === 'left' && 'justify-content: start;'}
  ${({ align }) => align === 'right' && 'justify-content: end;'}
  ${({ align }) => align === 'center' && 'justify-content: center;'}
  &:hover svg {
    opacity: 1;
  }
  svg {
    transition: opacity ${({ theme }) => `${theme.transition.duration.normal}ms ${theme.transition.function.default}`};
  }
`;
const Sortable = (0,dist_theme/* styled */.zo)(IconSortFilled/* default */.Z) `
  margin-left: ${({ theme }) => theme.sizes.$4};
  min-width: 8px;
  margin-right: -12px;
  svg {
    opacity: 0;
  }
`;
const Sorting = (0,dist_theme/* styled */.zo)(IconSortArrow/* default */.Z) `
  transform: rotate(${({ sortDirection }) => (sortDirection === 'asc' ? '180deg' : '0')});
  margin-left: ${({ theme }) => theme.sizes.$4};
  min-width: 8px;
  margin-right: -12px;
`;
const SortingWrapper = ({ children, sortable, sortDirection, align, onClick }) => {
    if (!sortable) {
        // eslint-disable-next-line react/jsx-no-useless-fragment
        return (0,jsx_runtime.jsx)(jsx_runtime.Fragment, { children: children });
    }
    return ((0,jsx_runtime.jsxs)(ButtonWrapper, Object.assign({ onClick: onClick, align: align }, { children: [(0,jsx_runtime.jsx)("span", { children: children }), !sortDirection && (0,jsx_runtime.jsx)(Sortable, { size: 8, sortDirection: sortDirection }), !!sortDirection && (0,jsx_runtime.jsx)(Sorting, { size: 8, sortDirection: sortDirection })] })));
};

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Table/TableHead.js
var TableHead_rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};







const TableGroupCell = (0,dist_theme/* styled */.zo)(TableHeaderCell) `
  text-align: center;
  border-bottom: none;
  padding-left: 0;
  padding-right: 0;

  &:before {
    content: '';
    width: 100%;
    height: 1px;
    display: block;
    position: relative;
    top: 7px;
    border-top: 1px solid ${({ theme }) => theme.color('dark50', 'light70')};
  }
`;
const TableGroupCellEmpty = (0,dist_theme/* styled */.zo)('th') `
  border-right: 1px solid ${({ theme }) => theme.color('transparent')};
  ${(0,index_esm/* compose */.qC)(index_esm/* width */.bf)}
`;
const TableGroupTitle = dist_theme/* styled.span */.zo.span `
  background-color: inherit;
  position: relative;
  padding: 0 20px;
`;
const Head = ({ columns, selected, expandableRows, isEmpty, isSomeSelected, isAllSelected, handleSelectAll, sortState = null, sortByColumn }) => {
    const { topGroups, bottomGroups } = (0,react.useMemo)(() => {
        const groups = columns.reduce((acc, column) => {
            var _a;
            if (column.hidden) {
                return acc;
            }
            if (!((_a = column.columns) === null || _a === void 0 ? void 0 : _a.length)) {
                acc.topGroups.push({ column });
                acc.bottomGroups.push({ column });
                return acc;
            }
            acc.topGroups.push({ colspan: column.columns.length, column });
            column.columns.forEach((col) => acc.bottomGroups.push({ column: col }));
            return acc;
        }, { topGroups: [], bottomGroups: [] });
        return {
            topGroups: groups.topGroups.filter(Boolean).length ? groups.topGroups : [],
            bottomGroups: groups.bottomGroups
        };
    }, [columns]);
    return ((0,jsx_runtime.jsxs)("thead", { children: [topGroups.length ? ((0,jsx_runtime.jsxs)("tr", { children: [expandableRows && (0,jsx_runtime.jsx)(TableGroupCellEmpty, { width: 60 }), selected && (0,jsx_runtime.jsx)(TableGroupCellEmpty, { width: 60 }), topGroups.map(({ colspan, column }) => {
                        if (!colspan)
                            return ((0,jsx_runtime.jsx)(TableGroupCellEmpty, { role: "columnheader", "aria-label": column.title, width: column.width }, column.id));
                        return ((0,jsx_runtime.jsx)(TableGroupCell, Object.assign({ role: "columnheader", width: column.width, className: column.align || 'left', ellipsis: column.ellipsis, title: column.ellipsis ? column.title : undefined, colSpan: colspan }, { children: (0,jsx_runtime.jsx)(TableGroupTitle, { children: column.title }) }), column.id));
                    })] })) : null, (0,jsx_runtime.jsxs)("tr", { children: [selected && ((0,jsx_runtime.jsx)(TableHeaderCell, Object.assign({ width: 60, py: 0 }, { children: (0,jsx_runtime.jsx)(Checkbox/* Checkbox */.X, { disabled: isEmpty, size: "small", checked: isSomeSelected, indeterminate: !isAllSelected, onChange: handleSelectAll }) }))), bottomGroups.map((_a, index) => {
                        var _b = _a.column, { id, title } = _b, column = TableHead_rest(_b, ["id", "title"]);
                        return ((0,jsx_runtime.jsx)(TableHeaderCell, Object.assign({ role: "columnheader", colSpan: index === 0 && expandableRows ? 2 : 1, title: column.ellipsis ? title : undefined }, column, { children: (0,jsx_runtime.jsx)(SortingWrapper, Object.assign({ sortable: column.sortable, sortDirection: sortState && sortState[0] === id ? sortState[1] : undefined, onClick: sortByColumn ? () => sortByColumn(id) : undefined, align: column.align }, { children: title })) }), id));
                    })] })] }));
};
const TableHead = (0,react.memo)(Head);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Table/Table.js
var Table_rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};












const TableBody = ({ data, columns, rowProps, row: RowComponent }) => {
    const columnGroups = (0,react.useMemo)(() => columns.flatMap((column) => { var _a; return [...(((_a = column === null || column === void 0 ? void 0 : column.columns) === null || _a === void 0 ? void 0 : _a.length) ? column.columns : [column])].map((item) => (Object.assign(Object.assign({}, item), { hidden: column.hidden }))); }), [columns]);
    return ((0,jsx_runtime.jsx)(jsx_runtime.Fragment, { children: data.map((row) => {
            return (
            // eslint-disable-next-line react/jsx-no-constructed-context-values
            (0,jsx_runtime.jsx)(RowContext.Provider, Object.assign({ value: { index: row.index, isExpanded: false, columnGroups } }, { children: RowComponent ? ((0,jsx_runtime.jsx)(RowComponent, { rowData: row.content, props: rowProps })) : ((0,jsx_runtime.jsx)(Row, { children: columnGroups.map(({ id }) => ((0,jsx_runtime.jsx)(Cell, { children: row.content[id] }, id))) })) }), row.id || row.index));
        }) }));
};
const TableBase = (_a, forwardedRef) => {
    var { data, columns, noDataFound = 'No data found', keyId, row: RowComponent, rowCount = 5, rowProps, selected, onSelect, variant = 'default', onSortByColumn, expandableRows, layoutMode, backgroundColor, minWidth } = _a, containerProps = Table_rest(_a, ["data", "columns", "noDataFound", "keyId", "row", "rowCount", "rowProps", "selected", "onSelect", "variant", "onSortByColumn", "expandableRows", "layoutMode", "backgroundColor", "minWidth"]);
    const pageSize = (0,react.useMemo)(() => (rowCount === 'all' ? data.length : rowCount), [data, rowCount]);
    const { from, setFrom, to, paginationProps } = usePagination({
        total: data.length,
        pageSize
    });
    (0,react.useEffect)(() => {
        // reset the pagination start if we got less data then we have scrolled to
        if (from > 0 && data.length < to)
            setFrom(0);
    }, [data, from, to]);
    const pageData = (0,react.useMemo)(() => {
        return data.slice(from, to).map((content, index) => ({
            id: keyId ? content[keyId] : index,
            index: from + index,
            content
        }));
    }, [data, from, to]);
    const { isSomeSelected, isAllSelected, handleSelectAll, handleSelectRow } = useTable({
        items: data,
        selected,
        onSelect
    });
    const [sortState, sortByColumn] = useSortByColumn(columns, onSortByColumn);
    const contextValue = (0,react.useMemo)(() => ({
        columns,
        selected,
        variant,
        expandableRows,
        onSelectRow: handleSelectRow
    }), [columns, selected, variant, expandableRows, handleSelectRow]);
    return ((0,jsx_runtime.jsx)(TableContext.Provider, Object.assign({ value: contextValue }, { children: (0,jsx_runtime.jsxs)(Box/* default */.Z, Object.assign({ display: "flex", flexDirection: "column", width: "100%", pt: 4, ref: forwardedRef }, containerProps, { children: [(0,jsx_runtime.jsxs)(TableContainer, Object.assign({ layoutMode: layoutMode, stickyColumn: variant === 'sticky-first-column', backgroundColor: backgroundColor, minWidth: minWidth }, { children: [(0,jsx_runtime.jsx)(TableHead, { columns: columns, selected: selected, isEmpty: !data.length, isSomeSelected: isSomeSelected, isAllSelected: isAllSelected, handleSelectAll: handleSelectAll, sortState: sortState, sortByColumn: sortByColumn, expandableRows: expandableRows }), (0,jsx_runtime.jsxs)("tbody", { children: [data.length === 0 && ((0,jsx_runtime.jsx)("tr", { children: (0,jsx_runtime.jsx)("td", Object.assign({ colSpan: columns.length + (selected ? 1 : 0) + (expandableRows ? 1 : 0) }, { children: (0,jsx_runtime.jsx)(Box/* default */.Z, Object.assign({ width: 1, pt: 75, pb: 75, textAlign: "center", color: "dark30" }, { children: noDataFound || 'No data found' })) })) })), (0,jsx_runtime.jsx)(TableBody, { data: pageData, row: RowComponent, columns: columns, rowProps: rowProps })] })] })), data.length > pageSize && (0,jsx_runtime.jsx)(TablePagination, Object.assign({}, paginationProps))] })) })));
};
/**
 * Tables display information in a way that's easy to scan, so that users can look for patterns and insights.
 *
 * @see
 * {@link https://design-system.solventek.com/component/table}
 *
 * @example
 * <Table columns={columns} data={data} />
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const Table_Table = (0,react.memo)((0,react.forwardRef)(TableBase));
Table_Table.Pagination = TablePagination;
Table_Table.ColumnSelect = ColumnSelect;

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Tabs/components/context.js

const TabsState = (0,react.createContext)([0, () => null]);
const Elements = (0,react.createContext)({});
const useTabState = (hash) => {
    const tabRef = (0,react.useRef)(null);
    const [activeIndex, setActive] = (0,react.useContext)(TabsState);
    const elements = (0,react.useContext)(Elements);
    const tabIndex = (0,react.useMemo)(() => {
        const currentIndex = elements.tabs;
        elements.tabs += 1;
        return currentIndex;
    }, [elements]);
    (0,react.useEffect)(() => {
        const onHashChange = () => {
            if (hash) {
                const currentHash = window.location.hash.replace('#', '');
                if (hash === currentHash) {
                    setActive(tabIndex);
                }
            }
        };
        onHashChange();
        window.addEventListener('hashchange', onHashChange, false);
        return () => window.removeEventListener('hashchange', onHashChange);
    }, [hash, tabIndex]);
    (0,react.useEffect)(() => {
        var _a, _b, _c;
        const onClick = () => {
            if (hash) {
                window.location.hash = hash;
            }
            else {
                setActive(tabIndex);
            }
        };
        const onKeyDown = (event) => {
            switch (event.key) {
                case 'End':
                    setActive(elements.tabs - 1);
                    break;
                case 'Home':
                    setActive(0);
                    break;
                case 'ArrowLeft':
                    if (activeIndex > 0) {
                        setActive(activeIndex - 1);
                    }
                    break;
                case 'ArrowRight':
                    if (activeIndex < elements.tabs - 1) {
                        setActive(activeIndex + 1);
                    }
                    break;
                default:
                    break;
            }
        };
        (_a = tabRef.current) === null || _a === void 0 ? void 0 : _a.addEventListener('click', onClick, { passive: true });
        (_b = tabRef.current) === null || _b === void 0 ? void 0 : _b.addEventListener('keydown', onKeyDown, { passive: true });
        if (activeIndex === tabIndex) {
            (_c = tabRef.current) === null || _c === void 0 ? void 0 : _c.classList.add('active');
        }
        return () => {
            var _a, _b, _c;
            (_a = tabRef.current) === null || _a === void 0 ? void 0 : _a.removeEventListener('click', onClick);
            (_b = tabRef.current) === null || _b === void 0 ? void 0 : _b.removeEventListener('keydown', onKeyDown);
            (_c = tabRef.current) === null || _c === void 0 ? void 0 : _c.classList.remove('active');
        };
    }, [activeIndex, hash, tabIndex]);
    const isActive = (0,react.useMemo)(() => {
        return activeIndex === tabIndex;
    }, [activeIndex, tabIndex]);
    return [tabRef, isActive];
};
const usePanelState = () => {
    const [activeIndex] = (0,react.useContext)(TabsState);
    const elements = (0,react.useContext)(Elements);
    const panelIndex = (0,react.useMemo)(() => {
        const currentIndex = elements.panels;
        elements.panels += 1;
        return currentIndex;
    }, []);
    return panelIndex === activeIndex;
};

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Tabs/components/Tab.js
var Tab_rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};








const StyledTab = dist_theme/* styled.button */.zo.button `
  display: inline-flex;
  align-items: center;
  height: ${({ theme }) => theme.sizes.$48};
  background: transparent;
  margin-right: ${({ theme }) => theme.sizes.$40};
  color: ${({ theme }) => theme.color('dark0')};
  border-bottom: 3px solid transparent;

  ${helpers/* styledFocus */.By}

  &.active {
    border-color: ${({ theme }) => theme.colors.purple50};
  }

  &:disabled {
    color: ${({ theme }) => theme.color('dark30')};
    pointer-events: none;
  }
`;
/**
 * Single Tab title used in Tabs component.
 *
 * @see
 * {@link https://design-system.solventek.com/component/tabs}
 *
 * @example
 * <Tabs.Tab>Label</Tabs.Tab>
 */
const Tab = (0,component/* componentWithRef */.w)((_a, forwardRef) => {
    var { children, hash, badgeLabel } = _a, rest = Tab_rest(_a, ["children", "hash", "badgeLabel"]);
    const [tabRef, isActive] = useTabState(hash);
    const combinedRef = (0,useForkRef/* useForkRef */.c)(tabRef, forwardRef);
    return ((0,jsx_runtime.jsxs)(StyledTab, Object.assign({ type: "button", ref: combinedRef, role: "tab" }, rest, { children: [children, badgeLabel && ((0,jsx_runtime.jsx)(Box/* default */.Z, Object.assign({ ml: "$8" }, { children: (0,jsx_runtime.jsx)(Badge/* Badge */.C, { label: badgeLabel, variant: isActive ? 'purple' : 'primary', highlight: true, size: "small" }) })))] })));
});

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Tabs/components/Panel.js
var Panel_rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};




/**
 * Single Tab content container used in Tabs component.
 *
 * @see
 * {@link https://design-system.solventek.com/component/tabs}
 *
 * @example
 * <Tabs.Panel>Content</Tabs.Panel>
 */
const Panel_Panel = (0,component/* componentWithRef */.w)((_a, forwardRef) => {
    var { children } = _a, rest = Panel_rest(_a, ["children"]);
    const isActive = usePanelState();
    return isActive ? ((0,jsx_runtime.jsx)(Box/* default */.Z, Object.assign({ ref: forwardRef, role: "tabpanel" }, rest, { children: children }))) : null;
});

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Tabs/Tabs.js
var Tabs_rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};





const compoundComponents = {
    Tab: Tab,
    Panel: Panel_Panel
};
/**
 * Tabs organize content across different screens and makes it easy to explore and switch between them.
 *
 * @see
 * {@link https://design-system.solventek.com/component/tabs}
 *
 * @example
 * <Tabs>
 *   <Tabs.Tab>Tab 1</Tabs.Tab>
 *   <Tabs.Tab>Tab 2</Tabs.Tab>
 *   <Tabs.Panel>Tab content 1</Tabs.Panel>
 *   <Tabs.Panel>Tab content 2</Tabs.Panel>
 * </Tabs>
 */
const Tabs = (0,component/* componentWithRef */.w)((_a, forwardRef) => {
    var { activeTab, children, setActiveTab, width } = _a, rest = Tabs_rest(_a, ["activeTab", "children", "setActiveTab", "width"]);
    const state = (0,react.useState)(activeTab || 0);
    const elements = (0,react.useMemo)(() => ({ tabs: 0, panels: 0 }), []);
    const tabState = (0,react.useMemo)(() => (typeof activeTab === 'number' && typeof setActiveTab === 'function' ? [activeTab, setActiveTab] : state), [activeTab, setActiveTab, state]);
    return ((0,jsx_runtime.jsx)(Elements.Provider, Object.assign({ value: elements }, { children: (0,jsx_runtime.jsx)(TabsState.Provider, Object.assign({ value: tabState }, { children: (0,jsx_runtime.jsx)(Box/* default */.Z, Object.assign({ as: "ul", ref: forwardRef, role: "tablist", width: width }, rest, { children: children })) })) })));
}, compoundComponents);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Tabs/index.js


// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/components/Tooltip/Tooltip.js
var components_Tooltip_Tooltip = __webpack_require__(4183);
;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Content/Content.js
var Content_rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};




const Content_Container = (0,dist_theme/* styled */.zo)(Box/* default */.Z) `
  p,
  li {
    font-size: ${({ theme }) => theme.fontSizes.$14};
    line-height: ${({ theme }) => theme.lineHeights.$140};
    margin-bottom: 0.75em;
  }

  h1,
  h2,
  h3,
  h4,
  h5,
  h6 {
    font-family: ${({ theme }) => theme.fonts.title};
    font-weight: ${({ theme }) => theme.fontWeights.semibold};
    line-height: ${({ theme }) => theme.lineHeights.$120};
    margin: 1em 0 0.75em;

    &:first-child {
      margin-top: 0px;
    }

    a {
      color: inherit;
      font-weight: inherit;
      text-decoration: none;
    }
  }

  h1 {
    font-size: ${({ theme }) => theme.fontSizes.$48};
  }

  h2 {
    font-size: ${({ theme }) => theme.fontSizes.$36};
  }

  h3 {
    font-size: ${({ theme }) => theme.fontSizes.$24};
  }

  ul,
  ol {
    margin-left: ${({ theme }) => theme.sizes.$16};
  }

  pre {
    display: block;
    background: ${({ theme }) => theme.color('dark90')};
    max-width: 100%;
    overflow: auto;
    font-size: ${({ theme }) => theme.fontSizes.$13};
  }

  *:not(pre) > code {
    color: ${({ theme }) => theme.color('yellow50', 'yellow30')};
    background: ${({ theme }) => theme.color('dark90')};
    border: 1px solid ${({ theme }) => theme.color('dark60')};
    padding: 1px 4px;
    border-radius: 2px;
    font-size: 90%;
  }

  a {
    color: ${({ theme }) => theme.color('purple70', 'purple50')};
    text-decoration: underline;
  }

  strong {
    font-weight: ${({ theme }) => theme.fontWeights.semibold};
  }

  // TODO: Update styles of Content once available
`;
/**
 * A CSS utility component that styles the wrapped child content with styles for better readability. Useful for article like content.
 *
 * @see
 * {@link https://design-system.solventek.com/component/content}
 *
 * @example
 * <Content>
 *   <h1>Lorem ipsum</h1>
 *   <p>Dolor sit amet</p>
 * </Content>
 */
const Content = (0,component/* componentWithRef */.w)((_a, forwardRef) => {
    var { children } = _a, rest = Content_rest(_a, ["children"]);
    return ((0,jsx_runtime.jsx)(Content_Container, Object.assign({ ref: forwardRef }, rest, { children: children })));
});

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Content/index.js


// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/components/Typography/Typography.js
var Typography = __webpack_require__(2888);
;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Typography/index.js


;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Menu/index.js


// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/components/Select/Select.js
var Select = __webpack_require__(6138);
;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Select/index.js


// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js
var objectWithoutPropertiesLoose = __webpack_require__(3560);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/extends.js
var esm_extends = __webpack_require__(2733);
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js
function assertThisInitialized_assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/inheritsLoose.js + 1 modules
var inheritsLoose = __webpack_require__(3699);
// EXTERNAL MODULE: ./node_modules/react-transition-group/esm/TransitionGroupContext.js
var TransitionGroupContext = __webpack_require__(1605);
;// CONCATENATED MODULE: ./node_modules/react-transition-group/esm/utils/ChildMapping.js

/**
 * Given `this.props.children`, return an object mapping key to child.
 *
 * @param {*} children `this.props.children`
 * @return {object} Mapping of key to child
 */

function getChildMapping(children, mapFn) {
  var mapper = function mapper(child) {
    return mapFn && (0,react.isValidElement)(child) ? mapFn(child) : child;
  };

  var result = Object.create(null);
  if (children) react.Children.map(children, function (c) {
    return c;
  }).forEach(function (child) {
    // run the map function here instead so that the key is the computed one
    result[child.key] = mapper(child);
  });
  return result;
}
/**
 * When you're adding or removing children some may be added or removed in the
 * same render pass. We want to show *both* since we want to simultaneously
 * animate elements in and out. This function takes a previous set of keys
 * and a new set of keys and merges them with its best guess of the correct
 * ordering. In the future we may expose some of the utilities in
 * ReactMultiChild to make this easy, but for now React itself does not
 * directly have this concept of the union of prevChildren and nextChildren
 * so we implement it here.
 *
 * @param {object} prev prev children as returned from
 * `ReactTransitionChildMapping.getChildMapping()`.
 * @param {object} next next children as returned from
 * `ReactTransitionChildMapping.getChildMapping()`.
 * @return {object} a key set that contains all keys in `prev` and all keys
 * in `next` in a reasonable order.
 */

function mergeChildMappings(prev, next) {
  prev = prev || {};
  next = next || {};

  function getValueForKey(key) {
    return key in next ? next[key] : prev[key];
  } // For each key of `next`, the list of keys to insert before that key in
  // the combined list


  var nextKeysPending = Object.create(null);
  var pendingKeys = [];

  for (var prevKey in prev) {
    if (prevKey in next) {
      if (pendingKeys.length) {
        nextKeysPending[prevKey] = pendingKeys;
        pendingKeys = [];
      }
    } else {
      pendingKeys.push(prevKey);
    }
  }

  var i;
  var childMapping = {};

  for (var nextKey in next) {
    if (nextKeysPending[nextKey]) {
      for (i = 0; i < nextKeysPending[nextKey].length; i++) {
        var pendingNextKey = nextKeysPending[nextKey][i];
        childMapping[nextKeysPending[nextKey][i]] = getValueForKey(pendingNextKey);
      }
    }

    childMapping[nextKey] = getValueForKey(nextKey);
  } // Finally, add the keys which didn't appear before any key in `next`


  for (i = 0; i < pendingKeys.length; i++) {
    childMapping[pendingKeys[i]] = getValueForKey(pendingKeys[i]);
  }

  return childMapping;
}

function getProp(child, prop, props) {
  return props[prop] != null ? props[prop] : child.props[prop];
}

function getInitialChildMapping(props, onExited) {
  return getChildMapping(props.children, function (child) {
    return (0,react.cloneElement)(child, {
      onExited: onExited.bind(null, child),
      in: true,
      appear: getProp(child, 'appear', props),
      enter: getProp(child, 'enter', props),
      exit: getProp(child, 'exit', props)
    });
  });
}
function getNextChildMapping(nextProps, prevChildMapping, onExited) {
  var nextChildMapping = getChildMapping(nextProps.children);
  var children = mergeChildMappings(prevChildMapping, nextChildMapping);
  Object.keys(children).forEach(function (key) {
    var child = children[key];
    if (!(0,react.isValidElement)(child)) return;
    var hasPrev = (key in prevChildMapping);
    var hasNext = (key in nextChildMapping);
    var prevChild = prevChildMapping[key];
    var isLeaving = (0,react.isValidElement)(prevChild) && !prevChild.props.in; // item is new (entering)

    if (hasNext && (!hasPrev || isLeaving)) {
      // console.log('entering', key)
      children[key] = (0,react.cloneElement)(child, {
        onExited: onExited.bind(null, child),
        in: true,
        exit: getProp(child, 'exit', nextProps),
        enter: getProp(child, 'enter', nextProps)
      });
    } else if (!hasNext && hasPrev && !isLeaving) {
      // item is old (exiting)
      // console.log('leaving', key)
      children[key] = (0,react.cloneElement)(child, {
        in: false
      });
    } else if (hasNext && hasPrev && (0,react.isValidElement)(prevChild)) {
      // item hasn't changed transition states
      // copy over the last transition props;
      // console.log('unchanged', key)
      children[key] = (0,react.cloneElement)(child, {
        onExited: onExited.bind(null, child),
        in: prevChild.props.in,
        exit: getProp(child, 'exit', nextProps),
        enter: getProp(child, 'enter', nextProps)
      });
    }
  });
  return children;
}
;// CONCATENATED MODULE: ./node_modules/react-transition-group/esm/TransitionGroup.js









var values = Object.values || function (obj) {
  return Object.keys(obj).map(function (k) {
    return obj[k];
  });
};

var defaultProps = {
  component: 'div',
  childFactory: function childFactory(child) {
    return child;
  }
};
/**
 * The `<TransitionGroup>` component manages a set of transition components
 * (`<Transition>` and `<CSSTransition>`) in a list. Like with the transition
 * components, `<TransitionGroup>` is a state machine for managing the mounting
 * and unmounting of components over time.
 *
 * Consider the example below. As items are removed or added to the TodoList the
 * `in` prop is toggled automatically by the `<TransitionGroup>`.
 *
 * Note that `<TransitionGroup>`  does not define any animation behavior!
 * Exactly _how_ a list item animates is up to the individual transition
 * component. This means you can mix and match animations across different list
 * items.
 */

var TransitionGroup = /*#__PURE__*/function (_React$Component) {
  (0,inheritsLoose/* default */.Z)(TransitionGroup, _React$Component);

  function TransitionGroup(props, context) {
    var _this;

    _this = _React$Component.call(this, props, context) || this;

    var handleExited = _this.handleExited.bind(assertThisInitialized_assertThisInitialized(_this)); // Initial children should all be entering, dependent on appear


    _this.state = {
      contextValue: {
        isMounting: true
      },
      handleExited: handleExited,
      firstRender: true
    };
    return _this;
  }

  var _proto = TransitionGroup.prototype;

  _proto.componentDidMount = function componentDidMount() {
    this.mounted = true;
    this.setState({
      contextValue: {
        isMounting: false
      }
    });
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    this.mounted = false;
  };

  TransitionGroup.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, _ref) {
    var prevChildMapping = _ref.children,
        handleExited = _ref.handleExited,
        firstRender = _ref.firstRender;
    return {
      children: firstRender ? getInitialChildMapping(nextProps, handleExited) : getNextChildMapping(nextProps, prevChildMapping, handleExited),
      firstRender: false
    };
  } // node is `undefined` when user provided `nodeRef` prop
  ;

  _proto.handleExited = function handleExited(child, node) {
    var currentChildMapping = getChildMapping(this.props.children);
    if (child.key in currentChildMapping) return;

    if (child.props.onExited) {
      child.props.onExited(node);
    }

    if (this.mounted) {
      this.setState(function (state) {
        var children = (0,esm_extends/* default */.Z)({}, state.children);

        delete children[child.key];
        return {
          children: children
        };
      });
    }
  };

  _proto.render = function render() {
    var _this$props = this.props,
        Component = _this$props.component,
        childFactory = _this$props.childFactory,
        props = (0,objectWithoutPropertiesLoose/* default */.Z)(_this$props, ["component", "childFactory"]);

    var contextValue = this.state.contextValue;
    var children = values(this.state.children).map(childFactory);
    delete props.appear;
    delete props.enter;
    delete props.exit;

    if (Component === null) {
      return /*#__PURE__*/react.createElement(TransitionGroupContext/* default.Provider */.Z.Provider, {
        value: contextValue
      }, children);
    }

    return /*#__PURE__*/react.createElement(TransitionGroupContext/* default.Provider */.Z.Provider, {
      value: contextValue
    }, /*#__PURE__*/react.createElement(Component, props, children));
  };

  return TransitionGroup;
}(react.Component);

TransitionGroup.propTypes =  false ? 0 : {};
TransitionGroup.defaultProps = defaultProps;
/* harmony default export */ const esm_TransitionGroup = (TransitionGroup);
;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Snackbar/SnackbarMessage.js
var SnackbarMessage_rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};







const MessageStyled = dist_theme/* styled.div */.zo.div `
  position: relative;
  display: flex;
  justify-content: space-between;
  align-items: center;
  min-width: 250px;
  padding: 12px 24px;
  margin-bottom: 8px;
  pointer-events: all;
  border-radius: 40px;
  ${({ theme }) => theme.name === 'light' &&
    `
    box-shadow: 0px 4px 16px rgb(0, 0, 0, 0.08);
    `}

  > .icon {
    margin-right: 8px;
  }

  > p {
    flex-grow: 1;
    font-size: 14px;
    line-height: 16px;
    margin-bottom: 0px;
  }

  > div {
    display: flex;
    margin-left: 16px;

    > * {
      margin-left: 12px;
    }
  }

  &:last-of-type {
    margin-bottom: 20px;
  }

  ${({ theme }) => (0,index_esm/* variant */.bU)({
    variants: {
        default: {
            color: theme.color('dark0', 'light0')({ theme }),
            bg: theme.color('dark50', 'light100')({ theme }),
            border: theme.name === 'light' && `solid 1px ${theme.colors.light70}`,
            boxShadow: theme.name === 'light' && '0px 4px 16px rgb(0, 0, 0, 0.09)'
        },
        danger: {
            color: 'red10',
            bg: 'red50'
        },
        info: {
            color: 'purple10',
            bg: 'purple70'
        },
        success: {
            color: 'green10',
            bg: 'green70'
        },
        warning: {
            color: 'yellow10',
            bg: 'yellow50'
        }
    }
})};

  button {
    ${({ theme }) => (0,index_esm/* variant */.bU)({
    variants: {
        default: {
            color: theme.color('dark0', 'light0')({ theme })
        },
        danger: {
            color: 'red10'
        },
        info: {
            color: 'purple10'
        },
        success: {
            color: 'green10'
        },
        warning: {
            color: 'yellow10'
        }
    }
})};

    .icon {
      ${({ theme }) => (0,index_esm/* variant */.bU)({
    variants: {
        default: {
            color: theme.color('dark0', 'purple50')({ theme })
        }
    }
})};
    }
  }

  hr {
    background: rgba(0, 0, 0, 0.2);
  }
`;
const SnackbarMessage = (_a) => {
    var { message, timeout, onClose } = _a, rest = SnackbarMessage_rest(_a, ["message", "timeout", "onClose"]);
    const { actions, close, closeAction, id, icon, variant, persist, messageActions } = message;
    const Icon = icon;
    (0,react.useEffect)(() => {
        if (persist) {
            return undefined;
        }
        const hideTimeout = setTimeout(() => {
            onClose(message.id);
        }, message.autoHide || timeout);
        return () => {
            clearTimeout(hideTimeout);
        };
    }, [id, persist]);
    const handleMessageActions = () => {
        return messageActions && messageActions(id);
    };
    const handleClose = () => {
        onClose(message.id);
        return closeAction && closeAction();
    };
    return ((0,jsx_runtime.jsxs)(MessageStyled, Object.assign({ variant: variant || 'default', className: messageActions ? 'action' : '' }, rest, { children: [Icon && (0,jsx_runtime.jsx)(Icon, { size: "small" }), messageActions ? ((0,jsx_runtime.jsx)(Button/* Button */.z, Object.assign({ variant: "secondary", onClick: handleMessageActions }, { children: message.message }))) : ((0,jsx_runtime.jsx)("p", { children: message.message })), (0,jsx_runtime.jsxs)("div", { children: [actions && actions(id), close && ((0,jsx_runtime.jsx)(Box/* default */.Z, Object.assign({ display: "flex" }, { children: (0,jsx_runtime.jsx)(Box/* default */.Z, Object.assign({ ml: 8, alignSelf: "center" }, { children: (0,jsx_runtime.jsx)(Button/* Button */.z, { onClick: handleClose, variant: "ghost", size: "small", icon: IconX/* default */.Z }) })) })))] })] })));
};
/* harmony default export */ const Snackbar_SnackbarMessage = (SnackbarMessage);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Snackbar/Snackbar.js
var Snackbar_rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};





const SnackbarTransitionGroupStyled = (0,dist_theme/* styled */.zo)(esm_TransitionGroup) `
  position: fixed;
  z-index: ${({ theme }) => theme.zIndex.snackBar};
  bottom: 0px;
  right: 20px;
  pointer-events: none;
`;
const SnackBarContext = (0,react.createContext)({ addSnackbar: () => '', closeSnackbar: () => null });
const useSnackbar = () => (0,react.useContext)(SnackBarContext);
/**
 * Snackbar component
 */
const Snackbar = (_a) => {
    var { max, timeout, children } = _a, rest = Snackbar_rest(_a, ["max", "timeout", "children"]);
    const [messages, setMessages] = (0,react.useState)([]);
    const closeSnackbar = (id) => {
        setMessages((items) => items.filter((item) => item.id !== id));
    };
    const addSnackbar = (message) => {
        const id = (new Date().getTime() + Math.random()).toString();
        if (message.unique) {
            const messageExists = messages.find((item) => item.message === message.message);
            if (messageExists) {
                return messageExists.id;
            }
        }
        const activeMessages = messages.filter((item) => !item.persist);
        if (max && max <= messages.length) {
            for (let i = 0; i < messages.length - max + 1; i += 1) {
                if (activeMessages[i]) {
                    closeSnackbar(activeMessages[i].id);
                }
            }
        }
        setMessages((items) => [...items, Object.assign({ id }, message)]);
        return id;
    };
    const contextValue = (0,react.useMemo)(() => ({ addSnackbar, closeSnackbar }), [addSnackbar, closeSnackbar]);
    return ((0,jsx_runtime.jsxs)(jsx_runtime.Fragment, { children: [(0,jsx_runtime.jsx)(SnackbarTransitionGroupStyled, Object.assign({}, rest, { children: messages.map((message) => ((0,jsx_runtime.jsx)(Transition/* Transition.Slide */.u.Slide, Object.assign({ "$x": "100%", "$y": "0" }, { children: (0,jsx_runtime.jsx)(Snackbar_SnackbarMessage, { onClose: closeSnackbar, timeout: timeout || 5000, message: message }, message.id) }), message.id))) })), (0,jsx_runtime.jsx)(SnackBarContext.Provider, Object.assign({ value: contextValue }, { children: children }))] }));
};
Snackbar.defaultProps = {
    timeout: 5000
};
/* harmony default export */ const Snackbar_Snackbar = (Snackbar);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Popover/index.js


;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Snackbar/withSnackbar.js


const withSnackbar = (Component) => {
    const ComponentWithSnackbar = (props) => {
        return (0,jsx_runtime.jsx)(SnackBarContext.Consumer, { children: (context) => (0,jsx_runtime.jsx)(Component, Object.assign({}, context, props)) });
    };
    return ComponentWithSnackbar;
};
/* harmony default export */ const Snackbar_withSnackbar = (withSnackbar);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Slider/Slider.js
var Slider_rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};



const SliderWrapper = dist_theme/* styled.label */.zo.label `
  display: flex;
  align-items: center;
  width: 100%;
  height: ${({ theme }) => theme.sizes.$24};

  > span {
    user-select: none;
  }

  > div {
    flex: 1;
    margin: 0 ${({ theme }) => theme.sizes.$8};
    position: relative;
    height: ${({ theme }) => theme.sizes.$24};

    &:before {
      position: absolute;
      content: '';
      top: 10px;
      left: 10px;
      width: calc(100% - 20px);
      height: 4px;
      background: ${({ theme }) => theme.colors.purple50};
      border-radius: 4px;
    }

    &:before {
      background: ${({ theme }) => theme.color('dark30')};
    }
  }

  &.disabled {
    color: ${({ theme }) => theme.color('dark40')};
    pointer-events: none;

    > div:before {
      background: ${({ theme }) => theme.color('dark80')};
    }

    > div > div {
      background: ${({ theme }) => theme.color('dark50')};
    }
  }
`;
const Thumb = dist_theme/* css */.iv `
  appearance: none;
  position: relative;
  width: ${({ theme }) => theme.sizes.$28};
  height: ${({ theme }) => theme.sizes.$28};
  border-radius: ${({ theme }) => theme.sizes.$28};
  background: transparent
    url("data:image/svg+xml,%3Csvg width='28' height='28' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Crect x='4' y='4' width='20' height='20' rx='10' fill='%236C50FA'/%3E%3C/svg%3E");
  border: none;
  cursor: pointer;
`;
const ThumbDisabled = dist_theme/* css */.iv `
  background-image: url("data:image/svg+xml,%3Csvg width='28' height='28' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Crect x='4' y='4' width='20' height='20' rx='10' fill='%2364728B'/%3E%3C/svg%3E");
`;
const ThumbHover = dist_theme/* css */.iv `
  background-image: url("data:image/svg+xml,%3Csvg width='28' height='28' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Crect x='4' y='4' width='20' height='20' rx='10' fill='%23583ADC'/%3E%3Crect x='1' y='1' width='26' height='26' rx='13' stroke='%23583ADC' stroke-width='2'/%3E%3C/svg%3E");
`;
const SliderStyled = dist_theme/* styled.input */.zo.input `
  position: relative;
  z-index: 3;
  width: 100%;
  appearance: none;
  height: ${({ theme }) => theme.sizes.$4};
  border-radius: ${({ theme }) => theme.sizes.$4};
  background: none;
  outline: none;

  &:disabled::-webkit-slider-thumb {
    ${ThumbDisabled}
    pointer-events: none;
  }

  &:disabled::-moz-range-thumb {
    ${ThumbDisabled}
  }

  &::-webkit-slider-thumb {
    ${Thumb}
  }

  &::-moz-range-thumb {
    ${Thumb}
  }

  &.focus-visible::-webkit-slider-thumb,
  &::-webkit-slider-thumb:hover {
    ${ThumbHover}
  }

  &.focus-visible::-moz-range-thumb,
  &::-moz-range-thumb:hover {
    ${ThumbHover}
  }
`;
const SliderRange = dist_theme/* styled.div */.zo.div `
  position: absolute;
  content: '';
  top: 10px;
  left: 10px;
  height: ${({ theme }) => theme.sizes.$4};
  background: ${({ theme }) => theme.color('dark0', 'purple30')};
  border-radius: ${({ theme }) => theme.sizes.$4};
  width: calc(${({ width }) => width}% - ${({ width }) => width * 0.2}px);
`;
/**
 * Slider component allow users to make selections from a range of values.
 *
 * @see
 * {@link https://design-system.solventek.com/component/slider}
 *
 * @example
 * <Slider value={value} onChange={onChange} min={0} max={100} />
 */
const Slider = (0,component/* componentWithRef */.w)((_a, forwardRef) => {
    var { labelMin, labelMax } = _a, rest = Slider_rest(_a, ["labelMin", "labelMax"]);
    const value = typeof rest.value === 'string' ? parseInt(rest.value || '0', 10) : rest.value;
    const min = typeof rest.min === 'string' ? parseInt(rest.min, 10) : rest.min || 0;
    const max = typeof rest.max === 'string' ? parseInt(rest.max, 10) : rest.max || 100;
    const percent = typeof value === 'number' ? ((value - min) * 100) / (max - min) : 0;
    return ((0,jsx_runtime.jsxs)(SliderWrapper, { children: [(0,jsx_runtime.jsx)("strong", { children: labelMin || rest.min }), (0,jsx_runtime.jsxs)("div", { children: [(0,jsx_runtime.jsx)(SliderRange, { width: percent }), (0,jsx_runtime.jsx)(SliderStyled, Object.assign({ ref: forwardRef, type: "range" }, rest))] }), (0,jsx_runtime.jsx)("span", { children: labelMax || rest.max })] }));
});

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Slider/index.js


;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Chip/ChipGroup.js
var ChipGroup_rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};



const ChipContext = (0,react.createContext)({});
const ChipGroupStyled = dist_theme/* styled.nav */.zo.nav `
  display: flex;
  max-width: 100%;
  flex-wrap: wrap;

  .chip:not(:first-child) {
    margin-left: 16px;

    ${({ theme }) => theme.screen.m} {
      margin: 4px;
    }
  }

  .chip {
    ${({ theme }) => theme.screen.m} {
      margin: 4px;
    }
  }
`;
const ChipGroup = (_a) => {
    var { children, onChange, value } = _a, rest = ChipGroup_rest(_a, ["children", "onChange", "value"]);
    const contextValue = (0,react.useMemo)(() => ({
        handleChange: (targetValue) => {
            if (onChange) {
                onChange(targetValue);
            }
        },
        groupValue: value
    }), [value]);
    return ((0,jsx_runtime.jsx)(ChipGroupStyled, Object.assign({}, rest, { children: (0,jsx_runtime.jsx)(ChipContext.Provider, Object.assign({ value: contextValue }, { children: children })) })));
};
ChipGroup.defaultProps = {};
/* harmony default export */ const Chip_ChipGroup = (ChipGroup);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Chip/Chip.js
var Chip_rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};





const ChipStyled = dist_theme/* styled.button */.zo.button `
  display: inline-flex;
  align-items: center;
  padding: 4px 6px 4px;
  border-radius: 20px;
  line-height: 24px;
  white-space: nowrap;
  cursor: pointer;
  color: ${({ active, theme }) => (active ? theme.colors.dark0 : theme.color('dark0')({ theme }))};
  background: ${({ active, theme }) => (active ? theme.colors.purple50 : 'transparent')};

  .chipLabel {
    margin: 0 8px;
  }

  ${({ disabled, theme }) => disabled &&
    `
    cursor: not-allowed;
    background: transparent;
    opacity: 0.4;
    color: ${theme.color('dark20')({ theme })};
    background: ${theme.color('dark60')({ theme })};
  `}

  ${helpers/* styledFocus */.By}
`;
const ChipContent = dist_theme/* styled.span */.zo.span `
  display: flex;
  align-items: center;
  padding: 0 8px;
  border-radius: 20px;
  background: ${({ active, theme }) => (active ? theme.colors.purple30 : theme.color('dark80')({ theme }))};

  &.number {
    font-family: 'Source Code Pro', Monaco, monospace;
    font-weight: bold;
  }
`;
/**
 * Chip component
 */
const Chip = (_a) => {
    var { label, value, content, onChange, disabled, active } = _a, rest = Chip_rest(_a, ["label", "value", "content", "onChange", "disabled", "active"]);
    const { handleChange, groupValue } = (0,react.useContext)(ChipContext);
    const isChecked = typeof groupValue !== 'undefined' ? groupValue === value : active;
    const handleActiveChip = (e) => {
        if (typeof handleChange === 'function') {
            handleChange(value);
        }
        if (typeof onChange === 'function') {
            onChange(e);
        }
    };
    return ((0,jsx_runtime.jsxs)(ChipStyled, Object.assign({ disabled: disabled, onClick: !disabled ? handleActiveChip : undefined, active: isChecked, className: "chip", tabIndex: 0 }, rest, { children: [(0,jsx_runtime.jsx)("p", Object.assign({ className: "chipLabel" }, { children: label })), content && ((0,jsx_runtime.jsx)(ChipContent, Object.assign({ active: isChecked, className: `${typeof content === 'number' ? 'number' : ''}` }, { children: content })))] })));
};
Chip.defaultProps = {
    active: false
};
/* harmony default export */ const Chip_Chip = (Chip);

// EXTERNAL MODULE: ./node_modules/@robocorp/ds/node_modules/@floating-ui/react-dom-interactions/dist/floating-ui.react-dom-interactions.mjs + 2 modules
var floating_ui_react_dom_interactions = __webpack_require__(9277);
;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Drawer/Drawer.js
var Drawer_rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};







const Backdrop = (0,dist_theme/* styled */.zo)(floating_ui_react_dom_interactions/* FloatingOverlay */.y0) `
  background: ${({ theme }) => (theme.name === 'light' ? 'rgba(91, 105, 123, 0.8)' : 'rgba(0, 0, 0, 0.6)')};
  z-index: ${({ theme }) => theme.zIndex.overlay};
`;
const DrawerStyled = dist_theme/* styled.aside */.zo.aside `
  height: 100%;
  max-height: 100%;
  position: fixed;
  left: 0;
  top: 0;
  bottom: 0;
  width: ${({ width }) => width}px;
  overflow-x: hidden;
  z-index: ${({ theme }) => theme.zIndex.drawer};
  background: ${({ theme }) => theme.color('dark80')};
  box-shadow: ${({ theme }) => theme.shadows.level2};
  ${helpers/* parseColorProps */.sL};

  ${({ position }) => position === 'right' &&
    `
    right: 0;
    left: auto;
  `}

  &.primary {
    border-right: 1px solid ${({ theme }) => theme.color('dark60')};

    ${({ position, theme }) => position === 'right' &&
    `
      border-right: none;
      border-left: 1px solid ${theme.color('dark60')({ theme })};
    `}
  }

  &.nav {
    background-color: ${({ theme }) => theme.color('dark100')};
    border-right: 1px solid ${({ theme }) => theme.color('dark60')};

    ${({ position, theme }) => position === 'right' &&
    `
      border-right: none;
      border-left: 1px solid ${theme.color('dark60')({ theme })};
    `}

    padding: 40px 28px;

    ${({ theme }) => theme.screen.m} {
      padding: 20px 16px;
    }

    hr {
      margin: 30px 0;
    }
    button.nav {
      width: 100%;
    }
    a, button.blank {
      display: block;
      position: relative;
      line-height: 20px;
      margin: 12px 0 12px 46px;
      color: ${({ theme }) => theme.color('dark20')};
      span {
        margin: 0;
      }
      &.current,
      &:active,
      &.active,
      &:hover {
        color: ${({ theme }) => theme.color('dark0')};
        text-shadow: 0px 0px 1px ${({ theme }) => theme.color('dark20')};
      }
      &.current:before,
      &:active:before,
      &.active:before {
          content: '';
          width: 6px;
          height: 6px;
          border-radius: 6px;
          position: absolute;
          top: 6px;
          left: -16px;
          background: ${({ theme }) => theme.colors.yellow50};
        }
      }
    }
  }
`;
const ActiveContainer = ({ children }) => (0,jsx_runtime.jsx)(Backdrop, Object.assign({ lockScroll: true }, { children: children }));
const PassiveContainer = ({ children }) => children;
/**
 * Drawer is a type of layered surface containing supplementary content at the edge of the screen.
 *
 * @see
 * {@link https://design-system.solventek.com/component/drawer}
 *
 * @example
 * <Drawer open={open} onClose={onClose} position="right">
 *   My Content
 * </Drawer>
 */
const Drawer = (0,component/* componentWithRef */.w)((_a, forwardRef) => {
    var { variant, open, onClose, children, width, passive } = _a, rest = Drawer_rest(_a, ["variant", "open", "onClose", "children", "width", "passive"]);
    const { floating, context } = (0,floating_ui_react_dom_interactions/* useFloating */.YF)({
        open,
        onOpenChange: onClose
    });
    const id = (0,react.useId)();
    const labelId = `${id}-label`;
    const Portal = (0,usePortal/* usePortal */.v)();
    const { getFloatingProps } = (0,floating_ui_react_dom_interactions/* useInteractions */.NI)([
        (0,floating_ui_react_dom_interactions/* useClick */.eS)(context),
        (0,floating_ui_react_dom_interactions/* useRole */.qs)(context),
        (0,floating_ui_react_dom_interactions/* useDismiss */.bQ)(context, { bubbles: false, outsidePress: !passive })
    ]);
    const Container = passive ? PassiveContainer : ActiveContainer;
    return ((0,jsx_runtime.jsx)(Transition/* Transition.Fade */.u.Fade, Object.assign({ in: open, timeout: { enter: 200, exit: 120 } }, { children: (0,jsx_runtime.jsx)(Portal, { children: (0,jsx_runtime.jsx)(Container, { children: (0,jsx_runtime.jsx)(floating_ui_react_dom_interactions/* FloatingFocusManager */.wD, Object.assign({ context: context }, { children: (0,jsx_runtime.jsx)(Transition/* Transition.Slide */.u.Slide, Object.assign({ in: open, enter: false, timeout: { appear: 200, exit: 120 }, "$x": rest.position === 'right' ? `${width}px` : `-${width}px`, "$y": "0", appear: true }, { children: (0,jsx_runtime.jsx)(DrawerStyled, Object.assign({ passive: passive, width: width, className: variant, ref: forwardRef }, rest, getFloatingProps({
                            ref: floating,
                            'aria-labelledby': labelId
                        }), { children: children })) })) })) }) }) })));
});
Drawer.defaultProps = {
    width: 400,
    backgroundColor: 'dark80',
    position: 'left',
    passive: false
};
/* harmony default export */ const Drawer_Drawer = (Drawer);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Sidebar/Sidebar.js
var Sidebar_rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};




const StyledSidebar = dist_theme/* styled.aside */.zo.aside `
max-width: 320px;
  flex: 1 0 320px;
  padding: 48px 24px;
  border-right: 1px solid ${({ theme }) => theme.color('dark80', 'light70')};
  ${({ fullHeight }) => fullHeight && `height: 100%;`}
  nav {
    position: sticky;
    top: 40px;
    left: 0px;
    overflow: visible;
    ${({ theme }) => theme.screen.m} {
      position: static;
    }
  }
  form {
    margin: 0 22px 40px;
  }
  hr {
    margin: 30px 0;
  }
  button.nav {
    width: 100%;
  }
  a, button.blank {
    display: block;
    position: relative;
    line-height: 1.25em;
    margin: 12px 0 12px 46px;
    color: ${({ theme }) => theme.color('dark20')};
    span {
      margin: 0;
    }
    &.current,
    &:active,
    &[aria-current="page"],
    &:hover {
      color: ${({ theme }) => theme.color('dark0')};
    }
    &.current:before,
    &:active:before,
    &[aria-current="page"]:before {
        content: '';
        width: 6px;
        height: 6px;
        border-radius: 6px;
        position: absolute;
        top: 6px;
        left: -16px;
        background: ${({ theme }) => theme.colors.yellow50};
      }
    }
  }
  ${({ theme }) => theme.screen.m} {
    display: none;
  }
`;
const Sidebar_Switch = (0,dist_theme/* styled */.zo)(Button/* ButtonBase */.X).attrs({ size: 'large' }) `
  width: 100%;
  padding: 0 0 ${({ theme }) => theme.sizes.$8};
  text-align: left;
  line-height: ${({ theme }) => theme.lineHeights.$120};
`;
const Sidebar_Button = (0,dist_theme/* styled */.zo)(Button/* ButtonBase */.X) `
  width: 100%;
  justify-content: space-between;
  padding: 0 0 0 46px;
  text-transform: uppercase;

  &:hover {
    color: ${({ theme }) => theme.color('dark10')};
  }

  &:disabled {
    color: ${({ theme }) => theme.color('dark30')};
  }

  > div:first-child {
    display: none;
  }
`;
const Sidebar_compoundComponents = {
    Switch: Sidebar_Switch,
    Button: Sidebar_Button
};
/**
 * Sidebar component
 */
const Sidebar = (0,component/* componentWithRef */.w)((_a, forwardedRef) => {
    var { children } = _a, rest = Sidebar_rest(_a, ["children"]);
    return ((0,jsx_runtime.jsx)(StyledSidebar, Object.assign({ ref: forwardedRef }, rest, { children: children })));
}, Sidebar_compoundComponents);
Sidebar.defaultProps = {
    fullHeight: true
};

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Sidebar/index.js


// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/hooks/useViewport.js
var useViewport = __webpack_require__(9261);
// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/hooks/useLockScroll.js
var useLockScroll = __webpack_require__(6501);
;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/hooks/useSystemTheme.js

const defaultTheme = typeof window === 'object' && window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
/**
 * Detects user's system theme preference for dark or light mode.
 *
 * @example
 * const themeName = useSystemTheme();
 *
 * @returns Current system theme name
 */
const useSystemTheme = () => {
    const [theme, setTheme] = (0,react.useState)(defaultTheme);
    (0,react.useEffect)(() => {
        const switchTheme = (e) => {
            const newTheme = e.matches ? 'dark' : 'light';
            setTheme(newTheme);
        };
        if (typeof window === 'object' && window.matchMedia) {
            window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', switchTheme, true);
        }
        return () => {
            if (typeof window === 'object' && window.matchMedia) {
                window.matchMedia('(prefers-color-scheme: dark)').removeEventListener('change', switchTheme, true);
            }
        };
    });
    return theme;
};
/* harmony default export */ const hooks_useSystemTheme = (useSystemTheme);

// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/hooks/useTheme.js
var useTheme = __webpack_require__(5050);
// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/hooks/useAutoWidth.js
var useAutoWidth = __webpack_require__(926);
;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/hooks/index.js











;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Header/Header.js
var Header_rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};




const HeaderStyled = (0,dist_theme/* styled */.zo)(Box/* default */.Z) `
  width: 100%;
  margin-bottom: 32px;
  justify-content: space-between;
`;
const StyledActions = (0,dist_theme/* styled */.zo)(Box/* default */.Z) `
  > *:not(:last-child) {
    margin-right: 16px;
    white-space: nowrap;
  }
`;
/**
 * Header component
 */
const Header = (_a) => {
    var { heading, subheading, actions } = _a, rest = Header_rest(_a, ["heading", "subheading", "actions"]);
    return ((0,jsx_runtime.jsxs)(HeaderStyled, Object.assign({ display: ['block', 'block', 'flex'] }, rest, { children: [(0,jsx_runtime.jsxs)(Content, Object.assign({ maxWidth: ['100%', '100%', '60%', '70%'], mb: [16, 16, 0] }, { children: [(0,jsx_runtime.jsx)("h2", { children: heading }), subheading && (0,jsx_runtime.jsx)("p", { children: subheading })] })), (0,jsx_runtime.jsx)(StyledActions, Object.assign({ display: "flex", mt: [20, 20, 0] }, { children: actions }))] })));
};
/* harmony default export */ const Header_Header = (Header);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/AppSideNav/AppSideNav.js



const SideNavItem = (0,dist_theme/* styled */.zo)(Box/* default */.Z) `
  display: flex;
  align-items: center;
  justify-content: center;

  width: 63px;
  height: 64px;
`;
const AppSideNavStyled = dist_theme/* styled.div */.zo.div `
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: flex-end;
  height: 100%;
  width: 64px;
  background-color: ${({ theme }) => theme.color('dark80', 'light100')};
  border-right: 1px solid ${({ theme }) => theme.color('dark60')};
`;
/**
 * AppSideNav component
 */
const AppSideNav = ({ children, className }) => {
    return (0,jsx_runtime.jsx)(AppSideNavStyled, Object.assign({ className: className }, { children: children }));
};
AppSideNav.defaultProps = {};
/* harmony default export */ const AppSideNav_AppSideNav = (AppSideNav);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Stat/Stat.js



const StatLabel = ({ children }) => {
    return ((0,jsx_runtime.jsx)(Box/* default */.Z, Object.assign({ mb: 10, color: "dark20", fontWeight: "500" }, { children: children })));
};
const Stat_Label = (0,dist_theme/* styled */.zo)(Box/* default */.Z) `
  font-family: ${({ theme }) => theme.fonts.title};
  font-size: ${({ theme }) => theme.fontSizes.$24};
  font-weight: ${({ theme }) => theme.fontWeights.bold};
`;
const StatNumber = ({ children, unit, details }) => {
    return ((0,jsx_runtime.jsxs)(jsx_runtime.Fragment, { children: [(0,jsx_runtime.jsxs)(Box/* default */.Z, Object.assign({ display: "flex", flexDirection: "row", alignItems: "flex-end", mb: 10, width: details ? '60%' : '100%' }, { children: [(0,jsx_runtime.jsx)(Stat_Label, Object.assign({ mr: 4, color: "dark40" }, { children: children })), unit && (0,jsx_runtime.jsx)(Box/* default */.Z, Object.assign({ fontWeight: 500 }, { children: unit }))] })), details ? ((0,jsx_runtime.jsx)(Box/* default */.Z, Object.assign({ display: "flex", width: "40%", ml: ['5px', '5px', '0', '0'] }, { children: details }))) : null] }));
};
/**
 * Stat component
 */
const Stat = ({ label, kpi, kpiUnit, kpiDetails, diff, diffDetails }) => {
    return ((0,jsx_runtime.jsxs)(Box/* default */.Z, { children: [(0,jsx_runtime.jsx)(StatLabel, { children: label }), (0,jsx_runtime.jsx)(Box/* default */.Z, Object.assign({ display: "flex", flexDirection: "row", alignItems: "center" }, { children: (0,jsx_runtime.jsx)(StatNumber, Object.assign({ unit: kpiUnit, details: kpiDetails }, { children: kpi })) })), (0,jsx_runtime.jsxs)(Box/* default */.Z, Object.assign({ display: "flex", alignItems: "flex-end" }, { children: [diffDetails ? ((0,jsx_runtime.jsx)(Box/* default */.Z, Object.assign({ flex: "1", mr: "10px" }, { children: diffDetails }))) : null, diff ? (0,jsx_runtime.jsx)(Box/* default */.Z, { children: diff }) : null] }))] }));
};
Stat.displayName = 'Stat';
/* harmony default export */ const Stat_Stat = (Stat);

// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconFilledCircle.js
var IconFilledCircle = __webpack_require__(2062);
;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Timeline/Timeline.js





const Timeline_Line = (0,dist_theme/* styled */.zo)(Box/* default */.Z) `
  display: flex;
  height: 100%;
  width: 1px;
  position: relative;

  :before {
    content: '';
    position: relative;
    width: 1px;
    background-color: ${({ theme }) => theme.color('dark50', 'light50')};

    height: ${({ isFirst, isLast }) => (isFirst || isLast ? '50%' : '100%')};
    top: ${({ isFirst }) => {
    if (isFirst)
        return `50%`;
    return '0';
}};
    left: 13px;
  }
`;
const LineContainer = (0,dist_theme/* styled */.zo)(Box/* default */.Z) `
  width: 25px;
  margin-right: 15px;
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 20;
`;
const TimelineItem = ({ label, details, isFirst, isLast, variant = 'small' }) => {
    if (variant === 'large') {
        return ((0,jsx_runtime.jsxs)(Box/* default */.Z, Object.assign({ display: "flex", width: "100%", alignItems: "center", height: "60px", flexDirection: "row" }, { children: [(0,jsx_runtime.jsx)(Timeline_Line, { isFirst: isFirst, isLast: isLast }), (0,jsx_runtime.jsx)(LineContainer, { children: (0,jsx_runtime.jsx)(IconFilledCircle/* default */.Z, { colors: ['dark0', 'light0'], size: 11 }) }), (0,jsx_runtime.jsxs)(Box/* default */.Z, Object.assign({ display: "flex", flexDirection: "column" }, { children: [(0,jsx_runtime.jsx)(Box/* default */.Z, Object.assign({ mb: 4, colors: ['dark20', 'light20'] }, { children: label })), (0,jsx_runtime.jsx)(Box/* default */.Z, Object.assign({ fontWeight: "bold" }, { children: details }))] }))] })));
    }
    return ((0,jsx_runtime.jsxs)(Box/* default */.Z, Object.assign({ display: "flex", width: "100%", alignItems: "center", height: "40px" }, { children: [(0,jsx_runtime.jsx)(Timeline_Line, { isFirst: isFirst, isLast: isLast }), (0,jsx_runtime.jsx)(LineContainer, { children: (0,jsx_runtime.jsx)(IconFilledCircle/* default */.Z, { colors: ['dark50', 'light50'], size: 7 }) }), (0,jsx_runtime.jsx)(Box/* default */.Z, Object.assign({ pr: 16, colors: ['dark20', 'light20'] }, { children: label })), (0,jsx_runtime.jsx)(Box/* default */.Z, Object.assign({ ml: "auto", colors: ['dark30', 'light30'] }, { children: details }))] })));
};
const TimelineGroupItem = ({ icon, label, details, isFirst, isLast }) => {
    return ((0,jsx_runtime.jsxs)(Box/* default */.Z, Object.assign({ display: "flex", flexDirection: "row", width: "100%", alignItems: "center", height: "40px" }, { children: [(0,jsx_runtime.jsx)(Timeline_Line, { isFirst: isFirst, isLast: isLast }), (0,jsx_runtime.jsx)(LineContainer, { children: icon }), (0,jsx_runtime.jsx)(Box/* default */.Z, Object.assign({ fontWeight: "bold" }, { children: label })), details ? ((0,jsx_runtime.jsx)(Box/* default */.Z, Object.assign({ ml: "auto", fontWeight: "bold" }, { children: details }))) : null] })));
};
/**
 * Timeline component
 */
const Timeline = ({ id, className, data }) => {
    return ((0,jsx_runtime.jsx)(Box/* default */.Z, Object.assign({ display: "flex", flexDirection: "column", id: id, className: className }, { children: data === null || data === void 0 ? void 0 : data.map(({ id: groupId, icon, label, details, items }, idx) => {
            const isFirstGroup = idx === 0;
            const isLastGroup = idx === data.length - 1;
            return ((0,jsx_runtime.jsxs)(react.Fragment, { children: [label ? ((0,jsx_runtime.jsx)(TimelineGroupItem, { icon: icon, label: label, details: details, isFirst: isFirstGroup, isLast: isLastGroup && !items.length })) : null, items.map((item, itemIdx) => ((0,jsx_runtime.jsx)(TimelineItem, { label: item.label, details: item.details, isFirst: isFirstGroup && itemIdx === 0 && !label, isLast: isLastGroup && itemIdx === items.length - 1, variant: item.variant }, item.id)))] }, groupId));
        }) })));
};
Timeline.defaultProps = {
    data: []
};
/* harmony default export */ const Timeline_Timeline = (Timeline);

// EXTERNAL MODULE: ./node_modules/styled-components/dist/styled-components.browser.esm.js + 2 modules
var styled_components_browser_esm = __webpack_require__(2294);
;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Skeleton/Skeleton.js
var Skeleton_rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};




const BackgroundStop = styled_components_browser_esm["default"].stop `
  stop-color: ${({ theme }) => theme.color('dark60', 'light70')};
`;
const ForegroundStop = styled_components_browser_esm["default"].stop `
  stop-color: ${({ theme }) => theme.color('dark50', 'light40')};
`;
const Skeleton = (_a) => {
    var { baseUrl = '', backgroundOpacity = 0.9, foregroundOpacity = 0.4, gradientRatio = 2, interval = 0.15, speed = 1.5, uniqueKey, children } = _a, props = Skeleton_rest(_a, ["baseUrl", "backgroundOpacity", "foregroundOpacity", "gradientRatio", "interval", "speed", "uniqueKey", "children"]);
    const fixedIdRef = (0,react.useRef)(uniqueKey !== null && uniqueKey !== void 0 ? uniqueKey : (0,utils/* uid */.hQ)());
    const idClip = `${fixedIdRef.current}-diff`;
    const idGradient = `${fixedIdRef.current}-animated-diff`;
    const keyTimes = `0; ${interval}; 1`;
    const dur = `${speed}s`;
    return ((0,jsx_runtime.jsxs)("svg", Object.assign({ role: "presentation" }, props, { children: [(0,jsx_runtime.jsx)("rect", { role: "presentation", x: "0", y: "0", width: "100%", height: "100%", clipPath: `url(${baseUrl}#${idClip})`, style: { fill: `url(${baseUrl}#${idGradient})` } }), (0,jsx_runtime.jsxs)("defs", { children: [(0,jsx_runtime.jsx)("clipPath", Object.assign({ id: idClip }, { children: children })), (0,jsx_runtime.jsxs)("linearGradient", Object.assign({ id: idGradient }, { children: [(0,jsx_runtime.jsx)(BackgroundStop, Object.assign({ offset: "0%", stopOpacity: backgroundOpacity }, { children: (0,jsx_runtime.jsx)("animate", { attributeName: "offset", values: `${-gradientRatio}; ${-gradientRatio}; 1`, keyTimes: keyTimes, dur: dur, repeatCount: "indefinite" }) })), (0,jsx_runtime.jsx)(ForegroundStop, Object.assign({ offset: "50%", stopOpacity: foregroundOpacity }, { children: (0,jsx_runtime.jsx)("animate", { attributeName: "offset", values: `${-gradientRatio / 2}; ${-gradientRatio / 2}; ${1 + gradientRatio / 2}`, keyTimes: keyTimes, dur: dur, repeatCount: "indefinite" }) })), (0,jsx_runtime.jsx)(BackgroundStop, Object.assign({ stopOpacity: backgroundOpacity }, { children: (0,jsx_runtime.jsx)("animate", { attributeName: "offset", values: `0; 0; ${1 + gradientRatio}`, keyTimes: keyTimes, dur: dur, repeatCount: "indefinite" }) }))] }))] })] })));
};
/* harmony default export */ const Skeleton_Skeleton = (Skeleton);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Skeleton/index.js




/* harmony default export */ const components_Skeleton = (Skeleton_Skeleton);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Skeleton/SkeletonLoader.js


const SkeletonLoader = ({ loading, children, skeleton: Skeleton }) => ((0,jsx_runtime.jsxs)(jsx_runtime.Fragment, { children: [(0,jsx_runtime.jsx)(Transition/* Transition.Fade */.u.Fade, Object.assign({ in: loading, timeout: { enter: 300 }, exit: false }, { children: (0,jsx_runtime.jsx)(Skeleton, {}) })), (0,jsx_runtime.jsx)(Transition/* Transition.Fade */.u.Fade, Object.assign({ in: !loading, timeout: { enter: 300 }, exit: false }, { children: (0,jsx_runtime.jsx)(jsx_runtime.Fragment, { children: children }) }))] }));
/* harmony default export */ const Skeleton_SkeletonLoader = (SkeletonLoader);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Skeleton/skeletons/TableSkeleton.js



const SmallRect = dist_theme/* styled.rect */.zo.rect `
  visibility: hidden;
  ${({ theme }) => theme.screen.s} {
    visibility: visible;
  }
`;
const SmallTableSkeleton = () => ((0,jsx_runtime.jsxs)(jsx_runtime.Fragment, { children: [(0,jsx_runtime.jsx)(SmallRect, { x: "2%", y: "12", rx: "3", ry: "3", width: "10%", height: "16" }), (0,jsx_runtime.jsx)(SmallRect, { x: "40%", y: "12", rx: "3", ry: "3", width: "30%", height: "16" }), (0,jsx_runtime.jsx)(SmallRect, { x: "2%", y: "45", rx: "3", ry: "3", width: "20%", height: "16" }), (0,jsx_runtime.jsx)(SmallRect, { x: "40%", y: "45", rx: "3", ry: "3", width: "50%", height: "16" }), (0,jsx_runtime.jsx)(SmallRect, { x: "2%", y: "78", rx: "3", ry: "3", width: "25%", height: "16" }), (0,jsx_runtime.jsx)(SmallRect, { x: "40%", y: "78", rx: "3", ry: "3", width: "22%", height: "16" }), (0,jsx_runtime.jsx)(SmallRect, { x: "2%", y: "111", rx: "3", ry: "3", width: "18%", height: "16" }), (0,jsx_runtime.jsx)(SmallRect, { x: "40%", y: "111", rx: "3", ry: "3", width: "40%", height: "16" }), (0,jsx_runtime.jsx)(SmallRect, { x: "2%", y: "144", rx: "3", ry: "3", width: "28%", height: "16" }), (0,jsx_runtime.jsx)(SmallRect, { x: "40%", y: "144", rx: "3", ry: "3", width: "34%", height: "16" })] }));
const BaseRect = dist_theme/* styled.rect */.zo.rect `
  ${({ theme }) => theme.screen.s} {
    visibility: hidden;
  }
`;
const BaseTableSkeleton = () => ((0,jsx_runtime.jsxs)(jsx_runtime.Fragment, { children: [(0,jsx_runtime.jsx)(BaseRect, { x: "2%", y: "0", rx: "3", ry: "3", width: "12%", height: "14" }), (0,jsx_runtime.jsx)(BaseRect, { x: "25%", y: "0", rx: "3", ry: "3", width: "6%", height: "14" }), (0,jsx_runtime.jsx)(BaseRect, { x: "50%", y: "0", rx: "3", ry: "3", width: "15%", height: "14" }), (0,jsx_runtime.jsx)(BaseRect, { x: "80%", y: "0", rx: "3", ry: "3", width: "10%", height: "14" }), (0,jsx_runtime.jsx)(BaseRect, { x: "0", y: "26", width: "100%", height: "1" }), (0,jsx_runtime.jsx)(BaseRect, { x: "2%", y: "40", rx: "3", ry: "3", width: "14%", height: "16" }), (0,jsx_runtime.jsx)(BaseRect, { x: "25%", y: "40", rx: "3", ry: "3", width: "10%", height: "16" }), (0,jsx_runtime.jsx)(BaseRect, { x: "50%", y: "40", rx: "3", ry: "3", width: "20%", height: "16" }), (0,jsx_runtime.jsx)(BaseRect, { x: "80%", y: "40", rx: "3", ry: "3", width: "18%", height: "16" }), (0,jsx_runtime.jsx)(BaseRect, { x: "0", y: "69", width: "100%", height: "1" }), (0,jsx_runtime.jsx)(BaseRect, { x: "2%", y: "83", rx: "3", ry: "3", width: "6%", height: "16" }), (0,jsx_runtime.jsx)(BaseRect, { x: "25%", y: "83", rx: "3", ry: "3", width: "20%", height: "16" }), (0,jsx_runtime.jsx)(BaseRect, { x: "50%", y: "83", rx: "3", ry: "3", width: "10%", height: "16" }), (0,jsx_runtime.jsx)(BaseRect, { x: "80%", y: "83", rx: "3", ry: "3", width: "15%", height: "16" }), (0,jsx_runtime.jsx)(BaseRect, { x: "0", y: "112", width: "100%", height: "1" }), (0,jsx_runtime.jsx)(BaseRect, { x: "2%", y: "126", rx: "3", ry: "3", width: "8%", height: "16" }), (0,jsx_runtime.jsx)(BaseRect, { x: "25%", y: "126", rx: "3", ry: "3", width: "12%", height: "16" }), (0,jsx_runtime.jsx)(BaseRect, { x: "50%", y: "126", rx: "3", ry: "3", width: "20%", height: "16" }), (0,jsx_runtime.jsx)(BaseRect, { x: "80%", y: "126", rx: "3", ry: "3", width: "5%", height: "16" })] }));
const StyledSkeleton = (0,dist_theme/* styled */.zo)(Skeleton_Skeleton) `
  height: 153px;
  ${({ theme }) => theme.screen.s} {
    height: 174px;
  }
`;
const TableSkeleton = (props) => ((0,jsx_runtime.jsxs)(StyledSkeleton, Object.assign({ width: "100%" }, props, { children: [(0,jsx_runtime.jsx)(BaseTableSkeleton, {}), (0,jsx_runtime.jsx)(SmallTableSkeleton, {})] })));
/* harmony default export */ const skeletons_TableSkeleton = (TableSkeleton);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Skeleton/skeletons/ListSkeleton.js



const BoxRect = styled_components_browser_esm["default"].rect `
  transform: translateX(calc(98% - 42px));
`;
const ListSkeleton = (props) => ((0,jsx_runtime.jsxs)(Skeleton_Skeleton, Object.assign({ width: "100%", height: "120px" }, props, { children: [(0,jsx_runtime.jsx)("rect", { x: "2%", y: "12", rx: "3", ry: "3", width: "65%", height: "36" }), (0,jsx_runtime.jsx)(BoxRect, { x: "0%", y: "12", rx: "3", ry: "3", width: "42", height: "36" }), (0,jsx_runtime.jsx)("rect", { x: "2%", y: "72", rx: "3", ry: "3", width: "70%", height: "36" }), (0,jsx_runtime.jsx)(BoxRect, { x: "0%", y: "72", rx: "3", ry: "3", width: "42", height: "36" })] })));
/* harmony default export */ const skeletons_ListSkeleton = (ListSkeleton);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/SideNavigation/components/MenuItemIcon.js
var MenuItemIcon_rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};




const ItemIcon = dist_theme/* styled.span.withConfig */.zo.span.withConfig({
    shouldForwardProp: (prop, defaultValidationFn) => !['shape', 'color'].includes(prop) && defaultValidationFn(prop)
})(helpers/* parseColorProps */.sL, (0,index_esm/* variant */.bU)({
    prop: 'shape',
    variants: {
        circle: {
            borderRadius: '50%'
        },
        rounded: {
            borderRadius: '20%'
        }
    }
}), (0,index_esm/* variant */.bU)({
    prop: 'size',
    variants: {
        small: {
            width: 24,
            height: 24,
            fontSize: 8,
            '.icon': {
                width: 16,
                height: 16
            }
        },
        medium: {
            width: 32,
            height: 32,
            fontSize: 12,
            '.icon': {
                width: 22,
                height: 22
            }
        }
    }
}), `display: inline-flex;
  flex: 0 0 auto;
  align-items: center;
  justify-content: center;
  user-select: none;
  font-weight: 600;
  transition: color 150ms ease-in-out;
  `);
const MenuItemIcon = (_a) => {
    var { children, label, isActive, color, shape, alt } = _a, restProps = MenuItemIcon_rest(_a, ["children", "label", "isActive", "color", "shape", "alt"]);
    const usedColor = isActive ? 'purple50' : color;
    return restProps.src !== undefined ? ((0,jsx_runtime.jsx)(ItemIcon, Object.assign({ as: "img", alt: alt !== null && alt !== void 0 ? alt : '', shape: shape }, restProps))) : ((0,jsx_runtime.jsx)(ItemIcon, Object.assign({ shape: shape, color: usedColor }, restProps, { children: label ? (0,utils/* initials */.eu)(label) : children })));
};
MenuItemIcon.defaultProps = {
    isActive: false,
    shape: 'rounded',
    size: 'medium',
    backgroundColor: 'transparent'
};

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/SideNavigation/components/MenuItem.js
var MenuItem_rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};




const StyledContainer = (0,dist_theme/* styled */.zo)(Box/* default */.Z).withConfig({
    shouldForwardProp: (prop, defaultValidationFn) => prop !== 'display' && defaultValidationFn(prop)
}) `
  font-weight: inherit;
`;
const StyledContent = (0,dist_theme/* styled */.zo)(Box/* default */.Z) `
  width: 100%;
  overflow: hidden;
  text-align: left;
  text-overflow: ellipsis;
  white-space: nowrap;
  font-weight: inherit;
`;
const MenuItem = (_a) => {
    var { children, isActive } = _a, _b = _a.iconProps, _c = _b === void 0 ? {} : _b, { icon: Icon, label } = _c, iconProps = MenuItem_rest(_c, ["icon", "label"]), restProps = MenuItem_rest(_a, ["children", "isActive", "iconProps"]);
    const isContentString = typeof children === 'string' ? children : undefined;
    const showAvatar = !!(iconProps.src || Icon || label || isContentString);
    const contentSpacing = iconProps.size === 'medium' ? 12 : 8;
    return ((0,jsx_runtime.jsxs)(StyledContainer, Object.assign({ display: "flex", alignItems: "center", width: "100%" }, restProps, { children: [showAvatar && ((0,jsx_runtime.jsx)(MenuItemIcon, Object.assign({ isActive: isActive, label: !iconProps.src && !Icon ? label !== null && label !== void 0 ? label : isContentString : undefined }, iconProps, { children: Icon ? (0,jsx_runtime.jsx)(Icon, { size: "small" }) : null }))), (0,jsx_runtime.jsx)(StyledContent, Object.assign({ ml: showAvatar ? contentSpacing : 0 }, { children: children }))] })));
};

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/SideNavigation/components/Link.js
var components_Link_rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};





const Link_StyledLink = (0,dist_theme/* styled */.zo)('a').withConfig({
    shouldForwardProp: (prop, defaultValidationFn) => !['fontWeight', 'fontSize'].includes(prop) && defaultValidationFn(prop)
}) `
  display: inline-block;
  width: 100%;
  padding: 2px 16px;
  text-decoration: none;
  color: ${({ theme, isActive }) => (isActive ? theme.color('dark0', 'light10') : theme.color('dark20', 'light20'))};
  font-size: ${({ theme }) => theme.fontSizes.$12};
  line-height: ${({ theme }) => theme.lineHeights.$115};
  &:hover {
    color: ${({ theme }) => theme.color('dark0', 'light10')};
    text-decoration: none;
  }
  ${helpers/* styledFocus */.By}
  ${helpers/* parseColorProps */.sL}
  ${index_esm/* fontSize */.JB}
  ${index_esm/* fontWeight */.Ue}
`;
const Link_Link = (_a) => {
    var { children, iconProps, isActive = false } = _a, linkProps = components_Link_rest(_a, ["children", "iconProps", "isActive"]);
    return ((0,jsx_runtime.jsx)(Link_StyledLink, Object.assign({ isActive: isActive }, linkProps, { children: (0,jsx_runtime.jsx)(MenuItem, Object.assign({ iconProps: iconProps, isActive: isActive }, { children: children })) })));
};

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/SideNavigation/components/Button.js
var Button_rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};





const StyledButton = (0,dist_theme/* styled */.zo)('button').withConfig({
    shouldForwardProp: (prop, defaultValidationFn) => !['fontWeight', 'fontSize'].includes(prop) && defaultValidationFn(prop)
}) `
  display: inline-block;
  width: 100%;
  padding: 2px 16px;
  background-color: inherit;
  color: ${({ theme }) => theme.color('dark20', 'light20')};
  font-size: ${({ theme }) => theme.fontSizes.$12};
  line-height: ${({ theme }) => theme.lineHeights.$115};
  &:hover {
    color: ${({ theme }) => theme.color('dark0', 'light10')};
    text-decoration: none;
  }
  :disabled {
    color: ${({ theme }) => theme.color('dark50', 'light50')};
    cursor: not-allowed;
  }
  ${helpers/* styledFocus */.By}
  ${helpers/* parseColorProps */.sL}
  ${index_esm/* fontSize */.JB}
  ${index_esm/* fontWeight */.Ue}
`;
const Button_Button = (_a) => {
    var { children, iconProps } = _a, buttonProps = Button_rest(_a, ["children", "iconProps"]);
    return ((0,jsx_runtime.jsx)(StyledButton, Object.assign({}, buttonProps, { children: (0,jsx_runtime.jsx)(MenuItem, Object.assign({ iconProps: iconProps }, { children: children })) })));
};

// EXTERNAL MODULE: ./node_modules/@floating-ui/core/dist/floating-ui.core.mjs
var floating_ui_core = __webpack_require__(7680);
// EXTERNAL MODULE: ./node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs
var floating_ui_dom = __webpack_require__(7555);
;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/SideNavigation/components/Menu.js
var Menu_rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};








const Menu_Container = dist_theme/* styled.div */.zo.div `
  z-index: ${({ theme }) => theme.zIndex.dropdown};
  padding: ${({ theme }) => theme.sizes.$4} 0;
  border-radius: ${({ theme }) => theme.sizes.$4};
  background-color: ${({ theme }) => theme.color('dark100', 'white')};
  box-shadow: ${({ theme }) => theme.shadows.level2};
  margin-bottom: 8px;

  ol,
  ul {
    list-style-type: none;
  }

  ${index_esm/* width */.bf}
  ${index_esm/* minWidth */.ih}
`;
const MenuBase = (0,component/* componentWithRef */.w)((_a, forwardedRef) => {
    var { children, trigger } = _a, rest = Menu_rest(_a, ["children", "trigger"]);
    const Portal = (0,usePortal/* usePortal */.v)();
    const menuItemsRef = (0,react.useRef)([]);
    const [open, onOpenChange] = (0,react.useState)(false);
    const nodeId = (0,floating_ui_react_dom_interactions/* useFloatingNodeId */.jV)();
    const parentId = (0,floating_ui_react_dom_interactions/* useFloatingParentNodeId */.Zm)();
    const nested = parentId != null;
    const { x, y, reference, floating, strategy, context } = (0,floating_ui_react_dom_interactions/* useFloating */.YF)({
        open,
        onOpenChange,
        middleware: [(0,floating_ui_core/* offset */.cv)({ mainAxis: nested ? 2 : 6, alignmentAxis: nested ? -5 : 0 })],
        placement: nested ? 'right-start' : 'bottom',
        nodeId,
        whileElementsMounted: floating_ui_dom/* autoUpdate */.Me
    });
    const combinedMenuRef = (0,useForkRef/* useForkRef */.c)(forwardedRef, floating);
    const { getReferenceProps, getFloatingProps, getItemProps } = (0,floating_ui_react_dom_interactions/* useInteractions */.NI)([
        (0,floating_ui_react_dom_interactions/* useHover */.XI)(context, {
            handleClose: (0,floating_ui_react_dom_interactions/* safePolygon */.xp)({ restMs: 75, buffer: 5 }),
            enabled: nested,
            delay: { open: 75 }
        }),
        (0,floating_ui_react_dom_interactions/* useClick */.eS)(context, {
            toggle: !nested,
            event: 'mousedown',
            ignoreMouse: nested
        }),
        (0,floating_ui_react_dom_interactions/* useRole */.qs)(context, { role: 'menu' }),
        (0,floating_ui_react_dom_interactions/* useDismiss */.bQ)(context, { bubbles: false }),
        (0,floating_ui_react_dom_interactions/* useListNavigation */.c0)(context, {
            listRef: menuItemsRef,
            activeIndex: null,
            nested
        })
    ]);
    const Wrapper = nested ? react.Fragment : floating_ui_react_dom_interactions/* FloatingTree */.RB;
    const Portaled = nested ? react.Fragment : Portal;
    return ((0,jsx_runtime.jsx)(Wrapper, { children: (0,jsx_runtime.jsxs)(floating_ui_react_dom_interactions/* FloatingNode */.mN, Object.assign({ id: nodeId }, { children: [(0,react.isValidElement)(trigger) &&
                    (0,react.cloneElement)(trigger, Object.assign({}, getReferenceProps(Object.assign(Object.assign({}, trigger.props), { ref: reference, isActive: open, onClick(event) {
                            if (nested) {
                                event.stopPropagation();
                            }
                        } })))), (0,jsx_runtime.jsx)(Portaled, { children: (0,jsx_runtime.jsx)(Transition/* Transition */.u, Object.assign({ in: open, timeout: { enter: 120, exit: 80 } }, { children: (0,jsx_runtime.jsx)(floating_ui_react_dom_interactions/* FloatingFocusManager */.wD, Object.assign({ context: context }, { children: (0,jsx_runtime.jsx)(Transition/* Transition.Slide */.u.Slide, Object.assign({ in: open, timeout: { appear: 120, exit: 80 }, enter: false, appear: true }, { children: (0,jsx_runtime.jsx)(Menu_Container, Object.assign({}, getFloatingProps({
                                    ref: combinedMenuRef,
                                    style: {
                                        position: strategy,
                                        top: y !== null && y !== void 0 ? y : '',
                                        left: x !== null && x !== void 0 ? x : ''
                                    }
                                }), rest, { children: react.Children.map(children, (child) => (0,react.isValidElement)(child) &&
                                        (0,react.cloneElement)(child, Object.assign({}, getItemProps(Object.assign(Object.assign({}, child.props), { onClick(event) {
                                                var _a, _b;
                                                (_b = (_a = child.props).onClick) === null || _b === void 0 ? void 0 : _b.call(_a, event);
                                                onOpenChange(false);
                                            } }))))) })) })) })) })) })] })) }));
});
const components_Menu_Menu = (0,component/* componentWithRef */.w)((props, forwardedRef) => {
    const parentId = (0,floating_ui_react_dom_interactions/* useFloatingParentNodeId */.Zm)();
    const Wrapper = parentId ? react.Fragment : floating_ui_react_dom_interactions/* FloatingTree */.RB;
    return ((0,jsx_runtime.jsx)(Wrapper, { children: (0,jsx_runtime.jsx)(MenuBase, Object.assign({ ref: forwardedRef }, props)) }));
});
components_Menu_Menu.defaultProps = {
    width: 244
};

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/SideNavigation/components/Accordion.js
var Accordion_rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};






const Accordion_Container = dist_theme/* styled.div */.zo.div `
  background-color: ${({ theme, isActive }) => (isActive ? theme.color('dark70', 'light100') : 'inherit')};
  border-radius: ${({ isActive }) => (isActive ? 3 : 0)}px;
  transition: background-color 100ms ease-in-out;
  margin-left: 8px;
  margin-right: 8px;

  a.focus-visible,
  button.focus-visible {
    position: relative;
  }
`;
const Accordion_StyledButton = dist_theme/* styled.button */.zo.button `
  position: relative;
  display: inline-block;
  width: 100%;
  background-color: inherit;
  color: ${({ theme, isActive }) => (isActive ? theme.color('dark0', 'light0') : theme.color('dark20', 'light20'))};
  font-size: ${({ theme }) => theme.fontSizes.$12};
  line-height: ${({ theme }) => theme.lineHeights.$115};
  font-weight: 500;
  margin: 2px 0;
  &:hover {
    color: ${({ theme }) => theme.color('dark0', 'light10')};
  }
  ${helpers/* styledFocus */.By}
`;
const Chevron = (0,dist_theme/* styled */.zo)(IconChevronRight/* default */.Z) `
  position: absolute;
  right: 10px;
  top: 50%;
  transform: translateY(-50%);
  ${({ isOpen }) => isOpen && `transform: translateY(-50%) rotate(90deg);`}
  transition: transform ${({ theme }) => `${theme.transition.duration.fast}ms ${theme.transition.function.default}`};
`;
const Accordion = (_a) => {
    var { children, title, isOpen = false, isActive = false } = _a, buttonProps = Accordion_rest(_a, ["children", "title", "isOpen", "isActive"]);
    return ((0,jsx_runtime.jsxs)(Accordion_Container, Object.assign({ isActive: isOpen && isActive }, { children: [(0,jsx_runtime.jsxs)(Accordion_StyledButton, Object.assign({ isActive: isActive }, buttonProps, { children: [(0,jsx_runtime.jsx)(MenuItem, Object.assign({ isActive: isActive, paddingRight: 26 }, { children: title })), (0,jsx_runtime.jsx)(Chevron, { size: 16, isOpen: isOpen })] })), (0,jsx_runtime.jsx)(Transition/* Transition.Collapse */.u.Collapse, Object.assign({ in: isOpen }, { children: children }))] })));
};

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/SideNavigation/components/AccordionFlat.js
var AccordionFlat_rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};





const AccordionFlat_Container = dist_theme/* styled.div */.zo.div `
  margin-left: 8px;
  margin-right: 8px;

  a.focus-visible,
  button.focus-visible {
    position: relative;
  }
`;
const AccordionFlat_StyledButton = dist_theme/* styled.button */.zo.button `
  display: inline-block;
  background-color: inherit;
  width: 100%;
  color: ${({ theme }) => theme.color('dark30', 'light30')};
  font-size: ${({ theme }) => theme.fontSizes.$12};
  line-height: ${({ theme }) => theme.lineHeights.$115};
  font-weight: 500;
  margin: 2px 0;
  padding: 8px 8px;
  text-align: left;
  &:hover {
    color: ${({ theme }) => theme.color('dark10', 'light20')};
  }
  ${helpers/* styledFocus */.By}
`;
const TitleContent = dist_theme/* styled.div */.zo.div `
  display: inline-block;
  position: relative;
  font-weight: inherit;
  padding-right: 26px;
  max-width: 100%;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
`;
const AccordionFlat_Chevron = (0,dist_theme/* styled */.zo)(IconChevronRight/* default */.Z) `
  position: absolute;
  right: 2px;
  top: 50%;
  transform: translateY(-50%);
  ${({ isOpen }) => isOpen && `transform: translateY(-50%) rotate(90deg);`}
  transition: transform ${({ theme }) => `${theme.transition.duration.fast}ms ${theme.transition.function.default}`};
`;
const AccordionFlat = (_a) => {
    var { children, title, isOpen = false } = _a, buttonProps = AccordionFlat_rest(_a, ["children", "title", "isOpen"]);
    return ((0,jsx_runtime.jsxs)(AccordionFlat_Container, { children: [(0,jsx_runtime.jsx)(AccordionFlat_StyledButton, Object.assign({}, buttonProps, { children: (0,jsx_runtime.jsxs)(TitleContent, { children: [title, (0,jsx_runtime.jsx)(AccordionFlat_Chevron, { size: 16, isOpen: isOpen })] }) })), (0,jsx_runtime.jsx)(Transition/* Transition.Collapse */.u.Collapse, Object.assign({ in: isOpen }, { children: children }))] }));
};

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/SideNavigation/SideNavigation.js
var SideNavigation_rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};










const SideNavigation_StyledSidebar = dist_theme/* styled.aside */.zo.aside `
  background-color: ${({ theme }) => theme.color('dark90', 'white')};
  display: flex;
  flex-direction: column;
  flex-shrink: 0;
  width: 260px;
  height: 100%;
  overflow: visible;
  ol,
  ul {
    list-style-type: none;
  }
`;
const SideNavigation_compoundComponents = {
    Menu: components_Menu_Menu,
    MenuItem: MenuItem,
    Button: Button_Button,
    Link: Link_Link,
    Accordion: Accordion,
    AccordionFlat: AccordionFlat
};
const SideNavigation = (0,component/* componentWithRef */.w)((_a, forwardedRef) => {
    var { children, isOpen = true } = _a, rest = SideNavigation_rest(_a, ["children", "isOpen"]);
    return ((0,jsx_runtime.jsx)(Transition/* Transition.Slide */.u.Slide, Object.assign({ in: isOpen, timeout: { enter: 200, exit: 120 }, "$x": "-100%", "$y": "0" }, { children: (0,jsx_runtime.jsx)(SideNavigation_StyledSidebar, Object.assign({ ref: forwardedRef }, rest, { children: children })) })));
}, SideNavigation_compoundComponents);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/SideNavigation/index.js


// EXTERNAL MODULE: ./node_modules/react-transition-group/esm/Transition.js + 1 modules
var esm_Transition = __webpack_require__(284);
;// CONCATENATED MODULE: ./node_modules/react-transition-group/esm/SwitchTransition.js


var _leaveRenders, _enterRenders;






function areChildrenDifferent(oldChildren, newChildren) {
  if (oldChildren === newChildren) return false;

  if (react.isValidElement(oldChildren) && react.isValidElement(newChildren) && oldChildren.key != null && oldChildren.key === newChildren.key) {
    return false;
  }

  return true;
}
/**
 * Enum of modes for SwitchTransition component
 * @enum { string }
 */


var modes = {
  out: 'out-in',
  in: 'in-out'
};

var callHook = function callHook(element, name, cb) {
  return function () {
    var _element$props;

    element.props[name] && (_element$props = element.props)[name].apply(_element$props, arguments);
    cb();
  };
};

var leaveRenders = (_leaveRenders = {}, _leaveRenders[modes.out] = function (_ref) {
  var current = _ref.current,
      changeState = _ref.changeState;
  return react.cloneElement(current, {
    in: false,
    onExited: callHook(current, 'onExited', function () {
      changeState(esm_Transition/* ENTERING */.d0, null);
    })
  });
}, _leaveRenders[modes.in] = function (_ref2) {
  var current = _ref2.current,
      changeState = _ref2.changeState,
      children = _ref2.children;
  return [current, react.cloneElement(children, {
    in: true,
    onEntered: callHook(children, 'onEntered', function () {
      changeState(esm_Transition/* ENTERING */.d0);
    })
  })];
}, _leaveRenders);
var enterRenders = (_enterRenders = {}, _enterRenders[modes.out] = function (_ref3) {
  var children = _ref3.children,
      changeState = _ref3.changeState;
  return react.cloneElement(children, {
    in: true,
    onEntered: callHook(children, 'onEntered', function () {
      changeState(esm_Transition/* ENTERED */.cn, react.cloneElement(children, {
        in: true
      }));
    })
  });
}, _enterRenders[modes.in] = function (_ref4) {
  var current = _ref4.current,
      children = _ref4.children,
      changeState = _ref4.changeState;
  return [react.cloneElement(current, {
    in: false,
    onExited: callHook(current, 'onExited', function () {
      changeState(esm_Transition/* ENTERED */.cn, react.cloneElement(children, {
        in: true
      }));
    })
  }), react.cloneElement(children, {
    in: true
  })];
}, _enterRenders);
/**
 * A transition component inspired by the [vue transition modes](https://vuejs.org/v2/guide/transitions.html#Transition-Modes).
 * You can use it when you want to control the render between state transitions.
 * Based on the selected mode and the child's key which is the `Transition` or `CSSTransition` component, the `SwitchTransition` makes a consistent transition between them.
 *
 * If the `out-in` mode is selected, the `SwitchTransition` waits until the old child leaves and then inserts a new child.
 * If the `in-out` mode is selected, the `SwitchTransition` inserts a new child first, waits for the new child to enter and then removes the old child.
 *
 * **Note**: If you want the animation to happen simultaneously
 * (that is, to have the old child removed and a new child inserted **at the same time**),
 * you should use
 * [`TransitionGroup`](https://reactcommunity.org/react-transition-group/transition-group)
 * instead.
 *
 * ```jsx
 * function App() {
 *  const [state, setState] = useState(false);
 *  return (
 *    <SwitchTransition>
 *      <CSSTransition
 *        key={state ? "Goodbye, world!" : "Hello, world!"}
 *        addEndListener={(node, done) => node.addEventListener("transitionend", done, false)}
 *        classNames='fade'
 *      >
 *        <button onClick={() => setState(state => !state)}>
 *          {state ? "Goodbye, world!" : "Hello, world!"}
 *        </button>
 *      </CSSTransition>
 *    </SwitchTransition>
 *  );
 * }
 * ```
 *
 * ```css
 * .fade-enter{
 *    opacity: 0;
 * }
 * .fade-exit{
 *    opacity: 1;
 * }
 * .fade-enter-active{
 *    opacity: 1;
 * }
 * .fade-exit-active{
 *    opacity: 0;
 * }
 * .fade-enter-active,
 * .fade-exit-active{
 *    transition: opacity 500ms;
 * }
 * ```
 */

var SwitchTransition = /*#__PURE__*/function (_React$Component) {
  (0,inheritsLoose/* default */.Z)(SwitchTransition, _React$Component);

  function SwitchTransition() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.state = {
      status: esm_Transition/* ENTERED */.cn,
      current: null
    };
    _this.appeared = false;

    _this.changeState = function (status, current) {
      if (current === void 0) {
        current = _this.state.current;
      }

      _this.setState({
        status: status,
        current: current
      });
    };

    return _this;
  }

  var _proto = SwitchTransition.prototype;

  _proto.componentDidMount = function componentDidMount() {
    this.appeared = true;
  };

  SwitchTransition.getDerivedStateFromProps = function getDerivedStateFromProps(props, state) {
    if (props.children == null) {
      return {
        current: null
      };
    }

    if (state.status === esm_Transition/* ENTERING */.d0 && props.mode === modes.in) {
      return {
        status: esm_Transition/* ENTERING */.d0
      };
    }

    if (state.current && areChildrenDifferent(state.current, props.children)) {
      return {
        status: esm_Transition/* EXITING */.Ix
      };
    }

    return {
      current: react.cloneElement(props.children, {
        in: true
      })
    };
  };

  _proto.render = function render() {
    var _this$props = this.props,
        children = _this$props.children,
        mode = _this$props.mode,
        _this$state = this.state,
        status = _this$state.status,
        current = _this$state.current;
    var data = {
      children: children,
      current: current,
      changeState: this.changeState,
      status: status
    };
    var component;

    switch (status) {
      case esm_Transition/* ENTERING */.d0:
        component = enterRenders[mode](data);
        break;

      case esm_Transition/* EXITING */.Ix:
        component = leaveRenders[mode](data);
        break;

      case esm_Transition/* ENTERED */.cn:
        component = current;
    }

    return /*#__PURE__*/react.createElement(TransitionGroupContext/* default.Provider */.Z.Provider, {
      value: {
        isMounting: !this.appeared
      }
    }, component);
  };

  return SwitchTransition;
}(react.Component);

SwitchTransition.propTypes =  false ? 0 : {};
SwitchTransition.defaultProps = {
  mode: modes.out
};
/* harmony default export */ const esm_SwitchTransition = (SwitchTransition);
;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Transition/index.js



// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconChevronDown.js
var IconChevronDown = __webpack_require__(3469);
;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/FilterMenu/FilterMenuTrigger.js
var FilterMenuTrigger_rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};







const TriggerButtonStyled = (0,styled_components_browser_esm["default"])(Button/* ButtonBase */.X) `
  ${({ theme }) => styled_components_browser_esm.css `
    border: 1px solid ${theme.color('dark60')};
    border-radius: 8px;
    padding: 7px;
    background-color: ${theme.color('dark70', 'light100')};
  `}
`;
const FilterTriggerButton = (0,react.forwardRef)((_a, ref) => {
    var { label, selectedOptionLabel, onClearClick, showResetButton } = _a, buttonProps = FilterMenuTrigger_rest(_a, ["label", "selectedOptionLabel", "onClearClick", "showResetButton"]);
    const triggerButton = (0,react.useMemo)(() => ((0,jsx_runtime.jsx)(TriggerButtonStyled, Object.assign({ iconAfter: IconChevronDown/* default */.Z, ref: ref }, buttonProps, { children: (0,jsx_runtime.jsxs)(Box/* default */.Z, Object.assign({ display: "flex" }, { children: [(0,jsx_runtime.jsx)(Box/* default */.Z, { children: label }), selectedOptionLabel ? ((0,jsx_runtime.jsxs)(jsx_runtime.Fragment, { children: [(0,jsx_runtime.jsx)(Box/* default */.Z, { ml: 10 }), (0,jsx_runtime.jsx)(Divider/* default */.Z, { orientation: "vertical" }), (0,jsx_runtime.jsx)(Box/* default */.Z, Object.assign({ ml: 10, colors: ['purple50'] }, { children: selectedOptionLabel }))] })) : null] })) }))), [buttonProps, label, ref, selectedOptionLabel]);
    if (!selectedOptionLabel || !onClearClick) {
        return ((0,jsx_runtime.jsx)(TriggerButtonStyled, Object.assign({ iconAfter: IconChevronDown/* default */.Z, ref: ref }, buttonProps, { children: (0,jsx_runtime.jsxs)(Box/* default */.Z, Object.assign({ display: "flex" }, { children: [(0,jsx_runtime.jsx)(Box/* default */.Z, { children: label }), selectedOptionLabel ? ((0,jsx_runtime.jsxs)(jsx_runtime.Fragment, { children: [(0,jsx_runtime.jsx)(Box/* default */.Z, { ml: 10 }), (0,jsx_runtime.jsx)(Divider/* default */.Z, { orientation: "vertical" }), (0,jsx_runtime.jsx)(Box/* default */.Z, Object.assign({ ml: 10, colors: ['purple50'] }, { children: selectedOptionLabel }))] })) : null] })) })));
    }
    if (!showResetButton) {
        return triggerButton;
    }
    return ((0,jsx_runtime.jsxs)(Button/* Button.Group */.z.Group, { children: [triggerButton, (0,jsx_runtime.jsx)(TriggerButtonStyled, { icon: IconX/* default */.Z, onClick: onClearClick })] }));
});

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/FilterMenu/FilterMenu.js




const defaultSearchFilterFn = (searchTerm, options) => {
    return options.filter((option) => option.label.toLocaleLowerCase().startsWith(searchTerm));
};
/**
 * FilterMenu component allows user to implement filtering UI that works with single or multiple selections.
 *
 * @see
 * {@link https://design-system.solventek.com/component/filter-menu}
 *
 * @example
 * <FilterMenu
 *   label="Foo"
 *   onSelect={setSelected}
 *   options={[{ label: 'Bar', value: 'bar', itemType: 'checkbox' }]}
 *   showResetButton
 *   showSearchInput
 * />
 */
const FilterMenu = ({ label, selectedValues = [], options = [], onSelect, loading, showResetButton, showSearchInput, noResultsFoundText = 'No results found', searchInputProps, onSearchFilterFn = defaultSearchFilterFn, leaveMenuOpenOnItemSelect = true, selectValueLabel }) => {
    const [searchTerm, setSearchTerm] = (0,react.useState)('');
    const handleSearchChange = (0,react.useCallback)((e) => {
        const { value } = e.target;
        setSearchTerm(value);
    }, []);
    const searchInputRef = (0,react.useRef)(null);
    const getNextState = (0,react.useCallback)((option) => {
        var _a, _b;
        const found = selectedValues.find((value) => value === option.value);
        if (!found) {
            if (option.itemType === 'radio') {
                onSelect === null || onSelect === void 0 ? void 0 : onSelect([option.value]);
            }
            if (option.itemType === 'checkbox') {
                onSelect === null || onSelect === void 0 ? void 0 : onSelect([...selectedValues, option.value]);
            }
            (_a = searchInputRef.current) === null || _a === void 0 ? void 0 : _a.focus();
            return undefined;
        }
        onSelect === null || onSelect === void 0 ? void 0 : onSelect(selectedValues.filter((value) => value !== option.value));
        (_b = searchInputRef.current) === null || _b === void 0 ? void 0 : _b.focus();
        return undefined;
    }, [onSelect, selectedValues, searchInputRef]);
    const selectedOptionLabel = (0,react.useMemo)(() => {
        if (selectValueLabel)
            return selectValueLabel;
        return options === null || options === void 0 ? void 0 : options.flatMap((option) => {
            const checked = selectedValues.includes(option.value);
            if (!checked)
                return [];
            return [option.label];
        }).join(', ');
    }, [options, selectedValues, selectValueLabel]);
    const handleClear = (0,react.useCallback)(() => {
        onSelect === null || onSelect === void 0 ? void 0 : onSelect([]);
    }, [onSelect]);
    const [isMenuOpen, setMenuState] = (0,react.useState)(false);
    const handleMenuVisibility = (0,react.useCallback)((state) => {
        setMenuState(state);
        if (!state)
            setSearchTerm('');
    }, []);
    const filteredOptions = (0,react.useMemo)(() => {
        return onSearchFilterFn(searchTerm.trim(), options);
    }, [searchTerm, options]);
    return ((0,jsx_runtime.jsxs)(Menu_Menu/* Menu */.v, Object.assign({ visible: isMenuOpen, setVisible: handleMenuVisibility, trigger: (0,jsx_runtime.jsx)(FilterTriggerButton, { label: label, selectedOptionLabel: selectedOptionLabel, loading: loading, onClearClick: onSelect ? handleClear : undefined, showResetButton: showResetButton }), onVirtualChange: (index) => {
            getNextState(filteredOptions[index - 1]);
        }, leaveMenuOpenOnItemSelect: leaveMenuOpenOnItemSelect, initialFocus: 1, minWidth: 240 }, { children: [showSearchInput ? ((0,jsx_runtime.jsx)(Menu_Menu/* Menu.Input */.v.Input, Object.assign({ placeholder: "Search", value: searchTerm, onChange: handleSearchChange }, searchInputProps))) : null, filteredOptions.map((option) => {
                const checked = selectedValues.includes(option.value);
                if (option.itemType === 'checkbox') {
                    return ((0,jsx_runtime.jsx)(Menu_Menu/* Menu.Checkbox */.v.Checkbox, Object.assign({ checked: checked, onClick: () => getNextState(option) }, { children: option.label }), option.value));
                }
                return ((0,jsx_runtime.jsx)(Menu_Menu/* Menu.Radio */.v.Radio, Object.assign({ checked: checked, onClick: () => getNextState(option) }, { children: option.label }), option.value));
            }), !(filteredOptions === null || filteredOptions === void 0 ? void 0 : filteredOptions.length) ? (0,jsx_runtime.jsx)(Menu_Menu/* Menu.Item */.v.Item, Object.assign({ disabled: true }, { children: noResultsFoundText })) : null] })));
};

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/FilterMenu/index.js


;// CONCATENATED MODULE: ./node_modules/date-fns/esm/locale/en-US/_lib/formatDistance/index.js
var formatDistanceLocale = {
  lessThanXSeconds: {
    one: 'less than a second',
    other: 'less than {{count}} seconds'
  },
  xSeconds: {
    one: '1 second',
    other: '{{count}} seconds'
  },
  halfAMinute: 'half a minute',
  lessThanXMinutes: {
    one: 'less than a minute',
    other: 'less than {{count}} minutes'
  },
  xMinutes: {
    one: '1 minute',
    other: '{{count}} minutes'
  },
  aboutXHours: {
    one: 'about 1 hour',
    other: 'about {{count}} hours'
  },
  xHours: {
    one: '1 hour',
    other: '{{count}} hours'
  },
  xDays: {
    one: '1 day',
    other: '{{count}} days'
  },
  aboutXWeeks: {
    one: 'about 1 week',
    other: 'about {{count}} weeks'
  },
  xWeeks: {
    one: '1 week',
    other: '{{count}} weeks'
  },
  aboutXMonths: {
    one: 'about 1 month',
    other: 'about {{count}} months'
  },
  xMonths: {
    one: '1 month',
    other: '{{count}} months'
  },
  aboutXYears: {
    one: 'about 1 year',
    other: 'about {{count}} years'
  },
  xYears: {
    one: '1 year',
    other: '{{count}} years'
  },
  overXYears: {
    one: 'over 1 year',
    other: 'over {{count}} years'
  },
  almostXYears: {
    one: 'almost 1 year',
    other: 'almost {{count}} years'
  }
};

var formatDistance = function formatDistance(token, count, options) {
  var result;
  var tokenValue = formatDistanceLocale[token];

  if (typeof tokenValue === 'string') {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace('{{count}}', count.toString());
  }

  if (options !== null && options !== void 0 && options.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return 'in ' + result;
    } else {
      return result + ' ago';
    }
  }

  return result;
};

/* harmony default export */ const _lib_formatDistance = (formatDistance);
;// CONCATENATED MODULE: ./node_modules/date-fns/esm/locale/_lib/buildFormatLongFn/index.js
function buildFormatLongFn(args) {
  return function () {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    // TODO: Remove String()
    var width = options.width ? String(options.width) : args.defaultWidth;
    var format = args.formats[width] || args.formats[args.defaultWidth];
    return format;
  };
}
;// CONCATENATED MODULE: ./node_modules/date-fns/esm/locale/en-US/_lib/formatLong/index.js

var dateFormats = {
  full: 'EEEE, MMMM do, y',
  long: 'MMMM do, y',
  medium: 'MMM d, y',
  short: 'MM/dd/yyyy'
};
var timeFormats = {
  full: 'h:mm:ss a zzzz',
  long: 'h:mm:ss a z',
  medium: 'h:mm:ss a',
  short: 'h:mm a'
};
var dateTimeFormats = {
  full: "{{date}} 'at' {{time}}",
  long: "{{date}} 'at' {{time}}",
  medium: '{{date}}, {{time}}',
  short: '{{date}}, {{time}}'
};
var formatLong = {
  date: buildFormatLongFn({
    formats: dateFormats,
    defaultWidth: 'full'
  }),
  time: buildFormatLongFn({
    formats: timeFormats,
    defaultWidth: 'full'
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats,
    defaultWidth: 'full'
  })
};
/* harmony default export */ const _lib_formatLong = (formatLong);
;// CONCATENATED MODULE: ./node_modules/date-fns/esm/locale/en-US/_lib/formatRelative/index.js
var formatRelativeLocale = {
  lastWeek: "'last' eeee 'at' p",
  yesterday: "'yesterday at' p",
  today: "'today at' p",
  tomorrow: "'tomorrow at' p",
  nextWeek: "eeee 'at' p",
  other: 'P'
};

var formatRelative = function formatRelative(token, _date, _baseDate, _options) {
  return formatRelativeLocale[token];
};

/* harmony default export */ const _lib_formatRelative = (formatRelative);
;// CONCATENATED MODULE: ./node_modules/date-fns/esm/locale/_lib/buildLocalizeFn/index.js
function buildLocalizeFn(args) {
  return function (dirtyIndex, options) {
    var context = options !== null && options !== void 0 && options.context ? String(options.context) : 'standalone';
    var valuesArray;

    if (context === 'formatting' && args.formattingValues) {
      var defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
      var width = options !== null && options !== void 0 && options.width ? String(options.width) : defaultWidth;
      valuesArray = args.formattingValues[width] || args.formattingValues[defaultWidth];
    } else {
      var _defaultWidth = args.defaultWidth;

      var _width = options !== null && options !== void 0 && options.width ? String(options.width) : args.defaultWidth;

      valuesArray = args.values[_width] || args.values[_defaultWidth];
    }

    var index = args.argumentCallback ? args.argumentCallback(dirtyIndex) : dirtyIndex; // @ts-ignore: For some reason TypeScript just don't want to match it, no matter how hard we try. I challenge you to try to remove it!

    return valuesArray[index];
  };
}
;// CONCATENATED MODULE: ./node_modules/date-fns/esm/locale/en-US/_lib/localize/index.js

var eraValues = {
  narrow: ['B', 'A'],
  abbreviated: ['BC', 'AD'],
  wide: ['Before Christ', 'Anno Domini']
};
var quarterValues = {
  narrow: ['1', '2', '3', '4'],
  abbreviated: ['Q1', 'Q2', 'Q3', 'Q4'],
  wide: ['1st quarter', '2nd quarter', '3rd quarter', '4th quarter']
}; // Note: in English, the names of days of the week and months are capitalized.
// If you are making a new locale based on this one, check if the same is true for the language you're working on.
// Generally, formatted dates should look like they are in the middle of a sentence,
// e.g. in Spanish language the weekdays and months should be in the lowercase.

var monthValues = {
  narrow: ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O', 'N', 'D'],
  abbreviated: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
  wide: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December']
};
var dayValues = {
  narrow: ['S', 'M', 'T', 'W', 'T', 'F', 'S'],
  short: ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'],
  abbreviated: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
  wide: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday']
};
var dayPeriodValues = {
  narrow: {
    am: 'a',
    pm: 'p',
    midnight: 'mi',
    noon: 'n',
    morning: 'morning',
    afternoon: 'afternoon',
    evening: 'evening',
    night: 'night'
  },
  abbreviated: {
    am: 'AM',
    pm: 'PM',
    midnight: 'midnight',
    noon: 'noon',
    morning: 'morning',
    afternoon: 'afternoon',
    evening: 'evening',
    night: 'night'
  },
  wide: {
    am: 'a.m.',
    pm: 'p.m.',
    midnight: 'midnight',
    noon: 'noon',
    morning: 'morning',
    afternoon: 'afternoon',
    evening: 'evening',
    night: 'night'
  }
};
var formattingDayPeriodValues = {
  narrow: {
    am: 'a',
    pm: 'p',
    midnight: 'mi',
    noon: 'n',
    morning: 'in the morning',
    afternoon: 'in the afternoon',
    evening: 'in the evening',
    night: 'at night'
  },
  abbreviated: {
    am: 'AM',
    pm: 'PM',
    midnight: 'midnight',
    noon: 'noon',
    morning: 'in the morning',
    afternoon: 'in the afternoon',
    evening: 'in the evening',
    night: 'at night'
  },
  wide: {
    am: 'a.m.',
    pm: 'p.m.',
    midnight: 'midnight',
    noon: 'noon',
    morning: 'in the morning',
    afternoon: 'in the afternoon',
    evening: 'in the evening',
    night: 'at night'
  }
};

var ordinalNumber = function ordinalNumber(dirtyNumber, _options) {
  var number = Number(dirtyNumber); // If ordinal numbers depend on context, for example,
  // if they are different for different grammatical genders,
  // use `options.unit`.
  //
  // `unit` can be 'year', 'quarter', 'month', 'week', 'date', 'dayOfYear',
  // 'day', 'hour', 'minute', 'second'.

  var rem100 = number % 100;

  if (rem100 > 20 || rem100 < 10) {
    switch (rem100 % 10) {
      case 1:
        return number + 'st';

      case 2:
        return number + 'nd';

      case 3:
        return number + 'rd';
    }
  }

  return number + 'th';
};

var localize = {
  ordinalNumber: ordinalNumber,
  era: buildLocalizeFn({
    values: eraValues,
    defaultWidth: 'wide'
  }),
  quarter: buildLocalizeFn({
    values: quarterValues,
    defaultWidth: 'wide',
    argumentCallback: function argumentCallback(quarter) {
      return quarter - 1;
    }
  }),
  month: buildLocalizeFn({
    values: monthValues,
    defaultWidth: 'wide'
  }),
  day: buildLocalizeFn({
    values: dayValues,
    defaultWidth: 'wide'
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues,
    defaultWidth: 'wide',
    formattingValues: formattingDayPeriodValues,
    defaultFormattingWidth: 'wide'
  })
};
/* harmony default export */ const _lib_localize = (localize);
;// CONCATENATED MODULE: ./node_modules/date-fns/esm/locale/_lib/buildMatchFn/index.js
function buildMatchFn(args) {
  return function (string) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var width = options.width;
    var matchPattern = width && args.matchPatterns[width] || args.matchPatterns[args.defaultMatchWidth];
    var matchResult = string.match(matchPattern);

    if (!matchResult) {
      return null;
    }

    var matchedString = matchResult[0];
    var parsePatterns = width && args.parsePatterns[width] || args.parsePatterns[args.defaultParseWidth];
    var key = Array.isArray(parsePatterns) ? findIndex(parsePatterns, function (pattern) {
      return pattern.test(matchedString);
    }) : findKey(parsePatterns, function (pattern) {
      return pattern.test(matchedString);
    });
    var value;
    value = args.valueCallback ? args.valueCallback(key) : key;
    value = options.valueCallback ? options.valueCallback(value) : value;
    var rest = string.slice(matchedString.length);
    return {
      value: value,
      rest: rest
    };
  };
}

function findKey(object, predicate) {
  for (var key in object) {
    if (object.hasOwnProperty(key) && predicate(object[key])) {
      return key;
    }
  }

  return undefined;
}

function findIndex(array, predicate) {
  for (var key = 0; key < array.length; key++) {
    if (predicate(array[key])) {
      return key;
    }
  }

  return undefined;
}
;// CONCATENATED MODULE: ./node_modules/date-fns/esm/locale/_lib/buildMatchPatternFn/index.js
function buildMatchPatternFn(args) {
  return function (string) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var matchResult = string.match(args.matchPattern);
    if (!matchResult) return null;
    var matchedString = matchResult[0];
    var parseResult = string.match(args.parsePattern);
    if (!parseResult) return null;
    var value = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
    value = options.valueCallback ? options.valueCallback(value) : value;
    var rest = string.slice(matchedString.length);
    return {
      value: value,
      rest: rest
    };
  };
}
;// CONCATENATED MODULE: ./node_modules/date-fns/esm/locale/en-US/_lib/match/index.js


var matchOrdinalNumberPattern = /^(\d+)(th|st|nd|rd)?/i;
var parseOrdinalNumberPattern = /\d+/i;
var matchEraPatterns = {
  narrow: /^(b|a)/i,
  abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
  wide: /^(before christ|before common era|anno domini|common era)/i
};
var parseEraPatterns = {
  any: [/^b/i, /^(a|c)/i]
};
var matchQuarterPatterns = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](th|st|nd|rd)? quarter/i
};
var parseQuarterPatterns = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
  wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
};
var parseMonthPatterns = {
  narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
  any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
};
var matchDayPatterns = {
  narrow: /^[smtwf]/i,
  short: /^(su|mo|tu|we|th|fr|sa)/i,
  abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
  wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
};
var parseDayPatterns = {
  narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
  any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
};
var matchDayPeriodPatterns = {
  narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
  any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
};
var parseDayPeriodPatterns = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mi/i,
    noon: /^no/i,
    morning: /morning/i,
    afternoon: /afternoon/i,
    evening: /evening/i,
    night: /night/i
  }
};
var match = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern,
    parsePattern: parseOrdinalNumberPattern,
    valueCallback: function valueCallback(value) {
      return parseInt(value, 10);
    }
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns,
    defaultMatchWidth: 'wide',
    parsePatterns: parseEraPatterns,
    defaultParseWidth: 'any'
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns,
    defaultMatchWidth: 'wide',
    parsePatterns: parseQuarterPatterns,
    defaultParseWidth: 'any',
    valueCallback: function valueCallback(index) {
      return index + 1;
    }
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns,
    defaultMatchWidth: 'wide',
    parsePatterns: parseMonthPatterns,
    defaultParseWidth: 'any'
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns,
    defaultMatchWidth: 'wide',
    parsePatterns: parseDayPatterns,
    defaultParseWidth: 'any'
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns,
    defaultMatchWidth: 'any',
    parsePatterns: parseDayPeriodPatterns,
    defaultParseWidth: 'any'
  })
};
/* harmony default export */ const _lib_match = (match);
;// CONCATENATED MODULE: ./node_modules/date-fns/esm/locale/en-US/index.js






/**
 * @type {Locale}
 * @category Locales
 * @summary English locale (United States).
 * @language English
 * @iso-639-2 eng
 * @author Sasha Koss [@kossnocorp]{@link https://github.com/kossnocorp}
 * @author Lesha Koss [@leshakoss]{@link https://github.com/leshakoss}
 */
var en_US_locale = {
  code: 'en-US',
  formatDistance: _lib_formatDistance,
  formatLong: _lib_formatLong,
  formatRelative: _lib_formatRelative,
  localize: _lib_localize,
  match: _lib_match,
  options: {
    weekStartsOn: 0
    /* Sunday */
    ,
    firstWeekContainsDate: 1
  }
};
/* harmony default export */ const en_US = (en_US_locale);
;// CONCATENATED MODULE: ./node_modules/date-fns/esm/_lib/requiredArgs/index.js
function requiredArgs(required, args) {
  if (args.length < required) {
    throw new TypeError(required + ' argument' + (required > 1 ? 's' : '') + ' required, but only ' + args.length + ' present');
  }
}
;// CONCATENATED MODULE: ./node_modules/date-fns/esm/isDate/index.js
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }


/**
 * @name isDate
 * @category Common Helpers
 * @summary Is the given value a date?
 *
 * @description
 * Returns true if the given value is an instance of Date. The function works for dates transferred across iframes.
 *
 * @param {*} value - the value to check
 * @returns {boolean} true if the given value is a date
 * @throws {TypeError} 1 arguments required
 *
 * @example
 * // For a valid date:
 * const result = isDate(new Date())
 * //=> true
 *
 * @example
 * // For an invalid date:
 * const result = isDate(new Date(NaN))
 * //=> true
 *
 * @example
 * // For some value:
 * const result = isDate('2014-02-31')
 * //=> false
 *
 * @example
 * // For an object:
 * const result = isDate({})
 * //=> false
 */

function isDate(value) {
  requiredArgs(1, arguments);
  return value instanceof Date || _typeof(value) === 'object' && Object.prototype.toString.call(value) === '[object Date]';
}
;// CONCATENATED MODULE: ./node_modules/date-fns/esm/toDate/index.js
function toDate_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { toDate_typeof = function _typeof(obj) { return typeof obj; }; } else { toDate_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return toDate_typeof(obj); }


/**
 * @name toDate
 * @category Common Helpers
 * @summary Convert the given argument to an instance of Date.
 *
 * @description
 * Convert the given argument to an instance of Date.
 *
 * If the argument is an instance of Date, the function returns its clone.
 *
 * If the argument is a number, it is treated as a timestamp.
 *
 * If the argument is none of the above, the function returns Invalid Date.
 *
 * **Note**: *all* Date arguments passed to any *date-fns* function is processed by `toDate`.
 *
 * @param {Date|Number} argument - the value to convert
 * @returns {Date} the parsed date in the local time zone
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // Clone the date:
 * const result = toDate(new Date(2014, 1, 11, 11, 30, 30))
 * //=> Tue Feb 11 2014 11:30:30
 *
 * @example
 * // Convert the timestamp to date:
 * const result = toDate(1392098430000)
 * //=> Tue Feb 11 2014 11:30:30
 */

function toDate(argument) {
  requiredArgs(1, arguments);
  var argStr = Object.prototype.toString.call(argument); // Clone the date

  if (argument instanceof Date || toDate_typeof(argument) === 'object' && argStr === '[object Date]') {
    // Prevent the date to lose the milliseconds when passed to new Date() in IE10
    return new Date(argument.getTime());
  } else if (typeof argument === 'number' || argStr === '[object Number]') {
    return new Date(argument);
  } else {
    if ((typeof argument === 'string' || argStr === '[object String]') && typeof console !== 'undefined') {
      // eslint-disable-next-line no-console
      console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as date arguments. Please use `parseISO` to parse strings. See: https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#string-arguments"); // eslint-disable-next-line no-console

      console.warn(new Error().stack);
    }

    return new Date(NaN);
  }
}
;// CONCATENATED MODULE: ./node_modules/date-fns/esm/isValid/index.js



/**
 * @name isValid
 * @category Common Helpers
 * @summary Is the given date valid?
 *
 * @description
 * Returns false if argument is Invalid Date and true otherwise.
 * Argument is converted to Date using `toDate`. See [toDate]{@link https://date-fns.org/docs/toDate}
 * Invalid Date is a Date, whose time value is NaN.
 *
 * Time value of Date: http://es5.github.io/#x15.9.1.1
 *
 * @param {*} date - the date to check
 * @returns {Boolean} the date is valid
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // For the valid date:
 * const result = isValid(new Date(2014, 1, 31))
 * //=> true
 *
 * @example
 * // For the value, convertable into a date:
 * const result = isValid(1393804800000)
 * //=> true
 *
 * @example
 * // For the invalid date:
 * const result = isValid(new Date(''))
 * //=> false
 */

function isValid(dirtyDate) {
  requiredArgs(1, arguments);

  if (!isDate(dirtyDate) && typeof dirtyDate !== 'number') {
    return false;
  }

  var date = toDate(dirtyDate);
  return !isNaN(Number(date));
}
;// CONCATENATED MODULE: ./node_modules/date-fns/esm/_lib/toInteger/index.js
function toInteger(dirtyNumber) {
  if (dirtyNumber === null || dirtyNumber === true || dirtyNumber === false) {
    return NaN;
  }

  var number = Number(dirtyNumber);

  if (isNaN(number)) {
    return number;
  }

  return number < 0 ? Math.ceil(number) : Math.floor(number);
}
;// CONCATENATED MODULE: ./node_modules/date-fns/esm/addMilliseconds/index.js



/**
 * @name addMilliseconds
 * @category Millisecond Helpers
 * @summary Add the specified number of milliseconds to the given date.
 *
 * @description
 * Add the specified number of milliseconds to the given date.
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} amount - the amount of milliseconds to be added. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
 * @returns {Date} the new date with the milliseconds added
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Add 750 milliseconds to 10 July 2014 12:45:30.000:
 * const result = addMilliseconds(new Date(2014, 6, 10, 12, 45, 30, 0), 750)
 * //=> Thu Jul 10 2014 12:45:30.750
 */

function addMilliseconds(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var timestamp = toDate(dirtyDate).getTime();
  var amount = toInteger(dirtyAmount);
  return new Date(timestamp + amount);
}
;// CONCATENATED MODULE: ./node_modules/date-fns/esm/subMilliseconds/index.js



/**
 * @name subMilliseconds
 * @category Millisecond Helpers
 * @summary Subtract the specified number of milliseconds from the given date.
 *
 * @description
 * Subtract the specified number of milliseconds from the given date.
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} amount - the amount of milliseconds to be subtracted. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
 * @returns {Date} the new date with the milliseconds subtracted
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Subtract 750 milliseconds from 10 July 2014 12:45:30.000:
 * const result = subMilliseconds(new Date(2014, 6, 10, 12, 45, 30, 0), 750)
 * //=> Thu Jul 10 2014 12:45:29.250
 */

function subMilliseconds(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addMilliseconds(dirtyDate, -amount);
}
;// CONCATENATED MODULE: ./node_modules/date-fns/esm/_lib/getUTCDayOfYear/index.js


var MILLISECONDS_IN_DAY = 86400000;
function getUTCDayOfYear(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var timestamp = date.getTime();
  date.setUTCMonth(0, 1);
  date.setUTCHours(0, 0, 0, 0);
  var startOfYearTimestamp = date.getTime();
  var difference = timestamp - startOfYearTimestamp;
  return Math.floor(difference / MILLISECONDS_IN_DAY) + 1;
}
;// CONCATENATED MODULE: ./node_modules/date-fns/esm/_lib/startOfUTCISOWeek/index.js


function startOfUTCISOWeek(dirtyDate) {
  requiredArgs(1, arguments);
  var weekStartsOn = 1;
  var date = toDate(dirtyDate);
  var day = date.getUTCDay();
  var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  date.setUTCDate(date.getUTCDate() - diff);
  date.setUTCHours(0, 0, 0, 0);
  return date;
}
;// CONCATENATED MODULE: ./node_modules/date-fns/esm/_lib/getUTCISOWeekYear/index.js



function getUTCISOWeekYear(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var year = date.getUTCFullYear();
  var fourthOfJanuaryOfNextYear = new Date(0);
  fourthOfJanuaryOfNextYear.setUTCFullYear(year + 1, 0, 4);
  fourthOfJanuaryOfNextYear.setUTCHours(0, 0, 0, 0);
  var startOfNextYear = startOfUTCISOWeek(fourthOfJanuaryOfNextYear);
  var fourthOfJanuaryOfThisYear = new Date(0);
  fourthOfJanuaryOfThisYear.setUTCFullYear(year, 0, 4);
  fourthOfJanuaryOfThisYear.setUTCHours(0, 0, 0, 0);
  var startOfThisYear = startOfUTCISOWeek(fourthOfJanuaryOfThisYear);

  if (date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}
;// CONCATENATED MODULE: ./node_modules/date-fns/esm/_lib/startOfUTCISOWeekYear/index.js



function startOfUTCISOWeekYear(dirtyDate) {
  requiredArgs(1, arguments);
  var year = getUTCISOWeekYear(dirtyDate);
  var fourthOfJanuary = new Date(0);
  fourthOfJanuary.setUTCFullYear(year, 0, 4);
  fourthOfJanuary.setUTCHours(0, 0, 0, 0);
  var date = startOfUTCISOWeek(fourthOfJanuary);
  return date;
}
;// CONCATENATED MODULE: ./node_modules/date-fns/esm/_lib/getUTCISOWeek/index.js




var MILLISECONDS_IN_WEEK = 604800000;
function getUTCISOWeek(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var diff = startOfUTCISOWeek(date).getTime() - startOfUTCISOWeekYear(date).getTime(); // Round the number of days to the nearest integer
  // because the number of milliseconds in a week is not constant
  // (e.g. it's different in the week of the daylight saving time clock shift)

  return Math.round(diff / MILLISECONDS_IN_WEEK) + 1;
}
;// CONCATENATED MODULE: ./node_modules/date-fns/esm/_lib/defaultOptions/index.js
var defaultOptions = {};
function getDefaultOptions() {
  return defaultOptions;
}
function setDefaultOptions(newOptions) {
  defaultOptions = newOptions;
}
;// CONCATENATED MODULE: ./node_modules/date-fns/esm/_lib/startOfUTCWeek/index.js




function startOfUTCWeek(dirtyDate, options) {
  var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;

  requiredArgs(1, arguments);
  var defaultOptions = getDefaultOptions();
  var weekStartsOn = toInteger((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref !== void 0 ? _ref : 0); // Test if weekStartsOn is between 0 and 6 _and_ is not NaN

  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
  }

  var date = toDate(dirtyDate);
  var day = date.getUTCDay();
  var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  date.setUTCDate(date.getUTCDate() - diff);
  date.setUTCHours(0, 0, 0, 0);
  return date;
}
;// CONCATENATED MODULE: ./node_modules/date-fns/esm/_lib/getUTCWeekYear/index.js





function getUTCWeekYear(dirtyDate, options) {
  var _ref, _ref2, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;

  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var year = date.getUTCFullYear();
  var defaultOptions = getDefaultOptions();
  var firstWeekContainsDate = toInteger((_ref = (_ref2 = (_ref3 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref !== void 0 ? _ref : 1); // Test if weekStartsOn is between 1 and 7 _and_ is not NaN

  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError('firstWeekContainsDate must be between 1 and 7 inclusively');
  }

  var firstWeekOfNextYear = new Date(0);
  firstWeekOfNextYear.setUTCFullYear(year + 1, 0, firstWeekContainsDate);
  firstWeekOfNextYear.setUTCHours(0, 0, 0, 0);
  var startOfNextYear = startOfUTCWeek(firstWeekOfNextYear, options);
  var firstWeekOfThisYear = new Date(0);
  firstWeekOfThisYear.setUTCFullYear(year, 0, firstWeekContainsDate);
  firstWeekOfThisYear.setUTCHours(0, 0, 0, 0);
  var startOfThisYear = startOfUTCWeek(firstWeekOfThisYear, options);

  if (date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}
;// CONCATENATED MODULE: ./node_modules/date-fns/esm/_lib/startOfUTCWeekYear/index.js





function startOfUTCWeekYear(dirtyDate, options) {
  var _ref, _ref2, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;

  requiredArgs(1, arguments);
  var defaultOptions = getDefaultOptions();
  var firstWeekContainsDate = toInteger((_ref = (_ref2 = (_ref3 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref !== void 0 ? _ref : 1);
  var year = getUTCWeekYear(dirtyDate, options);
  var firstWeek = new Date(0);
  firstWeek.setUTCFullYear(year, 0, firstWeekContainsDate);
  firstWeek.setUTCHours(0, 0, 0, 0);
  var date = startOfUTCWeek(firstWeek, options);
  return date;
}
;// CONCATENATED MODULE: ./node_modules/date-fns/esm/_lib/getUTCWeek/index.js




var getUTCWeek_MILLISECONDS_IN_WEEK = 604800000;
function getUTCWeek(dirtyDate, options) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var diff = startOfUTCWeek(date, options).getTime() - startOfUTCWeekYear(date, options).getTime(); // Round the number of days to the nearest integer
  // because the number of milliseconds in a week is not constant
  // (e.g. it's different in the week of the daylight saving time clock shift)

  return Math.round(diff / getUTCWeek_MILLISECONDS_IN_WEEK) + 1;
}
;// CONCATENATED MODULE: ./node_modules/date-fns/esm/_lib/addLeadingZeros/index.js
function addLeadingZeros(number, targetLength) {
  var sign = number < 0 ? '-' : '';
  var output = Math.abs(number).toString();

  while (output.length < targetLength) {
    output = '0' + output;
  }

  return sign + output;
}
;// CONCATENATED MODULE: ./node_modules/date-fns/esm/_lib/format/lightFormatters/index.js

/*
 * |     | Unit                           |     | Unit                           |
 * |-----|--------------------------------|-----|--------------------------------|
 * |  a  | AM, PM                         |  A* |                                |
 * |  d  | Day of month                   |  D  |                                |
 * |  h  | Hour [1-12]                    |  H  | Hour [0-23]                    |
 * |  m  | Minute                         |  M  | Month                          |
 * |  s  | Second                         |  S  | Fraction of second             |
 * |  y  | Year (abs)                     |  Y  |                                |
 *
 * Letters marked by * are not implemented but reserved by Unicode standard.
 */

var formatters = {
  // Year
  y: function y(date, token) {
    // From http://www.unicode.org/reports/tr35/tr35-31/tr35-dates.html#Date_Format_tokens
    // | Year     |     y | yy |   yyy |  yyyy | yyyyy |
    // |----------|-------|----|-------|-------|-------|
    // | AD 1     |     1 | 01 |   001 |  0001 | 00001 |
    // | AD 12    |    12 | 12 |   012 |  0012 | 00012 |
    // | AD 123   |   123 | 23 |   123 |  0123 | 00123 |
    // | AD 1234  |  1234 | 34 |  1234 |  1234 | 01234 |
    // | AD 12345 | 12345 | 45 | 12345 | 12345 | 12345 |
    var signedYear = date.getUTCFullYear(); // Returns 1 for 1 BC (which is year 0 in JavaScript)

    var year = signedYear > 0 ? signedYear : 1 - signedYear;
    return addLeadingZeros(token === 'yy' ? year % 100 : year, token.length);
  },
  // Month
  M: function M(date, token) {
    var month = date.getUTCMonth();
    return token === 'M' ? String(month + 1) : addLeadingZeros(month + 1, 2);
  },
  // Day of the month
  d: function d(date, token) {
    return addLeadingZeros(date.getUTCDate(), token.length);
  },
  // AM or PM
  a: function a(date, token) {
    var dayPeriodEnumValue = date.getUTCHours() / 12 >= 1 ? 'pm' : 'am';

    switch (token) {
      case 'a':
      case 'aa':
        return dayPeriodEnumValue.toUpperCase();

      case 'aaa':
        return dayPeriodEnumValue;

      case 'aaaaa':
        return dayPeriodEnumValue[0];

      case 'aaaa':
      default:
        return dayPeriodEnumValue === 'am' ? 'a.m.' : 'p.m.';
    }
  },
  // Hour [1-12]
  h: function h(date, token) {
    return addLeadingZeros(date.getUTCHours() % 12 || 12, token.length);
  },
  // Hour [0-23]
  H: function H(date, token) {
    return addLeadingZeros(date.getUTCHours(), token.length);
  },
  // Minute
  m: function m(date, token) {
    return addLeadingZeros(date.getUTCMinutes(), token.length);
  },
  // Second
  s: function s(date, token) {
    return addLeadingZeros(date.getUTCSeconds(), token.length);
  },
  // Fraction of second
  S: function S(date, token) {
    var numberOfDigits = token.length;
    var milliseconds = date.getUTCMilliseconds();
    var fractionalSeconds = Math.floor(milliseconds * Math.pow(10, numberOfDigits - 3));
    return addLeadingZeros(fractionalSeconds, token.length);
  }
};
/* harmony default export */ const lightFormatters = (formatters);
;// CONCATENATED MODULE: ./node_modules/date-fns/esm/_lib/format/formatters/index.js







var dayPeriodEnum = {
  am: 'am',
  pm: 'pm',
  midnight: 'midnight',
  noon: 'noon',
  morning: 'morning',
  afternoon: 'afternoon',
  evening: 'evening',
  night: 'night'
};

/*
 * |     | Unit                           |     | Unit                           |
 * |-----|--------------------------------|-----|--------------------------------|
 * |  a  | AM, PM                         |  A* | Milliseconds in day            |
 * |  b  | AM, PM, noon, midnight         |  B  | Flexible day period            |
 * |  c  | Stand-alone local day of week  |  C* | Localized hour w/ day period   |
 * |  d  | Day of month                   |  D  | Day of year                    |
 * |  e  | Local day of week              |  E  | Day of week                    |
 * |  f  |                                |  F* | Day of week in month           |
 * |  g* | Modified Julian day            |  G  | Era                            |
 * |  h  | Hour [1-12]                    |  H  | Hour [0-23]                    |
 * |  i! | ISO day of week                |  I! | ISO week of year               |
 * |  j* | Localized hour w/ day period   |  J* | Localized hour w/o day period  |
 * |  k  | Hour [1-24]                    |  K  | Hour [0-11]                    |
 * |  l* | (deprecated)                   |  L  | Stand-alone month              |
 * |  m  | Minute                         |  M  | Month                          |
 * |  n  |                                |  N  |                                |
 * |  o! | Ordinal number modifier        |  O  | Timezone (GMT)                 |
 * |  p! | Long localized time            |  P! | Long localized date            |
 * |  q  | Stand-alone quarter            |  Q  | Quarter                        |
 * |  r* | Related Gregorian year         |  R! | ISO week-numbering year        |
 * |  s  | Second                         |  S  | Fraction of second             |
 * |  t! | Seconds timestamp              |  T! | Milliseconds timestamp         |
 * |  u  | Extended year                  |  U* | Cyclic year                    |
 * |  v* | Timezone (generic non-locat.)  |  V* | Timezone (location)            |
 * |  w  | Local week of year             |  W* | Week of month                  |
 * |  x  | Timezone (ISO-8601 w/o Z)      |  X  | Timezone (ISO-8601)            |
 * |  y  | Year (abs)                     |  Y  | Local week-numbering year      |
 * |  z  | Timezone (specific non-locat.) |  Z* | Timezone (aliases)             |
 *
 * Letters marked by * are not implemented but reserved by Unicode standard.
 *
 * Letters marked by ! are non-standard, but implemented by date-fns:
 * - `o` modifies the previous token to turn it into an ordinal (see `format` docs)
 * - `i` is ISO day of week. For `i` and `ii` is returns numeric ISO week days,
 *   i.e. 7 for Sunday, 1 for Monday, etc.
 * - `I` is ISO week of year, as opposed to `w` which is local week of year.
 * - `R` is ISO week-numbering year, as opposed to `Y` which is local week-numbering year.
 *   `R` is supposed to be used in conjunction with `I` and `i`
 *   for universal ISO week-numbering date, whereas
 *   `Y` is supposed to be used in conjunction with `w` and `e`
 *   for week-numbering date specific to the locale.
 * - `P` is long localized date format
 * - `p` is long localized time format
 */
var formatters_formatters = {
  // Era
  G: function G(date, token, localize) {
    var era = date.getUTCFullYear() > 0 ? 1 : 0;

    switch (token) {
      // AD, BC
      case 'G':
      case 'GG':
      case 'GGG':
        return localize.era(era, {
          width: 'abbreviated'
        });
      // A, B

      case 'GGGGG':
        return localize.era(era, {
          width: 'narrow'
        });
      // Anno Domini, Before Christ

      case 'GGGG':
      default:
        return localize.era(era, {
          width: 'wide'
        });
    }
  },
  // Year
  y: function y(date, token, localize) {
    // Ordinal number
    if (token === 'yo') {
      var signedYear = date.getUTCFullYear(); // Returns 1 for 1 BC (which is year 0 in JavaScript)

      var year = signedYear > 0 ? signedYear : 1 - signedYear;
      return localize.ordinalNumber(year, {
        unit: 'year'
      });
    }

    return lightFormatters.y(date, token);
  },
  // Local week-numbering year
  Y: function Y(date, token, localize, options) {
    var signedWeekYear = getUTCWeekYear(date, options); // Returns 1 for 1 BC (which is year 0 in JavaScript)

    var weekYear = signedWeekYear > 0 ? signedWeekYear : 1 - signedWeekYear; // Two digit year

    if (token === 'YY') {
      var twoDigitYear = weekYear % 100;
      return addLeadingZeros(twoDigitYear, 2);
    } // Ordinal number


    if (token === 'Yo') {
      return localize.ordinalNumber(weekYear, {
        unit: 'year'
      });
    } // Padding


    return addLeadingZeros(weekYear, token.length);
  },
  // ISO week-numbering year
  R: function R(date, token) {
    var isoWeekYear = getUTCISOWeekYear(date); // Padding

    return addLeadingZeros(isoWeekYear, token.length);
  },
  // Extended year. This is a single number designating the year of this calendar system.
  // The main difference between `y` and `u` localizers are B.C. years:
  // | Year | `y` | `u` |
  // |------|-----|-----|
  // | AC 1 |   1 |   1 |
  // | BC 1 |   1 |   0 |
  // | BC 2 |   2 |  -1 |
  // Also `yy` always returns the last two digits of a year,
  // while `uu` pads single digit years to 2 characters and returns other years unchanged.
  u: function u(date, token) {
    var year = date.getUTCFullYear();
    return addLeadingZeros(year, token.length);
  },
  // Quarter
  Q: function Q(date, token, localize) {
    var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);

    switch (token) {
      // 1, 2, 3, 4
      case 'Q':
        return String(quarter);
      // 01, 02, 03, 04

      case 'QQ':
        return addLeadingZeros(quarter, 2);
      // 1st, 2nd, 3rd, 4th

      case 'Qo':
        return localize.ordinalNumber(quarter, {
          unit: 'quarter'
        });
      // Q1, Q2, Q3, Q4

      case 'QQQ':
        return localize.quarter(quarter, {
          width: 'abbreviated',
          context: 'formatting'
        });
      // 1, 2, 3, 4 (narrow quarter; could be not numerical)

      case 'QQQQQ':
        return localize.quarter(quarter, {
          width: 'narrow',
          context: 'formatting'
        });
      // 1st quarter, 2nd quarter, ...

      case 'QQQQ':
      default:
        return localize.quarter(quarter, {
          width: 'wide',
          context: 'formatting'
        });
    }
  },
  // Stand-alone quarter
  q: function q(date, token, localize) {
    var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);

    switch (token) {
      // 1, 2, 3, 4
      case 'q':
        return String(quarter);
      // 01, 02, 03, 04

      case 'qq':
        return addLeadingZeros(quarter, 2);
      // 1st, 2nd, 3rd, 4th

      case 'qo':
        return localize.ordinalNumber(quarter, {
          unit: 'quarter'
        });
      // Q1, Q2, Q3, Q4

      case 'qqq':
        return localize.quarter(quarter, {
          width: 'abbreviated',
          context: 'standalone'
        });
      // 1, 2, 3, 4 (narrow quarter; could be not numerical)

      case 'qqqqq':
        return localize.quarter(quarter, {
          width: 'narrow',
          context: 'standalone'
        });
      // 1st quarter, 2nd quarter, ...

      case 'qqqq':
      default:
        return localize.quarter(quarter, {
          width: 'wide',
          context: 'standalone'
        });
    }
  },
  // Month
  M: function M(date, token, localize) {
    var month = date.getUTCMonth();

    switch (token) {
      case 'M':
      case 'MM':
        return lightFormatters.M(date, token);
      // 1st, 2nd, ..., 12th

      case 'Mo':
        return localize.ordinalNumber(month + 1, {
          unit: 'month'
        });
      // Jan, Feb, ..., Dec

      case 'MMM':
        return localize.month(month, {
          width: 'abbreviated',
          context: 'formatting'
        });
      // J, F, ..., D

      case 'MMMMM':
        return localize.month(month, {
          width: 'narrow',
          context: 'formatting'
        });
      // January, February, ..., December

      case 'MMMM':
      default:
        return localize.month(month, {
          width: 'wide',
          context: 'formatting'
        });
    }
  },
  // Stand-alone month
  L: function L(date, token, localize) {
    var month = date.getUTCMonth();

    switch (token) {
      // 1, 2, ..., 12
      case 'L':
        return String(month + 1);
      // 01, 02, ..., 12

      case 'LL':
        return addLeadingZeros(month + 1, 2);
      // 1st, 2nd, ..., 12th

      case 'Lo':
        return localize.ordinalNumber(month + 1, {
          unit: 'month'
        });
      // Jan, Feb, ..., Dec

      case 'LLL':
        return localize.month(month, {
          width: 'abbreviated',
          context: 'standalone'
        });
      // J, F, ..., D

      case 'LLLLL':
        return localize.month(month, {
          width: 'narrow',
          context: 'standalone'
        });
      // January, February, ..., December

      case 'LLLL':
      default:
        return localize.month(month, {
          width: 'wide',
          context: 'standalone'
        });
    }
  },
  // Local week of year
  w: function w(date, token, localize, options) {
    var week = getUTCWeek(date, options);

    if (token === 'wo') {
      return localize.ordinalNumber(week, {
        unit: 'week'
      });
    }

    return addLeadingZeros(week, token.length);
  },
  // ISO week of year
  I: function I(date, token, localize) {
    var isoWeek = getUTCISOWeek(date);

    if (token === 'Io') {
      return localize.ordinalNumber(isoWeek, {
        unit: 'week'
      });
    }

    return addLeadingZeros(isoWeek, token.length);
  },
  // Day of the month
  d: function d(date, token, localize) {
    if (token === 'do') {
      return localize.ordinalNumber(date.getUTCDate(), {
        unit: 'date'
      });
    }

    return lightFormatters.d(date, token);
  },
  // Day of year
  D: function D(date, token, localize) {
    var dayOfYear = getUTCDayOfYear(date);

    if (token === 'Do') {
      return localize.ordinalNumber(dayOfYear, {
        unit: 'dayOfYear'
      });
    }

    return addLeadingZeros(dayOfYear, token.length);
  },
  // Day of week
  E: function E(date, token, localize) {
    var dayOfWeek = date.getUTCDay();

    switch (token) {
      // Tue
      case 'E':
      case 'EE':
      case 'EEE':
        return localize.day(dayOfWeek, {
          width: 'abbreviated',
          context: 'formatting'
        });
      // T

      case 'EEEEE':
        return localize.day(dayOfWeek, {
          width: 'narrow',
          context: 'formatting'
        });
      // Tu

      case 'EEEEEE':
        return localize.day(dayOfWeek, {
          width: 'short',
          context: 'formatting'
        });
      // Tuesday

      case 'EEEE':
      default:
        return localize.day(dayOfWeek, {
          width: 'wide',
          context: 'formatting'
        });
    }
  },
  // Local day of week
  e: function e(date, token, localize, options) {
    var dayOfWeek = date.getUTCDay();
    var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;

    switch (token) {
      // Numerical value (Nth day of week with current locale or weekStartsOn)
      case 'e':
        return String(localDayOfWeek);
      // Padded numerical value

      case 'ee':
        return addLeadingZeros(localDayOfWeek, 2);
      // 1st, 2nd, ..., 7th

      case 'eo':
        return localize.ordinalNumber(localDayOfWeek, {
          unit: 'day'
        });

      case 'eee':
        return localize.day(dayOfWeek, {
          width: 'abbreviated',
          context: 'formatting'
        });
      // T

      case 'eeeee':
        return localize.day(dayOfWeek, {
          width: 'narrow',
          context: 'formatting'
        });
      // Tu

      case 'eeeeee':
        return localize.day(dayOfWeek, {
          width: 'short',
          context: 'formatting'
        });
      // Tuesday

      case 'eeee':
      default:
        return localize.day(dayOfWeek, {
          width: 'wide',
          context: 'formatting'
        });
    }
  },
  // Stand-alone local day of week
  c: function c(date, token, localize, options) {
    var dayOfWeek = date.getUTCDay();
    var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;

    switch (token) {
      // Numerical value (same as in `e`)
      case 'c':
        return String(localDayOfWeek);
      // Padded numerical value

      case 'cc':
        return addLeadingZeros(localDayOfWeek, token.length);
      // 1st, 2nd, ..., 7th

      case 'co':
        return localize.ordinalNumber(localDayOfWeek, {
          unit: 'day'
        });

      case 'ccc':
        return localize.day(dayOfWeek, {
          width: 'abbreviated',
          context: 'standalone'
        });
      // T

      case 'ccccc':
        return localize.day(dayOfWeek, {
          width: 'narrow',
          context: 'standalone'
        });
      // Tu

      case 'cccccc':
        return localize.day(dayOfWeek, {
          width: 'short',
          context: 'standalone'
        });
      // Tuesday

      case 'cccc':
      default:
        return localize.day(dayOfWeek, {
          width: 'wide',
          context: 'standalone'
        });
    }
  },
  // ISO day of week
  i: function i(date, token, localize) {
    var dayOfWeek = date.getUTCDay();
    var isoDayOfWeek = dayOfWeek === 0 ? 7 : dayOfWeek;

    switch (token) {
      // 2
      case 'i':
        return String(isoDayOfWeek);
      // 02

      case 'ii':
        return addLeadingZeros(isoDayOfWeek, token.length);
      // 2nd

      case 'io':
        return localize.ordinalNumber(isoDayOfWeek, {
          unit: 'day'
        });
      // Tue

      case 'iii':
        return localize.day(dayOfWeek, {
          width: 'abbreviated',
          context: 'formatting'
        });
      // T

      case 'iiiii':
        return localize.day(dayOfWeek, {
          width: 'narrow',
          context: 'formatting'
        });
      // Tu

      case 'iiiiii':
        return localize.day(dayOfWeek, {
          width: 'short',
          context: 'formatting'
        });
      // Tuesday

      case 'iiii':
      default:
        return localize.day(dayOfWeek, {
          width: 'wide',
          context: 'formatting'
        });
    }
  },
  // AM or PM
  a: function a(date, token, localize) {
    var hours = date.getUTCHours();
    var dayPeriodEnumValue = hours / 12 >= 1 ? 'pm' : 'am';

    switch (token) {
      case 'a':
      case 'aa':
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'abbreviated',
          context: 'formatting'
        });

      case 'aaa':
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'abbreviated',
          context: 'formatting'
        }).toLowerCase();

      case 'aaaaa':
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'narrow',
          context: 'formatting'
        });

      case 'aaaa':
      default:
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'wide',
          context: 'formatting'
        });
    }
  },
  // AM, PM, midnight, noon
  b: function b(date, token, localize) {
    var hours = date.getUTCHours();
    var dayPeriodEnumValue;

    if (hours === 12) {
      dayPeriodEnumValue = dayPeriodEnum.noon;
    } else if (hours === 0) {
      dayPeriodEnumValue = dayPeriodEnum.midnight;
    } else {
      dayPeriodEnumValue = hours / 12 >= 1 ? 'pm' : 'am';
    }

    switch (token) {
      case 'b':
      case 'bb':
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'abbreviated',
          context: 'formatting'
        });

      case 'bbb':
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'abbreviated',
          context: 'formatting'
        }).toLowerCase();

      case 'bbbbb':
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'narrow',
          context: 'formatting'
        });

      case 'bbbb':
      default:
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'wide',
          context: 'formatting'
        });
    }
  },
  // in the morning, in the afternoon, in the evening, at night
  B: function B(date, token, localize) {
    var hours = date.getUTCHours();
    var dayPeriodEnumValue;

    if (hours >= 17) {
      dayPeriodEnumValue = dayPeriodEnum.evening;
    } else if (hours >= 12) {
      dayPeriodEnumValue = dayPeriodEnum.afternoon;
    } else if (hours >= 4) {
      dayPeriodEnumValue = dayPeriodEnum.morning;
    } else {
      dayPeriodEnumValue = dayPeriodEnum.night;
    }

    switch (token) {
      case 'B':
      case 'BB':
      case 'BBB':
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'abbreviated',
          context: 'formatting'
        });

      case 'BBBBB':
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'narrow',
          context: 'formatting'
        });

      case 'BBBB':
      default:
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'wide',
          context: 'formatting'
        });
    }
  },
  // Hour [1-12]
  h: function h(date, token, localize) {
    if (token === 'ho') {
      var hours = date.getUTCHours() % 12;
      if (hours === 0) hours = 12;
      return localize.ordinalNumber(hours, {
        unit: 'hour'
      });
    }

    return lightFormatters.h(date, token);
  },
  // Hour [0-23]
  H: function H(date, token, localize) {
    if (token === 'Ho') {
      return localize.ordinalNumber(date.getUTCHours(), {
        unit: 'hour'
      });
    }

    return lightFormatters.H(date, token);
  },
  // Hour [0-11]
  K: function K(date, token, localize) {
    var hours = date.getUTCHours() % 12;

    if (token === 'Ko') {
      return localize.ordinalNumber(hours, {
        unit: 'hour'
      });
    }

    return addLeadingZeros(hours, token.length);
  },
  // Hour [1-24]
  k: function k(date, token, localize) {
    var hours = date.getUTCHours();
    if (hours === 0) hours = 24;

    if (token === 'ko') {
      return localize.ordinalNumber(hours, {
        unit: 'hour'
      });
    }

    return addLeadingZeros(hours, token.length);
  },
  // Minute
  m: function m(date, token, localize) {
    if (token === 'mo') {
      return localize.ordinalNumber(date.getUTCMinutes(), {
        unit: 'minute'
      });
    }

    return lightFormatters.m(date, token);
  },
  // Second
  s: function s(date, token, localize) {
    if (token === 'so') {
      return localize.ordinalNumber(date.getUTCSeconds(), {
        unit: 'second'
      });
    }

    return lightFormatters.s(date, token);
  },
  // Fraction of second
  S: function S(date, token) {
    return lightFormatters.S(date, token);
  },
  // Timezone (ISO-8601. If offset is 0, output is always `'Z'`)
  X: function X(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();

    if (timezoneOffset === 0) {
      return 'Z';
    }

    switch (token) {
      // Hours and optional minutes
      case 'X':
        return formatTimezoneWithOptionalMinutes(timezoneOffset);
      // Hours, minutes and optional seconds without `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `XX`

      case 'XXXX':
      case 'XX':
        // Hours and minutes without `:` delimiter
        return formatTimezone(timezoneOffset);
      // Hours, minutes and optional seconds with `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `XXX`

      case 'XXXXX':
      case 'XXX': // Hours and minutes with `:` delimiter

      default:
        return formatTimezone(timezoneOffset, ':');
    }
  },
  // Timezone (ISO-8601. If offset is 0, output is `'+00:00'` or equivalent)
  x: function x(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();

    switch (token) {
      // Hours and optional minutes
      case 'x':
        return formatTimezoneWithOptionalMinutes(timezoneOffset);
      // Hours, minutes and optional seconds without `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `xx`

      case 'xxxx':
      case 'xx':
        // Hours and minutes without `:` delimiter
        return formatTimezone(timezoneOffset);
      // Hours, minutes and optional seconds with `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `xxx`

      case 'xxxxx':
      case 'xxx': // Hours and minutes with `:` delimiter

      default:
        return formatTimezone(timezoneOffset, ':');
    }
  },
  // Timezone (GMT)
  O: function O(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();

    switch (token) {
      // Short
      case 'O':
      case 'OO':
      case 'OOO':
        return 'GMT' + formatTimezoneShort(timezoneOffset, ':');
      // Long

      case 'OOOO':
      default:
        return 'GMT' + formatTimezone(timezoneOffset, ':');
    }
  },
  // Timezone (specific non-location)
  z: function z(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();

    switch (token) {
      // Short
      case 'z':
      case 'zz':
      case 'zzz':
        return 'GMT' + formatTimezoneShort(timezoneOffset, ':');
      // Long

      case 'zzzz':
      default:
        return 'GMT' + formatTimezone(timezoneOffset, ':');
    }
  },
  // Seconds timestamp
  t: function t(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timestamp = Math.floor(originalDate.getTime() / 1000);
    return addLeadingZeros(timestamp, token.length);
  },
  // Milliseconds timestamp
  T: function T(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timestamp = originalDate.getTime();
    return addLeadingZeros(timestamp, token.length);
  }
};

function formatTimezoneShort(offset, dirtyDelimiter) {
  var sign = offset > 0 ? '-' : '+';
  var absOffset = Math.abs(offset);
  var hours = Math.floor(absOffset / 60);
  var minutes = absOffset % 60;

  if (minutes === 0) {
    return sign + String(hours);
  }

  var delimiter = dirtyDelimiter || '';
  return sign + String(hours) + delimiter + addLeadingZeros(minutes, 2);
}

function formatTimezoneWithOptionalMinutes(offset, dirtyDelimiter) {
  if (offset % 60 === 0) {
    var sign = offset > 0 ? '-' : '+';
    return sign + addLeadingZeros(Math.abs(offset) / 60, 2);
  }

  return formatTimezone(offset, dirtyDelimiter);
}

function formatTimezone(offset, dirtyDelimiter) {
  var delimiter = dirtyDelimiter || '';
  var sign = offset > 0 ? '-' : '+';
  var absOffset = Math.abs(offset);
  var hours = addLeadingZeros(Math.floor(absOffset / 60), 2);
  var minutes = addLeadingZeros(absOffset % 60, 2);
  return sign + hours + delimiter + minutes;
}

/* harmony default export */ const format_formatters = (formatters_formatters);
;// CONCATENATED MODULE: ./node_modules/date-fns/esm/_lib/format/longFormatters/index.js
var dateLongFormatter = function dateLongFormatter(pattern, formatLong) {
  switch (pattern) {
    case 'P':
      return formatLong.date({
        width: 'short'
      });

    case 'PP':
      return formatLong.date({
        width: 'medium'
      });

    case 'PPP':
      return formatLong.date({
        width: 'long'
      });

    case 'PPPP':
    default:
      return formatLong.date({
        width: 'full'
      });
  }
};

var timeLongFormatter = function timeLongFormatter(pattern, formatLong) {
  switch (pattern) {
    case 'p':
      return formatLong.time({
        width: 'short'
      });

    case 'pp':
      return formatLong.time({
        width: 'medium'
      });

    case 'ppp':
      return formatLong.time({
        width: 'long'
      });

    case 'pppp':
    default:
      return formatLong.time({
        width: 'full'
      });
  }
};

var dateTimeLongFormatter = function dateTimeLongFormatter(pattern, formatLong) {
  var matchResult = pattern.match(/(P+)(p+)?/) || [];
  var datePattern = matchResult[1];
  var timePattern = matchResult[2];

  if (!timePattern) {
    return dateLongFormatter(pattern, formatLong);
  }

  var dateTimeFormat;

  switch (datePattern) {
    case 'P':
      dateTimeFormat = formatLong.dateTime({
        width: 'short'
      });
      break;

    case 'PP':
      dateTimeFormat = formatLong.dateTime({
        width: 'medium'
      });
      break;

    case 'PPP':
      dateTimeFormat = formatLong.dateTime({
        width: 'long'
      });
      break;

    case 'PPPP':
    default:
      dateTimeFormat = formatLong.dateTime({
        width: 'full'
      });
      break;
  }

  return dateTimeFormat.replace('{{date}}', dateLongFormatter(datePattern, formatLong)).replace('{{time}}', timeLongFormatter(timePattern, formatLong));
};

var longFormatters = {
  p: timeLongFormatter,
  P: dateTimeLongFormatter
};
/* harmony default export */ const format_longFormatters = (longFormatters);
;// CONCATENATED MODULE: ./node_modules/date-fns/esm/_lib/getTimezoneOffsetInMilliseconds/index.js
/**
 * Google Chrome as of 67.0.3396.87 introduced timezones with offset that includes seconds.
 * They usually appear for dates that denote time before the timezones were introduced
 * (e.g. for 'Europe/Prague' timezone the offset is GMT+00:57:44 before 1 October 1891
 * and GMT+01:00:00 after that date)
 *
 * Date#getTimezoneOffset returns the offset in minutes and would return 57 for the example above,
 * which would lead to incorrect calculations.
 *
 * This function returns the timezone offset in milliseconds that takes seconds in account.
 */
function getTimezoneOffsetInMilliseconds(date) {
  var utcDate = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()));
  utcDate.setUTCFullYear(date.getFullYear());
  return date.getTime() - utcDate.getTime();
}
;// CONCATENATED MODULE: ./node_modules/date-fns/esm/_lib/protectedTokens/index.js
var protectedDayOfYearTokens = ['D', 'DD'];
var protectedWeekYearTokens = ['YY', 'YYYY'];
function isProtectedDayOfYearToken(token) {
  return protectedDayOfYearTokens.indexOf(token) !== -1;
}
function isProtectedWeekYearToken(token) {
  return protectedWeekYearTokens.indexOf(token) !== -1;
}
function throwProtectedError(token, format, input) {
  if (token === 'YYYY') {
    throw new RangeError("Use `yyyy` instead of `YYYY` (in `".concat(format, "`) for formatting years to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  } else if (token === 'YY') {
    throw new RangeError("Use `yy` instead of `YY` (in `".concat(format, "`) for formatting years to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  } else if (token === 'D') {
    throw new RangeError("Use `d` instead of `D` (in `".concat(format, "`) for formatting days of the month to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  } else if (token === 'DD') {
    throw new RangeError("Use `dd` instead of `DD` (in `".concat(format, "`) for formatting days of the month to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  }
}
;// CONCATENATED MODULE: ./node_modules/date-fns/esm/_lib/defaultLocale/index.js

/* harmony default export */ const _lib_defaultLocale = (en_US);
;// CONCATENATED MODULE: ./node_modules/date-fns/esm/format/index.js










 // This RegExp consists of three parts separated by `|`:
// - [yYQqMLwIdDecihHKkms]o matches any available ordinal number token
//   (one of the certain letters followed by `o`)
// - (\w)\1* matches any sequences of the same letter
// - '' matches two quote characters in a row
// - '(''|[^'])+('|$) matches anything surrounded by two quote characters ('),
//   except a single quote symbol, which ends the sequence.
//   Two quote characters do not end the sequence.
//   If there is no matching single quote
//   then the sequence will continue until the end of the string.
// - . matches any single character unmatched by previous parts of the RegExps

var formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g; // This RegExp catches symbols escaped by quotes, and also
// sequences of symbols P, p, and the combinations like `PPPPPPPppppp`

var longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
var escapedStringRegExp = /^'([^]*?)'?$/;
var doubleQuoteRegExp = /''/g;
var unescapedLatinCharacterRegExp = /[a-zA-Z]/;
/**
 * @name format
 * @category Common Helpers
 * @summary Format the date.
 *
 * @description
 * Return the formatted date string in the given format. The result may vary by locale.
 *
 * >  Please note that the `format` tokens differ from Moment.js and other libraries.
 * > See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 *
 * The characters wrapped between two single quotes characters (') are escaped.
 * Two single quotes in a row, whether inside or outside a quoted sequence, represent a 'real' single quote.
 * (see the last example)
 *
 * Format of the string is based on Unicode Technical Standard #35:
 * https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table
 * with a few additions (see note 7 below the table).
 *
 * Accepted patterns:
 * | Unit                            | Pattern | Result examples                   | Notes |
 * |---------------------------------|---------|-----------------------------------|-------|
 * | Era                             | G..GGG  | AD, BC                            |       |
 * |                                 | GGGG    | Anno Domini, Before Christ        | 2     |
 * |                                 | GGGGG   | A, B                              |       |
 * | Calendar year                   | y       | 44, 1, 1900, 2017                 | 5     |
 * |                                 | yo      | 44th, 1st, 0th, 17th              | 5,7   |
 * |                                 | yy      | 44, 01, 00, 17                    | 5     |
 * |                                 | yyy     | 044, 001, 1900, 2017              | 5     |
 * |                                 | yyyy    | 0044, 0001, 1900, 2017            | 5     |
 * |                                 | yyyyy   | ...                               | 3,5   |
 * | Local week-numbering year       | Y       | 44, 1, 1900, 2017                 | 5     |
 * |                                 | Yo      | 44th, 1st, 1900th, 2017th         | 5,7   |
 * |                                 | YY      | 44, 01, 00, 17                    | 5,8   |
 * |                                 | YYY     | 044, 001, 1900, 2017              | 5     |
 * |                                 | YYYY    | 0044, 0001, 1900, 2017            | 5,8   |
 * |                                 | YYYYY   | ...                               | 3,5   |
 * | ISO week-numbering year         | R       | -43, 0, 1, 1900, 2017             | 5,7   |
 * |                                 | RR      | -43, 00, 01, 1900, 2017           | 5,7   |
 * |                                 | RRR     | -043, 000, 001, 1900, 2017        | 5,7   |
 * |                                 | RRRR    | -0043, 0000, 0001, 1900, 2017     | 5,7   |
 * |                                 | RRRRR   | ...                               | 3,5,7 |
 * | Extended year                   | u       | -43, 0, 1, 1900, 2017             | 5     |
 * |                                 | uu      | -43, 01, 1900, 2017               | 5     |
 * |                                 | uuu     | -043, 001, 1900, 2017             | 5     |
 * |                                 | uuuu    | -0043, 0001, 1900, 2017           | 5     |
 * |                                 | uuuuu   | ...                               | 3,5   |
 * | Quarter (formatting)            | Q       | 1, 2, 3, 4                        |       |
 * |                                 | Qo      | 1st, 2nd, 3rd, 4th                | 7     |
 * |                                 | QQ      | 01, 02, 03, 04                    |       |
 * |                                 | QQQ     | Q1, Q2, Q3, Q4                    |       |
 * |                                 | QQQQ    | 1st quarter, 2nd quarter, ...     | 2     |
 * |                                 | QQQQQ   | 1, 2, 3, 4                        | 4     |
 * | Quarter (stand-alone)           | q       | 1, 2, 3, 4                        |       |
 * |                                 | qo      | 1st, 2nd, 3rd, 4th                | 7     |
 * |                                 | qq      | 01, 02, 03, 04                    |       |
 * |                                 | qqq     | Q1, Q2, Q3, Q4                    |       |
 * |                                 | qqqq    | 1st quarter, 2nd quarter, ...     | 2     |
 * |                                 | qqqqq   | 1, 2, 3, 4                        | 4     |
 * | Month (formatting)              | M       | 1, 2, ..., 12                     |       |
 * |                                 | Mo      | 1st, 2nd, ..., 12th               | 7     |
 * |                                 | MM      | 01, 02, ..., 12                   |       |
 * |                                 | MMM     | Jan, Feb, ..., Dec                |       |
 * |                                 | MMMM    | January, February, ..., December  | 2     |
 * |                                 | MMMMM   | J, F, ..., D                      |       |
 * | Month (stand-alone)             | L       | 1, 2, ..., 12                     |       |
 * |                                 | Lo      | 1st, 2nd, ..., 12th               | 7     |
 * |                                 | LL      | 01, 02, ..., 12                   |       |
 * |                                 | LLL     | Jan, Feb, ..., Dec                |       |
 * |                                 | LLLL    | January, February, ..., December  | 2     |
 * |                                 | LLLLL   | J, F, ..., D                      |       |
 * | Local week of year              | w       | 1, 2, ..., 53                     |       |
 * |                                 | wo      | 1st, 2nd, ..., 53th               | 7     |
 * |                                 | ww      | 01, 02, ..., 53                   |       |
 * | ISO week of year                | I       | 1, 2, ..., 53                     | 7     |
 * |                                 | Io      | 1st, 2nd, ..., 53th               | 7     |
 * |                                 | II      | 01, 02, ..., 53                   | 7     |
 * | Day of month                    | d       | 1, 2, ..., 31                     |       |
 * |                                 | do      | 1st, 2nd, ..., 31st               | 7     |
 * |                                 | dd      | 01, 02, ..., 31                   |       |
 * | Day of year                     | D       | 1, 2, ..., 365, 366               | 9     |
 * |                                 | Do      | 1st, 2nd, ..., 365th, 366th       | 7     |
 * |                                 | DD      | 01, 02, ..., 365, 366             | 9     |
 * |                                 | DDD     | 001, 002, ..., 365, 366           |       |
 * |                                 | DDDD    | ...                               | 3     |
 * | Day of week (formatting)        | E..EEE  | Mon, Tue, Wed, ..., Sun           |       |
 * |                                 | EEEE    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 | EEEEE   | M, T, W, T, F, S, S               |       |
 * |                                 | EEEEEE  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
 * | ISO day of week (formatting)    | i       | 1, 2, 3, ..., 7                   | 7     |
 * |                                 | io      | 1st, 2nd, ..., 7th                | 7     |
 * |                                 | ii      | 01, 02, ..., 07                   | 7     |
 * |                                 | iii     | Mon, Tue, Wed, ..., Sun           | 7     |
 * |                                 | iiii    | Monday, Tuesday, ..., Sunday      | 2,7   |
 * |                                 | iiiii   | M, T, W, T, F, S, S               | 7     |
 * |                                 | iiiiii  | Mo, Tu, We, Th, Fr, Sa, Su        | 7     |
 * | Local day of week (formatting)  | e       | 2, 3, 4, ..., 1                   |       |
 * |                                 | eo      | 2nd, 3rd, ..., 1st                | 7     |
 * |                                 | ee      | 02, 03, ..., 01                   |       |
 * |                                 | eee     | Mon, Tue, Wed, ..., Sun           |       |
 * |                                 | eeee    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 | eeeee   | M, T, W, T, F, S, S               |       |
 * |                                 | eeeeee  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
 * | Local day of week (stand-alone) | c       | 2, 3, 4, ..., 1                   |       |
 * |                                 | co      | 2nd, 3rd, ..., 1st                | 7     |
 * |                                 | cc      | 02, 03, ..., 01                   |       |
 * |                                 | ccc     | Mon, Tue, Wed, ..., Sun           |       |
 * |                                 | cccc    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 | ccccc   | M, T, W, T, F, S, S               |       |
 * |                                 | cccccc  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
 * | AM, PM                          | a..aa   | AM, PM                            |       |
 * |                                 | aaa     | am, pm                            |       |
 * |                                 | aaaa    | a.m., p.m.                        | 2     |
 * |                                 | aaaaa   | a, p                              |       |
 * | AM, PM, noon, midnight          | b..bb   | AM, PM, noon, midnight            |       |
 * |                                 | bbb     | am, pm, noon, midnight            |       |
 * |                                 | bbbb    | a.m., p.m., noon, midnight        | 2     |
 * |                                 | bbbbb   | a, p, n, mi                       |       |
 * | Flexible day period             | B..BBB  | at night, in the morning, ...     |       |
 * |                                 | BBBB    | at night, in the morning, ...     | 2     |
 * |                                 | BBBBB   | at night, in the morning, ...     |       |
 * | Hour [1-12]                     | h       | 1, 2, ..., 11, 12                 |       |
 * |                                 | ho      | 1st, 2nd, ..., 11th, 12th         | 7     |
 * |                                 | hh      | 01, 02, ..., 11, 12               |       |
 * | Hour [0-23]                     | H       | 0, 1, 2, ..., 23                  |       |
 * |                                 | Ho      | 0th, 1st, 2nd, ..., 23rd          | 7     |
 * |                                 | HH      | 00, 01, 02, ..., 23               |       |
 * | Hour [0-11]                     | K       | 1, 2, ..., 11, 0                  |       |
 * |                                 | Ko      | 1st, 2nd, ..., 11th, 0th          | 7     |
 * |                                 | KK      | 01, 02, ..., 11, 00               |       |
 * | Hour [1-24]                     | k       | 24, 1, 2, ..., 23                 |       |
 * |                                 | ko      | 24th, 1st, 2nd, ..., 23rd         | 7     |
 * |                                 | kk      | 24, 01, 02, ..., 23               |       |
 * | Minute                          | m       | 0, 1, ..., 59                     |       |
 * |                                 | mo      | 0th, 1st, ..., 59th               | 7     |
 * |                                 | mm      | 00, 01, ..., 59                   |       |
 * | Second                          | s       | 0, 1, ..., 59                     |       |
 * |                                 | so      | 0th, 1st, ..., 59th               | 7     |
 * |                                 | ss      | 00, 01, ..., 59                   |       |
 * | Fraction of second              | S       | 0, 1, ..., 9                      |       |
 * |                                 | SS      | 00, 01, ..., 99                   |       |
 * |                                 | SSS     | 000, 001, ..., 999                |       |
 * |                                 | SSSS    | ...                               | 3     |
 * | Timezone (ISO-8601 w/ Z)        | X       | -08, +0530, Z                     |       |
 * |                                 | XX      | -0800, +0530, Z                   |       |
 * |                                 | XXX     | -08:00, +05:30, Z                 |       |
 * |                                 | XXXX    | -0800, +0530, Z, +123456          | 2     |
 * |                                 | XXXXX   | -08:00, +05:30, Z, +12:34:56      |       |
 * | Timezone (ISO-8601 w/o Z)       | x       | -08, +0530, +00                   |       |
 * |                                 | xx      | -0800, +0530, +0000               |       |
 * |                                 | xxx     | -08:00, +05:30, +00:00            | 2     |
 * |                                 | xxxx    | -0800, +0530, +0000, +123456      |       |
 * |                                 | xxxxx   | -08:00, +05:30, +00:00, +12:34:56 |       |
 * | Timezone (GMT)                  | O...OOO | GMT-8, GMT+5:30, GMT+0            |       |
 * |                                 | OOOO    | GMT-08:00, GMT+05:30, GMT+00:00   | 2     |
 * | Timezone (specific non-locat.)  | z...zzz | GMT-8, GMT+5:30, GMT+0            | 6     |
 * |                                 | zzzz    | GMT-08:00, GMT+05:30, GMT+00:00   | 2,6   |
 * | Seconds timestamp               | t       | 512969520                         | 7     |
 * |                                 | tt      | ...                               | 3,7   |
 * | Milliseconds timestamp          | T       | 512969520900                      | 7     |
 * |                                 | TT      | ...                               | 3,7   |
 * | Long localized date             | P       | 04/29/1453                        | 7     |
 * |                                 | PP      | Apr 29, 1453                      | 7     |
 * |                                 | PPP     | April 29th, 1453                  | 7     |
 * |                                 | PPPP    | Friday, April 29th, 1453          | 2,7   |
 * | Long localized time             | p       | 12:00 AM                          | 7     |
 * |                                 | pp      | 12:00:00 AM                       | 7     |
 * |                                 | ppp     | 12:00:00 AM GMT+2                 | 7     |
 * |                                 | pppp    | 12:00:00 AM GMT+02:00             | 2,7   |
 * | Combination of date and time    | Pp      | 04/29/1453, 12:00 AM              | 7     |
 * |                                 | PPpp    | Apr 29, 1453, 12:00:00 AM         | 7     |
 * |                                 | PPPppp  | April 29th, 1453 at ...           | 7     |
 * |                                 | PPPPpppp| Friday, April 29th, 1453 at ...   | 2,7   |
 * Notes:
 * 1. "Formatting" units (e.g. formatting quarter) in the default en-US locale
 *    are the same as "stand-alone" units, but are different in some languages.
 *    "Formatting" units are declined according to the rules of the language
 *    in the context of a date. "Stand-alone" units are always nominative singular:
 *
 *    `format(new Date(2017, 10, 6), 'do LLLL', {locale: cs}) //=> '6. listopad'`
 *
 *    `format(new Date(2017, 10, 6), 'do MMMM', {locale: cs}) //=> '6. listopadu'`
 *
 * 2. Any sequence of the identical letters is a pattern, unless it is escaped by
 *    the single quote characters (see below).
 *    If the sequence is longer than listed in table (e.g. `EEEEEEEEEEE`)
 *    the output will be the same as default pattern for this unit, usually
 *    the longest one (in case of ISO weekdays, `EEEE`). Default patterns for units
 *    are marked with "2" in the last column of the table.
 *
 *    `format(new Date(2017, 10, 6), 'MMM') //=> 'Nov'`
 *
 *    `format(new Date(2017, 10, 6), 'MMMM') //=> 'November'`
 *
 *    `format(new Date(2017, 10, 6), 'MMMMM') //=> 'N'`
 *
 *    `format(new Date(2017, 10, 6), 'MMMMMM') //=> 'November'`
 *
 *    `format(new Date(2017, 10, 6), 'MMMMMMM') //=> 'November'`
 *
 * 3. Some patterns could be unlimited length (such as `yyyyyyyy`).
 *    The output will be padded with zeros to match the length of the pattern.
 *
 *    `format(new Date(2017, 10, 6), 'yyyyyyyy') //=> '00002017'`
 *
 * 4. `QQQQQ` and `qqqqq` could be not strictly numerical in some locales.
 *    These tokens represent the shortest form of the quarter.
 *
 * 5. The main difference between `y` and `u` patterns are B.C. years:
 *
 *    | Year | `y` | `u` |
 *    |------|-----|-----|
 *    | AC 1 |   1 |   1 |
 *    | BC 1 |   1 |   0 |
 *    | BC 2 |   2 |  -1 |
 *
 *    Also `yy` always returns the last two digits of a year,
 *    while `uu` pads single digit years to 2 characters and returns other years unchanged:
 *
 *    | Year | `yy` | `uu` |
 *    |------|------|------|
 *    | 1    |   01 |   01 |
 *    | 14   |   14 |   14 |
 *    | 376  |   76 |  376 |
 *    | 1453 |   53 | 1453 |
 *
 *    The same difference is true for local and ISO week-numbering years (`Y` and `R`),
 *    except local week-numbering years are dependent on `options.weekStartsOn`
 *    and `options.firstWeekContainsDate` (compare [getISOWeekYear]{@link https://date-fns.org/docs/getISOWeekYear}
 *    and [getWeekYear]{@link https://date-fns.org/docs/getWeekYear}).
 *
 * 6. Specific non-location timezones are currently unavailable in `date-fns`,
 *    so right now these tokens fall back to GMT timezones.
 *
 * 7. These patterns are not in the Unicode Technical Standard #35:
 *    - `i`: ISO day of week
 *    - `I`: ISO week of year
 *    - `R`: ISO week-numbering year
 *    - `t`: seconds timestamp
 *    - `T`: milliseconds timestamp
 *    - `o`: ordinal number modifier
 *    - `P`: long localized date
 *    - `p`: long localized time
 *
 * 8. `YY` and `YYYY` tokens represent week-numbering years but they are often confused with years.
 *    You should enable `options.useAdditionalWeekYearTokens` to use them. See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 *
 * 9. `D` and `DD` tokens represent days of the year but they are often confused with days of the month.
 *    You should enable `options.useAdditionalDayOfYearTokens` to use them. See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 *
 * @param {Date|Number} date - the original date
 * @param {String} format - the string of tokens
 * @param {Object} [options] - an object with options.
 * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
 * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
 * @param {Number} [options.firstWeekContainsDate=1] - the day of January, which is
 * @param {Boolean} [options.useAdditionalWeekYearTokens=false] - if true, allows usage of the week-numbering year tokens `YY` and `YYYY`;
 *   see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @param {Boolean} [options.useAdditionalDayOfYearTokens=false] - if true, allows usage of the day of year tokens `D` and `DD`;
 *   see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @returns {String} the formatted date string
 * @throws {TypeError} 2 arguments required
 * @throws {RangeError} `date` must not be Invalid Date
 * @throws {RangeError} `options.locale` must contain `localize` property
 * @throws {RangeError} `options.locale` must contain `formatLong` property
 * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
 * @throws {RangeError} `options.firstWeekContainsDate` must be between 1 and 7
 * @throws {RangeError} use `yyyy` instead of `YYYY` for formatting years using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @throws {RangeError} use `yy` instead of `YY` for formatting years using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @throws {RangeError} use `d` instead of `D` for formatting days of the month using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @throws {RangeError} use `dd` instead of `DD` for formatting days of the month using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @throws {RangeError} format string contains an unescaped latin alphabet character
 *
 * @example
 * // Represent 11 February 2014 in middle-endian format:
 * const result = format(new Date(2014, 1, 11), 'MM/dd/yyyy')
 * //=> '02/11/2014'
 *
 * @example
 * // Represent 2 July 2014 in Esperanto:
 * import { eoLocale } from 'date-fns/locale/eo'
 * const result = format(new Date(2014, 6, 2), "do 'de' MMMM yyyy", {
 *   locale: eoLocale
 * })
 * //=> '2-a de julio 2014'
 *
 * @example
 * // Escape string by single quote characters:
 * const result = format(new Date(2014, 6, 2, 15), "h 'o''clock'")
 * //=> "3 o'clock"
 */

function format_format(dirtyDate, dirtyFormatStr, options) {
  var _ref, _options$locale, _ref2, _ref3, _ref4, _options$firstWeekCon, _options$locale2, _options$locale2$opti, _defaultOptions$local, _defaultOptions$local2, _ref5, _ref6, _ref7, _options$weekStartsOn, _options$locale3, _options$locale3$opti, _defaultOptions$local3, _defaultOptions$local4;

  requiredArgs(2, arguments);
  var formatStr = String(dirtyFormatStr);
  var defaultOptions = getDefaultOptions();
  var locale = (_ref = (_options$locale = options === null || options === void 0 ? void 0 : options.locale) !== null && _options$locale !== void 0 ? _options$locale : defaultOptions.locale) !== null && _ref !== void 0 ? _ref : _lib_defaultLocale;
  var firstWeekContainsDate = toInteger((_ref2 = (_ref3 = (_ref4 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale2 = options.locale) === null || _options$locale2 === void 0 ? void 0 : (_options$locale2$opti = _options$locale2.options) === null || _options$locale2$opti === void 0 ? void 0 : _options$locale2$opti.firstWeekContainsDate) !== null && _ref4 !== void 0 ? _ref4 : defaultOptions.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : 1); // Test if weekStartsOn is between 1 and 7 _and_ is not NaN

  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError('firstWeekContainsDate must be between 1 and 7 inclusively');
  }

  var weekStartsOn = toInteger((_ref5 = (_ref6 = (_ref7 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale3 = options.locale) === null || _options$locale3 === void 0 ? void 0 : (_options$locale3$opti = _options$locale3.options) === null || _options$locale3$opti === void 0 ? void 0 : _options$locale3$opti.weekStartsOn) !== null && _ref7 !== void 0 ? _ref7 : defaultOptions.weekStartsOn) !== null && _ref6 !== void 0 ? _ref6 : (_defaultOptions$local3 = defaultOptions.locale) === null || _defaultOptions$local3 === void 0 ? void 0 : (_defaultOptions$local4 = _defaultOptions$local3.options) === null || _defaultOptions$local4 === void 0 ? void 0 : _defaultOptions$local4.weekStartsOn) !== null && _ref5 !== void 0 ? _ref5 : 0); // Test if weekStartsOn is between 0 and 6 _and_ is not NaN

  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
  }

  if (!locale.localize) {
    throw new RangeError('locale must contain localize property');
  }

  if (!locale.formatLong) {
    throw new RangeError('locale must contain formatLong property');
  }

  var originalDate = toDate(dirtyDate);

  if (!isValid(originalDate)) {
    throw new RangeError('Invalid time value');
  } // Convert the date in system timezone to the same date in UTC+00:00 timezone.
  // This ensures that when UTC functions will be implemented, locales will be compatible with them.
  // See an issue about UTC functions: https://github.com/date-fns/date-fns/issues/376


  var timezoneOffset = getTimezoneOffsetInMilliseconds(originalDate);
  var utcDate = subMilliseconds(originalDate, timezoneOffset);
  var formatterOptions = {
    firstWeekContainsDate: firstWeekContainsDate,
    weekStartsOn: weekStartsOn,
    locale: locale,
    _originalDate: originalDate
  };
  var result = formatStr.match(longFormattingTokensRegExp).map(function (substring) {
    var firstCharacter = substring[0];

    if (firstCharacter === 'p' || firstCharacter === 'P') {
      var longFormatter = format_longFormatters[firstCharacter];
      return longFormatter(substring, locale.formatLong);
    }

    return substring;
  }).join('').match(formattingTokensRegExp).map(function (substring) {
    // Replace two single quote characters with one single quote character
    if (substring === "''") {
      return "'";
    }

    var firstCharacter = substring[0];

    if (firstCharacter === "'") {
      return cleanEscapedString(substring);
    }

    var formatter = format_formatters[firstCharacter];

    if (formatter) {
      if (!(options !== null && options !== void 0 && options.useAdditionalWeekYearTokens) && isProtectedWeekYearToken(substring)) {
        throwProtectedError(substring, dirtyFormatStr, String(dirtyDate));
      }

      if (!(options !== null && options !== void 0 && options.useAdditionalDayOfYearTokens) && isProtectedDayOfYearToken(substring)) {
        throwProtectedError(substring, dirtyFormatStr, String(dirtyDate));
      }

      return formatter(utcDate, substring, locale.localize, formatterOptions);
    }

    if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
      throw new RangeError('Format string contains an unescaped latin alphabet character `' + firstCharacter + '`');
    }

    return substring;
  }).join('');
  return result;
}

function cleanEscapedString(input) {
  var matched = input.match(escapedStringRegExp);

  if (!matched) {
    return input;
  }

  return matched[1].replace(doubleQuoteRegExp, "'");
}
;// CONCATENATED MODULE: ./node_modules/date-fns/esm/endOfMonth/index.js


/**
 * @name endOfMonth
 * @category Month Helpers
 * @summary Return the end of a month for the given date.
 *
 * @description
 * Return the end of a month for the given date.
 * The result will be in the local timezone.
 *
 * @param {Date|Number} date - the original date
 * @returns {Date} the end of a month
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // The end of a month for 2 September 2014 11:55:00:
 * const result = endOfMonth(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Tue Sep 30 2014 23:59:59.999
 */

function endOfMonth(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var month = date.getMonth();
  date.setFullYear(date.getFullYear(), month + 1, 0);
  date.setHours(23, 59, 59, 999);
  return date;
}
;// CONCATENATED MODULE: ./node_modules/date-fns/esm/startOfDay/index.js


/**
 * @name startOfDay
 * @category Day Helpers
 * @summary Return the start of a day for the given date.
 *
 * @description
 * Return the start of a day for the given date.
 * The result will be in the local timezone.
 *
 * @param {Date|Number} date - the original date
 * @returns {Date} the start of a day
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // The start of a day for 2 September 2014 11:55:00:
 * const result = startOfDay(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Tue Sep 02 2014 00:00:00
 */

function startOfDay(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  date.setHours(0, 0, 0, 0);
  return date;
}
;// CONCATENATED MODULE: ./node_modules/date-fns/esm/startOfMonth/index.js


/**
 * @name startOfMonth
 * @category Month Helpers
 * @summary Return the start of a month for the given date.
 *
 * @description
 * Return the start of a month for the given date.
 * The result will be in the local timezone.
 *
 * @param {Date|Number} date - the original date
 * @returns {Date} the start of a month
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // The start of a month for 2 September 2014 11:55:00:
 * const result = startOfMonth(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Mon Sep 01 2014 00:00:00
 */

function startOfMonth(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  date.setDate(1);
  date.setHours(0, 0, 0, 0);
  return date;
}
;// CONCATENATED MODULE: ./node_modules/date-fns/esm/isSameYear/index.js


/**
 * @name isSameYear
 * @category Year Helpers
 * @summary Are the given dates in the same year?
 *
 * @description
 * Are the given dates in the same year?
 *
 * @param {Date|Number} dateLeft - the first date to check
 * @param {Date|Number} dateRight - the second date to check
 * @returns {Boolean} the dates are in the same year
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Are 2 September 2014 and 25 September 2014 in the same year?
 * const result = isSameYear(new Date(2014, 8, 2), new Date(2014, 8, 25))
 * //=> true
 */

function isSameYear(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeft = toDate(dirtyDateLeft);
  var dateRight = toDate(dirtyDateRight);
  return dateLeft.getFullYear() === dateRight.getFullYear();
}
;// CONCATENATED MODULE: ./node_modules/date-fns/esm/getDaysInMonth/index.js


/**
 * @name getDaysInMonth
 * @category Month Helpers
 * @summary Get the number of days in a month of the given date.
 *
 * @description
 * Get the number of days in a month of the given date.
 *
 * @param {Date|Number} date - the given date
 * @returns {Number} the number of days in a month
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // How many days are in February 2000?
 * const result = getDaysInMonth(new Date(2000, 1))
 * //=> 29
 */

function getDaysInMonth(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var year = date.getFullYear();
  var monthIndex = date.getMonth();
  var lastDayOfMonth = new Date(0);
  lastDayOfMonth.setFullYear(year, monthIndex + 1, 0);
  lastDayOfMonth.setHours(0, 0, 0, 0);
  return lastDayOfMonth.getDate();
}
;// CONCATENATED MODULE: ./node_modules/date-fns/esm/setMonth/index.js




/**
 * @name setMonth
 * @category Month Helpers
 * @summary Set the month to the given date.
 *
 * @description
 * Set the month to the given date.
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} month - the month of the new date
 * @returns {Date} the new date with the month set
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Set February to 1 September 2014:
 * const result = setMonth(new Date(2014, 8, 1), 1)
 * //=> Sat Feb 01 2014 00:00:00
 */

function setMonth(dirtyDate, dirtyMonth) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var month = toInteger(dirtyMonth);
  var year = date.getFullYear();
  var day = date.getDate();
  var dateWithDesiredMonth = new Date(0);
  dateWithDesiredMonth.setFullYear(year, month, 15);
  dateWithDesiredMonth.setHours(0, 0, 0, 0);
  var daysInMonth = getDaysInMonth(dateWithDesiredMonth); // Set the last day of the new month
  // if the original date was the last day of the longer month

  date.setMonth(month, Math.min(day, daysInMonth));
  return date;
}
;// CONCATENATED MODULE: ./node_modules/date-fns/esm/setYear/index.js



/**
 * @name setYear
 * @category Year Helpers
 * @summary Set the year to the given date.
 *
 * @description
 * Set the year to the given date.
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} year - the year of the new date
 * @returns {Date} the new date with the year set
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Set year 2013 to 1 September 2014:
 * const result = setYear(new Date(2014, 8, 1), 2013)
 * //=> Sun Sep 01 2013 00:00:00
 */

function setYear(dirtyDate, dirtyYear) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var year = toInteger(dirtyYear); // Check if date is Invalid Date because Date.prototype.setFullYear ignores the value of Invalid Date

  if (isNaN(date.getTime())) {
    return new Date(NaN);
  }

  date.setFullYear(year);
  return date;
}
;// CONCATENATED MODULE: ./node_modules/date-fns/esm/startOfYear/index.js


/**
 * @name startOfYear
 * @category Year Helpers
 * @summary Return the start of a year for the given date.
 *
 * @description
 * Return the start of a year for the given date.
 * The result will be in the local timezone.
 *
 * @param {Date|Number} date - the original date
 * @returns {Date} the start of a year
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // The start of a year for 2 September 2014 11:55:00:
 * const result = startOfYear(new Date(2014, 8, 2, 11, 55, 00))
 * //=> Wed Jan 01 2014 00:00:00
 */

function startOfYear(dirtyDate) {
  requiredArgs(1, arguments);
  var cleanDate = toDate(dirtyDate);
  var date = new Date(0);
  date.setFullYear(cleanDate.getFullYear(), 0, 1);
  date.setHours(0, 0, 0, 0);
  return date;
}
;// CONCATENATED MODULE: ./node_modules/date-fns/esm/addMonths/index.js



/**
 * @name addMonths
 * @category Month Helpers
 * @summary Add the specified number of months to the given date.
 *
 * @description
 * Add the specified number of months to the given date.
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} amount - the amount of months to be added. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
 * @returns {Date} the new date with the months added
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Add 5 months to 1 September 2014:
 * const result = addMonths(new Date(2014, 8, 1), 5)
 * //=> Sun Feb 01 2015 00:00:00
 */

function addMonths(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var amount = toInteger(dirtyAmount);

  if (isNaN(amount)) {
    return new Date(NaN);
  }

  if (!amount) {
    // If 0 months, no-op to avoid changing times in the hour before end of DST
    return date;
  }

  var dayOfMonth = date.getDate(); // The JS Date object supports date math by accepting out-of-bounds values for
  // month, day, etc. For example, new Date(2020, 0, 0) returns 31 Dec 2019 and
  // new Date(2020, 13, 1) returns 1 Feb 2021.  This is *almost* the behavior we
  // want except that dates will wrap around the end of a month, meaning that
  // new Date(2020, 13, 31) will return 3 Mar 2021 not 28 Feb 2021 as desired. So
  // we'll default to the end of the desired month by adding 1 to the desired
  // month and using a date of 0 to back up one day to the end of the desired
  // month.

  var endOfDesiredMonth = new Date(date.getTime());
  endOfDesiredMonth.setMonth(date.getMonth() + amount + 1, 0);
  var daysInMonth = endOfDesiredMonth.getDate();

  if (dayOfMonth >= daysInMonth) {
    // If we're already at the end of the month, then this is the correct date
    // and we're done.
    return endOfDesiredMonth;
  } else {
    // Otherwise, we now know that setting the original day-of-month value won't
    // cause an overflow, so set the desired day-of-month. Note that we can't
    // just set the date of `endOfDesiredMonth` because that object may have had
    // its time changed in the unusual case where where a DST transition was on
    // the last day of the month and its local time was in the hour skipped or
    // repeated next to a DST transition.  So we use `date` instead which is
    // guaranteed to still have the original time.
    date.setFullYear(endOfDesiredMonth.getFullYear(), endOfDesiredMonth.getMonth(), dayOfMonth);
    return date;
  }
}
;// CONCATENATED MODULE: ./node_modules/date-fns/esm/isBefore/index.js


/**
 * @name isBefore
 * @category Common Helpers
 * @summary Is the first date before the second one?
 *
 * @description
 * Is the first date before the second one?
 *
 * @param {Date|Number} date - the date that should be before the other one to return true
 * @param {Date|Number} dateToCompare - the date to compare with
 * @returns {Boolean} the first date is before the second date
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Is 10 July 1989 before 11 February 1987?
 * const result = isBefore(new Date(1989, 6, 10), new Date(1987, 1, 11))
 * //=> false
 */

function isBefore(dirtyDate, dirtyDateToCompare) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var dateToCompare = toDate(dirtyDateToCompare);
  return date.getTime() < dateToCompare.getTime();
}
;// CONCATENATED MODULE: ./node_modules/date-fns/esm/isSameMonth/index.js


/**
 * @name isSameMonth
 * @category Month Helpers
 * @summary Are the given dates in the same month (and year)?
 *
 * @description
 * Are the given dates in the same month (and year)?
 *
 * @param {Date|Number} dateLeft - the first date to check
 * @param {Date|Number} dateRight - the second date to check
 * @returns {Boolean} the dates are in the same month (and year)
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Are 2 September 2014 and 25 September 2014 in the same month?
 * const result = isSameMonth(new Date(2014, 8, 2), new Date(2014, 8, 25))
 * //=> true
 *
 * @example
 * // Are 2 September 2014 and 25 September 2015 in the same month?
 * const result = isSameMonth(new Date(2014, 8, 2), new Date(2015, 8, 25))
 * //=> false
 */

function isSameMonth(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeft = toDate(dirtyDateLeft);
  var dateRight = toDate(dirtyDateRight);
  return dateLeft.getFullYear() === dateRight.getFullYear() && dateLeft.getMonth() === dateRight.getMonth();
}
;// CONCATENATED MODULE: ./node_modules/date-fns/esm/differenceInCalendarMonths/index.js


/**
 * @name differenceInCalendarMonths
 * @category Month Helpers
 * @summary Get the number of calendar months between the given dates.
 *
 * @description
 * Get the number of calendar months between the given dates.
 *
 * @param {Date|Number} dateLeft - the later date
 * @param {Date|Number} dateRight - the earlier date
 * @returns {Number} the number of calendar months
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // How many calendar months are between 31 January 2014 and 1 September 2014?
 * const result = differenceInCalendarMonths(
 *   new Date(2014, 8, 1),
 *   new Date(2014, 0, 31)
 * )
 * //=> 8
 */

function differenceInCalendarMonths(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeft = toDate(dirtyDateLeft);
  var dateRight = toDate(dirtyDateRight);
  var yearDiff = dateLeft.getFullYear() - dateRight.getFullYear();
  var monthDiff = dateLeft.getMonth() - dateRight.getMonth();
  return yearDiff * 12 + monthDiff;
}
;// CONCATENATED MODULE: ./node_modules/date-fns/esm/addDays/index.js



/**
 * @name addDays
 * @category Day Helpers
 * @summary Add the specified number of days to the given date.
 *
 * @description
 * Add the specified number of days to the given date.
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} amount - the amount of days to be added. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
 * @returns {Date} - the new date with the days added
 * @throws {TypeError} - 2 arguments required
 *
 * @example
 * // Add 10 days to 1 September 2014:
 * const result = addDays(new Date(2014, 8, 1), 10)
 * //=> Thu Sep 11 2014 00:00:00
 */

function addDays(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var amount = toInteger(dirtyAmount);

  if (isNaN(amount)) {
    return new Date(NaN);
  }

  if (!amount) {
    // If 0 days, no-op to avoid changing times in the hour before end of DST
    return date;
  }

  date.setDate(date.getDate() + amount);
  return date;
}
;// CONCATENATED MODULE: ./node_modules/date-fns/esm/startOfWeek/index.js




/**
 * @name startOfWeek
 * @category Week Helpers
 * @summary Return the start of a week for the given date.
 *
 * @description
 * Return the start of a week for the given date.
 * The result will be in the local timezone.
 *
 * @param {Date|Number} date - the original date
 * @param {Object} [options] - an object with options.
 * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
 * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
 * @returns {Date} the start of a week
 * @throws {TypeError} 1 argument required
 * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
 *
 * @example
 * // The start of a week for 2 September 2014 11:55:00:
 * const result = startOfWeek(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Sun Aug 31 2014 00:00:00
 *
 * @example
 * // If the week starts on Monday, the start of the week for 2 September 2014 11:55:00:
 * const result = startOfWeek(new Date(2014, 8, 2, 11, 55, 0), { weekStartsOn: 1 })
 * //=> Mon Sep 01 2014 00:00:00
 */

function startOfWeek(dirtyDate, options) {
  var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;

  requiredArgs(1, arguments);
  var defaultOptions = getDefaultOptions();
  var weekStartsOn = toInteger((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref !== void 0 ? _ref : 0); // Test if weekStartsOn is between 0 and 6 _and_ is not NaN

  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
  }

  var date = toDate(dirtyDate);
  var day = date.getDay();
  var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  date.setDate(date.getDate() - diff);
  date.setHours(0, 0, 0, 0);
  return date;
}
;// CONCATENATED MODULE: ./node_modules/date-fns/esm/startOfISOWeek/index.js


/**
 * @name startOfISOWeek
 * @category ISO Week Helpers
 * @summary Return the start of an ISO week for the given date.
 *
 * @description
 * Return the start of an ISO week for the given date.
 * The result will be in the local timezone.
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @param {Date|Number} date - the original date
 * @returns {Date} the start of an ISO week
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // The start of an ISO week for 2 September 2014 11:55:00:
 * const result = startOfISOWeek(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Mon Sep 01 2014 00:00:00
 */

function startOfISOWeek(dirtyDate) {
  requiredArgs(1, arguments);
  return startOfWeek(dirtyDate, {
    weekStartsOn: 1
  });
}
;// CONCATENATED MODULE: ./node_modules/date-fns/esm/getTime/index.js


/**
 * @name getTime
 * @category Timestamp Helpers
 * @summary Get the milliseconds timestamp of the given date.
 *
 * @description
 * Get the milliseconds timestamp of the given date.
 *
 * @param {Date|Number} date - the given date
 * @returns {Number} the timestamp
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // Get the timestamp of 29 February 2012 11:45:05.123:
 * const result = getTime(new Date(2012, 1, 29, 11, 45, 5, 123))
 * //=> 1330515905123
 */

function getTime(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var timestamp = date.getTime();
  return timestamp;
}
;// CONCATENATED MODULE: ./node_modules/date-fns/esm/getUnixTime/index.js


/**
 * @name getUnixTime
 * @category Timestamp Helpers
 * @summary Get the seconds timestamp of the given date.
 *
 * @description
 * Get the seconds timestamp of the given date.
 *
 * @param {Date|Number} date - the given date
 * @returns {Number} the timestamp
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // Get the timestamp of 29 February 2012 11:45:05 CET:
 * const result = getUnixTime(new Date(2012, 1, 29, 11, 45, 5))
 * //=> 1330512305
 */

function getUnixTime(dirtyDate) {
  requiredArgs(1, arguments);
  return Math.floor(getTime(dirtyDate) / 1000);
}
;// CONCATENATED MODULE: ./node_modules/date-fns/esm/isSameDay/index.js


/**
 * @name isSameDay
 * @category Day Helpers
 * @summary Are the given dates in the same day (and year and month)?
 *
 * @description
 * Are the given dates in the same day (and year and month)?
 *
 * @param {Date|Number} dateLeft - the first date to check
 * @param {Date|Number} dateRight - the second date to check
 * @returns {Boolean} the dates are in the same day (and year and month)
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Are 4 September 06:00:00 and 4 September 18:00:00 in the same day?
 * const result = isSameDay(new Date(2014, 8, 4, 6, 0), new Date(2014, 8, 4, 18, 0))
 * //=> true
 *
 * @example
 * // Are 4 September and 4 October in the same day?
 * const result = isSameDay(new Date(2014, 8, 4), new Date(2014, 9, 4))
 * //=> false
 *
 * @example
 * // Are 4 September, 2014 and 4 September, 2015 in the same day?
 * const result = isSameDay(new Date(2014, 8, 4), new Date(2015, 8, 4))
 * //=> false
 */

function isSameDay(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeftStartOfDay = startOfDay(dirtyDateLeft);
  var dateRightStartOfDay = startOfDay(dirtyDateRight);
  return dateLeftStartOfDay.getTime() === dateRightStartOfDay.getTime();
}
;// CONCATENATED MODULE: ./node_modules/date-fns/esm/isAfter/index.js


/**
 * @name isAfter
 * @category Common Helpers
 * @summary Is the first date after the second one?
 *
 * @description
 * Is the first date after the second one?
 *
 * @param {Date|Number} date - the date that should be after the other one to return true
 * @param {Date|Number} dateToCompare - the date to compare with
 * @returns {Boolean} the first date is after the second date
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Is 10 July 1989 after 11 February 1987?
 * const result = isAfter(new Date(1989, 6, 10), new Date(1987, 1, 11))
 * //=> true
 */

function isAfter(dirtyDate, dirtyDateToCompare) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var dateToCompare = toDate(dirtyDateToCompare);
  return date.getTime() > dateToCompare.getTime();
}
;// CONCATENATED MODULE: ./node_modules/date-fns/esm/differenceInCalendarDays/index.js



var differenceInCalendarDays_MILLISECONDS_IN_DAY = 86400000;
/**
 * @name differenceInCalendarDays
 * @category Day Helpers
 * @summary Get the number of calendar days between the given dates.
 *
 * @description
 * Get the number of calendar days between the given dates. This means that the times are removed
 * from the dates and then the difference in days is calculated.
 *
 * @param {Date|Number} dateLeft - the later date
 * @param {Date|Number} dateRight - the earlier date
 * @returns {Number} the number of calendar days
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // How many calendar days are between
 * // 2 July 2011 23:00:00 and 2 July 2012 00:00:00?
 * const result = differenceInCalendarDays(
 *   new Date(2012, 6, 2, 0, 0),
 *   new Date(2011, 6, 2, 23, 0)
 * )
 * //=> 366
 * // How many calendar days are between
 * // 2 July 2011 23:59:00 and 3 July 2011 00:01:00?
 * const result = differenceInCalendarDays(
 *   new Date(2011, 6, 3, 0, 1),
 *   new Date(2011, 6, 2, 23, 59)
 * )
 * //=> 1
 */

function differenceInCalendarDays_differenceInCalendarDays(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var startOfDayLeft = startOfDay(dirtyDateLeft);
  var startOfDayRight = startOfDay(dirtyDateRight);
  var timestampLeft = startOfDayLeft.getTime() - getTimezoneOffsetInMilliseconds(startOfDayLeft);
  var timestampRight = startOfDayRight.getTime() - getTimezoneOffsetInMilliseconds(startOfDayRight); // Round the number of days to the nearest integer
  // because the number of milliseconds in a day is not constant
  // (e.g. it's different in the day of the daylight saving time clock shift)

  return Math.round((timestampLeft - timestampRight) / differenceInCalendarDays_MILLISECONDS_IN_DAY);
}
;// CONCATENATED MODULE: ./node_modules/date-fns/esm/subDays/index.js



/**
 * @name subDays
 * @category Day Helpers
 * @summary Subtract the specified number of days from the given date.
 *
 * @description
 * Subtract the specified number of days from the given date.
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} amount - the amount of days to be subtracted. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
 * @returns {Date} the new date with the days subtracted
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Subtract 10 days from 1 September 2014:
 * const result = subDays(new Date(2014, 8, 1), 10)
 * //=> Fri Aug 22 2014 00:00:00
 */

function subDays(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addDays(dirtyDate, -amount);
}
;// CONCATENATED MODULE: ./node_modules/date-fns/esm/addWeeks/index.js



/**
 * @name addWeeks
 * @category Week Helpers
 * @summary Add the specified number of weeks to the given date.
 *
 * @description
 * Add the specified number of week to the given date.
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} amount - the amount of weeks to be added. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
 * @returns {Date} the new date with the weeks added
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Add 4 weeks to 1 September 2014:
 * const result = addWeeks(new Date(2014, 8, 1), 4)
 * //=> Mon Sep 29 2014 00:00:00
 */

function addWeeks(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  var days = amount * 7;
  return addDays(dirtyDate, days);
}
;// CONCATENATED MODULE: ./node_modules/date-fns/esm/addYears/index.js



/**
 * @name addYears
 * @category Year Helpers
 * @summary Add the specified number of years to the given date.
 *
 * @description
 * Add the specified number of years to the given date.
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} amount - the amount of years to be added. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
 * @returns {Date} the new date with the years added
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Add 5 years to 1 September 2014:
 * const result = addYears(new Date(2014, 8, 1), 5)
 * //=> Sun Sep 01 2019 00:00:00
 */

function addYears(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addMonths(dirtyDate, amount * 12);
}
;// CONCATENATED MODULE: ./node_modules/date-fns/esm/endOfWeek/index.js





/**
 * @name endOfWeek
 * @category Week Helpers
 * @summary Return the end of a week for the given date.
 *
 * @description
 * Return the end of a week for the given date.
 * The result will be in the local timezone.
 *
 * @param {Date|Number} date - the original date
 * @param {Object} [options] - an object with options.
 * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
 * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
 * @returns {Date} the end of a week
 * @throws {TypeError} 1 argument required
 * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
 *
 * @example
 * // The end of a week for 2 September 2014 11:55:00:
 * const result = endOfWeek(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Sat Sep 06 2014 23:59:59.999
 *
 * @example
 * // If the week starts on Monday, the end of the week for 2 September 2014 11:55:00:
 * const result = endOfWeek(new Date(2014, 8, 2, 11, 55, 0), { weekStartsOn: 1 })
 * //=> Sun Sep 07 2014 23:59:59.999
 */
function endOfWeek(dirtyDate, options) {
  var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;

  requiredArgs(1, arguments);
  var defaultOptions = getDefaultOptions();
  var weekStartsOn = toInteger((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref !== void 0 ? _ref : 0); // Test if weekStartsOn is between 0 and 6 _and_ is not NaN

  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
  }

  var date = toDate(dirtyDate);
  var day = date.getDay();
  var diff = (day < weekStartsOn ? -7 : 0) + 6 - (day - weekStartsOn);
  date.setDate(date.getDate() + diff);
  date.setHours(23, 59, 59, 999);
  return date;
}
;// CONCATENATED MODULE: ./node_modules/date-fns/esm/endOfISOWeek/index.js


/**
 * @name endOfISOWeek
 * @category ISO Week Helpers
 * @summary Return the end of an ISO week for the given date.
 *
 * @description
 * Return the end of an ISO week for the given date.
 * The result will be in the local timezone.
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @param {Date|Number} date - the original date
 * @returns {Date} the end of an ISO week
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // The end of an ISO week for 2 September 2014 11:55:00:
 * const result = endOfISOWeek(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Sun Sep 07 2014 23:59:59.999
 */

function endOfISOWeek(dirtyDate) {
  requiredArgs(1, arguments);
  return endOfWeek(dirtyDate, {
    weekStartsOn: 1
  });
}
;// CONCATENATED MODULE: ./node_modules/date-fns/esm/max/index.js
function max_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { max_typeof = function _typeof(obj) { return typeof obj; }; } else { max_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return max_typeof(obj); }



/**
 * @name max
 * @category Common Helpers
 * @summary Return the latest of the given dates.
 *
 * @description
 * Return the latest of the given dates.
 *
 * @param {Date[]|Number[]} datesArray - the dates to compare
 * @returns {Date} the latest of the dates
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // Which of these dates is the latest?
 * const result = max([
 *   new Date(1989, 6, 10),
 *   new Date(1987, 1, 11),
 *   new Date(1995, 6, 2),
 *   new Date(1990, 0, 1)
 * ])
 * //=> Sun Jul 02 1995 00:00:00
 */

function max(dirtyDatesArray) {
  requiredArgs(1, arguments);
  var datesArray; // `dirtyDatesArray` is Array, Set or Map, or object with custom `forEach` method

  if (dirtyDatesArray && typeof dirtyDatesArray.forEach === 'function') {
    datesArray = dirtyDatesArray; // If `dirtyDatesArray` is Array-like Object, convert to Array.
  } else if (max_typeof(dirtyDatesArray) === 'object' && dirtyDatesArray !== null) {
    datesArray = Array.prototype.slice.call(dirtyDatesArray);
  } else {
    // `dirtyDatesArray` is non-iterable, return Invalid Date
    return new Date(NaN);
  }

  var result;
  datesArray.forEach(function (dirtyDate) {
    var currentDate = toDate(dirtyDate);

    if (result === undefined || result < currentDate || isNaN(Number(currentDate))) {
      result = currentDate;
    }
  });
  return result || new Date(NaN);
}
;// CONCATENATED MODULE: ./node_modules/date-fns/esm/min/index.js
function min_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { min_typeof = function _typeof(obj) { return typeof obj; }; } else { min_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return min_typeof(obj); }



/**
 * @name min
 * @category Common Helpers
 * @summary Returns the earliest of the given dates.
 *
 * @description
 * Returns the earliest of the given dates.
 *
 * @param {Date[]|Number[]} datesArray - the dates to compare
 * @returns {Date} - the earliest of the dates
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // Which of these dates is the earliest?
 * const result = min([
 *   new Date(1989, 6, 10),
 *   new Date(1987, 1, 11),
 *   new Date(1995, 6, 2),
 *   new Date(1990, 0, 1)
 * ])
 * //=> Wed Feb 11 1987 00:00:00
 */

function min(dirtyDatesArray) {
  requiredArgs(1, arguments);
  var datesArray; // `dirtyDatesArray` is Array, Set or Map, or object with custom `forEach` method

  if (dirtyDatesArray && typeof dirtyDatesArray.forEach === 'function') {
    datesArray = dirtyDatesArray; // If `dirtyDatesArray` is Array-like Object, convert to Array.
  } else if (min_typeof(dirtyDatesArray) === 'object' && dirtyDatesArray !== null) {
    datesArray = Array.prototype.slice.call(dirtyDatesArray);
  } else {
    // `dirtyDatesArray` is non-iterable, return Invalid Date
    return new Date(NaN);
  }

  var result;
  datesArray.forEach(function (dirtyDate) {
    var currentDate = toDate(dirtyDate);

    if (result === undefined || result > currentDate || isNaN(currentDate.getDate())) {
      result = currentDate;
    }
  });
  return result || new Date(NaN);
}
;// CONCATENATED MODULE: ./node_modules/date-fns/esm/differenceInCalendarWeeks/index.js



var differenceInCalendarWeeks_MILLISECONDS_IN_WEEK = 604800000;
/**
 * @name differenceInCalendarWeeks
 * @category Week Helpers
 * @summary Get the number of calendar weeks between the given dates.
 *
 * @description
 * Get the number of calendar weeks between the given dates.
 *
 * @param {Date|Number} dateLeft - the later date
 * @param {Date|Number} dateRight - the earlier date
 * @param {Object} [options] - an object with options.
 * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
 * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
 * @returns {Number} the number of calendar weeks
 * @throws {TypeError} 2 arguments required
 * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
 *
 * @example
 * // How many calendar weeks are between 5 July 2014 and 20 July 2014?
 * const result = differenceInCalendarWeeks(
 *   new Date(2014, 6, 20),
 *   new Date(2014, 6, 5)
 * )
 * //=> 3
 *
 * @example
 * // If the week starts on Monday,
 * // how many calendar weeks are between 5 July 2014 and 20 July 2014?
 * const result = differenceInCalendarWeeks(
 *   new Date(2014, 6, 20),
 *   new Date(2014, 6, 5),
 *   { weekStartsOn: 1 }
 * )
 * //=> 2
 */

function differenceInCalendarWeeks(dirtyDateLeft, dirtyDateRight, options) {
  requiredArgs(2, arguments);
  var startOfWeekLeft = startOfWeek(dirtyDateLeft, options);
  var startOfWeekRight = startOfWeek(dirtyDateRight, options);
  var timestampLeft = startOfWeekLeft.getTime() - getTimezoneOffsetInMilliseconds(startOfWeekLeft);
  var timestampRight = startOfWeekRight.getTime() - getTimezoneOffsetInMilliseconds(startOfWeekRight); // Round the number of days to the nearest integer
  // because the number of milliseconds in a week is not constant
  // (e.g. it's different in the week of the daylight saving time clock shift)

  return Math.round((timestampLeft - timestampRight) / differenceInCalendarWeeks_MILLISECONDS_IN_WEEK);
}
;// CONCATENATED MODULE: ./node_modules/date-fns/esm/lastDayOfMonth/index.js


/**
 * @name lastDayOfMonth
 * @category Month Helpers
 * @summary Return the last day of a month for the given date.
 *
 * @description
 * Return the last day of a month for the given date.
 * The result will be in the local timezone.
 *
 * @param {Date|Number} date - the original date
 * @returns {Date} the last day of a month
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // The last day of a month for 2 September 2014 11:55:00:
 * const result = lastDayOfMonth(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Tue Sep 30 2014 00:00:00
 */

function lastDayOfMonth(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var month = date.getMonth();
  date.setFullYear(date.getFullYear(), month + 1, 0);
  date.setHours(0, 0, 0, 0);
  return date;
}
;// CONCATENATED MODULE: ./node_modules/date-fns/esm/getWeeksInMonth/index.js





/**
 * @name getWeeksInMonth
 * @category Week Helpers
 * @summary Get the number of calendar weeks a month spans.
 *
 * @description
 * Get the number of calendar weeks the month in the given date spans.
 *
 * @param {Date|Number} date - the given date
 * @param {Object} [options] - an object with options.
 * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
 * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
 * @returns {Number} the number of calendar weeks
 * @throws {TypeError} 2 arguments required
 * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
 *
 * @example
 * // How many calendar weeks does February 2015 span?
 * const result = getWeeksInMonth(new Date(2015, 1, 8))
 * //=> 4
 *
 * @example
 * // If the week starts on Monday,
 * // how many calendar weeks does July 2017 span?
 * const result = getWeeksInMonth(new Date(2017, 6, 5), { weekStartsOn: 1 })
 * //=> 6
 */
function getWeeksInMonth(date, options) {
  requiredArgs(1, arguments);
  return differenceInCalendarWeeks(lastDayOfMonth(date), startOfMonth(date), options) + 1;
}
;// CONCATENATED MODULE: ./node_modules/date-fns/esm/getISOWeekYear/index.js



/**
 * @name getISOWeekYear
 * @category ISO Week-Numbering Year Helpers
 * @summary Get the ISO week-numbering year of the given date.
 *
 * @description
 * Get the ISO week-numbering year of the given date,
 * which always starts 3 days before the year's first Thursday.
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @param {Date|Number} date - the given date
 * @returns {Number} the ISO week-numbering year
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // Which ISO-week numbering year is 2 January 2005?
 * const result = getISOWeekYear(new Date(2005, 0, 2))
 * //=> 2004
 */

function getISOWeekYear(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var year = date.getFullYear();
  var fourthOfJanuaryOfNextYear = new Date(0);
  fourthOfJanuaryOfNextYear.setFullYear(year + 1, 0, 4);
  fourthOfJanuaryOfNextYear.setHours(0, 0, 0, 0);
  var startOfNextYear = startOfISOWeek(fourthOfJanuaryOfNextYear);
  var fourthOfJanuaryOfThisYear = new Date(0);
  fourthOfJanuaryOfThisYear.setFullYear(year, 0, 4);
  fourthOfJanuaryOfThisYear.setHours(0, 0, 0, 0);
  var startOfThisYear = startOfISOWeek(fourthOfJanuaryOfThisYear);

  if (date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}
;// CONCATENATED MODULE: ./node_modules/date-fns/esm/startOfISOWeekYear/index.js



/**
 * @name startOfISOWeekYear
 * @category ISO Week-Numbering Year Helpers
 * @summary Return the start of an ISO week-numbering year for the given date.
 *
 * @description
 * Return the start of an ISO week-numbering year,
 * which always starts 3 days before the year's first Thursday.
 * The result will be in the local timezone.
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @param {Date|Number} date - the original date
 * @returns {Date} the start of an ISO week-numbering year
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // The start of an ISO week-numbering year for 2 July 2005:
 * const result = startOfISOWeekYear(new Date(2005, 6, 2))
 * //=> Mon Jan 03 2005 00:00:00
 */

function startOfISOWeekYear(dirtyDate) {
  requiredArgs(1, arguments);
  var year = getISOWeekYear(dirtyDate);
  var fourthOfJanuary = new Date(0);
  fourthOfJanuary.setFullYear(year, 0, 4);
  fourthOfJanuary.setHours(0, 0, 0, 0);
  var date = startOfISOWeek(fourthOfJanuary);
  return date;
}
;// CONCATENATED MODULE: ./node_modules/date-fns/esm/getISOWeek/index.js




var getISOWeek_MILLISECONDS_IN_WEEK = 604800000;
/**
 * @name getISOWeek
 * @category ISO Week Helpers
 * @summary Get the ISO week of the given date.
 *
 * @description
 * Get the ISO week of the given date.
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @param {Date|Number} date - the given date
 * @returns {Number} the ISO week
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // Which week of the ISO-week numbering year is 2 January 2005?
 * const result = getISOWeek(new Date(2005, 0, 2))
 * //=> 53
 */

function getISOWeek(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var diff = startOfISOWeek(date).getTime() - startOfISOWeekYear(date).getTime(); // Round the number of days to the nearest integer
  // because the number of milliseconds in a week is not constant
  // (e.g. it's different in the week of the daylight saving time clock shift)

  return Math.round(diff / getISOWeek_MILLISECONDS_IN_WEEK) + 1;
}
;// CONCATENATED MODULE: ./node_modules/date-fns/esm/getWeekYear/index.js





/**
 * @name getWeekYear
 * @category Week-Numbering Year Helpers
 * @summary Get the local week-numbering year of the given date.
 *
 * @description
 * Get the local week-numbering year of the given date.
 * The exact calculation depends on the values of
 * `options.weekStartsOn` (which is the index of the first day of the week)
 * and `options.firstWeekContainsDate` (which is the day of January, which is always in
 * the first week of the week-numbering year)
 *
 * Week numbering: https://en.wikipedia.org/wiki/Week#Week_numbering
 *
 * @param {Date|Number} date - the given date
 * @param {Object} [options] - an object with options.
 * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
 * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
 * @param {1|2|3|4|5|6|7} [options.firstWeekContainsDate=1] - the day of January, which is always in the first week of the year
 * @returns {Number} the local week-numbering year
 * @throws {TypeError} 1 argument required
 * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
 * @throws {RangeError} `options.firstWeekContainsDate` must be between 1 and 7
 *
 * @example
 * // Which week numbering year is 26 December 2004 with the default settings?
 * const result = getWeekYear(new Date(2004, 11, 26))
 * //=> 2005
 *
 * @example
 * // Which week numbering year is 26 December 2004 if week starts on Saturday?
 * const result = getWeekYear(new Date(2004, 11, 26), { weekStartsOn: 6 })
 * //=> 2004
 *
 * @example
 * // Which week numbering year is 26 December 2004 if the first week contains 4 January?
 * const result = getWeekYear(new Date(2004, 11, 26), { firstWeekContainsDate: 4 })
 * //=> 2004
 */

function getWeekYear(dirtyDate, options) {
  var _ref, _ref2, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;

  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var year = date.getFullYear();
  var defaultOptions = getDefaultOptions();
  var firstWeekContainsDate = toInteger((_ref = (_ref2 = (_ref3 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref !== void 0 ? _ref : 1); // Test if weekStartsOn is between 1 and 7 _and_ is not NaN

  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError('firstWeekContainsDate must be between 1 and 7 inclusively');
  }

  var firstWeekOfNextYear = new Date(0);
  firstWeekOfNextYear.setFullYear(year + 1, 0, firstWeekContainsDate);
  firstWeekOfNextYear.setHours(0, 0, 0, 0);
  var startOfNextYear = startOfWeek(firstWeekOfNextYear, options);
  var firstWeekOfThisYear = new Date(0);
  firstWeekOfThisYear.setFullYear(year, 0, firstWeekContainsDate);
  firstWeekOfThisYear.setHours(0, 0, 0, 0);
  var startOfThisYear = startOfWeek(firstWeekOfThisYear, options);

  if (date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}
;// CONCATENATED MODULE: ./node_modules/date-fns/esm/startOfWeekYear/index.js





/**
 * @name startOfWeekYear
 * @category Week-Numbering Year Helpers
 * @summary Return the start of a local week-numbering year for the given date.
 *
 * @description
 * Return the start of a local week-numbering year.
 * The exact calculation depends on the values of
 * `options.weekStartsOn` (which is the index of the first day of the week)
 * and `options.firstWeekContainsDate` (which is the day of January, which is always in
 * the first week of the week-numbering year)
 *
 * Week numbering: https://en.wikipedia.org/wiki/Week#Week_numbering
 *
 * @param {Date|Number} date - the original date
 * @param {Object} [options] - an object with options.
 * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
 * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
 * @param {1|2|3|4|5|6|7} [options.firstWeekContainsDate=1] - the day of January, which is always in the first week of the year
 * @returns {Date} the start of a week-numbering year
 * @throws {TypeError} 1 argument required
 * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
 * @throws {RangeError} `options.firstWeekContainsDate` must be between 1 and 7
 *
 * @example
 * // The start of an a week-numbering year for 2 July 2005 with default settings:
 * const result = startOfWeekYear(new Date(2005, 6, 2))
 * //=> Sun Dec 26 2004 00:00:00
 *
 * @example
 * // The start of a week-numbering year for 2 July 2005
 * // if Monday is the first day of week
 * // and 4 January is always in the first week of the year:
 * const result = startOfWeekYear(new Date(2005, 6, 2), {
 *   weekStartsOn: 1,
 *   firstWeekContainsDate: 4
 * })
 * //=> Mon Jan 03 2005 00:00:00
 */

function startOfWeekYear(dirtyDate, options) {
  var _ref, _ref2, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;

  requiredArgs(1, arguments);
  var defaultOptions = getDefaultOptions();
  var firstWeekContainsDate = toInteger((_ref = (_ref2 = (_ref3 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref !== void 0 ? _ref : 1);
  var year = getWeekYear(dirtyDate, options);
  var firstWeek = new Date(0);
  firstWeek.setFullYear(year, 0, firstWeekContainsDate);
  firstWeek.setHours(0, 0, 0, 0);
  var date = startOfWeek(firstWeek, options);
  return date;
}
;// CONCATENATED MODULE: ./node_modules/date-fns/esm/getWeek/index.js




var getWeek_MILLISECONDS_IN_WEEK = 604800000;
/**
 * @name getWeek
 * @category Week Helpers
 * @summary Get the local week index of the given date.
 *
 * @description
 * Get the local week index of the given date.
 * The exact calculation depends on the values of
 * `options.weekStartsOn` (which is the index of the first day of the week)
 * and `options.firstWeekContainsDate` (which is the day of January, which is always in
 * the first week of the week-numbering year)
 *
 * Week numbering: https://en.wikipedia.org/wiki/Week#Week_numbering
 *
 * @param {Date|Number} date - the given date
 * @param {Object} [options] - an object with options.
 * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
 * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
 * @param {1|2|3|4|5|6|7} [options.firstWeekContainsDate=1] - the day of January, which is always in the first week of the year
 * @returns {Number} the week
 * @throws {TypeError} 1 argument required
 * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
 * @throws {RangeError} `options.firstWeekContainsDate` must be between 1 and 7
 *
 * @example
 * // Which week of the local week numbering year is 2 January 2005 with default options?
 * const result = getWeek(new Date(2005, 0, 2))
 * //=> 2
 *
 * // Which week of the local week numbering year is 2 January 2005,
 * // if Monday is the first day of the week,
 * // and the first week of the year always contains 4 January?
 * const result = getWeek(new Date(2005, 0, 2), {
 *   weekStartsOn: 1,
 *   firstWeekContainsDate: 4
 * })
 * //=> 53
 */

function getWeek(dirtyDate, options) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var diff = startOfWeek(date, options).getTime() - startOfWeekYear(date, options).getTime(); // Round the number of days to the nearest integer
  // because the number of milliseconds in a week is not constant
  // (e.g. it's different in the week of the daylight saving time clock shift)

  return Math.round(diff / getWeek_MILLISECONDS_IN_WEEK) + 1;
}
;// CONCATENATED MODULE: ./node_modules/react-day-picker/dist/index.esm.js




































/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function index_esm_rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function __spreadArray(to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
}

/** Returns true when the props are of type {@link DayPickerMultipleProps}. */
function isDayPickerMultiple(props) {
    return props.mode === 'multiple';
}

/** Returns true when the props are of type {@link DayPickerRangeProps}. */
function isDayPickerRange(props) {
    return props.mode === 'range';
}

/** Returns true when the props are of type {@link DayPickerSingleProps}. */
function isDayPickerSingle(props) {
    return props.mode === 'single';
}

/**
 * The name of the default CSS classes.
 */
var defaultClassNames = {
    root: 'rdp',
    multiple_months: 'rdp-multiple_months',
    with_weeknumber: 'rdp-with_weeknumber',
    vhidden: 'rdp-vhidden',
    button_reset: 'rdp-button_reset',
    button: 'rdp-button',
    caption: 'rdp-caption',
    caption_start: 'rdp-caption_start',
    caption_end: 'rdp-caption_end',
    caption_between: 'rdp-caption_between',
    caption_label: 'rdp-caption_label',
    caption_dropdowns: 'rdp-caption_dropdowns',
    dropdown: 'rdp-dropdown',
    dropdown_month: 'rdp-dropdown_month',
    dropdown_year: 'rdp-dropdown_year',
    dropdown_icon: 'rdp-dropdown_icon',
    months: 'rdp-months',
    month: 'rdp-month',
    table: 'rdp-table',
    tbody: 'rdp-tbody',
    tfoot: 'rdp-tfoot',
    head: 'rdp-head',
    head_row: 'rdp-head_row',
    head_cell: 'rdp-head_cell',
    nav: 'rdp-nav',
    nav_button: 'rdp-nav_button',
    nav_button_previous: 'rdp-nav_button_previous',
    nav_button_next: 'rdp-nav_button_next',
    nav_icon: 'rdp-nav_icon',
    row: 'rdp-row',
    weeknumber: 'rdp-weeknumber',
    cell: 'rdp-cell',
    day: 'rdp-day',
    day_today: 'rdp-day_today',
    day_outside: 'rdp-day_outside',
    day_selected: 'rdp-day_selected',
    day_disabled: 'rdp-day_disabled',
    day_hidden: 'rdp-day_hidden',
    day_range_start: 'rdp-day_range_start',
    day_range_end: 'rdp-day_range_end',
    day_range_middle: 'rdp-day_range_middle'
};

/**
 * The default formatter for the caption.
 */
function formatCaption(month, options) {
    return format_format(month, 'LLLL y', options);
}

/**
 * The default formatter for the Day button.
 */
function formatDay(day, options) {
    return format_format(day, 'd', options);
}

/**
 * The default formatter for the Month caption.
 */
function formatMonthCaption(month, options) {
    return format_format(month, 'LLLL', options);
}

/**
 * The default formatter for the week number.
 */
function formatWeekNumber(weekNumber) {
    return "".concat(weekNumber);
}

/**
 * The default formatter for the name of the weekday.
 */
function formatWeekdayName(weekday, options) {
    return format_format(weekday, 'cccccc', options);
}

/**
 * The default formatter for the Year caption.
 */
function formatYearCaption(year, options) {
    return format_format(year, 'yyyy', options);
}

var index_esm_formatters = /*#__PURE__*/Object.freeze({
    __proto__: null,
    formatCaption: formatCaption,
    formatDay: formatDay,
    formatMonthCaption: formatMonthCaption,
    formatWeekNumber: formatWeekNumber,
    formatWeekdayName: formatWeekdayName,
    formatYearCaption: formatYearCaption
});

/**
 * The default ARIA label for the day button.
 */
var labelDay = function (day, activeModifiers, options) {
    return format_format(day, 'do MMMM (EEEE)', options);
};

/**
 * The default ARIA label for the WeekNumber element.
 */
var labelMonthDropdown = function () {
    return 'Month: ';
};

/**
 * The default ARIA label for next month button in navigation
 */
var labelNext = function () {
    return 'Go to next month';
};

/**
 * The default ARIA label for previous month button in navigation
 */
var labelPrevious = function () {
    return 'Go to previous month';
};

/**
 * The default ARIA label for the Weekday element.
 */
var labelWeekday = function (day, options) {
    return format_format(day, 'cccc', options);
};

/**
 * The default ARIA label for the WeekNumber element.
 */
var labelWeekNumber = function (n) {
    return "Week n. ".concat(n);
};

/**
 * The default ARIA label for the WeekNumber element.
 */
var labelYearDropdown = function () {
    return 'Year: ';
};

var labels = /*#__PURE__*/Object.freeze({
    __proto__: null,
    labelDay: labelDay,
    labelMonthDropdown: labelMonthDropdown,
    labelNext: labelNext,
    labelPrevious: labelPrevious,
    labelWeekday: labelWeekday,
    labelWeekNumber: labelWeekNumber,
    labelYearDropdown: labelYearDropdown
});

/**
 * Returns the default values to use in the DayPickerContext, in case they are
 * not passed down with the DayPicker initial props.
 */
function getDefaultContextValues() {
    var captionLayout = 'buttons';
    var classNames = defaultClassNames;
    var locale = en_US;
    var modifiersClassNames = {};
    var modifiers = {};
    var numberOfMonths = 1;
    var styles = {};
    var today = new Date();
    return {
        captionLayout: captionLayout,
        classNames: classNames,
        formatters: index_esm_formatters,
        labels: labels,
        locale: locale,
        modifiersClassNames: modifiersClassNames,
        modifiers: modifiers,
        numberOfMonths: numberOfMonths,
        styles: styles,
        today: today,
        mode: 'default'
    };
}

/** Return the `fromDate` and `toDate` prop values values parsing the DayPicker props. */
function parseFromToProps(props) {
    var fromYear = props.fromYear, toYear = props.toYear, fromMonth = props.fromMonth, toMonth = props.toMonth;
    var fromDate = props.fromDate, toDate = props.toDate;
    if (fromMonth) {
        fromDate = startOfMonth(fromMonth);
    }
    else if (fromYear) {
        fromDate = new Date(fromYear, 0, 1);
    }
    if (toMonth) {
        toDate = endOfMonth(toMonth);
    }
    else if (toYear) {
        toDate = new Date(toYear, 11, 31);
    }
    return {
        fromDate: fromDate ? startOfDay(fromDate) : undefined,
        toDate: toDate ? startOfDay(toDate) : undefined
    };
}

/**
 * The DayPicker context shares the props passed to DayPicker within internal
 * and custom components. It is used to set the default values and perform
 * one-time calculations required to render the days.
 *
 * Access to this context from the {@link useDayPicker} hook.
 */
var DayPickerContext = (0,react.createContext)(undefined);
/**
 * The provider for the {@link DayPickerContext}, assigning the defaults from the
 * initial DayPicker props.
 */
function DayPickerProvider(props) {
    var _a;
    var initialProps = props.initialProps;
    var defaultContextValues = getDefaultContextValues();
    var _b = parseFromToProps(initialProps), fromDate = _b.fromDate, toDate = _b.toDate;
    var captionLayout = (_a = initialProps.captionLayout) !== null && _a !== void 0 ? _a : defaultContextValues.captionLayout;
    if (captionLayout !== 'buttons' && (!fromDate || !toDate)) {
        // When no from/to dates are set, the caption is always buttons
        captionLayout = 'buttons';
    }
    var onSelect;
    if (isDayPickerSingle(initialProps) ||
        isDayPickerMultiple(initialProps) ||
        isDayPickerRange(initialProps)) {
        onSelect = initialProps.onSelect;
    }
    var value = __assign(__assign(__assign({}, defaultContextValues), initialProps), { captionLayout: captionLayout, classNames: __assign(__assign({}, defaultContextValues.classNames), initialProps.classNames), components: __assign({}, initialProps.components), formatters: __assign(__assign({}, defaultContextValues.formatters), initialProps.formatters), fromDate: fromDate, labels: __assign(__assign({}, defaultContextValues.labels), initialProps.labels), mode: initialProps.mode || defaultContextValues.mode, modifiers: __assign(__assign({}, defaultContextValues.modifiers), initialProps.modifiers), modifiersClassNames: __assign(__assign({}, defaultContextValues.modifiersClassNames), initialProps.modifiersClassNames), onSelect: onSelect, styles: __assign(__assign({}, defaultContextValues.styles), initialProps.styles), toDate: toDate });
    return (react.createElement(DayPickerContext.Provider, { value: value }, props.children));
}
/**
 * Hook to access the {@link DayPickerContextValue}.
 *
 * Use the DayPicker context to access to the props passed to DayPicker inside
 * internal or custom components.
 */
function useDayPicker() {
    var context = (0,react.useContext)(DayPickerContext);
    if (!context) {
        throw new Error("useDayPicker must be used within a DayPickerProvider.");
    }
    return context;
}

/** Render the caption for the displayed month. This component is used when `captionLayout="buttons"`. */
function CaptionLabel(props) {
    var _a = useDayPicker(), locale = _a.locale, classNames = _a.classNames, styles = _a.styles, formatCaption = _a.formatters.formatCaption;
    return (react.createElement("h2", { className: classNames.caption_label, style: styles.caption_label, "aria-live": "polite", "aria-atomic": "true", id: props.id }, formatCaption(props.displayMonth, { locale: locale })));
}

/**
 * Render the icon in the styled drop-down.
 */
function IconDropdown(props) {
    return (react.createElement("svg", __assign({ width: "8px", height: "8px", viewBox: "0 0 120 120", "data-testid": "iconDropdown" }, props),
        react.createElement("path", { d: "M4.22182541,48.2218254 C8.44222828,44.0014225 15.2388494,43.9273804 19.5496459,47.9996989 L19.7781746,48.2218254 L60,88.443 L100.221825,48.2218254 C104.442228,44.0014225 111.238849,43.9273804 115.549646,47.9996989 L115.778175,48.2218254 C119.998577,52.4422283 120.07262,59.2388494 116.000301,63.5496459 L115.778175,63.7781746 L67.7781746,111.778175 C63.5577717,115.998577 56.7611506,116.07262 52.4503541,112.000301 L52.2218254,111.778175 L4.22182541,63.7781746 C-0.0739418023,59.4824074 -0.0739418023,52.5175926 4.22182541,48.2218254 Z", fill: "currentColor", fillRule: "nonzero" })));
}

/**
 * Render a styled select component  displaying a caption and a custom
 * drop-down icon.
 */
function index_esm_Dropdown(props) {
    var _a, _b;
    var onChange = props.onChange, value = props.value, children = props.children, caption = props.caption, className = props.className, style = props.style;
    var dayPicker = useDayPicker();
    var IconDropdownComponent = (_b = (_a = dayPicker.components) === null || _a === void 0 ? void 0 : _a.IconDropdown) !== null && _b !== void 0 ? _b : IconDropdown;
    return (react.createElement("div", { className: className, style: style },
        react.createElement("span", { className: dayPicker.classNames.vhidden }, props['aria-label']),
        react.createElement("select", { name: props.name, "aria-label": props['aria-label'], className: dayPicker.classNames.dropdown, style: dayPicker.styles.dropdown, value: value, onChange: onChange }, children),
        react.createElement("div", { className: dayPicker.classNames.caption_label, style: dayPicker.styles.caption_label, "aria-hidden": "true" },
            caption,
            react.createElement(IconDropdownComponent, { className: dayPicker.classNames.dropdown_icon, style: dayPicker.styles.dropdown_icon }))));
}

/** Render the dropdown to navigate between months. */
function MonthsDropdown(props) {
    var _a;
    var _b = useDayPicker(), fromDate = _b.fromDate, toDate = _b.toDate, styles = _b.styles, locale = _b.locale, formatMonthCaption = _b.formatters.formatMonthCaption, classNames = _b.classNames, components = _b.components, labelMonthDropdown = _b.labels.labelMonthDropdown;
    // Dropdown should appear only when both from/toDate is set
    if (!fromDate)
        return react.createElement(react.Fragment, null);
    if (!toDate)
        return react.createElement(react.Fragment, null);
    var dropdownMonths = [];
    if (isSameYear(fromDate, toDate)) {
        // only display the months included in the range
        var date = startOfMonth(fromDate);
        for (var month = fromDate.getMonth(); month <= toDate.getMonth(); month++) {
            dropdownMonths.push(setMonth(date, month));
        }
    }
    else {
        // display all the 12 months
        var date = startOfMonth(new Date()); // Any date should be OK, as we just need the year
        for (var month = 0; month <= 11; month++) {
            dropdownMonths.push(setMonth(date, month));
        }
    }
    var handleChange = function (e) {
        var selectedMonth = Number(e.target.value);
        var newMonth = setMonth(startOfMonth(props.displayMonth), selectedMonth);
        props.onChange(newMonth);
    };
    var DropdownComponent = (_a = components === null || components === void 0 ? void 0 : components.Dropdown) !== null && _a !== void 0 ? _a : index_esm_Dropdown;
    return (react.createElement(DropdownComponent, { name: "months", "aria-label": labelMonthDropdown(), className: classNames.dropdown_month, style: styles.dropdown_month, onChange: handleChange, value: props.displayMonth.getMonth(), caption: formatMonthCaption(props.displayMonth, { locale: locale }) }, dropdownMonths.map(function (m) { return (react.createElement("option", { key: m.getMonth(), value: m.getMonth() }, formatMonthCaption(m, { locale: locale }))); })));
}

/**
 * Render a dropdown to change the year. Take in account the `nav.fromDate` and
 * `toDate` from context.
 */
function YearsDropdown(props) {
    var _a;
    var displayMonth = props.displayMonth;
    var _b = useDayPicker(), fromDate = _b.fromDate, toDate = _b.toDate, locale = _b.locale, styles = _b.styles, classNames = _b.classNames, components = _b.components, formatYearCaption = _b.formatters.formatYearCaption, labelYearDropdown = _b.labels.labelYearDropdown;
    var years = [];
    // Dropdown should appear only when both from/toDate is set
    if (!fromDate)
        return react.createElement(react.Fragment, null);
    if (!toDate)
        return react.createElement(react.Fragment, null);
    var fromYear = fromDate.getFullYear();
    var toYear = toDate.getFullYear();
    for (var year = fromYear; year <= toYear; year++) {
        years.push(setYear(startOfYear(new Date()), year));
    }
    var handleChange = function (e) {
        var newMonth = setYear(startOfMonth(displayMonth), Number(e.target.value));
        props.onChange(newMonth);
    };
    var DropdownComponent = (_a = components === null || components === void 0 ? void 0 : components.Dropdown) !== null && _a !== void 0 ? _a : index_esm_Dropdown;
    return (react.createElement(DropdownComponent, { name: "years", "aria-label": labelYearDropdown(), className: classNames.dropdown_year, style: styles.dropdown_year, onChange: handleChange, value: displayMonth.getFullYear(), caption: formatYearCaption(displayMonth, { locale: locale }) }, years.map(function (year) { return (react.createElement("option", { key: year.getFullYear(), value: year.getFullYear() }, formatYearCaption(year, { locale: locale }))); })));
}

/**
 * Helper hook for using controlled/uncontrolled values from a component props.
 *
 * When the value is not controlled, pass `undefined` as `controlledValue` and
 * use the returned setter to update it.
 *
 * When the value is controlled, pass the controlled value as second
 * argument, which will be always returned as `value`.
 */
function useControlledValue(defaultValue, controlledValue) {
    var _a = (0,react.useState)(defaultValue), uncontrolledValue = _a[0], setValue = _a[1];
    var value = controlledValue === undefined ? uncontrolledValue : controlledValue;
    return [value, setValue];
}

/** Return the initial month according to the given options. */
function getInitialMonth(context) {
    var month = context.month, defaultMonth = context.defaultMonth, today = context.today;
    var initialMonth = month || defaultMonth || today || new Date();
    var toDate = context.toDate, fromDate = context.fromDate, _a = context.numberOfMonths, numberOfMonths = _a === void 0 ? 1 : _a;
    // Fix the initialMonth if is after the to-date
    if (toDate && differenceInCalendarMonths(toDate, initialMonth) < 0) {
        var offset = -1 * (numberOfMonths - 1);
        initialMonth = addMonths(toDate, offset);
    }
    // Fix the initialMonth if is before the from-date
    if (fromDate && differenceInCalendarMonths(initialMonth, fromDate) < 0) {
        initialMonth = fromDate;
    }
    return startOfMonth(initialMonth);
}

/** Controls the navigation state. */
function useNavigationState() {
    var context = useDayPicker();
    var initialMonth = getInitialMonth(context);
    var _a = useControlledValue(initialMonth, context.month), month = _a[0], setMonth = _a[1];
    var goToMonth = function (date) {
        var _a;
        if (context.disableNavigation)
            return;
        var month = startOfMonth(date);
        setMonth(month);
        (_a = context.onMonthChange) === null || _a === void 0 ? void 0 : _a.call(context, month);
    };
    return [month, goToMonth];
}

/**
 * Return the months to display in the component according to the number of
 * months and the from/to date.
 */
function getDisplayMonths(month, _a) {
    var reverseMonths = _a.reverseMonths, numberOfMonths = _a.numberOfMonths;
    var start = startOfMonth(month);
    var end = startOfMonth(addMonths(start, numberOfMonths));
    var monthsDiff = differenceInCalendarMonths(end, start);
    var months = [];
    for (var i = 0; i < monthsDiff; i++) {
        var nextMonth = addMonths(start, i);
        months.push(nextMonth);
    }
    if (reverseMonths)
        months = months.reverse();
    return months;
}

/**
 * Returns the next month the user can navigate to according to the given
 * options.
 *
 * Please note that the next month is not always the next calendar month:
 *
 * - if after the `toDate` range, is undefined;
 * - if the navigation is paged, is the number of months displayed ahead.
 *
 */
function getNextMonth(startingMonth, options) {
    if (options.disableNavigation) {
        return undefined;
    }
    var toDate = options.toDate, pagedNavigation = options.pagedNavigation, _a = options.numberOfMonths, numberOfMonths = _a === void 0 ? 1 : _a;
    var offset = pagedNavigation ? numberOfMonths : 1;
    var month = startOfMonth(startingMonth);
    if (!toDate) {
        return addMonths(month, offset);
    }
    var monthsDiff = differenceInCalendarMonths(toDate, startingMonth);
    if (monthsDiff < numberOfMonths) {
        return undefined;
    }
    // Jump forward as the number of months when paged navigation
    return addMonths(month, offset);
}

/**
 * Returns the next previous the user can navigate to, according to the given
 * options.
 *
 * Please note that the previous month is not always the previous calendar
 * month:
 *
 * - if before the `fromDate` date, is `undefined`;
 * - if the navigation is paged, is the number of months displayed before.
 *
 */
function getPreviousMonth(startingMonth, options) {
    if (options.disableNavigation) {
        return undefined;
    }
    var fromDate = options.fromDate, pagedNavigation = options.pagedNavigation, _a = options.numberOfMonths, numberOfMonths = _a === void 0 ? 1 : _a;
    var offset = pagedNavigation ? numberOfMonths : 1;
    var month = startOfMonth(startingMonth);
    if (!fromDate) {
        return addMonths(month, -offset);
    }
    var monthsDiff = differenceInCalendarMonths(month, fromDate);
    if (monthsDiff <= 0) {
        return undefined;
    }
    // Jump back as the number of months when paged navigation
    return addMonths(month, -offset);
}

/**
 * The Navigation context shares details and methods to navigate the months in DayPicker.
 * Access this context from the {@link useNavigation} hook.
 */
var NavigationContext = (0,react.createContext)(undefined);
/** Provides the values for the {@link NavigationContext}. */
function NavigationProvider(props) {
    var dayPicker = useDayPicker();
    var _a = useNavigationState(), currentMonth = _a[0], goToMonth = _a[1];
    var displayMonths = getDisplayMonths(currentMonth, dayPicker);
    var nextMonth = getNextMonth(currentMonth, dayPicker);
    var previousMonth = getPreviousMonth(currentMonth, dayPicker);
    var isDateDisplayed = function (date) {
        return displayMonths.some(function (displayMonth) {
            return isSameMonth(date, displayMonth);
        });
    };
    var goToDate = function (date, refDate) {
        if (isDateDisplayed(date)) {
            return;
        }
        if (refDate && isBefore(date, refDate)) {
            goToMonth(addMonths(date, 1 + dayPicker.numberOfMonths * -1));
        }
        else {
            goToMonth(date);
        }
    };
    var value = {
        currentMonth: currentMonth,
        displayMonths: displayMonths,
        goToMonth: goToMonth,
        goToDate: goToDate,
        previousMonth: previousMonth,
        nextMonth: nextMonth,
        isDateDisplayed: isDateDisplayed
    };
    return (react.createElement(NavigationContext.Provider, { value: value }, props.children));
}
/**
 * Hook to access the {@link NavigationContextValue}. Use this hook to navigate
 * between months or years in DayPicker.
 *
 * This hook is meant to be used inside internal or custom components.
 */
function useNavigation() {
    var context = (0,react.useContext)(NavigationContext);
    if (!context) {
        throw new Error('useNavigation must be used within a NavigationProvider');
    }
    return context;
}

/**
 * Render a caption with the dropdowns to navigate between months and years.
 */
function CaptionDropdowns(props) {
    var _a;
    var _b = useDayPicker(), classNames = _b.classNames, styles = _b.styles, components = _b.components;
    var goToMonth = useNavigation().goToMonth;
    var handleMonthChange = function (newMonth) {
        goToMonth(newMonth);
    };
    var CaptionLabelComponent = (_a = components === null || components === void 0 ? void 0 : components.CaptionLabel) !== null && _a !== void 0 ? _a : CaptionLabel;
    var captionLabel = (react.createElement(CaptionLabelComponent, { id: props.id, displayMonth: props.displayMonth }));
    return (react.createElement("div", { className: classNames.caption_dropdowns, style: styles.caption_dropdowns },
        react.createElement("div", { className: classNames.vhidden }, captionLabel),
        react.createElement(MonthsDropdown, { onChange: handleMonthChange, displayMonth: props.displayMonth }),
        react.createElement(YearsDropdown, { onChange: handleMonthChange, displayMonth: props.displayMonth })));
}

/**
 * Render the "previous month" button in the navigation.
 */
function index_esm_IconLeft(props) {
    return (react.createElement("svg", __assign({ width: "16px", height: "16px", viewBox: "0 0 120 120" }, props),
        react.createElement("path", { d: "M69.490332,3.34314575 C72.6145263,0.218951416 77.6798462,0.218951416 80.8040405,3.34314575 C83.8617626,6.40086786 83.9268205,11.3179931 80.9992143,14.4548388 L80.8040405,14.6568542 L35.461,60 L80.8040405,105.343146 C83.8617626,108.400868 83.9268205,113.317993 80.9992143,116.454839 L80.8040405,116.656854 C77.7463184,119.714576 72.8291931,119.779634 69.6923475,116.852028 L69.490332,116.656854 L18.490332,65.6568542 C15.4326099,62.5991321 15.367552,57.6820069 18.2951583,54.5451612 L18.490332,54.3431458 L69.490332,3.34314575 Z", fill: "currentColor", fillRule: "nonzero" })));
}

/**
 * Render the "next month" button in the navigation.
 */
function index_esm_IconRight(props) {
    return (react.createElement("svg", __assign({ width: "16px", height: "16px", viewBox: "0 0 120 120" }, props),
        react.createElement("path", { d: "M49.8040405,3.34314575 C46.6798462,0.218951416 41.6145263,0.218951416 38.490332,3.34314575 C35.4326099,6.40086786 35.367552,11.3179931 38.2951583,14.4548388 L38.490332,14.6568542 L83.8333725,60 L38.490332,105.343146 C35.4326099,108.400868 35.367552,113.317993 38.2951583,116.454839 L38.490332,116.656854 C41.5480541,119.714576 46.4651794,119.779634 49.602025,116.852028 L49.8040405,116.656854 L100.804041,65.6568542 C103.861763,62.5991321 103.926821,57.6820069 100.999214,54.5451612 L100.804041,54.3431458 L49.8040405,3.34314575 Z", fill: "currentColor" })));
}

/**
 * Render a button HTML element applying the reset class name.
 */
var index_esm_Button = (0,react.forwardRef)(function (props, ref) {
    var _a = useDayPicker(), classNames = _a.classNames, styles = _a.styles;
    var classNamesArr = [classNames.button_reset, classNames.button];
    if (props.className) {
        classNamesArr.push(props.className);
    }
    var className = classNamesArr.join(' ');
    var style = __assign(__assign({}, styles.button_reset), styles.button);
    if (props.style) {
        Object.assign(style, props.style);
    }
    return (react.createElement("button", __assign({}, props, { ref: ref, type: "button", className: className, style: style })));
});

/** A component rendering the navigation buttons or the drop-downs. */
function Navigation(props) {
    var _a, _b;
    var _c = useDayPicker(), dir = _c.dir, locale = _c.locale, classNames = _c.classNames, styles = _c.styles, _d = _c.labels, labelPrevious = _d.labelPrevious, labelNext = _d.labelNext, components = _c.components;
    if (!props.nextMonth && !props.previousMonth) {
        return react.createElement(react.Fragment, null);
    }
    var previousLabel = labelPrevious(props.previousMonth, { locale: locale });
    var previousClassName = [
        classNames.nav_button,
        classNames.nav_button_previous
    ].join(' ');
    var nextLabel = labelNext(props.nextMonth, { locale: locale });
    var nextClassName = [
        classNames.nav_button,
        classNames.nav_button_next
    ].join(' ');
    var IconRightComponent = (_a = components === null || components === void 0 ? void 0 : components.IconRight) !== null && _a !== void 0 ? _a : index_esm_IconRight;
    var IconLeftComponent = (_b = components === null || components === void 0 ? void 0 : components.IconLeft) !== null && _b !== void 0 ? _b : index_esm_IconLeft;
    return (react.createElement("div", { className: classNames.nav, style: styles.nav },
        !props.hidePrevious && (react.createElement(index_esm_Button, { name: "previous-month", "aria-label": previousLabel, className: previousClassName, style: styles.nav_button_previous, disabled: !props.previousMonth, onClick: props.onPreviousClick }, dir === 'rtl' ? (react.createElement(IconRightComponent, { className: classNames.nav_icon, style: styles.nav_icon })) : (react.createElement(IconLeftComponent, { className: classNames.nav_icon, style: styles.nav_icon })))),
        !props.hideNext && (react.createElement(index_esm_Button, { name: "next-month", "aria-label": nextLabel, className: nextClassName, style: styles.nav_button_next, disabled: !props.nextMonth, onClick: props.onNextClick }, dir === 'rtl' ? (react.createElement(IconLeftComponent, { className: classNames.nav_icon, style: styles.nav_icon })) : (react.createElement(IconRightComponent, { className: classNames.nav_icon, style: styles.nav_icon }))))));
}

/**
 * Render a caption with a button-based navigation.
 */
function CaptionNavigation(props) {
    var _a;
    var _b;
    var _c = useDayPicker(), numberOfMonths = _c.numberOfMonths, dir = _c.dir, components = _c.components;
    var _d = useNavigation(), previousMonth = _d.previousMonth, nextMonth = _d.nextMonth, goToMonth = _d.goToMonth, displayMonths = _d.displayMonths;
    var displayIndex = displayMonths.findIndex(function (month) {
        return isSameMonth(props.displayMonth, month);
    });
    var isFirst = displayIndex === 0;
    var isLast = displayIndex === displayMonths.length - 1;
    if (dir === 'rtl') {
        _a = [isFirst, isLast], isLast = _a[0], isFirst = _a[1];
    }
    var hideNext = numberOfMonths > 1 && (isFirst || !isLast);
    var hidePrevious = numberOfMonths > 1 && (isLast || !isFirst);
    var handlePreviousClick = function () {
        if (!previousMonth)
            return;
        goToMonth(previousMonth);
    };
    var handleNextClick = function () {
        if (!nextMonth)
            return;
        goToMonth(nextMonth);
    };
    var CaptionLabelComponent = (_b = components === null || components === void 0 ? void 0 : components.CaptionLabel) !== null && _b !== void 0 ? _b : CaptionLabel;
    var captionLabel = (react.createElement(CaptionLabelComponent, { id: props.id, displayMonth: props.displayMonth }));
    return (react.createElement(react.Fragment, null,
        captionLabel,
        react.createElement(Navigation, { displayMonth: props.displayMonth, hideNext: hideNext, hidePrevious: hidePrevious, nextMonth: nextMonth, previousMonth: previousMonth, onPreviousClick: handlePreviousClick, onNextClick: handleNextClick })));
}

/**
 * Render the caption of a month. The caption has a different layout when
 * setting the {@link DayPickerBase.captionLayout} prop.
 */
function Caption(props) {
    var _a;
    var _b = useDayPicker(), classNames = _b.classNames, disableNavigation = _b.disableNavigation, styles = _b.styles, captionLayout = _b.captionLayout, components = _b.components;
    var CaptionLabelComponent = (_a = components === null || components === void 0 ? void 0 : components.CaptionLabel) !== null && _a !== void 0 ? _a : CaptionLabel;
    var caption;
    if (disableNavigation) {
        caption = (react.createElement(CaptionLabelComponent, { id: props.id, displayMonth: props.displayMonth }));
    }
    else if (captionLayout === 'dropdown') {
        caption = (react.createElement(CaptionDropdowns, { displayMonth: props.displayMonth, id: props.id }));
    }
    else {
        caption = (react.createElement(CaptionNavigation, { displayMonth: props.displayMonth, id: props.id }));
    }
    return (react.createElement("div", { className: classNames.caption, style: styles.caption }, caption));
}

/** Render the Footer component (empty as default).*/
function Footer() {
    var _a = useDayPicker(), footer = _a.footer, styles = _a.styles, tfoot = _a.classNames.tfoot;
    if (!footer)
        return react.createElement(react.Fragment, null);
    return (react.createElement("tfoot", { className: tfoot, style: styles.tfoot },
        react.createElement("tr", null,
            react.createElement("td", { colSpan: 8 }, footer))));
}

/**
 * Generate a series of 7 days, starting from the week, to use for formatting
 * the weekday names (Monday, Tuesday, etc.).
 */
function getWeekdays(locale, 
/** The index of the first day of the week (0 - Sunday). */
weekStartsOn, 
/** Use ISOWeek instead of locale/ */
ISOWeek) {
    var start = ISOWeek
        ? startOfISOWeek(new Date())
        : startOfWeek(new Date(), { locale: locale, weekStartsOn: weekStartsOn });
    var days = [];
    for (var i = 0; i < 7; i++) {
        var day = addDays(start, i);
        days.push(day);
    }
    return days;
}

/**
 * Render the HeadRow component - i.e. the table head row with the weekday names.
 */
function HeadRow() {
    var _a = useDayPicker(), classNames = _a.classNames, styles = _a.styles, showWeekNumber = _a.showWeekNumber, locale = _a.locale, weekStartsOn = _a.weekStartsOn, ISOWeek = _a.ISOWeek, formatWeekdayName = _a.formatters.formatWeekdayName, labelWeekday = _a.labels.labelWeekday;
    var weekdays = getWeekdays(locale, weekStartsOn, ISOWeek);
    return (react.createElement("tr", { style: styles.head_row, className: classNames.head_row },
        showWeekNumber && (react.createElement("th", { scope: "col", style: styles.head_cell, className: classNames.head_cell })),
        weekdays.map(function (weekday, i) { return (react.createElement("th", { key: i, scope: "col", className: classNames.head_cell, style: styles.head_cell },
            react.createElement("span", { "aria-hidden": true }, formatWeekdayName(weekday, { locale: locale })),
            react.createElement("span", { className: classNames.vhidden }, labelWeekday(weekday, { locale: locale })))); })));
}

/** Render the table head. */
function index_esm_Head() {
    var _a;
    var _b = useDayPicker(), classNames = _b.classNames, styles = _b.styles, components = _b.components;
    var HeadRowComponent = (_a = components === null || components === void 0 ? void 0 : components.HeadRow) !== null && _a !== void 0 ? _a : HeadRow;
    return (react.createElement("thead", { style: styles.head, className: classNames.head },
        react.createElement(HeadRowComponent, null)));
}

/** Render the content of the day cell. */
function DayContent(props) {
    var _a = useDayPicker(), locale = _a.locale, formatDay = _a.formatters.formatDay;
    return react.createElement(react.Fragment, null, formatDay(props.date, { locale: locale }));
}

/**
 * The SelectMultiple context shares details about the selected days when in
 * multiple selection mode.
 *
 * Access this context from the {@link useSelectMultiple} hook.
 */
var SelectMultipleContext = (0,react.createContext)(undefined);
/** Provides the values for the {@link SelectMultipleContext}. */
function SelectMultipleProvider(props) {
    if (!isDayPickerMultiple(props.initialProps)) {
        var emptyContextValue = {
            selected: undefined,
            modifiers: {
                disabled: []
            }
        };
        return (react.createElement(SelectMultipleContext.Provider, { value: emptyContextValue }, props.children));
    }
    return (react.createElement(SelectMultipleProviderInternal, { initialProps: props.initialProps, children: props.children }));
}
function SelectMultipleProviderInternal(_a) {
    var initialProps = _a.initialProps, children = _a.children;
    var selected = initialProps.selected, min = initialProps.min, max = initialProps.max;
    var onDayClick = function (day, activeModifiers, e) {
        var _a, _b;
        (_a = initialProps.onDayClick) === null || _a === void 0 ? void 0 : _a.call(initialProps, day, activeModifiers, e);
        var isMinSelected = Boolean(activeModifiers.selected && min && (selected === null || selected === void 0 ? void 0 : selected.length) === min);
        if (isMinSelected) {
            return;
        }
        var isMaxSelected = Boolean(!activeModifiers.selected && max && (selected === null || selected === void 0 ? void 0 : selected.length) === max);
        if (isMaxSelected) {
            return;
        }
        var selectedDays = selected ? __spreadArray([], selected, true) : [];
        if (activeModifiers.selected) {
            var index = selectedDays.findIndex(function (selectedDay) {
                return isSameDay(day, selectedDay);
            });
            selectedDays.splice(index, 1);
        }
        else {
            selectedDays.push(day);
        }
        (_b = initialProps.onSelect) === null || _b === void 0 ? void 0 : _b.call(initialProps, selectedDays, day, activeModifiers, e);
    };
    var modifiers = {
        disabled: []
    };
    if (selected) {
        modifiers.disabled.push(function (day) {
            var isMaxSelected = max && selected.length > max - 1;
            var isSelected = selected.some(function (selectedDay) {
                return isSameDay(selectedDay, day);
            });
            return Boolean(isMaxSelected && !isSelected);
        });
    }
    var contextValue = {
        selected: selected,
        onDayClick: onDayClick,
        modifiers: modifiers
    };
    return (react.createElement(SelectMultipleContext.Provider, { value: contextValue }, children));
}
/**
 * Hook to access the {@link SelectMultipleContextValue}.
 *
 * This hook is meant to be used inside internal or custom components.
 */
function useSelectMultiple() {
    var context = (0,react.useContext)(SelectMultipleContext);
    if (!context) {
        throw new Error('useSelectMultiple must be used within a SelectMultipleProvider');
    }
    return context;
}

/**
 * Add a day to an existing range.
 *
 * The returned range takes in account the `undefined` values and if the added
 * day is already present in the range.
 */
function addToRange(day, range) {
    var _a = range || {}, from = _a.from, to = _a.to;
    if (!from) {
        return { from: day, to: undefined };
    }
    if (!to && isSameDay(from, day)) {
        return { from: from, to: day };
    }
    if (!to && isBefore(day, from)) {
        return { from: day, to: from };
    }
    if (!to) {
        return { from: from, to: day };
    }
    if (isSameDay(to, day) && isSameDay(from, day)) {
        return undefined;
    }
    if (isSameDay(to, day)) {
        return { from: to, to: undefined };
    }
    if (isSameDay(from, day)) {
        return undefined;
    }
    if (isAfter(from, day)) {
        return { from: day, to: to };
    }
    return { from: from, to: day };
}

/**
 * The SelectRange context shares details about the selected days when in
 * range selection mode.
 *
 * Access this context from the {@link useSelectRange} hook.
 */
var SelectRangeContext = (0,react.createContext)(undefined);
/** Provides the values for the {@link SelectRangeProvider}. */
function SelectRangeProvider(props) {
    if (!isDayPickerRange(props.initialProps)) {
        var emptyContextValue = {
            selected: undefined,
            modifiers: {
                range_start: [],
                range_end: [],
                range_middle: [],
                disabled: []
            }
        };
        return (react.createElement(SelectRangeContext.Provider, { value: emptyContextValue }, props.children));
    }
    return (react.createElement(SelectRangeProviderInternal, { initialProps: props.initialProps, children: props.children }));
}
function SelectRangeProviderInternal(_a) {
    var initialProps = _a.initialProps, children = _a.children;
    var selected = initialProps.selected;
    var _b = selected || {}, selectedFrom = _b.from, selectedTo = _b.to;
    var min = initialProps.min;
    var max = initialProps.max;
    var onDayClick = function (day, activeModifiers, e) {
        var _a, _b;
        (_a = initialProps.onDayClick) === null || _a === void 0 ? void 0 : _a.call(initialProps, day, activeModifiers, e);
        var newRange = addToRange(day, selected);
        (_b = initialProps.onSelect) === null || _b === void 0 ? void 0 : _b.call(initialProps, newRange, day, activeModifiers, e);
    };
    var modifiers = {
        range_start: [],
        range_end: [],
        range_middle: [],
        disabled: []
    };
    if (selectedFrom) {
        modifiers.range_start = [selectedFrom];
        if (!selectedTo) {
            modifiers.range_end = [selectedFrom];
        }
        else {
            modifiers.range_end = [selectedTo];
            if (!isSameDay(selectedFrom, selectedTo)) {
                modifiers.range_middle = [
                    {
                        after: selectedFrom,
                        before: selectedTo
                    }
                ];
            }
        }
    }
    if (min) {
        if (selectedFrom && !selectedTo) {
            modifiers.disabled.push({
                after: subDays(selectedFrom, min - 1),
                before: addDays(selectedFrom, min - 1)
            });
        }
        if (selectedFrom && selectedTo) {
            modifiers.disabled.push({
                after: selectedFrom,
                before: addDays(selectedFrom, min - 1)
            });
        }
    }
    if (max) {
        if (selectedFrom && !selectedTo) {
            modifiers.disabled.push({
                before: addDays(selectedFrom, -max + 1)
            });
            modifiers.disabled.push({
                after: addDays(selectedFrom, max - 1)
            });
        }
        if (selectedFrom && selectedTo) {
            var selectedCount = differenceInCalendarDays_differenceInCalendarDays(selectedTo, selectedFrom) + 1;
            var offset = max - selectedCount;
            modifiers.disabled.push({
                before: subDays(selectedFrom, offset)
            });
            modifiers.disabled.push({
                after: addDays(selectedTo, offset)
            });
        }
    }
    return (react.createElement(SelectRangeContext.Provider, { value: { selected: selected, onDayClick: onDayClick, modifiers: modifiers } }, children));
}
/**
 * Hook to access the {@link SelectRangeContextValue}.
 *
 * This hook is meant to be used inside internal or custom components.
 */
function useSelectRange() {
    var context = (0,react.useContext)(SelectRangeContext);
    if (!context) {
        throw new Error('useSelectRange must be used within a SelectRangeProvider');
    }
    return context;
}

/** Normalize to array a matcher input. */
function matcherToArray(matcher) {
    if (Array.isArray(matcher)) {
        return __spreadArray([], matcher, true);
    }
    else if (matcher !== undefined) {
        return [matcher];
    }
    else {
        return [];
    }
}

/** Create CustomModifiers from dayModifiers */
function getCustomModifiers(dayModifiers) {
    var customModifiers = {};
    Object.entries(dayModifiers).forEach(function (_a) {
        var modifier = _a[0], matcher = _a[1];
        customModifiers[modifier] = matcherToArray(matcher);
    });
    return customModifiers;
}

/** The name of the modifiers that are used internally by DayPicker. */
var InternalModifier;
(function (InternalModifier) {
    InternalModifier["Outside"] = "outside";
    /** Name of the modifier applied to the disabled days, using the `disabled` prop. */
    InternalModifier["Disabled"] = "disabled";
    /** Name of the modifier applied to the selected days using the `selected` prop). */
    InternalModifier["Selected"] = "selected";
    /** Name of the modifier applied to the hidden days using the `hidden` prop). */
    InternalModifier["Hidden"] = "hidden";
    /** Name of the modifier applied to the day specified using the `today` prop). */
    InternalModifier["Today"] = "today";
    /** The modifier applied to the day starting a selected range, when in range selection mode.  */
    InternalModifier["RangeStart"] = "range_start";
    /** The modifier applied to the day ending a selected range, when in range selection mode.  */
    InternalModifier["RangeEnd"] = "range_end";
    /** The modifier applied to the days between the start and the end of a selected range, when in range selection mode.  */
    InternalModifier["RangeMiddle"] = "range_middle";
})(InternalModifier || (InternalModifier = {}));

var Selected = InternalModifier.Selected, Disabled = InternalModifier.Disabled, Hidden = InternalModifier.Hidden, Today = InternalModifier.Today, RangeEnd = InternalModifier.RangeEnd, RangeMiddle = InternalModifier.RangeMiddle, RangeStart = InternalModifier.RangeStart, Outside = InternalModifier.Outside;
/** Return the {@link InternalModifiers} from the DayPicker and select contexts. */
function getInternalModifiers(dayPicker, selectMultiple, selectRange) {
    var _a;
    var internalModifiers = (_a = {},
        _a[Selected] = matcherToArray(dayPicker.selected),
        _a[Disabled] = matcherToArray(dayPicker.disabled),
        _a[Hidden] = matcherToArray(dayPicker.hidden),
        _a[Today] = [dayPicker.today],
        _a[RangeEnd] = [],
        _a[RangeMiddle] = [],
        _a[RangeStart] = [],
        _a[Outside] = [],
        _a);
    if (dayPicker.fromDate) {
        internalModifiers[Disabled].push({ before: dayPicker.fromDate });
    }
    if (dayPicker.toDate) {
        internalModifiers[Disabled].push({ after: dayPicker.toDate });
    }
    if (isDayPickerMultiple(dayPicker)) {
        internalModifiers[Disabled] = internalModifiers[Disabled].concat(selectMultiple.modifiers[Disabled]);
    }
    else if (isDayPickerRange(dayPicker)) {
        internalModifiers[Disabled] = internalModifiers[Disabled].concat(selectRange.modifiers[Disabled]);
        internalModifiers[RangeStart] = selectRange.modifiers[RangeStart];
        internalModifiers[RangeMiddle] = selectRange.modifiers[RangeMiddle];
        internalModifiers[RangeEnd] = selectRange.modifiers[RangeEnd];
    }
    return internalModifiers;
}

/** The Modifiers context store the modifiers used in DayPicker. To access the value of this context, use {@link useModifiers}. */
var ModifiersContext = (0,react.createContext)(undefined);
/** Provide the value for the {@link ModifiersContext}. */
function ModifiersProvider(props) {
    var dayPicker = useDayPicker();
    var selectMultiple = useSelectMultiple();
    var selectRange = useSelectRange();
    var internalModifiers = getInternalModifiers(dayPicker, selectMultiple, selectRange);
    var customModifiers = getCustomModifiers(dayPicker.modifiers);
    var modifiers = __assign(__assign({}, internalModifiers), customModifiers);
    return (react.createElement(ModifiersContext.Provider, { value: modifiers }, props.children));
}
/**
 * Return the modifiers used by DayPicker.
 *
 * This hook is meant to be used inside internal or custom components.
 * Requires to be wrapped into {@link ModifiersProvider}.
 *
 */
function useModifiers() {
    var context = (0,react.useContext)(ModifiersContext);
    if (!context) {
        throw new Error('useModifiers must be used within a ModifiersProvider');
    }
    return context;
}

/** Returns true if `matcher` is of type {@link DateInterval}. */
function isDateInterval(matcher) {
    return Boolean(matcher &&
        typeof matcher === 'object' &&
        'before' in matcher &&
        'after' in matcher);
}
/** Returns true if `value` is a {@link DateRange} type. */
function isDateRange(value) {
    return Boolean(value && typeof value === 'object' && 'from' in value);
}
/** Returns true if `value` is of type {@link DateAfter}. */
function isDateAfterType(value) {
    return Boolean(value && typeof value === 'object' && 'after' in value);
}
/** Returns true if `value` is of type {@link DateBefore}. */
function isDateBeforeType(value) {
    return Boolean(value && typeof value === 'object' && 'before' in value);
}
/** Returns true if `value` is a {@link DayOfWeek} type. */
function isDayOfWeekType(value) {
    return Boolean(value && typeof value === 'object' && 'dayOfWeek' in value);
}

/** Return `true` whether `date` is inside `range`. */
function isDateInRange(date, range) {
    var _a;
    var from = range.from, to = range.to;
    if (!from) {
        return false;
    }
    if (!to && isSameDay(from, date)) {
        return true;
    }
    if (!to) {
        return false;
    }
    var isRangeInverted = differenceInCalendarDays_differenceInCalendarDays(to, from) < 0;
    if (isRangeInverted) {
        _a = [to, from], from = _a[0], to = _a[1];
    }
    var isInRange = differenceInCalendarDays_differenceInCalendarDays(date, from) >= 0 &&
        differenceInCalendarDays_differenceInCalendarDays(to, date) >= 0;
    return isInRange;
}

/** Returns true if `value` is a Date type. */
function isDateType(value) {
    return isDate(value);
}
/** Returns true if `value` is an array of valid dates. */
function isArrayOfDates(value) {
    return Array.isArray(value) && value.every(isDate);
}
/**
 * Returns whether a day matches against at least one of the given Matchers.
 *
 * ```
 * const day = new Date(2022, 5, 19);
 * const matcher1: DateRange = {
 *    from: new Date(2021, 12, 21),
 *    to: new Date(2021, 12, 30)
 * }
 * const matcher2: DateRange = {
 *    from: new Date(2022, 5, 1),
 *    to: new Date(2022, 5, 23)
 * }
 *
 * const isMatch(day, [matcher1, matcher2]); // true, since day is in the matcher1 range.
 * ```
 * */
function isMatch(day, matchers) {
    return matchers.some(function (matcher) {
        if (typeof matcher === 'boolean') {
            return matcher;
        }
        if (isDateType(matcher)) {
            return isSameDay(day, matcher);
        }
        if (isArrayOfDates(matcher)) {
            return matcher.includes(day);
        }
        if (isDateRange(matcher)) {
            return isDateInRange(day, matcher);
        }
        if (isDayOfWeekType(matcher)) {
            return matcher.dayOfWeek.includes(day.getDay());
        }
        if (isDateInterval(matcher)) {
            var diffBefore = differenceInCalendarDays_differenceInCalendarDays(matcher.before, day);
            var diffAfter = differenceInCalendarDays_differenceInCalendarDays(matcher.after, day);
            var isDayBefore = diffBefore > 0;
            var isDayAfter = diffAfter < 0;
            var isClosedInterval = isAfter(matcher.before, matcher.after);
            if (isClosedInterval) {
                return isDayAfter && isDayBefore;
            }
            else {
                return isDayBefore || isDayAfter;
            }
        }
        if (isDateAfterType(matcher)) {
            return differenceInCalendarDays_differenceInCalendarDays(day, matcher.after) > 0;
        }
        if (isDateBeforeType(matcher)) {
            return differenceInCalendarDays_differenceInCalendarDays(matcher.before, day) > 0;
        }
        if (typeof matcher === 'function') {
            return matcher(day);
        }
        return false;
    });
}

/** Return the active modifiers for the given day. */
function getActiveModifiers(day, 
/** The modifiers to match for the given date. */
modifiers, 
/** The month where the day is displayed, to add the "outside" modifiers.  */
displayMonth) {
    var matchedModifiers = Object.keys(modifiers).reduce(function (result, key) {
        var modifier = modifiers[key];
        if (isMatch(day, modifier)) {
            result.push(key);
        }
        return result;
    }, []);
    var activeModifiers = {};
    matchedModifiers.forEach(function (modifier) { return (activeModifiers[modifier] = true); });
    if (displayMonth && !isSameMonth(day, displayMonth)) {
        activeModifiers.outside = true;
    }
    return activeModifiers;
}

/**
 * Returns the day that should be the target of the focus when DayPicker is
 * rendered the first time.
 *
 * TODO: this function doesn't consider if the day is outside the month. We
 * implemented this check in `useDayRender` but it should probably go here. See
 * https://github.com/gpbl/react-day-picker/pull/1576
 */
function getInitialFocusTarget(displayMonths, modifiers) {
    var firstDayInMonth = startOfMonth(displayMonths[0]);
    var lastDayInMonth = endOfMonth(displayMonths[displayMonths.length - 1]);
    // TODO: cleanup code
    var firstFocusableDay;
    var today;
    var date = firstDayInMonth;
    while (date <= lastDayInMonth) {
        var activeModifiers = getActiveModifiers(date, modifiers);
        var isFocusable = !activeModifiers.disabled && !activeModifiers.hidden;
        if (!isFocusable) {
            date = addDays(date, 1);
            continue;
        }
        if (activeModifiers.selected) {
            return date;
        }
        if (activeModifiers.today && !today) {
            today = date;
        }
        if (!firstFocusableDay) {
            firstFocusableDay = date;
        }
        date = addDays(date, 1);
    }
    if (today) {
        return today;
    }
    else {
        return firstFocusableDay;
    }
}

var MAX_RETRY = 365;
/** Return the next date to be focused. */
function getNextFocus(focusedDay, options) {
    var moveBy = options.moveBy, direction = options.direction, context = options.context, modifiers = options.modifiers, _a = options.retry, retry = _a === void 0 ? { count: 0, lastFocused: focusedDay } : _a;
    var weekStartsOn = context.weekStartsOn, fromDate = context.fromDate, toDate = context.toDate, locale = context.locale;
    var moveFns = {
        day: addDays,
        week: addWeeks,
        month: addMonths,
        year: addYears,
        startOfWeek: function (date) {
            return context.ISOWeek
                ? startOfISOWeek(date)
                : startOfWeek(date, { locale: locale, weekStartsOn: weekStartsOn });
        },
        endOfWeek: function (date) {
            return context.ISOWeek
                ? endOfISOWeek(date)
                : endOfWeek(date, { locale: locale, weekStartsOn: weekStartsOn });
        }
    };
    var newFocusedDay = moveFns[moveBy](focusedDay, direction === 'after' ? 1 : -1);
    if (direction === 'before' && fromDate) {
        newFocusedDay = max([fromDate, newFocusedDay]);
    }
    else if (direction === 'after' && toDate) {
        newFocusedDay = min([toDate, newFocusedDay]);
    }
    var isFocusable = true;
    if (modifiers) {
        var activeModifiers = getActiveModifiers(newFocusedDay, modifiers);
        isFocusable = !activeModifiers.disabled && !activeModifiers.hidden;
    }
    if (isFocusable) {
        return newFocusedDay;
    }
    else {
        if (retry.count > MAX_RETRY) {
            return retry.lastFocused;
        }
        return getNextFocus(newFocusedDay, {
            moveBy: moveBy,
            direction: direction,
            context: context,
            modifiers: modifiers,
            retry: __assign(__assign({}, retry), { count: retry.count + 1 })
        });
    }
}

/**
 * The Focus context shares details about the focused day for the keyboard
 *
 * Access this context from the {@link useFocusContext} hook.
 */
var FocusContext = (0,react.createContext)(undefined);
/** The provider for the {@link FocusContext}. */
function FocusProvider(props) {
    var navigation = useNavigation();
    var modifiers = useModifiers();
    var _a = (0,react.useState)(), focusedDay = _a[0], setFocusedDay = _a[1];
    var _b = (0,react.useState)(), lastFocused = _b[0], setLastFocused = _b[1];
    var initialFocusTarget = getInitialFocusTarget(navigation.displayMonths, modifiers);
    // TODO: cleanup and test obscure code below
    var focusTarget = (focusedDay !== null && focusedDay !== void 0 ? focusedDay : (lastFocused && navigation.isDateDisplayed(lastFocused)))
        ? lastFocused
        : initialFocusTarget;
    var blur = function () {
        setLastFocused(focusedDay);
        setFocusedDay(undefined);
    };
    var focus = function (date) {
        setFocusedDay(date);
    };
    var context = useDayPicker();
    var moveFocus = function (moveBy, direction) {
        if (!focusedDay)
            return;
        var nextFocused = getNextFocus(focusedDay, {
            moveBy: moveBy,
            direction: direction,
            context: context,
            modifiers: modifiers
        });
        if (isSameDay(focusedDay, nextFocused))
            return undefined;
        navigation.goToDate(nextFocused, focusedDay);
        focus(nextFocused);
    };
    var value = {
        focusedDay: focusedDay,
        focusTarget: focusTarget,
        blur: blur,
        focus: focus,
        focusDayAfter: function () { return moveFocus('day', 'after'); },
        focusDayBefore: function () { return moveFocus('day', 'before'); },
        focusWeekAfter: function () { return moveFocus('week', 'after'); },
        focusWeekBefore: function () { return moveFocus('week', 'before'); },
        focusMonthBefore: function () { return moveFocus('month', 'before'); },
        focusMonthAfter: function () { return moveFocus('month', 'after'); },
        focusYearBefore: function () { return moveFocus('year', 'before'); },
        focusYearAfter: function () { return moveFocus('year', 'after'); },
        focusStartOfWeek: function () { return moveFocus('startOfWeek', 'before'); },
        focusEndOfWeek: function () { return moveFocus('endOfWeek', 'after'); }
    };
    return (react.createElement(FocusContext.Provider, { value: value }, props.children));
}
/**
 * Hook to access the {@link FocusContextValue}. Use this hook to handle the
 * focus state of the elements.
 *
 * This hook is meant to be used inside internal or custom components.
 */
function useFocusContext() {
    var context = (0,react.useContext)(FocusContext);
    if (!context) {
        throw new Error('useFocusContext must be used within a FocusProvider');
    }
    return context;
}

/**
 * Return the active modifiers for the specified day.
 *
 * This hook is meant to be used inside internal or custom components.
 *
 * @param day
 * @param displayMonth
 */
function useActiveModifiers(day, 
/**
 * The month where the date is displayed. If not the same as `date`, the day
 * is an "outside day".
 */
displayMonth) {
    var modifiers = useModifiers();
    var activeModifiers = getActiveModifiers(day, modifiers, displayMonth);
    return activeModifiers;
}

/**
 * The SelectSingle context shares details about the selected days when in
 * single selection mode.
 *
 * Access this context from the {@link useSelectSingle} hook.
 */
var SelectSingleContext = (0,react.createContext)(undefined);
/** Provides the values for the {@link SelectSingleProvider}. */
function SelectSingleProvider(props) {
    if (!isDayPickerSingle(props.initialProps)) {
        var emptyContextValue = {
            selected: undefined
        };
        return (react.createElement(SelectSingleContext.Provider, { value: emptyContextValue }, props.children));
    }
    return (react.createElement(SelectSingleProviderInternal, { initialProps: props.initialProps, children: props.children }));
}
function SelectSingleProviderInternal(_a) {
    var initialProps = _a.initialProps, children = _a.children;
    var onDayClick = function (day, activeModifiers, e) {
        var _a, _b, _c;
        (_a = initialProps.onDayClick) === null || _a === void 0 ? void 0 : _a.call(initialProps, day, activeModifiers, e);
        if (activeModifiers.selected && !initialProps.required) {
            (_b = initialProps.onSelect) === null || _b === void 0 ? void 0 : _b.call(initialProps, undefined, day, activeModifiers, e);
            return;
        }
        (_c = initialProps.onSelect) === null || _c === void 0 ? void 0 : _c.call(initialProps, day, day, activeModifiers, e);
    };
    var contextValue = {
        selected: initialProps.selected,
        onDayClick: onDayClick
    };
    return (react.createElement(SelectSingleContext.Provider, { value: contextValue }, children));
}
/**
 * Hook to access the {@link SelectSingleContextValue}.
 *
 * This hook is meant to be used inside internal or custom components.
 */
function useSelectSingle() {
    var context = (0,react.useContext)(SelectSingleContext);
    if (!context) {
        throw new Error('useSelectSingle must be used within a SelectSingleProvider');
    }
    return context;
}

/**
 * This hook returns details about the content to render in the day cell.
 *
 *
 * When a day cell is rendered in the table, DayPicker can either:
 *
 * - render nothing: when the day is outside the month or has matched the
 *   "hidden" modifier.
 * - render a button when `onDayClick` or a selection mode is set.
 * - render a non-interactive element: when no selection mode is set, the day
 *   cell shouldnt respond to any interaction. DayPicker should render a `div`
 *   or a `span`.
 *
 * ### Usage
 *
 * Use this hook to customize the behavior of the {@link Day} component. Create a
 * new `Day` component using this hook and pass it to the `components` prop.
 * The source of {@link Day} can be a good starting point.
 *
 */
function useDayEventHandlers(date, activeModifiers) {
    var dayPicker = useDayPicker();
    var single = useSelectSingle();
    var multiple = useSelectMultiple();
    var range = useSelectRange();
    var _a = useFocusContext(), focusDayAfter = _a.focusDayAfter, focusDayBefore = _a.focusDayBefore, focusWeekAfter = _a.focusWeekAfter, focusWeekBefore = _a.focusWeekBefore, blur = _a.blur, focus = _a.focus, focusMonthBefore = _a.focusMonthBefore, focusMonthAfter = _a.focusMonthAfter, focusYearBefore = _a.focusYearBefore, focusYearAfter = _a.focusYearAfter, focusStartOfWeek = _a.focusStartOfWeek, focusEndOfWeek = _a.focusEndOfWeek;
    var onClick = function (e) {
        var _a, _b, _c, _d;
        if (isDayPickerSingle(dayPicker)) {
            (_a = single.onDayClick) === null || _a === void 0 ? void 0 : _a.call(single, date, activeModifiers, e);
        }
        else if (isDayPickerMultiple(dayPicker)) {
            (_b = multiple.onDayClick) === null || _b === void 0 ? void 0 : _b.call(multiple, date, activeModifiers, e);
        }
        else if (isDayPickerRange(dayPicker)) {
            (_c = range.onDayClick) === null || _c === void 0 ? void 0 : _c.call(range, date, activeModifiers, e);
        }
        else {
            (_d = dayPicker.onDayClick) === null || _d === void 0 ? void 0 : _d.call(dayPicker, date, activeModifiers, e);
        }
    };
    var onFocus = function (e) {
        var _a;
        focus(date);
        (_a = dayPicker.onDayFocus) === null || _a === void 0 ? void 0 : _a.call(dayPicker, date, activeModifiers, e);
    };
    var onBlur = function (e) {
        var _a;
        blur();
        (_a = dayPicker.onDayBlur) === null || _a === void 0 ? void 0 : _a.call(dayPicker, date, activeModifiers, e);
    };
    var onMouseEnter = function (e) {
        var _a;
        (_a = dayPicker.onDayMouseEnter) === null || _a === void 0 ? void 0 : _a.call(dayPicker, date, activeModifiers, e);
    };
    var onMouseLeave = function (e) {
        var _a;
        (_a = dayPicker.onDayMouseLeave) === null || _a === void 0 ? void 0 : _a.call(dayPicker, date, activeModifiers, e);
    };
    var onPointerEnter = function (e) {
        var _a;
        (_a = dayPicker.onDayPointerEnter) === null || _a === void 0 ? void 0 : _a.call(dayPicker, date, activeModifiers, e);
    };
    var onPointerLeave = function (e) {
        var _a;
        (_a = dayPicker.onDayPointerLeave) === null || _a === void 0 ? void 0 : _a.call(dayPicker, date, activeModifiers, e);
    };
    var onTouchCancel = function (e) {
        var _a;
        (_a = dayPicker.onDayTouchCancel) === null || _a === void 0 ? void 0 : _a.call(dayPicker, date, activeModifiers, e);
    };
    var onTouchEnd = function (e) {
        var _a;
        (_a = dayPicker.onDayTouchEnd) === null || _a === void 0 ? void 0 : _a.call(dayPicker, date, activeModifiers, e);
    };
    var onTouchMove = function (e) {
        var _a;
        (_a = dayPicker.onDayTouchMove) === null || _a === void 0 ? void 0 : _a.call(dayPicker, date, activeModifiers, e);
    };
    var onTouchStart = function (e) {
        var _a;
        (_a = dayPicker.onDayTouchStart) === null || _a === void 0 ? void 0 : _a.call(dayPicker, date, activeModifiers, e);
    };
    var onKeyUp = function (e) {
        var _a;
        (_a = dayPicker.onDayKeyUp) === null || _a === void 0 ? void 0 : _a.call(dayPicker, date, activeModifiers, e);
    };
    var onKeyDown = function (e) {
        var _a;
        switch (e.key) {
            case 'ArrowLeft':
                e.preventDefault();
                e.stopPropagation();
                dayPicker.dir === 'rtl' ? focusDayAfter() : focusDayBefore();
                break;
            case 'ArrowRight':
                e.preventDefault();
                e.stopPropagation();
                dayPicker.dir === 'rtl' ? focusDayBefore() : focusDayAfter();
                break;
            case 'ArrowDown':
                e.preventDefault();
                e.stopPropagation();
                focusWeekAfter();
                break;
            case 'ArrowUp':
                e.preventDefault();
                e.stopPropagation();
                focusWeekBefore();
                break;
            case 'PageUp':
                e.preventDefault();
                e.stopPropagation();
                e.shiftKey ? focusYearBefore() : focusMonthBefore();
                break;
            case 'PageDown':
                e.preventDefault();
                e.stopPropagation();
                e.shiftKey ? focusYearAfter() : focusMonthAfter();
                break;
            case 'Home':
                e.preventDefault();
                e.stopPropagation();
                focusStartOfWeek();
                break;
            case 'End':
                e.preventDefault();
                e.stopPropagation();
                focusEndOfWeek();
                break;
        }
        (_a = dayPicker.onDayKeyDown) === null || _a === void 0 ? void 0 : _a.call(dayPicker, date, activeModifiers, e);
    };
    var eventHandlers = {
        onClick: onClick,
        onFocus: onFocus,
        onBlur: onBlur,
        onKeyDown: onKeyDown,
        onKeyUp: onKeyUp,
        onMouseEnter: onMouseEnter,
        onMouseLeave: onMouseLeave,
        onPointerEnter: onPointerEnter,
        onPointerLeave: onPointerLeave,
        onTouchCancel: onTouchCancel,
        onTouchEnd: onTouchEnd,
        onTouchMove: onTouchMove,
        onTouchStart: onTouchStart
    };
    return eventHandlers;
}

/**
 * Return the current selected days when DayPicker is in selection mode. Days
 * selected by the custom selection mode are not returned.
 *
 * This hook is meant to be used inside internal or custom components.
 *
 */
function useSelectedDays() {
    var dayPicker = useDayPicker();
    var single = useSelectSingle();
    var multiple = useSelectMultiple();
    var range = useSelectRange();
    var selectedDays = isDayPickerSingle(dayPicker)
        ? single.selected
        : isDayPickerMultiple(dayPicker)
            ? multiple.selected
            : isDayPickerRange(dayPicker)
                ? range.selected
                : undefined;
    return selectedDays;
}

function isInternalModifier(modifier) {
    return Object.values(InternalModifier).includes(modifier);
}
/**
 * Return the class names for the Day element, according to the given active
 * modifiers.
 *
 * Custom class names are set via `modifiersClassNames` or `classNames`,
 * where the first have the precedence.
 */
function getDayClassNames(dayPicker, activeModifiers) {
    var classNames = [dayPicker.classNames.day];
    Object.keys(activeModifiers).forEach(function (modifier) {
        var customClassName = dayPicker.modifiersClassNames[modifier];
        if (customClassName) {
            classNames.push(customClassName);
        }
        else if (isInternalModifier(modifier)) {
            var internalClassName = dayPicker.classNames["day_".concat(modifier)];
            if (internalClassName) {
                classNames.push(internalClassName);
            }
        }
    });
    return classNames;
}

/** Return the style for the Day element, according to the given active modifiers. */
function getDayStyle(dayPicker, activeModifiers) {
    var style = __assign({}, dayPicker.styles.day);
    Object.keys(activeModifiers).forEach(function (modifier) {
        var _a;
        style = __assign(__assign({}, style), (_a = dayPicker.modifiersStyles) === null || _a === void 0 ? void 0 : _a[modifier]);
    });
    return style;
}

/**
 * Return props and data used to render the {@link Day} component.
 *
 * Use this hook when creating a component to replace the built-in `Day`
 * component.
 */
function useDayRender(
/** The date to render. */
day, 
/** The month where the date is displayed (if not the same as `date`, it means it is an "outside" day). */
displayMonth, 
/** A ref to the button element that will be target of focus when rendered (if required). */
buttonRef) {
    var _a;
    var _b, _c;
    var dayPicker = useDayPicker();
    var focusContext = useFocusContext();
    var activeModifiers = useActiveModifiers(day, displayMonth);
    var eventHandlers = useDayEventHandlers(day, activeModifiers);
    var selectedDays = useSelectedDays();
    var isButton = Boolean(dayPicker.onDayClick || dayPicker.mode !== 'default');
    // Focus the button if the day is focused according to the focus context
    (0,react.useEffect)(function () {
        var _a;
        if (activeModifiers.outside)
            return;
        if (!focusContext.focusedDay)
            return;
        if (!isButton)
            return;
        if (isSameDay(focusContext.focusedDay, day)) {
            (_a = buttonRef.current) === null || _a === void 0 ? void 0 : _a.focus();
        }
    }, [
        focusContext.focusedDay,
        day,
        buttonRef,
        isButton,
        activeModifiers.outside
    ]);
    var className = getDayClassNames(dayPicker, activeModifiers).join(' ');
    var style = getDayStyle(dayPicker, activeModifiers);
    var ariaLabel = dayPicker.labels.labelDay(day, activeModifiers, {
        locale: dayPicker.locale
    });
    var isHidden = Boolean((activeModifiers.outside && !dayPicker.showOutsideDays) ||
        activeModifiers.hidden);
    var DayContentComponent = (_c = (_b = dayPicker.components) === null || _b === void 0 ? void 0 : _b.DayContent) !== null && _c !== void 0 ? _c : DayContent;
    var children = (react.createElement(DayContentComponent, { date: day, displayMonth: displayMonth, activeModifiers: activeModifiers }));
    var divProps = {
        style: style,
        className: className,
        children: children,
        'aria-label': ariaLabel
    };
    var isFocusTarget = focusContext.focusTarget &&
        isSameDay(focusContext.focusTarget, day) &&
        !activeModifiers.outside;
    var isFocused = focusContext.focusedDay && isSameDay(focusContext.focusedDay, day);
    var buttonProps = __assign(__assign(__assign({}, divProps), (_a = { disabled: activeModifiers.disabled }, _a['aria-pressed'] = activeModifiers.selected, _a['aria-label'] = ariaLabel, _a.tabIndex = isFocused || isFocusTarget ? 0 : -1, _a)), eventHandlers);
    var dayRender = {
        isButton: isButton,
        isHidden: isHidden,
        activeModifiers: activeModifiers,
        selectedDays: selectedDays,
        buttonProps: buttonProps,
        divProps: divProps
    };
    return dayRender;
}

/**
 * The content of a day cell  as a button or span element according to its
 * modifiers.
 */
function Day(props) {
    var buttonRef = (0,react.useRef)(null);
    var dayRender = useDayRender(props.date, props.displayMonth, buttonRef);
    if (dayRender.isHidden) {
        return react.createElement(react.Fragment, null);
    }
    if (!dayRender.isButton) {
        return react.createElement("div", __assign({}, dayRender.divProps));
    }
    return react.createElement(index_esm_Button, __assign({ name: "day", ref: buttonRef }, dayRender.buttonProps));
}

/**
 * Render the week number element. If `onWeekNumberClick` is passed to DayPicker, it
 * renders a button, otherwise a span element.
 */
function WeekNumber(props) {
    var weekNumber = props.number, dates = props.dates;
    var _a = useDayPicker(), onWeekNumberClick = _a.onWeekNumberClick, styles = _a.styles, classNames = _a.classNames, locale = _a.locale, labelWeekNumber = _a.labels.labelWeekNumber, formatWeekNumber = _a.formatters.formatWeekNumber;
    var content = formatWeekNumber(Number(weekNumber), { locale: locale });
    if (!onWeekNumberClick) {
        return (react.createElement("span", { className: classNames.weeknumber, style: styles.weeknumber }, content));
    }
    var label = labelWeekNumber(Number(weekNumber), { locale: locale });
    var handleClick = function (e) {
        onWeekNumberClick(weekNumber, dates, e);
    };
    return (react.createElement(index_esm_Button, { name: "week-number", "aria-label": label, className: classNames.weeknumber, style: styles.weeknumber, onClick: handleClick }, content));
}

/** Render a row in the calendar, with the days and the week number. */
function index_esm_Row(props) {
    var _a, _b;
    var _c = useDayPicker(), styles = _c.styles, classNames = _c.classNames, showWeekNumber = _c.showWeekNumber, components = _c.components;
    var DayComponent = (_a = components === null || components === void 0 ? void 0 : components.Day) !== null && _a !== void 0 ? _a : Day;
    var WeeknumberComponent = (_b = components === null || components === void 0 ? void 0 : components.WeekNumber) !== null && _b !== void 0 ? _b : WeekNumber;
    var weekNumberCell;
    if (showWeekNumber) {
        weekNumberCell = (react.createElement("td", { className: classNames.cell, style: styles.cell },
            react.createElement(WeeknumberComponent, { number: props.weekNumber, dates: props.dates })));
    }
    return (react.createElement("tr", { className: classNames.row, style: styles.row },
        weekNumberCell,
        props.dates.map(function (date) { return (react.createElement("td", { className: classNames.cell, style: styles.cell, key: getUnixTime(date) },
            react.createElement(DayComponent, { displayMonth: props.displayMonth, date: date }))); })));
}

/** Return the weeks between two dates.  */
function daysToMonthWeeks(fromDate, toDate, options) {
    var toWeek = (options === null || options === void 0 ? void 0 : options.ISOWeek)
        ? endOfISOWeek(toDate)
        : endOfWeek(toDate, options);
    var fromWeek = (options === null || options === void 0 ? void 0 : options.ISOWeek)
        ? startOfISOWeek(fromDate)
        : startOfWeek(fromDate, options);
    var nOfDays = differenceInCalendarDays_differenceInCalendarDays(toWeek, fromWeek);
    var days = [];
    for (var i = 0; i <= nOfDays; i++) {
        days.push(addDays(fromWeek, i));
    }
    var weeksInMonth = days.reduce(function (result, date) {
        var weekNumber = (options === null || options === void 0 ? void 0 : options.ISOWeek)
            ? getISOWeek(date)
            : getWeek(date, options);
        var existingWeek = result.find(function (value) { return value.weekNumber === weekNumber; });
        if (existingWeek) {
            existingWeek.dates.push(date);
            return result;
        }
        result.push({
            weekNumber: weekNumber,
            dates: [date]
        });
        return result;
    }, []);
    return weeksInMonth;
}

/**
 * Return the weeks belonging to the given month, adding the "outside days" to
 * the first and last week.
 */
function getMonthWeeks(month, options) {
    var weeksInMonth = daysToMonthWeeks(startOfMonth(month), endOfMonth(month), options);
    if (options === null || options === void 0 ? void 0 : options.useFixedWeeks) {
        // Add extra weeks to the month, up to 6 weeks
        var nrOfMonthWeeks = getWeeksInMonth(month, options);
        if (nrOfMonthWeeks < 6) {
            var lastWeek = weeksInMonth[weeksInMonth.length - 1];
            var lastDate = lastWeek.dates[lastWeek.dates.length - 1];
            var toDate = addWeeks(lastDate, 6 - nrOfMonthWeeks);
            var extraWeeks = daysToMonthWeeks(addWeeks(lastDate, 1), toDate, options);
            weeksInMonth.push.apply(weeksInMonth, extraWeeks);
        }
    }
    return weeksInMonth;
}

/** Render the table with the calendar. */
function index_esm_Table(props) {
    var _a, _b, _c;
    var _d = useDayPicker(), locale = _d.locale, classNames = _d.classNames, styles = _d.styles, hideHead = _d.hideHead, fixedWeeks = _d.fixedWeeks, components = _d.components, weekStartsOn = _d.weekStartsOn, firstWeekContainsDate = _d.firstWeekContainsDate, ISOWeek = _d.ISOWeek;
    var weeks = getMonthWeeks(props.displayMonth, {
        useFixedWeeks: Boolean(fixedWeeks),
        ISOWeek: ISOWeek,
        locale: locale,
        weekStartsOn: weekStartsOn,
        firstWeekContainsDate: firstWeekContainsDate
    });
    var HeadComponent = (_a = components === null || components === void 0 ? void 0 : components.Head) !== null && _a !== void 0 ? _a : index_esm_Head;
    var RowComponent = (_b = components === null || components === void 0 ? void 0 : components.Row) !== null && _b !== void 0 ? _b : index_esm_Row;
    var FooterComponent = (_c = components === null || components === void 0 ? void 0 : components.Footer) !== null && _c !== void 0 ? _c : Footer;
    return (react.createElement("table", { className: classNames.table, style: styles.table, role: "grid", "aria-labelledby": props['aria-labelledby'] },
        !hideHead && react.createElement(HeadComponent, null),
        react.createElement("tbody", { className: classNames.tbody, style: styles.tbody }, weeks.map(function (week) { return (react.createElement(RowComponent, { displayMonth: props.displayMonth, key: week.weekNumber, dates: week.dates, weekNumber: week.weekNumber })); })),
        react.createElement(FooterComponent, null)));
}

/*
The MIT License (MIT)

Copyright (c) 2018-present, React Training LLC

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
function canUseDOM() {
    return !!(typeof window !== 'undefined' &&
        window.document &&
        window.document.createElement);
}
/**
 * React currently throws a warning when using useLayoutEffect on the server. To
 * get around it, we can conditionally useEffect on the server (no-op) and
 * useLayoutEffect in the browser. We occasionally need useLayoutEffect to
 * ensure we don't get a render flash for certain operations, but we may also
 * need affected components to render on the server. One example is when setting
 * a component's descendants to retrieve their index values.
 *
 * Important to note that using this hook as an escape hatch will break the
 * eslint dependency warnings unless you rename the import to `useLayoutEffect`.
 * Use sparingly only when the effect won't effect the rendered HTML to avoid
 * any server/client mismatch.
 *
 * If a useLayoutEffect is needed and the result would create a mismatch, it's
 * likely that the component in question shouldn't be rendered on the server at
 * all, so a better approach would be to lazily render those in a parent
 * component after client-side hydration.
 *
 * https://gist.github.com/gaearon/e7d97cdf38a2907924ea12e4ebdf3c85
 * https://github.com/reduxjs/react-redux/blob/master/src/utils/useIsomorphicLayoutEffect.js
 *
 * @param effect
 * @param deps
 */
var useIsomorphicLayoutEffect = canUseDOM()
    ? react.useLayoutEffect
    : react.useEffect;
var serverHandoffComplete = false;
var id = 0;
function genId() {
    return "react-day-picker-".concat(++id);
}
function useId(providedId) {
    // TODO: Remove error flag when updating internal deps to React 18. None of
    // our tricks will play well with concurrent rendering anyway.
    var _a;
    // If this instance isn't part of the initial render, we don't have to do the
    // double render/patch-up dance. We can just generate the ID and return it.
    var initialId = providedId !== null && providedId !== void 0 ? providedId : (serverHandoffComplete ? genId() : null);
    var _b = react.useState(initialId), id = _b[0], setId = _b[1];
    useIsomorphicLayoutEffect(function () {
        if (id === null) {
            // Patch the ID after render. We do this in `useLayoutEffect` to avoid any
            // rendering flicker, though it'll make the first render slower (unlikely
            // to matter, but you're welcome to measure your app and let us know if
            // it's a problem).
            setId(genId());
        }
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, []);
    react.useEffect(function () {
        if (serverHandoffComplete === false) {
            // Flag all future uses of `useId` to skip the update dance. This is in
            // `useEffect` because it goes after `useLayoutEffect`, ensuring we don't
            // accidentally bail out of the patch-up dance prematurely.
            serverHandoffComplete = true;
        }
    }, []);
    return (_a = providedId !== null && providedId !== void 0 ? providedId : id) !== null && _a !== void 0 ? _a : undefined;
}

/** Render a month. */
function Month(props) {
    var _a;
    var _b;
    var dayPicker = useDayPicker();
    var dir = dayPicker.dir, classNames = dayPicker.classNames, styles = dayPicker.styles, components = dayPicker.components;
    var displayMonths = useNavigation().displayMonths;
    var captionId = useId(dayPicker.id ? "".concat(dayPicker.id, "-").concat(props.displayIndex) : undefined);
    var className = [classNames.month];
    var style = styles.month;
    var isStart = props.displayIndex === 0;
    var isEnd = props.displayIndex === displayMonths.length - 1;
    var isCenter = !isStart && !isEnd;
    if (dir === 'rtl') {
        _a = [isStart, isEnd], isEnd = _a[0], isStart = _a[1];
    }
    if (isStart) {
        className.push(classNames.caption_start);
        style = __assign(__assign({}, style), styles.caption_start);
    }
    if (isEnd) {
        className.push(classNames.caption_end);
        style = __assign(__assign({}, style), styles.caption_end);
    }
    if (isCenter) {
        className.push(classNames.caption_between);
        style = __assign(__assign({}, style), styles.caption_between);
    }
    var CaptionComponent = (_b = components === null || components === void 0 ? void 0 : components.Caption) !== null && _b !== void 0 ? _b : Caption;
    return (react.createElement("div", { key: props.displayIndex, className: className.join(' '), style: style },
        react.createElement(CaptionComponent, { id: captionId, displayMonth: props.displayMonth }),
        react.createElement(index_esm_Table, { "aria-labelledby": captionId, displayMonth: props.displayMonth })));
}

/** Render the container with the months according to the number of months to display. */
function Root() {
    var dayPicker = useDayPicker();
    var focusContext = useFocusContext();
    var navigation = useNavigation();
    var _a = (0,react.useState)(false), hasInitialFocus = _a[0], setHasInitialFocus = _a[1];
    // Focus the focus target when initialFocus is passed in
    (0,react.useEffect)(function () {
        if (!dayPicker.initialFocus)
            return;
        if (!focusContext.focusTarget)
            return;
        if (hasInitialFocus)
            return;
        focusContext.focus(focusContext.focusTarget);
        setHasInitialFocus(true);
    }, [
        dayPicker.initialFocus,
        hasInitialFocus,
        focusContext.focus,
        focusContext.focusTarget,
        focusContext
    ]);
    // Apply classnames according to props
    var classNames = [dayPicker.classNames.root, dayPicker.className];
    if (dayPicker.numberOfMonths > 1) {
        classNames.push(dayPicker.classNames.multiple_months);
    }
    if (dayPicker.showWeekNumber) {
        classNames.push(dayPicker.classNames.with_weeknumber);
    }
    var style = __assign(__assign({}, dayPicker.styles.root), dayPicker.style);
    return (react.createElement("div", { className: classNames.join(' '), style: style, dir: dayPicker.dir },
        react.createElement("div", { className: dayPicker.classNames.months, style: dayPicker.styles.months }, navigation.displayMonths.map(function (month, i) { return (react.createElement(Month, { key: i, displayIndex: i, displayMonth: month })); }))));
}

/** Provide the value for all the context providers. */
function RootProvider(props) {
    var children = props.children, initialProps = index_esm_rest(props, ["children"]);
    return (react.createElement(DayPickerProvider, { initialProps: initialProps },
        react.createElement(NavigationProvider, null,
            react.createElement(SelectSingleProvider, { initialProps: initialProps },
                react.createElement(SelectMultipleProvider, { initialProps: initialProps },
                    react.createElement(SelectRangeProvider, { initialProps: initialProps },
                        react.createElement(ModifiersProvider, null,
                            react.createElement(FocusProvider, null, children))))))));
}

/**
 * DayPicker render a date picker component to let users pick dates from a
 * calendar. See http://react-day-picker.js.org for updated documentation and
 * examples.
 *
 * ### Customization
 *
 * DayPicker offers different customization props. For example,
 *
 * - show multiple months using `numberOfMonths`
 * - display a dropdown to navigate the months via `captionLayout`
 * - display the week numbers with `showWeekNumbers`
 * - disable or hide days with `disabled` or `hidden`
 *
 * ### Controlling the months
 *
 * Change the initially displayed month using the `defaultMonth` prop. The
 * displayed months are controlled by DayPicker and stored in its internal
 * state. To control the months yourself, use `month` instead of `defaultMonth`
 * and use the `onMonthChange` event to set it.
 *
 * To limit the months the user can navigate to, use
 * `fromDate`/`fromMonth`/`fromYear` or `toDate`/`toMonth`/`toYear`.
 *
 * ### Selection modes
 *
 * DayPicker supports different selection mode that can be toggled using the
 * `mode` prop:
 *
 * - `mode="single"`: only one day can be selected. Use `required` to make the
 *   selection required. Use the `onSelect` event handler to get the selected
 *   days.
 * - `mode="multiple"`: users can select one or more days. Limit the amount of
 *   days that can be selected with the `min` or the `max` props.
 * - `mode="range"`: users can select a range of days. Limit the amount of days
 *   in the range with the `min` or the `max` props.
 * - `mode="default"` (default): the built-in selections are disabled. Implement
 *   your own selection mode with `onDayClick`.
 *
 * The selection modes should cover the most common use cases. In case you
 * need a more refined way of selecting days, use `mode="default"`. Use the
 * `selected` props and add the day event handlers to add/remove days from the
 * selection.
 *
 * ### Modifiers
 *
 * A _modifier_ represents different styles or states for the days displayed in
 * the calendar (like "selected" or "disabled"). Define custom modifiers using
 * the `modifiers` prop.
 *
 * ### Formatters and custom component
 *
 * You can customize how the content is displayed in the date picker by using
 * either the formatters or replacing the internal components.
 *
 * For the most common cases you want to use the `formatters` prop to change how
 * the content is formatted in the calendar. Use the `components` prop to
 * replace the internal components, like the navigation icons.
 *
 * ### Styling
 *
 * DayPicker comes with a default, basic style in `react-day-picker/style`  use
 * it as template for your own style.
 *
 * If you are using CSS modules, pass the imported styles object the
 * `classNames` props.
 *
 * You can also style the elements via inline-styles using the `styles` prop.
 *
 * ### Form fields
 *
 * If you need to bind the date picker to a form field, you can use the
 * `useInput` hooks for a basic behavior. See the `useInput` source as an
 * example to bind the date picker with form fields.
 *
 * ### Localization
 *
 * To localize DayPicker, import the locale from `date-fns` package and use the
 * `locale` prop.
 *
 * For example, to use Spanish locale:
 *
 * ```
 * import es from 'date-fns/locale/es';
 * <DayPicker locale={es} />
 * ```
 */
function DayPicker(props) {
    return (react.createElement(RootProvider, __assign({}, props),
        react.createElement(Root, null)));
}

/** @private */
function isValidDate(day) {
    return !isNaN(day.getTime());
}

/** Return props and setters for binding an input field to DayPicker. */
function useInput(options) {
    if (options === void 0) { options = {}; }
    var _a = options.locale, locale = _a === void 0 ? enUS : _a, required = options.required, _b = options.format, format$1 = _b === void 0 ? 'PP' : _b, defaultSelected = options.defaultSelected, _c = options.today, today = _c === void 0 ? new Date() : _c;
    var _d = parseFromToProps(options), fromDate = _d.fromDate, toDate = _d.toDate;
    // Shortcut to the DateFns functions
    var parseValue = function (value) { return parse(value, format$1, today, { locale: locale }); };
    // Initialize states
    var _e = useState(defaultSelected !== null && defaultSelected !== void 0 ? defaultSelected : today), month = _e[0], setMonth = _e[1];
    var _f = useState(defaultSelected), selectedDay = _f[0], setSelectedDay = _f[1];
    var defaultInputValue = defaultSelected
        ? format(defaultSelected, format$1, { locale: locale })
        : '';
    var _g = useState(defaultInputValue), inputValue = _g[0], setInputValue = _g[1];
    var reset = function () {
        setSelectedDay(defaultSelected);
        setMonth(defaultSelected !== null && defaultSelected !== void 0 ? defaultSelected : today);
        setInputValue(defaultInputValue !== null && defaultInputValue !== void 0 ? defaultInputValue : '');
    };
    var setSelected = function (date) {
        setSelectedDay(date);
        setMonth(date !== null && date !== void 0 ? date : today);
        setInputValue(date ? format(date, format$1, { locale: locale }) : '');
    };
    var handleDayClick = function (day, _a) {
        var selected = _a.selected;
        if (!required && selected) {
            setSelectedDay(undefined);
            setInputValue('');
            return;
        }
        setSelectedDay(day);
        setInputValue(day ? format(day, format$1, { locale: locale }) : '');
    };
    var handleMonthChange = function (month) {
        setMonth(month);
    };
    // When changing the input field, save its value in state and check if the
    // string is a valid date. If it is a valid day, set it as selected and update
    // the calendars month.
    var handleChange = function (e) {
        setInputValue(e.target.value);
        var day = parseValue(e.target.value);
        var isBefore = fromDate && differenceInCalendarDays(fromDate, day) > 0;
        var isAfter = toDate && differenceInCalendarDays(day, toDate) > 0;
        if (!isValidDate(day) || isBefore || isAfter) {
            setSelectedDay(undefined);
            return;
        }
        setSelectedDay(day);
        setMonth(day);
    };
    // Special case for _required_ fields: on blur, if the value of the input is not
    // a valid date, reset the calendar and the input value.
    var handleBlur = function (e) {
        var day = parseValue(e.target.value);
        if (!isValidDate(day)) {
            reset();
        }
    };
    // When focusing, make sure DayPicker visualizes the month of the date in the
    // input field.
    var handleFocus = function (e) {
        if (!e.target.value) {
            reset();
            return;
        }
        var day = parseValue(e.target.value);
        if (isValidDate(day)) {
            setMonth(day);
        }
    };
    var dayPickerProps = {
        month: month,
        onDayClick: handleDayClick,
        onMonthChange: handleMonthChange,
        selected: selectedDay,
        locale: locale,
        fromDate: fromDate,
        toDate: toDate,
        today: today
    };
    var inputProps = {
        onBlur: handleBlur,
        onChange: handleChange,
        onFocus: handleFocus,
        value: inputValue,
        placeholder: format(new Date(), format$1, { locale: locale })
    };
    return { dayPickerProps: dayPickerProps, inputProps: inputProps, reset: reset, setSelected: setSelected };
}

/** Returns true when the props are of type {@link DayPickerDefaultProps}. */
function isDayPickerDefault(props) {
    return props.mode === undefined || props.mode === 'default';
}


//# sourceMappingURL=index.esm.js.map

// EXTERNAL MODULE: ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js
var injectStylesIntoStyleTag = __webpack_require__(3379);
var injectStylesIntoStyleTag_default = /*#__PURE__*/__webpack_require__.n(injectStylesIntoStyleTag);
// EXTERNAL MODULE: ./node_modules/style-loader/dist/runtime/styleDomAPI.js
var styleDomAPI = __webpack_require__(7795);
var styleDomAPI_default = /*#__PURE__*/__webpack_require__.n(styleDomAPI);
// EXTERNAL MODULE: ./node_modules/style-loader/dist/runtime/insertBySelector.js
var insertBySelector = __webpack_require__(569);
var insertBySelector_default = /*#__PURE__*/__webpack_require__.n(insertBySelector);
// EXTERNAL MODULE: ./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js
var setAttributesWithoutAttributes = __webpack_require__(3565);
var setAttributesWithoutAttributes_default = /*#__PURE__*/__webpack_require__.n(setAttributesWithoutAttributes);
// EXTERNAL MODULE: ./node_modules/style-loader/dist/runtime/insertStyleElement.js
var insertStyleElement = __webpack_require__(9216);
var insertStyleElement_default = /*#__PURE__*/__webpack_require__.n(insertStyleElement);
// EXTERNAL MODULE: ./node_modules/style-loader/dist/runtime/styleTagTransform.js
var styleTagTransform = __webpack_require__(4589);
var styleTagTransform_default = /*#__PURE__*/__webpack_require__.n(styleTagTransform);
// EXTERNAL MODULE: ./node_modules/css-loader/dist/cjs.js!./node_modules/react-day-picker/dist/style.css
var style = __webpack_require__(4088);
;// CONCATENATED MODULE: ./node_modules/react-day-picker/dist/style.css

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (styleTagTransform_default());
options.setAttributes = (setAttributesWithoutAttributes_default());

      options.insert = insertBySelector_default().bind(null, "head");
    
options.domAPI = (styleDomAPI_default());
options.insertStyleElement = (insertStyleElement_default());

var update = injectStylesIntoStyleTag_default()(style/* default */.Z, options);




       /* harmony default export */ const dist_style = (style/* default */.Z && style/* default.locals */.Z.locals ? style/* default.locals */.Z.locals : undefined);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/DateRangePicker/DateRangePicker.js
var DateRangePicker_rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};





const Wrapper = (0,dist_theme/* styled */.zo)(Box/* default */.Z) `
  .rdp {
    --rdp-cell-size: 40px;
    --rdp-accent-color: ${({ theme }) => theme.color('purple50')};
    --rdp-background-color: ${({ theme }) => theme.color('transparent')};
    /* Switch to dark colors for dark themes */
    --rdp-accent-color-dark: ${({ theme }) => theme.color('purple50')};
    --rdp-background-color-dark: ${({ theme }) => theme.color('transparent')};
    /* Outline border for focused elements */
    --rdp-outline: 2px solid var(--rdp-accent-color);
    /* Outline border for focused and selected elements */
    --rdp-outline-selected: 2px solid ${({ theme }) => theme.color('purple50')};
  }

  .rc-range-start {
    border-start-start-radius: 6px;
    border-end-start-radius: 6px;
    border-start-end-radius: 0;
    border-end-end-radius: 0;
  }

  .rc-range-end {
    border-start-end-radius: 6px;
    border-end-end-radius: 6px;
    border-start-start-radius: 0;
    border-end-start-radius: 0;
  }

  .rc-range-start.rc-range-end {
    border-radius: 6px;
  }

  .rdp-button:hover:not(.rdp-day_selected) {
    background-color: ${({ theme }) => theme.color('purple30', 'purple70')};
    border-radius: 6px;
    color: ${({ theme }) => theme.color('light100', 'light100')};
  }
`;
/**
 * `DateRangePicker` component
 *
 * Requires `date-fns` installed in the project importing this component.
 *
 * @see
 * {@link https://design-system.solventek.com/component/daterangepicker}
 *
 * @example
 * <DateRangePicker defaultMonth={lastMonth} selected={range} onSelect={setRange} />
 */
const DateRangePicker = (_a) => {
    var rest = DateRangePicker_rest(_a, []);
    return ((0,jsx_runtime.jsx)(Wrapper, { children: (0,jsx_runtime.jsx)(DayPicker, Object.assign({ mode: "range", numberOfMonths: 2, showOutsideDays: true, modifiersClassNames: {
                range_start: 'rc-range-start',
                range_end: 'rc-range-end'
            } }, rest)) }));
};
/* harmony default export */ const DateRangePicker_DateRangePicker = (DateRangePicker);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/index.js






















































/***/ }),

/***/ 3709:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "$_": () => (/* binding */ color),
/* harmony export */   "By": () => (/* binding */ styledFocus),
/* harmony export */   "sL": () => (/* binding */ parseColorProps)
/* harmony export */ });
/* harmony import */ var styled_components__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2294);


const MatchRgbNumbers = /(\d{1,3}),(\d{1,3}),(\d{1,3})/;
const styledFocus = ({ theme }) => styled_components__WEBPACK_IMPORTED_MODULE_0__.css `
  &.focus-visible {
    box-shadow: 0px 0px 0px 2px ${theme.color('dark100')({ theme })}, 0px 0px 0px 4px ${theme.colors.purple50};
  }
`;
// TODO: Update to actual matches
const lightFallbacks = {
    dark100: 'light100',
    dark90: 'light100',
    dark80: 'light80',
    dark70: 'light70',
    dark60: 'light60',
    dark50: 'light50',
    dark40: 'light40',
    dark30: 'light30',
    dark20: 'light20',
    dark10: 'light10',
    dark0: 'light0'
};
/**
 * Themed color helper
 * @param colorDark - Color to be used for dark theme
 * @param colorLight - Color to be used for light theme
 * @param alpha - alpha value
 */
const color = (colorDark, colorLight, alpha) => ({ theme }) => {
    let rgbColor;
    if (theme.name === 'light') {
        rgbColor = theme.colors[colorLight || lightFallbacks[colorDark] || colorDark];
    }
    else {
        rgbColor = theme.colors[colorDark];
    }
    if (!rgbColor) {
        return theme.name === 'light' && colorLight ? colorLight : colorDark;
    }
    if (alpha === undefined) {
        return rgbColor;
    }
    const [, r, g, b] = MatchRgbNumbers.exec(rgbColor.replace(/\s/g, '')) || [];
    return `rgba(${r}, ${g}, ${b}, ${alpha})`;
};
const parseColorProps = ({ backgroundTag, color: colorDark, colorTag, colors, backgroundColor, backgrounds, theme }) => {
    const output = [];
    if (typeof colors === 'object') {
        output.push(`${colorTag || 'color'}: ${color(...colors)({ theme })};`);
    }
    else if (colorDark) {
        output.push(`${colorTag || 'color'}: ${color(colorDark)({ theme })};`);
    }
    if (typeof backgrounds === 'object') {
        output.push(`${backgroundTag || 'background-color'}: ${color(...backgrounds)({ theme })};`);
    }
    else if (backgroundColor) {
        output.push(`${backgroundTag || 'background-color'}: ${color(backgroundColor)({ theme })};`);
    }
    return styled_components__WEBPACK_IMPORTED_MODULE_0__.css `
    ${output.join('')}
  `;
};


/***/ }),

/***/ 3694:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "Ni": () => (/* binding */ ThemeContext),
  "f6": () => (/* binding */ ThemeProvider),
  "iv": () => (/* binding */ css),
  "F4": () => (/* binding */ keyframes),
  "zo": () => (/* binding */ styled)
});

// UNUSED EXPORTS: color, parseColorProps, themeTokens

// EXTERNAL MODULE: ./node_modules/react/jsx-runtime.js
var jsx_runtime = __webpack_require__(38);
// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(4191);
// EXTERNAL MODULE: ./node_modules/focus-visible/dist/focus-visible.js
var focus_visible = __webpack_require__(6719);
// EXTERNAL MODULE: ./node_modules/styled-components/dist/styled-components.browser.esm.js + 2 modules
var styled_components_browser_esm = __webpack_require__(2294);
;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/theme/base.js
const themeBase = {
    radii: {
        $2: 2,
        $4: 4,
        $6: 6,
        $8: 8
    },
    fonts: {
        default: "'Inter', sans-serif",
        title: "'Barlow Semi Condensed', sans-serif",
        code: "'JetBrains Mono', monospace"
    },
    zIndex: {
        appBar: 1000,
        focus: 1750,
        explorer: 1900,
        overlay: 1950,
        dialog: 2000,
        drawer: 1990,
        tooltip: 2250,
        snackBar: 2500,
        dropdown: 3000
    },
    transition: {
        duration: {
            instant: 80,
            fast: 120,
            normal: 200,
            slow: 300
        },
        function: {
            default: 'cubic-bezier(0.4, 0.0, 0.2, 1)',
            easeOut: 'ease-out',
            linear: 'linear'
        }
    },
    breakpoints: ['640px', '840px', '1040px', '1240px'],
    screen: {
        xl: '@media only screen and (max-width: 1439px)',
        l: '@media only screen and (max-width: 1239px)',
        m: '@media only screen and (max-width: 1039px)',
        s: '@media only screen and (max-width: 839px)',
        xs: '@media only screen and (max-width: 639px)'
    },
    maxWidth: 1440
};
const themeLight = {
    shadows: {
        level1: '0px 2px 8px rgba(19, 25, 40, 0.06)',
        level2: '0px 2px 2px rgba(19, 46, 87, 0.12), 0px 4px 16px rgba(19, 46, 87, 0.12)'
    }
};
const themeDark = {
    shadows: {
        level1: '0px 4px 7px rgba(0, 0, 0, 0.2)',
        level2: '0 1px 1px rgba(0, 0, 0, 0.2), 0 0 8px rgba(0, 0, 0, 0.2)'
    }
};
/* harmony default export */ const base = (themeBase);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/theme/reset.js
const styleReset = () => `
   *, *:after, *:before {
      margin: 0;
      padding: 0;
      border: 0;
      font-weight: 400;
      box-sizing: border-box;
      outline: none;
   }

   html {
      font-size: 62.5%;
   } 

   html, body, #root {
      width: 100%;
      height: 100%;
   }

   .token.comment,
   .token.prolog,
   .token.doctype,
   .token.cdata {
      color: #8292a2;
   }

   .token.punctuation {
      color: #f8f8f2;
   }

   .token.namespace {
      opacity: 0.7;
   }

   .token.property,
   .token.tag,
   .token.constant,
   .token.symbol,
   .token.deleted {
      color: #f92672;
   }

   .token.boolean,
   .token.number {
      color: #ae81ff;
   }

   .token.selector,
   .token.attr-name,
   .token.string,
   .token.char,
   .token.builtin,
   .token.inserted {
      color: #a6e22e;
   }

   .token.operator,
   .token.entity,
   .token.url,
   .language-css .token.string,
   .style .token.string,
   .token.variable {
      color: #f8f8f2;
   }

   .token.atrule,
   .token.attr-value,
   .token.function,
   .token.class-name {
      color: #e6db74;
   }

   .token.keyword {
      color: #66d9ef;
   }

   .token.regex,
   .token.important {
      color: #fd971f;
   }

   .token.important,
   .token.bold {
      font-weight: bold;
   }
   .token.italic {
      font-style: italic;
   }

   .token.entity {
      cursor: help;
   }
`;
/* harmony default export */ const theme_reset = (styleReset);

// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/hooks/useViewport.js
var useViewport = __webpack_require__(9261);
// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/theme/helpers.js
var helpers = __webpack_require__(3709);
// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/theme/tokens.json
var tokens = __webpack_require__(4083);
;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/theme/index.js










const { default: styled, createGlobalStyle, css, keyframes } = styled_components_browser_esm;
const ThemeGlobals = createGlobalStyle `
  ${theme_reset}

  ${({ selector }) => selector} {
    background: ${({ theme }) => theme.color('dark100', 'light80')};
    font-family: ${({ theme }) => theme.fonts.default};
    font-size: ${({ theme }) => theme.fontSizes.$14};
    font-weight: ${({ theme }) => theme.fontWeights.regular};
    color: ${(0,helpers/* color */.$_)('dark0')};

    button, input, label, textarea {
      font-family: ${({ theme }) => theme.fonts.default};
      font-size: ${({ theme }) => theme.fontSizes.$14};
      font-weight: ${({ theme }) => theme.fontWeights.regular};
    }

    a, button {
      cursor: pointer;
      text-decoration: none;
    }

    code {
      font-family: ${({ theme }) => theme.fonts.code};
    }
  }
`;
const ThemeContext = styled_components_browser_esm.ThemeContext;
const ThemeProvider = ({ name, rootId, children }) => {
    const themeName = name || 'dark';
    const theme = (0,react.useMemo)(() => (Object.assign(Object.assign(Object.assign({ name: themeName, color: helpers/* color */.$_ }, base), (themeName === 'dark' ? themeDark : themeLight)), tokens)), [themeName]);
    return ((0,jsx_runtime.jsx)(styled_components_browser_esm.ThemeProvider, Object.assign({ theme: theme }, { children: (0,jsx_runtime.jsxs)(useViewport/* default */.Z, { children: [(0,jsx_runtime.jsx)(ThemeGlobals, { selector: rootId ? `#${rootId}` : 'body' }), children] }) })));
};



/***/ }),

/***/ 9978:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "M": () => (/* binding */ createShouldForwardProp),
/* harmony export */   "x": () => (/* binding */ shouldForwardProp)
/* harmony export */ });
/* harmony import */ var styled_system__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4912);

const DEFAULT_PROPS = (0,styled_system__WEBPACK_IMPORTED_MODULE_0__/* .compose */ .qC)(styled_system__WEBPACK_IMPORTED_MODULE_0__/* .space */ .Dh, styled_system__WEBPACK_IMPORTED_MODULE_0__/* .typography */ .cp, styled_system__WEBPACK_IMPORTED_MODULE_0__/* .color */ .$_, styled_system__WEBPACK_IMPORTED_MODULE_0__/* .border */ .Cg, styled_system__WEBPACK_IMPORTED_MODULE_0__/* .background */ .Oq, styled_system__WEBPACK_IMPORTED_MODULE_0__/* .position */ .FK, styled_system__WEBPACK_IMPORTED_MODULE_0__/* .size */ .dp, styled_system__WEBPACK_IMPORTED_MODULE_0__/* .width */ .bf, styled_system__WEBPACK_IMPORTED_MODULE_0__/* .height */ .Cb).propNames || [];
/**
 * Creates a memoized function to define props that need to be excluded from added as HTML element attributes when using Styled components
 *
 * @example
 * const shouldForwardProp = createShouldForwardProp(["title"])
 * const Component = styled('div').withConfig({ shouldForwardProp })<ComponentProps>`...`
 */
const createShouldForwardProp = (excludeProps) => {
    const cache = {};
    return (prop, defaultValidator) => {
        if (cache[prop] === undefined) {
            cache[prop] = defaultValidator(prop) && excludeProps.indexOf(prop) < 0;
        }
        return cache[prop];
    };
};
/**
 * Memoized function to define props to be excluded from added as HTML element attributes when using Styled components
 *
 * @example
 * const Component = styled('div').withConfig({ shouldForwardProp })<ComponentProps>`...`
 */
const shouldForwardProp = createShouldForwardProp(DEFAULT_PROPS);


/***/ }),

/***/ 1645:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "IconAdd": () => (/* reexport */ ElementIconAdd),
  "IconAddFile": () => (/* reexport */ ElementIconAddFile),
  "IconAddItem": () => (/* reexport */ ElementIconAddItem),
  "IconAnchor": () => (/* reexport */ ElementIconAnchor),
  "IconAttribute": () => (/* reexport */ ElementIconAttribute),
  "IconAttributeList": () => (/* reexport */ ElementIconAttributeList),
  "IconBranch": () => (/* reexport */ ElementIconBranch),
  "IconBrowser": () => (/* reexport */ ElementIconBrowser/* default */.Z),
  "IconButton": () => (/* reexport */ ElementIconButton/* default */.Z),
  "IconCamera": () => (/* reexport */ ElementIconCamera),
  "IconClickHand": () => (/* reexport */ ElementIconClickHand/* default */.Z),
  "IconClose": () => (/* reexport */ ElementIconClose),
  "IconCloseDataTable": () => (/* reexport */ ElementIconCloseDataTable),
  "IconCloseFile": () => (/* reexport */ ElementIconCloseFile),
  "IconCloseWindow": () => (/* reexport */ ElementIconCloseWindow),
  "IconCloudDownload": () => (/* reexport */ ElementIconCloudDownload),
  "IconCode": () => (/* reexport */ ElementIconCode),
  "IconCodeFile": () => (/* reexport */ ElementIconCodeFile),
  "IconComment": () => (/* reexport */ ElementIconComment),
  "IconContinue": () => (/* reexport */ ElementIconContinue),
  "IconCookie": () => (/* reexport */ ElementIconCookie),
  "IconCopyPaste": () => (/* reexport */ ElementIconCopyPaste),
  "IconCorner": () => (/* reexport */ ElementIconCorner),
  "IconDataTable": () => (/* reexport */ ElementIconDataTable),
  "IconDataTableList": () => (/* reexport */ ElementIconDataTableList),
  "IconDatabase": () => (/* reexport */ ElementIconDatabase),
  "IconDate": () => (/* reexport */ ElementIconDate),
  "IconDisabledFile": () => (/* reexport */ ElementIconDisabledFile),
  "IconDocument": () => (/* reexport */ ElementIconDocument),
  "IconEdit": () => (/* reexport */ ElementIconEdit),
  "IconEditCode": () => (/* reexport */ ElementIconEditCode),
  "IconExcelDocument": () => (/* reexport */ ElementIconExcelDocument),
  "IconExit": () => (/* reexport */ ElementIconExit),
  "IconExperiment": () => (/* reexport */ ElementIconExperiment),
  "IconFileError": () => (/* reexport */ ElementIconFileError),
  "IconFileSearch": () => (/* reexport */ ElementIconFileSearch),
  "IconFolder": () => (/* reexport */ ElementIconFolder),
  "IconForm": () => (/* reexport */ ElementIconForm),
  "IconGetValue": () => (/* reexport */ ElementIconGetValue),
  "IconGridCell": () => (/* reexport */ ElementIconGridCell/* default */.Z),
  "IconHeading": () => (/* reexport */ ElementIconHeading),
  "IconImage": () => (/* reexport */ ElementIconImage),
  "IconInput": () => (/* reexport */ ElementIconInput/* default */.Z),
  "IconJoin": () => (/* reexport */ ElementIconJoin),
  "IconLine": () => (/* reexport */ ElementIconLine),
  "IconLink": () => (/* reexport */ ElementIconLink/* default */.Z),
  "IconList": () => (/* reexport */ ElementIconList),
  "IconLoop": () => (/* reexport */ ElementIconLoop),
  "IconMail": () => (/* reexport */ ElementIconMail),
  "IconMaximize": () => (/* reexport */ ElementIconMaximize),
  "IconMicrosoftWindows": () => (/* reexport */ ElementIconMicrosoftWindows),
  "IconMinimize": () => (/* reexport */ ElementIconMinimize),
  "IconNumber": () => (/* reexport */ ElementIconNumber),
  "IconOpenFile": () => (/* reexport */ ElementIconOpenFile),
  "IconPass": () => (/* reexport */ ElementIconPass),
  "IconPause": () => (/* reexport */ ElementIconPause),
  "IconPdf": () => (/* reexport */ ElementIconPdf),
  "IconPlay": () => (/* reexport */ ElementIconPlay),
  "IconPrint": () => (/* reexport */ ElementIconPrint),
  "IconRemove": () => (/* reexport */ ElementIconRemove),
  "IconRemoveAnchor": () => (/* reexport */ ElementIconRemoveAnchor),
  "IconRemoveFile": () => (/* reexport */ ElementIconRemoveFile),
  "IconRemoveItem": () => (/* reexport */ ElementIconRemoveItem),
  "IconReplace": () => (/* reexport */ ElementIconReplace),
  "IconReturn": () => (/* reexport */ ElementIconReturn),
  "IconSaveFile": () => (/* reexport */ ElementIconSaveFile),
  "IconSearch": () => (/* reexport */ ElementIconSearch),
  "IconSelect": () => (/* reexport */ ElementIconSelect),
  "IconSetValue": () => (/* reexport */ ElementIconSetValue/* default */.Z),
  "IconSplit": () => (/* reexport */ ElementIconSplit),
  "IconStop": () => (/* reexport */ ElementIconStop),
  "IconTable": () => (/* reexport */ ElementIconTable),
  "IconText": () => (/* reexport */ ElementIconText),
  "IconTextBar": () => (/* reexport */ ElementIconTextBar),
  "IconTextFile": () => (/* reexport */ ElementIconTextFile),
  "IconTime": () => (/* reexport */ ElementIconTime/* default */.Z),
  "IconTree": () => (/* reexport */ ElementIconTree),
  "IconTryCatch": () => (/* reexport */ ElementIconTryCatch),
  "IconVariableSquare": () => (/* reexport */ ElementIconVariableSquare),
  "IconVariableX": () => (/* reexport */ ElementIconVariableX),
  "IconWarning": () => (/* reexport */ ElementIconWarning),
  "IconWindow": () => (/* reexport */ ElementIconWindow),
  "IconWindowList": () => (/* reexport */ ElementIconWindowList)
});

// EXTERNAL MODULE: ./node_modules/react/jsx-runtime.js
var jsx_runtime = __webpack_require__(38);
// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/Icon.js
var Icon = __webpack_require__(3170);
// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/helpers/component.js
var component = __webpack_require__(8335);
;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/ElementIconImage.js



/**
 * Semantic vector graphics icon IconImage.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconImage size="large" color="green50" />
 */
const IconImage = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsxs)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: [(0,jsx_runtime.jsx)("path", { d: "M24 8.41a1 1 0 0 0-.29-.7l-5.42-5.42a1 1 0 0 0-.7-.29H2a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h20a2 2 0 0 0 2-2V8.41ZM22 19.5a.5.5 0 0 1-.5.5h-19a.5.5 0 0 1-.5-.5v-15a.5.5 0 0 1 .5-.5H17a.49.49 0 0 1 .36.15l4.53 4.53A.49.49 0 0 1 22 9v10.5Z", fill: "currentColor" }), (0,jsx_runtime.jsx)("path", { d: "M8.3 10a2 2 0 1 0 0-4 2 2 0 0 0 0 4ZM13.72 10.68a.49.49 0 0 0-.84 0l-2.43 3.88a.27.27 0 0 1-.21.12.24.24 0 0 1-.21-.12l-.87-1.38a.49.49 0 0 0-.666-.175.509.509 0 0 0-.184.175l-2.77 4.44a.25.25 0 0 0 0 .25.26.26 0 0 0 .22.13h12.1a.26.26 0 0 0 .253-.255.25.25 0 0 0-.033-.125l-4.36-6.94Z", fill: "currentColor" })] })));
});
IconImage.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const ElementIconImage = (IconImage);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/ElementIconText.js



/**
 * Semantic vector graphics icon IconText.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconText size="large" color="green50" />
 */
const IconText = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { d: "M14.86 23.27H1.5a1.25 1.25 0 0 1 0-2.5h13.36a1.25 1.25 0 0 1 0 2.5ZM22.5 3.23h-21a1.25 1.25 0 0 1 0-2.5h21a1.25 1.25 0 1 1 0 2.5ZM22.5 9.91h-21a1.25 1.25 0 0 1 0-2.5h21a1.25 1.25 0 0 1 0 2.5ZM22.5 16.59h-21a1.25 1.25 0 0 1 0-2.5h21a1.25 1.25 0 0 1 0 2.5Z", fill: "currentColor" }) })));
});
IconText.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const ElementIconText = (IconText);

// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/ElementIconButton.js
var ElementIconButton = __webpack_require__(8566);
// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/ElementIconInput.js
var ElementIconInput = __webpack_require__(9895);
// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/ElementIconLink.js
var ElementIconLink = __webpack_require__(8958);
// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/ElementIconGridCell.js
var ElementIconGridCell = __webpack_require__(1542);
;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/ElementIconHeading.js



/**
 * Semantic vector graphics icon IconHeading.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconHeading size="large" color="green50" />
 */
const IconHeading = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { d: "M6.035 3.08a.25.25 0 0 1 .25-.25h1.81a1.25 1.25 0 0 0 0-2.5h-6.62a1.25 1.25 0 1 0 0 2.5h1.81a.25.25 0 0 1 .25.25v17.81a.25.25 0 0 1-.25.25h-1.81a1.25 1.25 0 0 0 0 2.5h6.62a1.25 1.25 0 0 0 0-2.5h-1.81a.25.25 0 0 1-.25-.25v-7.7H18.01v7.7a.25.25 0 0 1-.25.25h-1.81a1.25 1.25 0 0 0 0 2.5h6.62a1.25 1.25 0 0 0 0-2.5h-1.81a.25.25 0 0 1-.25-.25V3.08a.25.25 0 0 1 .25-.25h1.81a1.25 1.25 0 0 0 0-2.5h-6.62a1.25 1.25 0 1 0 0 2.5h1.81a.25.25 0 0 1 .25.25v7.61H6.035V3.08Z", fill: "currentColor" }) })));
});
IconHeading.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const ElementIconHeading = (IconHeading);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/ElementIconTable.js



/**
 * Semantic vector graphics icon IconTable.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconTable size="large" color="green50" />
 */
const IconTable = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { d: "M22 0H2a2 2 0 0 0-2 2v20a2 2 0 0 0 2 2h20a2 2 0 0 0 2-2V2a2 2 0 0 0-2-2Zm0 3v8h-8.75a.25.25 0 0 1-.25-.25V2h8a1 1 0 0 1 1 1ZM3 2h8v8.75a.25.25 0 0 1-.25.25H2V3a1 1 0 0 1 1-1ZM2 21v-8h8.75a.25.25 0 0 1 .25.25V22H3a1 1 0 0 1-1-1Zm19 1h-8v-8.75a.25.25 0 0 1 .25-.25H22v8a1 1 0 0 1-1 1Z", fill: "currentColor" }) })));
});
IconTable.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const ElementIconTable = (IconTable);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/ElementIconForm.js



/**
 * Semantic vector graphics icon IconForm.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconForm size="large" color="green50" />
 */
const IconForm = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsxs)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: [(0,jsx_runtime.jsx)("path", { d: "M24 8a3 3 0 0 0-3-3H3a3 3 0 0 0-3 3v8a3 3 0 0 0 3 3h18a3 3 0 0 0 3-3V8Zm-2 8a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V8a1 1 0 0 1 1-1h18a1 1 0 0 1 1 1v8Z", fill: "currentColor" }), (0,jsx_runtime.jsx)("path", { d: "M8 10a1 1 0 0 0 0-2H5a1 1 0 0 0 0 2h.25a.25.25 0 0 1 .25.25v3.5a.25.25 0 0 1-.25.25H5a1 1 0 0 0 0 2h3a1 1 0 0 0 0-2h-.25a.25.25 0 0 1-.25-.25v-3.5a.25.25 0 0 1 .25-.25H8Z", fill: "currentColor" })] })));
});
IconForm.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const ElementIconForm = (IconForm);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/ElementIconVariableSquare.js



/**
 * Semantic vector graphics icon IconVariableSquare.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconVariableSquare size="large" color="green50" />
 */
const IconVariableSquare = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsxs)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: [(0,jsx_runtime.jsx)("path", { d: "M9 10.125v-1.14c0-.17.27-.22.42-.22H10a1 1 0 1 0 0-2h-.63A2.27 2.27 0 0 0 7 8.985v1a.25.25 0 0 1-.1.21l-1.46 1a1 1 0 0 0-.337 1.318 1 1 0 0 0 .337.362l1.45.95a.26.26 0 0 1 .11.16v1a2.27 2.27 0 0 0 2.42 2.21H10a1 1 0 0 0 0-2h-.63c-.15 0-.42 0-.42-.21v-1.13a2.09 2.09 0 0 0-.88-1.68.25.25 0 0 1 0-.38 2.07 2.07 0 0 0 .93-1.67ZM16.85 10.175l1.71.94.01-.03a1 1 0 0 1 0 1.74l-1.71 1a.16.16 0 0 0-.1.16v1a2.372 2.372 0 0 1-2.63 2.21h-.69a1 1 0 1 1 0-2h.69c.44 0 .63-.16.63-.21v-1.1a2 2 0 0 1 .93-1.67.23.23 0 0 0 0-.39 2 2 0 0 1-.93-1.67v-1.17c0-.06-.19-.22-.63-.22h-.69a1 1 0 1 1 0-2h.69a2.37 2.37 0 0 1 2.63 2.22v1.03a.24.24 0 0 0 .09.16Z", fill: "currentColor" }), (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M22 0H2a2 2 0 0 0-2 2v20a2 2 0 0 0 2 2h20a2 2 0 0 0 2-2V2a2 2 0 0 0-2-2Zm0 21.75a.25.25 0 0 1-.25.25H2.25a.25.25 0 0 1-.25-.25V2.25A.25.25 0 0 1 2.25 2h19.5a.25.25 0 0 1 .25.25v19.5Z", fill: "currentColor" })] })));
});
IconVariableSquare.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const ElementIconVariableSquare = (IconVariableSquare);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/ElementIconLoop.js



/**
 * Semantic vector graphics icon IconLoop.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconLoop size="large" color="green50" />
 */
const IconLoop = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { d: "M10.66 20.07a1.251 1.251 0 0 0-.5 2.45c.724.15 1.46.227 2.2.23a10.75 10.75 0 1 0-10-6.65.24.24 0 0 1-.09.29l-1 .73a1 1 0 0 0-.39 1 1 1 0 0 0 .77.77l4 .85h.21a1 1 0 0 0 .54-.16 1.05 1.05 0 0 0 .43-.58l.94-4.4a1 1 0 0 0-1.56-1l-1.37 1a.24.24 0 0 1-.22 0 .22.22 0 0 1-.16-.16 8.26 8.26 0 1 1 6.2 5.64v-.01Z", fill: "currentColor" }) })));
});
IconLoop.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const ElementIconLoop = (IconLoop);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/ElementIconBranch.js



/**
 * Semantic vector graphics icon IconBranch.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconBranch size="large" color="green50" />
 */
const IconBranch = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { d: "M20.34 10.12a.924.924 0 0 0 .757-.069 1 1 0 0 0 .363-.331l1.89-2.83a1 1 0 0 0 0-1.11l-1.89-2.84a1 1 0 0 0-1.84.56v1.33a.25.25 0 0 1-.25.25h-1.58c-3 0-4.28 1.88-5.29 3.39-1.01 1.51-1.59 2.28-3.21 2.28H1.74a1.25 1.25 0 0 0 0 2.5h7.55c1.62 0 2.21.78 3.21 2.28 1 1.5 2.26 3.39 5.29 3.39h1.58a.25.25 0 0 1 .25.25v1.33a1 1 0 0 0 .72 1 .9.9 0 0 0 .28 0 1 1 0 0 0 .84-.45l1.89-2.83a1 1 0 0 0 0-1.11l-1.89-2.83a1 1 0 0 0-1.84.55v1.34a.25.25 0 0 1-.25.25h-1.58c-1.62 0-2.21-.78-3.21-2.28A10.086 10.086 0 0 0 12.83 12a10.09 10.09 0 0 0 1.75-2.14c1-1.5 1.59-2.28 3.21-2.28h1.58a.25.25 0 0 1 .25.25v1.34a1 1 0 0 0 .72.95Z", fill: "currentColor" }) })));
});
IconBranch.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const ElementIconBranch = (IconBranch);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/ElementIconPlay.js



/**
 * Semantic vector graphics icon IconPlay.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconPlay size="large" color="green50" />
 */
const IconPlay = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsxs)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: [(0,jsx_runtime.jsx)("path", { d: "m10.68 7.71 5.93 3v-.04a1.39 1.39 0 0 1 0 2.58l-5.93 3a1.64 1.64 0 0 1-.76.19 1.37 1.37 0 0 1-.76-.22 1.53 1.53 0 0 1-.7-1.34V9.12a1.48 1.48 0 0 1 2.22-1.41Z", fill: "currentColor" }), (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M5.333 2.022a12 12 0 1 1 13.334 19.956A12 12 0 0 1 5.333 2.022Zm1.428 17.819A9.43 9.43 0 0 0 12 21.43 9.44 9.44 0 0 0 21.43 12a9.43 9.43 0 1 0-14.669 7.84Z", fill: "currentColor" })] })));
});
IconPlay.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const ElementIconPlay = (IconPlay);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/ElementIconDocument.js



/**
 * Semantic vector graphics icon IconDocument.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconDocument size="large" color="green50" />
 */
const IconDocument = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "m19.85 6.68-4.53-4.53A.49.49 0 0 0 15 2H4.5a.5.5 0 0 0-.5.5v19a.5.5 0 0 0 .5.5h15a.5.5 0 0 0 .5-.5V7a.49.49 0 0 0-.15-.32ZM4 0h11.59a1 1 0 0 1 .7.29l5.42 5.42a1 1 0 0 1 .29.7V22a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V2a2 2 0 0 1 2-2Zm3 11h9a1 1 0 0 0 0-2H7a1 1 0 0 0 0 2Zm9 4H7a1 1 0 1 1 0-2h9a1 1 0 0 1 0 2Zm-9 4h4.5a1 1 0 0 0 0-2H7a1 1 0 1 0 0 2Z", fill: "currentColor" }) })));
});
IconDocument.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const ElementIconDocument = (IconDocument);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/ElementIconDisabledFile.js



/**
 * Semantic vector graphics icon IconDisabledFile.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconDisabledFile size="large" color="green50" />
 */
const IconDisabledFile = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsxs)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: [(0,jsx_runtime.jsx)("path", { d: "M21 .59 23.41 3A2 2 0 0 1 24 4.41V18.5a2 2 0 0 1-2 2h-7.77a.25.25 0 0 1-.23-.33c.18-.472.311-.961.39-1.46a.25.25 0 0 1 .25-.21h6.86a.5.5 0 0 0 .5-.5V4.62a.469.469 0 0 0-.15-.35l-2.12-2.12a.47.47 0 0 0-.35-.15H8.5a.5.5 0 0 0-.5.5v6.86a.25.25 0 0 1-.29.25 7.12 7.12 0 0 0-1.46-.09.24.24 0 0 1-.25-.24V2a2 2 0 0 1 2-2h11.59A2 2 0 0 1 21 .59Z", fill: "currentColor" }), (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M2.889 12.095a6.5 6.5 0 1 1 7.222 10.81 6.5 6.5 0 0 1-7.222-10.81ZM2.14 16.28a4.41 4.41 0 0 0 .36 3.32h.03a.25.25 0 0 0 .4.05l5.7-5.72a.26.26 0 0 0-.06-.4 4.41 4.41 0 0 0-3.32-.36 4.47 4.47 0 0 0-3.11 3.11Zm7.514 4.404A4.47 4.47 0 0 0 10.8 18.72h.03a4.41 4.41 0 0 0-.39-3.32.25.25 0 0 0-.4-.05l-5.72 5.72a.25.25 0 0 0 .05.4 4.41 4.41 0 0 0 3.32.36 4.47 4.47 0 0 0 1.964-1.146Z", fill: "currentColor" })] })));
});
IconDisabledFile.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const ElementIconDisabledFile = (IconDisabledFile);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/ElementIconCamera.js



/**
 * Semantic vector graphics icon IconCamera.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconCamera size="large" color="green50" />
 */
const IconCamera = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsxs)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: [(0,jsx_runtime.jsx)("path", { d: "M5.505 5.11h-3a.5.5 0 0 1-.5-.5v-.23a1.5 1.5 0 0 1 1.5-1.5h1a1.5 1.5 0 0 1 1.5 1.5v.23a.49.49 0 0 1-.5.5ZM14.755 16.88a3.75 3.75 0 1 0 0-7.5 3.75 3.75 0 0 0 0 7.5Z", fill: "currentColor" }), (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M21.445 6.12h-1.31a.53.53 0 0 1-.48-.34l-.077-.156c-.622-1.259-1.238-2.504-2.573-2.504h-5c-1.07 0-1.64.78-2.66 2.2l-.174.243c-.256.364-.392.557-.666.557h-6c-2.07 0-2.5 1.21-2.5 2.23v10.39a2.25 2.25 0 0 0 2.56 2.38h18.88a2.25 2.25 0 0 0 2.56-2.38V8.35c0-1.02-.44-2.23-2.56-2.23Zm-.94 7a5.75 5.75 0 1 1-5.75-5.74 5.76 5.76 0 0 1 5.75 5.74Zm-15.5-3.24a1.25 1.25 0 1 1-1.25-1.26 1.24 1.24 0 0 1 1.25 1.26Z", fill: "currentColor" })] })));
});
IconCamera.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const ElementIconCamera = (IconCamera);

// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/ElementIconTime.js
var ElementIconTime = __webpack_require__(5550);
// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/ElementIconClickHand.js
var ElementIconClickHand = __webpack_require__(8939);
;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/ElementIconCodeFile.js



/**
 * Semantic vector graphics icon IconCodeFile.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconCodeFile size="large" color="green50" />
 */
const IconCodeFile = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsxs)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: [(0,jsx_runtime.jsx)("path", { d: "M8.53 13.31a.25.25 0 0 1 0-.34l2.53-2.71a1.003 1.003 0 0 0-.045-1.415A1.001 1.001 0 0 0 9.6 8.89l-3.33 3.57a1 1 0 0 0 0 1.37L9.6 17.4a1 1 0 0 0 1.42.05 1 1 0 0 0 0-1.39l-2.49-2.75ZM14.085 8.633a1 1 0 0 1 .315.257l3.3 3.56a1 1 0 0 1 0 1.37l-3.33 3.57A1 1 0 0 1 12.94 16l2.53-2.66a.25.25 0 0 0 0-.34l-2.53-2.75a1 1 0 0 1 1.145-1.617Z", fill: "currentColor" }), (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M21.71 5.71 16.29.29a1 1 0 0 0-.7-.29H4a2 2 0 0 0-2 2v20a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V6.42a.999.999 0 0 0-.29-.71ZM20 21.5a.5.5 0 0 1-.5.5h-15a.5.5 0 0 1-.5-.5v-19a.5.5 0 0 1 .5-.5H15a.49.49 0 0 1 .36.15l4.53 4.53A.49.49 0 0 1 20 7v14.5Z", fill: "currentColor" })] })));
});
IconCodeFile.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const ElementIconCodeFile = (IconCodeFile);

// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/ElementIconBrowser.js
var ElementIconBrowser = __webpack_require__(1360);
;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/ElementIconCloudDownload.js



/**
 * Semantic vector graphics icon IconCloudDownload.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconCloudDownload size="large" color="green50" />
 */
const IconCloudDownload = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsxs)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: [(0,jsx_runtime.jsx)("path", { d: "M24.003 10.66a5.82 5.82 0 0 0-1.77-4.16 5.7 5.7 0 0 0-3.45-1.59.25.25 0 0 1-.19-.12 7.68 7.68 0 0 0-14.1 2.3.25.25 0 0 1-.22.19 4.66 4.66 0 0 0-2.58 1 4.59 4.59 0 0 0-1.69 3.58 4.33 4.33 0 0 0 1.24 3.21 5.58 5.58 0 0 0 3.6 1.38 1 1 0 0 0 0-2 3.36 3.36 0 0 1-2.17-.81 2.35 2.35 0 0 1-.67-1.78 2.58 2.58 0 0 1 3.12-2.53 1 1 0 0 0 .81-.19 1 1 0 0 0 .39-.73 5.68 5.68 0 0 1 10.82-2.09 1 1 0 0 0 .94.57 3.66 3.66 0 0 1 2.76 1.05 3.74 3.74 0 0 1 1.16 2.72 3.83 3.83 0 0 1-3.44 3.79 1.009 1.009 0 1 0 .26 2 5.82 5.82 0 0 0 5.18-5.79Z", fill: "currentColor" }), (0,jsx_runtime.jsx)("path", { d: "M15.504 17.45h-1.75a.25.25 0 0 1-.25-.25V10a1.5 1.5 0 0 0-3 0v7.2a.25.25 0 0 1-.25.25h-1.75a1 1 0 0 0-.71 1.7l3.5 3.5a1 1 0 0 0 1.42 0l3.5-3.5a1 1 0 0 0-.71-1.7Z", fill: "currentColor" })] })));
});
IconCloudDownload.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const ElementIconCloudDownload = (IconCloudDownload);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/ElementIconExcelDocument.js



/**
 * Semantic vector graphics icon IconExcelDocument.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconExcelDocument size="large" color="green50" />
 */
const IconExcelDocument = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsxs)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: [(0,jsx_runtime.jsx)("path", { d: "M18 19v-9a1 1 0 0 0-1-1H1a1 1 0 0 0-1 1v9a1 1 0 0 0 1 1h16a1 1 0 0 0 1-1ZM6.06 17.22a.63.63 0 0 1-.28.84.71.71 0 0 1-.28.06.62.62 0 0 1-.56-.34L4.06 16h-.12l-.88 1.76a.62.62 0 0 1-.56.34.71.71 0 0 1-.28-.06.63.63 0 0 1-.28-.84l1.31-2.61a.28.28 0 0 0 0-.22l-1.31-2.59a.63.63 0 0 1 1.12-.56L3.93 13a.08.08 0 0 0 .11.03.08.08 0 0 0 .03-.03c0-.06.87-1.75.87-1.75a.63.63 0 0 1 1.12.56l-1.31 2.58a.28.28 0 0 0 0 .22l1.31 2.61Zm4.44.9h-2a1.62 1.62 0 0 1-1.62-1.62v-5a.62.62 0 0 1 1.24 0v5a.37.37 0 0 0 .38.37h2a.63.63 0 0 1 0 1.25Zm2.93-4.75 1.84 1.22a1.94 1.94 0 0 1 .288 2.968 1.92 1.92 0 0 1-1.358.562h-1.7a.63.63 0 0 1 0-1.25h1.7a.68.68 0 0 0 .68-.67.691.691 0 0 0-.31-.57l-1.84-1.23a1.93 1.93 0 0 1 1.07-3.53h1.7a.63.63 0 0 1 0 1.25h-1.7a.68.68 0 0 0-.37 1.25Z", fill: "currentColor" }), (0,jsx_runtime.jsx)("path", { d: "M23.71 5.71 18.29.29a1 1 0 0 0-.7-.29H6a2 2 0 0 0-2 2v5.75a.25.25 0 0 0 .25.25h1.5A.25.25 0 0 0 6 7.75V2.5a.5.5 0 0 1 .5-.5h10.25a.25.25 0 0 1 .25.25V5a2 2 0 0 0 2 2h2.75a.25.25 0 0 1 .25.25V21.5a.5.5 0 0 1-.5.5H6.25a.25.25 0 0 1-.25-.25v-.5a.25.25 0 0 0-.25-.25h-1.5a.25.25 0 0 0-.25.25V22a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V6.41a1 1 0 0 0-.29-.7Z", fill: "currentColor" })] })));
});
IconExcelDocument.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const ElementIconExcelDocument = (IconExcelDocument);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/ElementIconCorner.js



/**
 * Semantic vector graphics icon IconCorner.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconCorner size="large" color="green50" />
 */
const IconCorner = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { d: "M0 16.001V1.251a.12.12 0 0 1 .006-.036 1.245 1.245 0 0 1 2.49-.004.15.15 0 0 1 .005.04v14.75a.76.76 0 0 0 .75.75H15a.25.25 0 0 0 .25-.25v-3.5a.999.999 0 0 1 .62-.92 1 1 0 0 1 1.09.21l5 5a1 1 0 0 1 0 1.42l-5 5a1 1 0 0 1-1.09.21 1 1 0 0 1-.62-.92v-3.5a.25.25 0 0 0-.25-.25H3.25A3.26 3.26 0 0 1 0 16.001Z", fill: "currentColor" }) })));
});
IconCorner.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const ElementIconCorner = (IconCorner);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/ElementIconVariableX.js



/**
 * Semantic vector graphics icon IconVariableX.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconVariableX size="large" color="green50" />
 */
const IconVariableX = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsxs)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: [(0,jsx_runtime.jsx)("path", { d: "M4.378 12.225a3.222 3.222 0 0 1 1.75 2.872v2.048c0 .49.474.806 1.192.806h1.05a1.313 1.313 0 0 1 0 2.627H7.32a3.503 3.503 0 0 1-3.818-3.503v-1.978a.806.806 0 0 0-.438-.648L.595 12.925a1.314 1.314 0 0 1-.433-1.728c.103-.192.252-.356.433-.478l2.347-1.523c.438-.228.63-.473.63-.666V6.516A3.502 3.502 0 0 1 7.39 3.014h1.05a1.313 1.313 0 1 1 0 2.627H7.39c-.718 0-1.191.315-1.191.823v2.049a3.292 3.292 0 0 1-1.944 2.924s-.298.14-.298.333c0 .192.42.455.42.455ZM23.254 12.96 20.61 14.45c-.543.245-.735.508-.735.63v2.049a3.73 3.73 0 0 1-4.168 3.502h-1.103a1.34 1.34 0 0 1 0-2.68h1.19c.876 0 1.542-.35 1.542-.805v-2.048a3.344 3.344 0 0 1 2.189-2.977s.28-.158.28-.35c0-.193-.403-.298-.403-.298a3.274 3.274 0 0 1-2.066-2.907V6.516c0-.472-.666-.823-1.541-.823h-1.191a1.313 1.313 0 1 1 0-2.626h1.19a3.73 3.73 0 0 1 4.168 3.502v2.049c0 .105.193.367.63.56l2.75 1.558a1.313 1.313 0 0 1 0 2.277l-.088-.053Z", fill: "currentColor" }), (0,jsx_runtime.jsx)("path", { d: "M13.89 12.995a.857.857 0 0 1-1.21 1.212l-.904-.903a.286.286 0 0 0-.411 0l-.903.902a.857.857 0 0 1-1.211-1.211l.902-.903a.285.285 0 0 0 0-.411l-.902-.972a.857.857 0 0 1 1.211-1.143l.903.903a.284.284 0 0 0 .411 0l.903-.903a.857.857 0 0 1 1.212 1.143l-.903.903a.287.287 0 0 0-.065.318.288.288 0 0 0 .065.094l.903.971Z", fill: "currentColor" })] })));
});
IconVariableX.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const ElementIconVariableX = (IconVariableX);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/ElementIconCode.js



/**
 * Semantic vector graphics icon IconCode.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconCode size="large" color="green50" />
 */
const IconCode = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { d: "M9.386 21.122c-.25.275-.589.43-.942.43s-.692-.155-.942-.43L.39 13.295A1.546 1.546 0 0 1 0 12.258c0-.389.14-.762.39-1.037l7.112-7.827c.253-.26.587-.4.932-.394.346.007.675.161.92.43.244.269.384.631.39 1.012.006.38-.122.748-.358 1.026l-5.831 6.497a.532.532 0 0 0 0 .704l5.85 6.438c.247.278.384.652.38 1.041-.003.389-.146.76-.399 1.033v-.059ZM23.61 13.295l-7.112 7.827c-.253.26-.587.4-.932.394a1.277 1.277 0 0 1-.92-.43 1.544 1.544 0 0 1-.39-1.011c-.006-.38.122-.749.358-1.027l5.85-6.438a.493.493 0 0 0 .1-.16.533.533 0 0 0-.1-.544l-5.85-6.38a1.553 1.553 0 0 1-.358-1.026c.006-.38.146-.743.39-1.011.245-.27.574-.423.92-.43.345-.007.68.134.932.394l7.112 7.827c.25.275.39.648.39 1.037 0 .389-.14.762-.39 1.037v-.059Z", fill: "currentColor" }) })));
});
IconCode.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const ElementIconCode = (IconCode);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/ElementIconPause.js



/**
 * Semantic vector graphics icon IconPause.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconPause size="large" color="green50" />
 */
const IconPause = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsxs)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: [(0,jsx_runtime.jsx)("path", { d: "M12 0a12 12 0 1 0 0 24 12 12 0 0 0 0-24Zm0 21.55A9.55 9.55 0 1 1 21.55 12 9.56 9.56 0 0 1 12 21.55Z", fill: "currentColor" }), (0,jsx_runtime.jsx)("path", { d: "M10.27 7.14H8.83a.98.98 0 0 0-.98.98v8.82c0 .541.439.98.98.98h1.44a.98.98 0 0 0 .98-.98V8.12a.98.98 0 0 0-.98-.98ZM15.2 7.1h-1.5a.98.98 0 0 0-.98.98v8.82c0 .541.439.98.98.98h1.5a.98.98 0 0 0 .98-.98V8.08a.98.98 0 0 0-.98-.98Z", fill: "currentColor" })] })));
});
IconPause.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const ElementIconPause = (IconPause);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/ElementIconStop.js



/**
 * Semantic vector graphics icon IconStop.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconStop size="large" color="green50" />
 */
const IconStop = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsxs)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: [(0,jsx_runtime.jsx)("path", { d: "M12 0a12 12 0 1 0 0 24 12 12 0 0 0 0-24Zm0 21.55A9.55 9.55 0 1 1 21.55 12 9.56 9.56 0 0 1 12 21.55Z", fill: "currentColor" }), (0,jsx_runtime.jsx)("path", { d: "M14.94 8.08H9.06a.98.98 0 0 0-.98.98v5.88c0 .541.439.98.98.98h5.88a.98.98 0 0 0 .98-.98V9.06a.98.98 0 0 0-.98-.98Z", fill: "currentColor" })] })));
});
IconStop.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const ElementIconStop = (IconStop);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/ElementIconOpenFile.js



/**
 * Semantic vector graphics icon IconOpenFile.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconOpenFile size="large" color="green50" />
 */
const IconOpenFile = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { d: "M23.44 9.55A1.5 1.5 0 0 0 22.28 9H10.42a.5.5 0 0 1-.49-.4l-.28-1.39A1.51 1.51 0 0 0 8.18 6H1.72a1.48 1.48 0 0 0-1.16.55 1.47 1.47 0 0 0-.31 1.24l2.6 13A1.51 1.51 0 0 0 4.32 22h16a1.51 1.51 0 0 0 1.47-1.21l2-10a1.469 1.469 0 0 0-.35-1.24ZM3.22 5a1 1 0 0 0 1-.78.26.26 0 0 1 .22-.22h15.28a.5.5 0 0 1 .5.5V7a1 1 0 0 0 2 0V4a2 2 0 0 0-2-2h-16a2 2 0 0 0-2 2 1 1 0 0 0 1 1Z", fill: "currentColor" }) })));
});
IconOpenFile.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const ElementIconOpenFile = (IconOpenFile);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/ElementIconDatabase.js



/**
 * Semantic vector graphics icon IconDatabase.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconDatabase size="large" color="green50" />
 */
const IconDatabase = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { d: "M12 .63c-5.08 0-10.49 1.75-10.5 5v12.75c0 3.25 5.41 5 10.5 5s10.5-1.75 10.5-5V5.64C22.5 2.38 17.09.63 12 .63Zm8.5 17.75c0 1.22-3.31 3-8.5 3-5.19 0-8.5-1.78-8.5-3v-.79a.25.25 0 0 1 .37-.22A17.62 17.62 0 0 0 12 19.13a17.65 17.65 0 0 0 8.13-1.76.25.25 0 0 1 .37.22v.79Zm0-4.25c0 1.22-3.31 3-8.5 3-5.19 0-8.5-1.78-8.5-3v-.79a.25.25 0 0 1 .37-.22A17.62 17.62 0 0 0 12 14.88a17.65 17.65 0 0 0 8.13-1.76.25.25 0 0 1 .37.22v.79Zm0-4.25c0 1.22-3.31 3-8.5 3-5.19 0-8.5-1.78-8.5-3v-.79a.25.25 0 0 1 .37-.22A17.65 17.65 0 0 0 12 10.63a17.65 17.65 0 0 0 8.13-1.76.25.25 0 0 1 .37.22v.79Zm0-4.25c0 1.23-3.32 3-8.5 3s-8.5-1.78-8.5-3 3.31-3 8.5-3c5.19 0 8.5 1.77 8.5 3Z", fill: "currentColor" }) })));
});
IconDatabase.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const ElementIconDatabase = (IconDatabase);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/ElementIconPdf.js



/**
 * Semantic vector graphics icon IconPdf.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconPdf size="large" color="green50" />
 */
const IconPdf = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsxs)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: [(0,jsx_runtime.jsx)("path", { d: "M8.45 12.32c-.1 0-.33-.05-.33.17v4a.24.24 0 0 0 .33.21 2.36 2.36 0 0 0 1.43-2.2 2.39 2.39 0 0 0-1.43-2.18ZM4 12.12h-.62a.26.26 0 0 0-.26.26v1.24a.26.26 0 0 0 .26.25H4a.88.88 0 1 0 0-1.75Z", fill: "currentColor" }), (0,jsx_runtime.jsx)("path", { d: "M18 19v-9a1 1 0 0 0-1-1H1a1 1 0 0 0-1 1v9a1 1 0 0 0 1 1h16a1 1 0 0 0 1-1ZM4 15.12h-.62a.26.26 0 0 0-.26.26v2.12a.62.62 0 0 1-1.24 0v-6a.63.63 0 0 1 .62-.63H4a2.13 2.13 0 0 1 0 4.25Zm3.5 3a.62.62 0 0 1-.62-.62v-6a.63.63 0 0 1 .62-.63 3.63 3.63 0 0 1 0 7.25Zm8-6h-2a.38.38 0 0 0-.38.38v1.12a.26.26 0 0 0 .26.25h1.12a.63.63 0 0 1 0 1.25h-1.12a.26.26 0 0 0-.26.26v2.12a.62.62 0 0 1-1.24 0v-5a1.62 1.62 0 0 1 1.62-1.63h2a.63.63 0 0 1 0 1.25Z", fill: "currentColor" }), (0,jsx_runtime.jsx)("path", { d: "M23.71 5.71 18.29.29a1 1 0 0 0-.7-.29H6a2 2 0 0 0-2 2v5.75a.25.25 0 0 0 .25.25h1.5A.25.25 0 0 0 6 7.75V2.5a.5.5 0 0 1 .5-.5h10.25a.25.25 0 0 1 .25.25V5a2 2 0 0 0 2 2h2.75a.25.25 0 0 1 .25.25V21.5a.5.5 0 0 1-.5.5H6.25a.25.25 0 0 1-.25-.25v-.5a.25.25 0 0 0-.25-.25h-1.5a.25.25 0 0 0-.25.25V22a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V6.41a1 1 0 0 0-.29-.7Z", fill: "currentColor" })] })));
});
IconPdf.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const ElementIconPdf = (IconPdf);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/ElementIconPass.js



/**
 * Semantic vector graphics icon IconPass.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconPass size="large" color="green50" />
 */
const IconPass = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { d: "M2.9 10.63a6.36 6.36 0 0 1 6.35-6.35h13.28a1.44 1.44 0 1 0 0-2.87H9.25a9.22 9.22 0 1 0 0 18.44h8.85a.25.25 0 0 1 .25.25v1.06a1.43 1.43 0 0 0 1.972 1.32c.172-.071.328-.177.458-.31l2.75-2.74a1.45 1.45 0 0 0 0-2l-2.73-2.78a1.43 1.43 0 0 0-2.45 1v1.06a.25.25 0 0 1-.25.25H9.25a6.35 6.35 0 0 1-6.35-6.33Z", fill: "currentColor" }) })));
});
IconPass.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const ElementIconPass = (IconPass);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/ElementIconNumber.js



/**
 * Semantic vector graphics icon IconNumber.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconNumber size="large" color="green50" />
 */
const IconNumber = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { d: "M22.5 7.41h-4.76a.28.28 0 0 1-.19-.09.23.23 0 0 1-.05-.21l1-5.39a1.27 1.27 0 1 0-2.5-.45L14.94 7.2a.26.26 0 0 1-.25.21h-3.63a.28.28 0 0 1-.19-.09.23.23 0 0 1 0-.21l1-5.39a1.25 1.25 0 1 0-2.46-.45L8.26 7.2a.26.26 0 0 1-.26.21H3.41a1.25 1.25 0 1 0 0 2.5h4.06a.25.25 0 0 1 .19.09.28.28 0 0 1 0 .2L7 13.88a.26.26 0 0 1-.25.21H1.5a1.25 1.25 0 1 0 0 2.5h4.75a.252.252 0 0 1 .19.09.21.21 0 0 1 0 .2l-1 5.39a1.3 1.3 0 1 0 2.56.45l1.08-5.93a.25.25 0 0 1 .25-.2h3.63a.252.252 0 0 1 .19.09.21.21 0 0 1 .05.2l-1 5.39a1.252 1.252 0 0 0 1.94 1.254 1.25 1.25 0 0 0 .52-.804l1.08-5.93a.25.25 0 0 1 .25-.2h4.61a1.25 1.25 0 1 0 0-2.5h-4.08a.25.25 0 0 1-.19-.09.3.3 0 0 1 0-.21l.67-3.68a.25.25 0 0 1 .25-.2h5.3a1.25 1.25 0 0 0 0-2.5h-.05Zm-8.78 6.47a.25.25 0 0 1-.24.21H9.84a.25.25 0 0 1-.241-.189.23.23 0 0 1 .001-.111l.67-3.68a.24.24 0 0 1 .24-.2h3.64a.25.25 0 0 1 .19.09.21.21 0 0 1 .05.2l-.67 3.68Z", fill: "currentColor" }) })));
});
IconNumber.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const ElementIconNumber = (IconNumber);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/ElementIconList.js



/**
 * Semantic vector graphics icon IconList.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconList size="large" color="green50" />
 */
const IconList = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsxs)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: [(0,jsx_runtime.jsx)("path", { d: "M8.5 5H23a1 1 0 1 0 0-2H8.5a1 1 0 0 0 0 2ZM23 11H8.5a1 1 0 0 0 0 2H23a1 1 0 0 0 0-2ZM23 19H8.5a1 1 0 0 0 0 2H23a1 1 0 0 0 0-2ZM3.5 2.5h-2A.5.5 0 0 0 1 3v2a.5.5 0 0 0 .5.5h2A.5.5 0 0 0 4 5V3a.5.5 0 0 0-.5-.5Z", fill: "currentColor" }), (0,jsx_runtime.jsx)("path", { d: "M3.5 1.5h-2A1.5 1.5 0 0 0 0 3v2a1.5 1.5 0 0 0 1.5 1.5h2A1.5 1.5 0 0 0 5 5V3a1.5 1.5 0 0 0-1.5-1.5ZM4 5a.5.5 0 0 1-.5.5h-2A.5.5 0 0 1 1 5V3a.5.5 0 0 1 .5-.5h2A.5.5 0 0 1 4 3v2ZM3.5 10.5h-2a.5.5 0 0 0-.5.5v2a.5.5 0 0 0 .5.5h2A.5.5 0 0 0 4 13v-2a.5.5 0 0 0-.5-.5Z", fill: "currentColor" }), (0,jsx_runtime.jsx)("path", { d: "M3.5 9.5h-2A1.5 1.5 0 0 0 0 11v2a1.5 1.5 0 0 0 1.5 1.5h2A1.5 1.5 0 0 0 5 13v-2a1.5 1.5 0 0 0-1.5-1.5ZM4 13a.5.5 0 0 1-.5.5h-2A.5.5 0 0 1 1 13v-2a.5.5 0 0 1 .5-.5h2a.5.5 0 0 1 .5.5v2ZM3.5 18.5h-2a.5.5 0 0 0-.5.5v2a.5.5 0 0 0 .5.5h2A.5.5 0 0 0 4 21v-2a.5.5 0 0 0-.5-.5Z", fill: "currentColor" }), (0,jsx_runtime.jsx)("path", { d: "M3.5 17.5h-2A1.5 1.5 0 0 0 0 19v2a1.5 1.5 0 0 0 1.5 1.5h2A1.5 1.5 0 0 0 5 21v-2a1.5 1.5 0 0 0-1.5-1.5ZM4 21a.5.5 0 0 1-.5.5h-2A.5.5 0 0 1 1 21v-2a.5.5 0 0 1 .5-.5h2a.5.5 0 0 1 .5.5v2Z", fill: "currentColor" })] })));
});
IconList.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const ElementIconList = (IconList);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/ElementIconTryCatch.js



/**
 * Semantic vector graphics icon IconTryCatch.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconTryCatch size="large" color="green50" />
 */
const IconTryCatch = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsxs)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: [(0,jsx_runtime.jsx)("path", { d: "M22 0H2a2 2 0 0 0-2 2v20a2 2 0 0 0 2 2h20a2 2 0 0 0 2-2V2a2 2 0 0 0-2-2Zm0 21.5a.5.5 0 0 1-.5.5h-19a.5.5 0 0 1-.5-.5v-19a.5.5 0 0 1 .5-.5h19a.5.5 0 0 1 .5.5v19Z", fill: "currentColor" }), (0,jsx_runtime.jsx)("path", { d: "M5.32 19.25h13.36a.77.77 0 0 0 .71-1.17L12.67 5.15a.74.74 0 0 0-1.34 0L4.61 18.08a.77.77 0 0 0 .71 1.17Z", fill: "currentColor" })] })));
});
IconTryCatch.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const ElementIconTryCatch = (IconTryCatch);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/ElementIconPrint.js



/**
 * Semantic vector graphics icon IconPrint.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconPrint size="large" color="green50" />
 */
const IconPrint = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsxs)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: [(0,jsx_runtime.jsx)("path", { d: "M5.75 6a1 1 0 0 0 1-1V2h8.84l2.16 2.16V5a1 1 0 0 0 2 0V3.75a1 1 0 0 0-.29-.75L17 .59A2 2 0 0 0 15.59 0H6.75a2 2 0 0 0-2 2v3a1 1 0 0 0 1 1ZM21.5 7h-19A2.5 2.5 0 0 0 0 9.5V14a2.5 2.5 0 0 0 2.5 2.5H5v6.25A1.25 1.25 0 0 0 6.25 24h12a1.249 1.249 0 0 0 1.25-1.25V16.5h2A2.5 2.5 0 0 0 24 14V9.5A2.5 2.5 0 0 0 21.5 7Zm-18 4.5a1 1 0 1 1 0-2.001 1 1 0 0 1 0 2.001Zm14 10a.5.5 0 0 1-.5.5H7.5a.5.5 0 0 1-.5-.5v-9a.5.5 0 0 1 .5-.5H17a.5.5 0 0 1 .5.5v9Z", fill: "currentColor" }), (0,jsx_runtime.jsx)("path", { d: "M15 14.75H9.5a.75.75 0 1 0 0 1.5H15a.75.75 0 1 0 0-1.5ZM13.25 18.25H9.5a.75.75 0 1 0 0 1.5h3.75a.75.75 0 1 0 0-1.5Z", fill: "currentColor" })] })));
});
IconPrint.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const ElementIconPrint = (IconPrint);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/ElementIconFileError.js



/**
 * Semantic vector graphics icon IconFileError.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconFileError size="large" color="green50" />
 */
const IconFileError = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsxs)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: [(0,jsx_runtime.jsx)("path", { d: "M20 7.5a1 1 0 0 0-1-1h-7a1 1 0 1 0 0 2h7a1 1 0 0 0 1-1ZM12.5 11a1 1 0 0 0 0 2h4a1 1 0 1 0 0-2h-4Z", fill: "currentColor" }), (0,jsx_runtime.jsx)("path", { d: "M23.41 3 21 .59A2 2 0 0 0 19.59 0H8a2 2 0 0 0-2 2v7.82a.25.25 0 0 0 .23.25c.489.027.974.097 1.45.21a.24.24 0 0 0 .32-.23V2.5a.5.5 0 0 1 .5-.5h10.88a.47.47 0 0 1 .35.15l2.12 2.12a.47.47 0 0 1 .15.35V18a.5.5 0 0 1-.5.5h-8.34a.259.259 0 0 0-.254.244.26.26 0 0 0 .024.126l.79 1.5a.25.25 0 0 0 .22.13H22a2 2 0 0 0 2-2V4.41A2 2 0 0 0 23.41 3Z", fill: "currentColor" }), (0,jsx_runtime.jsx)("path", { d: "M7.78 12.27a1.451 1.451 0 0 0-2.56 0L.16 21.9A1.44 1.44 0 0 0 1.44 24h10.12a1.43 1.43 0 0 0 1.28-2.09l-5.06-9.64ZM5.75 16a.75.75 0 1 1 1.5 0v3a.75.75 0 1 1-1.5 0v-3Zm.75 6.25a1 1 0 1 1 0-2.001 1 1 0 0 1 0 2Z", fill: "currentColor" })] })));
});
IconFileError.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const ElementIconFileError = (IconFileError);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/ElementIconExit.js



/**
 * Semantic vector graphics icon IconExit.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconExit size="large" color="green50" />
 */
const IconExit = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { d: "M23.75 11.52a1.25 1.25 0 0 0-1.25-1.25H11.32a.25.25 0 0 1-.25-.25V7.7a.5.5 0 0 0-.601-.487.51.51 0 0 0-.259.137L6.4 11.17a.48.48 0 0 0 0 .7l3.81 3.82a.51.51 0 0 0 .36.15.429.429 0 0 0 .19 0 .5.5 0 0 0 .31-.46V13a.25.25 0 0 1 .25-.25H22.5a1.25 1.25 0 0 0 1.25-1.23ZM1.5 23.75a1.25 1.25 0 0 0 1.25-1.25v-21a1.25 1.25 0 0 0-2.5 0v21a1.25 1.25 0 0 0 1.25 1.25Z", fill: "currentColor" }) })));
});
IconExit.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const ElementIconExit = (IconExit);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/ElementIconAddFile.js



/**
 * Semantic vector graphics icon IconAddFile.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconAddFile size="large" color="green50" />
 */
const IconAddFile = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsxs)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: [(0,jsx_runtime.jsx)("path", { d: "M23.41 3 21 .59A2 2 0 0 0 19.59 0H8a2 2 0 0 0-2 2v7.27a.25.25 0 0 0 .25.25c.4 0 1.16 0 1.46.08A.25.25 0 0 0 8 9.35V2.5a.5.5 0 0 1 .5-.5h10.88a.47.47 0 0 1 .35.15l2.12 2.12a.47.47 0 0 1 .15.35V18a.5.5 0 0 1-.5.5h-6.86a.25.25 0 0 0-.24.21 8.893 8.893 0 0 1-.4 1.46.24.24 0 0 0 .22.33H22a2 2 0 0 0 2-2V4.41A2 2 0 0 0 23.41 3Z", fill: "currentColor" }), (0,jsx_runtime.jsx)("path", { d: "M6.5 11a6.5 6.5 0 1 0 6.5 6.5A6.51 6.51 0 0 0 6.5 11ZM9 18.25H7.5a.25.25 0 0 0-.25.25V20a.75.75 0 1 1-1.5 0v-1.5a.25.25 0 0 0-.25-.25H4a.75.75 0 1 1 0-1.5h1.5a.25.25 0 0 0 .25-.25V15a.75.75 0 1 1 1.5 0v1.5a.25.25 0 0 0 .25.25H9a.75.75 0 1 1 0 1.5Z", fill: "currentColor" })] })));
});
IconAddFile.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const ElementIconAddFile = (IconAddFile);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/ElementIconRemoveFile.js



/**
 * Semantic vector graphics icon IconRemoveFile.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconRemoveFile size="large" color="green50" />
 */
const IconRemoveFile = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsxs)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: [(0,jsx_runtime.jsx)("path", { d: "M23.41 3 21 .59A2 2 0 0 0 19.59 0H8a2 2 0 0 0-2 2v7.28a.26.26 0 0 0 .24.25c.37 0 1 0 1.49.08A.25.25 0 0 0 8 9.36V2.5a.5.5 0 0 1 .5-.5h10.88a.47.47 0 0 1 .35.15l2.12 2.12a.47.47 0 0 1 .15.35V18a.5.5 0 0 1-.5.5h-6.86a.25.25 0 0 0-.24.21 8.893 8.893 0 0 1-.4 1.46.24.24 0 0 0 .23.33H22a2 2 0 0 0 2-2V4.41A2 2 0 0 0 23.41 3Z", fill: "currentColor" }), (0,jsx_runtime.jsx)("path", { d: "M6.5 11a6.5 6.5 0 1 0 6.5 6.5A6.51 6.51 0 0 0 6.5 11Zm1.24 6.68 1.41 1.41a.75.75 0 0 1-1.06 1.06l-1.41-1.41a.25.25 0 0 0-.36 0l-1.41 1.41a.75.75 0 0 1-1.06-1.06l1.41-1.41a.25.25 0 0 0 0-.36l-1.41-1.41a.75.75 0 1 1 1.06-1.06l1.41 1.41a.25.25 0 0 0 .36 0l1.41-1.41a.75.75 0 1 1 1.06 1.06l-1.41 1.41a.25.25 0 0 0 0 .36Z", fill: "currentColor" })] })));
});
IconRemoveFile.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const ElementIconRemoveFile = (IconRemoveFile);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/ElementIconSaveFile.js



/**
 * Semantic vector graphics icon IconSaveFile.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconSaveFile size="large" color="green50" />
 */
const IconSaveFile = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsxs)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: [(0,jsx_runtime.jsx)("path", { d: "M11 8h3.5a1 1 0 1 0 0-2H11a1 1 0 1 0 0 2ZM11 12h7.5a1 1 0 0 0 0-2H11a1 1 0 0 0 0 2Z", fill: "currentColor" }), (0,jsx_runtime.jsx)("path", { d: "M23.71 5.71 18.29.29a1 1 0 0 0-.7-.29H8a2 2 0 0 0-2 2v11.17c0 .19.1.33.25.33h1.5a.25.25 0 0 0 .25-.25v-11A.25.25 0 0 1 8.25 2h8.82a.31.31 0 0 1 .18.07l4.68 4.68a.31.31 0 0 1 .07.18v12.82a.25.25 0 0 1-.25.25h-6a.25.25 0 0 0-.25.25v1.5a.25.25 0 0 0 .25.25H22a2 2 0 0 0 2-2V6.41a1 1 0 0 0-.29-.7Z", fill: "currentColor" }), (0,jsx_runtime.jsx)("path", { d: "M13 15H6a.999.999 0 0 1-.8-.4l-.9-1.2a1 1 0 0 0-.8-.4H1a1 1 0 0 0-1 1v9a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-7a1 1 0 0 0-1-1Z", fill: "currentColor" })] })));
});
IconSaveFile.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const ElementIconSaveFile = (IconSaveFile);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/ElementIconCloseFile.js



/**
 * Semantic vector graphics icon IconCloseFile.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconCloseFile size="large" color="green50" />
 */
const IconCloseFile = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsxs)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: [(0,jsx_runtime.jsx)("path", { d: "M23.41 3 21 .59A2 2 0 0 0 19.59 0H8a2 2 0 0 0-2 2v7.28a.24.24 0 0 0 .25.24c.488-.02.978.01 1.46.09A.25.25 0 0 0 8 9.36V2.5a.5.5 0 0 1 .5-.5h10.88a.47.47 0 0 1 .35.15l2.12 2.12a.47.47 0 0 1 .15.35V18a.5.5 0 0 1-.5.5h-6.86a.25.25 0 0 0-.25.21c-.079.499-.21.988-.39 1.46a.25.25 0 0 0 .23.33H22a2 2 0 0 0 2-2V4.41A2 2 0 0 0 23.41 3Z", fill: "currentColor" }), (0,jsx_runtime.jsx)("path", { d: "M6.5 11a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13Zm-4 8.6a4.41 4.41 0 0 1-.36-3.32 4.47 4.47 0 0 1 3.11-3.11 4.41 4.41 0 0 1 3.32.36.26.26 0 0 1 .06.4l-5.7 5.72a.25.25 0 0 1-.4-.05H2.5Zm8.3-.88a4.47 4.47 0 0 1-3.11 3.11 4.41 4.41 0 0 1-3.32-.36.25.25 0 0 1-.05-.4l5.72-5.72a.25.25 0 0 1 .4.05 4.41 4.41 0 0 1 .39 3.32h-.03Z", fill: "currentColor" })] })));
});
IconCloseFile.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const ElementIconCloseFile = (IconCloseFile);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/ElementIconRemoveItem.js



/**
 * Semantic vector graphics icon IconRemoveItem.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconRemoveItem size="large" color="green50" />
 */
const IconRemoveItem = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsxs)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: [(0,jsx_runtime.jsx)("path", { d: "M17.495 11a6.5 6.5 0 1 0 6.5 6.5 6.51 6.51 0 0 0-6.5-6.5Zm1.24 6.68 1.41 1.41a.75.75 0 0 1-1.06 1.06l-1.41-1.41a.25.25 0 0 0-.36 0l-1.41 1.41a.75.75 0 0 1-1.06-1.06l1.41-1.41a.25.25 0 0 0 0-.36l-1.41-1.41a.75.75 0 1 1 1.06-1.06l1.41 1.41a.25.25 0 0 0 .36 0l1.41-1.41a.75.75 0 1 1 1.06 1.06l-1.41 1.41a.25.25 0 0 0 0 .36Z", fill: "currentColor" }), (0,jsx_runtime.jsx)("path", { d: "M8.75 18H2.5a.5.5 0 0 1-.5-.5v-15a.5.5 0 0 1 .5-.5h15a.5.5 0 0 1 .5.5v6.543a1 1 0 0 0 2 0V2a2 2 0 0 0-2-2H2a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h6.75a1 1 0 0 0 0-2Z", fill: "currentColor" })] })));
});
IconRemoveItem.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const ElementIconRemoveItem = (IconRemoveItem);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/ElementIconAddItem.js



/**
 * Semantic vector graphics icon IconAddItem.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconAddItem size="large" color="green50" />
 */
const IconAddItem = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsxs)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: [(0,jsx_runtime.jsx)("path", { d: "M17.495 11a6.5 6.5 0 1 0 6.5 6.5 6.51 6.51 0 0 0-6.5-6.5Zm2.5 7.25h-1.5a.25.25 0 0 0-.25.25V20a.75.75 0 1 1-1.5 0v-1.5a.25.25 0 0 0-.25-.25h-1.5a.75.75 0 1 1 0-1.5h1.5a.25.25 0 0 0 .25-.25V15a.75.75 0 1 1 1.5 0v1.5a.25.25 0 0 0 .25.25h1.5a.75.75 0 1 1 0 1.5Z", fill: "currentColor" }), (0,jsx_runtime.jsx)("path", { d: "M8.75 18H2.5a.5.5 0 0 1-.5-.5v-15a.5.5 0 0 1 .5-.5h15a.5.5 0 0 1 .5.5v6.543a1 1 0 0 0 2 0V2a2 2 0 0 0-2-2H2a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h6.75a1 1 0 0 0 0-2Z", fill: "currentColor" })] })));
});
IconAddItem.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const ElementIconAddItem = (IconAddItem);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/ElementIconWarning.js



/**
 * Semantic vector graphics icon IconWarning.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconWarning size="large" color="green50" />
 */
const IconWarning = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsxs)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: [(0,jsx_runtime.jsx)("path", { d: "m23.894 21.77-11-20.53a1 1 0 0 0-1.76 0l-11 20.53a1 1 0 0 0 0 1 1 1 0 0 0 .86.49h22.02a1 1 0 0 0 .86-.49 1 1 0 0 0 .02-1Zm-2.75-.65a.26.26 0 0 1-.22.13H3.104a.26.26 0 0 1-.22-.13.25.25 0 0 1 0-.24l8.91-16.64a.25.25 0 0 1 .44 0l8.91 16.64a.25.25 0 0 1 0 .24Z", fill: "currentColor" }), (0,jsx_runtime.jsx)("path", { d: "M12.264 15.71a1 1 0 0 0 1-1V9.45a1 1 0 0 0-2 0v5.26a1 1 0 0 0 1 1ZM12.264 19.46a1.5 1.5 0 1 0 0-3 1.5 1.5 0 0 0 0 3Z", fill: "currentColor" })] })));
});
IconWarning.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const ElementIconWarning = (IconWarning);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/ElementIconRemove.js



/**
 * Semantic vector graphics icon IconRemove.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconRemove size="large" color="green50" />
 */
const IconRemove = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsxs)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: [(0,jsx_runtime.jsx)("path", { d: "M21.75 0H2.25A2.25 2.25 0 0 0 0 2.25v19.5A2.25 2.25 0 0 0 2.25 24h19.5A2.25 2.25 0 0 0 24 21.75V2.25A2.25 2.25 0 0 0 21.75 0Zm-.25 21.5h-19v-19h19v19Z", fill: "currentColor" }), (0,jsx_runtime.jsx)("path", { d: "M7.07 16.93a1.231 1.231 0 0 0 1.76 0l3-3a.27.27 0 0 1 .36 0l3 3a1.23 1.23 0 0 0 1.76 0 1.24 1.24 0 0 0 0-1.76l-3-3a.27.27 0 0 1 0-.36l3-3a1.244 1.244 0 1 0-1.76-1.76l-3 3a.27.27 0 0 1-.36 0l-3-3a1.252 1.252 0 0 0-1.76 1.78l3 3a.27.27 0 0 1 0 .36l-3 3a1.24 1.24 0 0 0 0 1.74Z", fill: "currentColor" })] })));
});
IconRemove.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const ElementIconRemove = (IconRemove);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/ElementIconAdd.js



/**
 * Semantic vector graphics icon IconAdd.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconAdd size="large" color="green50" />
 */
const IconAdd = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsxs)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: [(0,jsx_runtime.jsx)("path", { d: "M21.8 0H2.2A2.21 2.21 0 0 0 0 2.2v19.6A2.21 2.21 0 0 0 2.2 24h19.6a2.21 2.21 0 0 0 2.2-2.2V2.2A2.21 2.21 0 0 0 21.8 0Zm-.3 21.5h-19v-19h19v19Z", fill: "currentColor" }), (0,jsx_runtime.jsx)("path", { d: "M6.27 13.25h4.23a.25.25 0 0 1 .25.25v4.23a1.25 1.25 0 0 0 2.5 0V13.5a.25.25 0 0 1 .25-.25h4.23a1.25 1.25 0 0 0 0-2.5H13.5a.25.25 0 0 1-.25-.25V6.27a1.25 1.25 0 0 0-2.5 0v4.23a.25.25 0 0 1-.25.25H6.27a1.25 1.25 0 0 0 0 2.5Z", fill: "currentColor" })] })));
});
IconAdd.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const ElementIconAdd = (IconAdd);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/ElementIconMail.js



/**
 * Semantic vector graphics icon IconMail.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconMail size="large" color="green50" />
 */
const IconMail = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsxs)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: [(0,jsx_runtime.jsx)("path", { d: "M22 1.5H5.5a2 2 0 0 0-2 2V17a2 2 0 0 0 2 2H22a2 2 0 0 0 2-2V3.5a2 2 0 0 0-2-2Zm-.5 2a.5.5 0 0 1 .5.5v.19a.502.502 0 0 1-.22.42l-7.52 5a.52.52 0 0 1-.55 0l-8-5a.5.5 0 0 1-.23-.42V4A.5.5 0 0 1 6 3.5h15.5ZM6 17a.5.5 0 0 1-.5-.5V7.72a.51.51 0 0 1 .26-.44.49.49 0 0 1 .51 0l7.2 4.54A.92.92 0 0 0 14 12a1 1 0 0 0 .55-.17l6.67-4.45a.5.5 0 0 1 .78.42v8.7a.51.51 0 0 1-.5.5H6Z", fill: "currentColor" }), (0,jsx_runtime.jsx)("path", { d: "M19.5 20.5h-17A.5.5 0 0 1 2 20V6a1 1 0 0 0-2 0v14.5a2 2 0 0 0 2 2h17.5a1 1 0 0 0 0-2Z", fill: "currentColor" })] })));
});
IconMail.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const ElementIconMail = (IconMail);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/ElementIconClose.js



/**
 * Semantic vector graphics icon IconClose.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconClose size="large" color="green50" />
 */
const IconClose = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { d: "M14.3 12.18a.24.24 0 0 1 0-.35l9.257-9.274a1.49 1.49 0 0 0 0-2.121 1.509 1.509 0 0 0-2.12 0L12.18 9.699a.251.251 0 0 1-.36 0L2.562.435A1.51 1.51 0 0 0 .115.92a1.492 1.492 0 0 0 .328 1.635L9.7 11.83a.24.24 0 0 1 0 .35L.443 21.444a1.49 1.49 0 0 0 0 2.121 1.51 1.51 0 0 0 2.12 0l9.257-9.264a.252.252 0 0 1 .278-.057c.03.014.059.033.082.057l9.258 9.264a1.51 1.51 0 0 0 2.447-.486 1.492 1.492 0 0 0-.328-1.635L14.3 12.18Z", fill: "currentColor" }) })));
});
IconClose.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const ElementIconClose = (IconClose);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/ElementIconContinue.js



/**
 * Semantic vector graphics icon IconContinue.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconContinue size="large" color="green50" />
 */
const IconContinue = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { d: "M24 11.963a2.41 2.41 0 0 0-.815-1.8L11.995.327A1.443 1.443 0 0 0 9.64 1.507c.018.373.18.724.451.98l8.646 7.6a.25.25 0 0 1-.165.436H1.442A1.442 1.442 0 0 0 0 11.963a1.439 1.439 0 0 0 1.442 1.44H18.57a.252.252 0 0 1 .165.438l-8.646 7.6a1.441 1.441 0 0 0 .284 2.418 1.443 1.443 0 0 0 1.619-.258l11.192-9.838a2.408 2.408 0 0 0 .816-1.8Z", fill: "currentColor" }) })));
});
IconContinue.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const ElementIconContinue = (IconContinue);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/ElementIconReturn.js



/**
 * Semantic vector graphics icon IconReturn.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconReturn size="large" color="green50" />
 */
const IconReturn = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { d: "M21.546 0h-8.12a1.5 1.5 0 0 0 0 3h7.33a.25.25 0 0 1 .25.25v13.22a.25.25 0 0 1-.25.25H7.006a.25.25 0 0 1-.25-.25v-3a1 1 0 0 0-1.71-.71l-4.75 4.75a1 1 0 0 0 0 1.42l4.78 4.77a1 1 0 0 0 .71.3 1 1 0 0 0 1-1v-3a.25.25 0 0 1 .22-.28h14.54a2.46 2.46 0 0 0 2.46-2.46V2.45A2.46 2.46 0 0 0 21.546 0Z", fill: "currentColor" }) })));
});
IconReturn.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const ElementIconReturn = (IconReturn);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/ElementIconAnchor.js



/**
 * Semantic vector graphics icon IconAnchor.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconAnchor size="large" color="green50" />
 */
const IconAnchor = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { d: "M21.943 15.236a1.25 1.25 0 0 0-2.13-1l-1.55 1.55a1.002 1.002 0 0 0 0 1.42 1 1 0 0 0 .69.29.24.24 0 0 1 .21.12.23.23 0 0 1 0 .24 7.579 7.579 0 0 1-5.09 4 .53.53 0 0 1-.42-.1.51.51 0 0 1-.19-.39v-9.47a.5.5 0 0 1 .5-.5h3a1 1 0 0 0 0-2h-3a.5.5 0 0 1-.5-.5v-1.69a.49.49 0 0 1 .31-.46 3.5 3.5 0 1 0-2.62 0 .49.49 0 0 1 .31.46v1.69a.5.5 0 0 1-.5.5h-3a1 1 0 1 0 0 2h3a.5.5 0 0 1 .5.5v9.45a.51.51 0 0 1-.19.39.53.53 0 0 1-.42.1 7.58 7.58 0 0 1-5.09-4 .23.23 0 0 1 0-.24.24.24 0 0 1 .21-.12 1 1 0 0 0 .69-1.71l-1.53-1.51a1.27 1.27 0 0 0-1.41-.24 1.26 1.26 0 0 0-.72 1.23 9.5 9.5 0 0 0 18.94 0v-.01Zm-10.97-11.72a1.5 1.5 0 1 1 3 0 1.5 1.5 0 0 1-3 0Z", fill: "currentColor" }) })));
});
IconAnchor.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const ElementIconAnchor = (IconAnchor);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/ElementIconRemoveAnchor.js



/**
 * Semantic vector graphics icon IconRemoveAnchor.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconRemoveAnchor size="large" color="green50" />
 */
const IconRemoveAnchor = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsxs)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: [(0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M6.315 16a6.33 6.33 0 0 0 1.87-.283 5.365 5.365 0 0 1-1.048-1.184.34.34 0 0 1-.161-.265 5.31 5.31 0 0 1-.696-2.637c0-.959.253-1.859.695-2.636v-1.06a.333.333 0 0 1 .334-.333h.808a5.33 5.33 0 0 1 1.76-1.016.666.666 0 0 0-.568-.317h-2a.333.333 0 0 1-.334-.333V4.809a.327.327 0 0 1 .207-.307 2.333 2.333 0 1 0-1.747 0 .327.327 0 0 1 .207.307v1.127a.333.333 0 0 1-.333.333h-2a.667.667 0 1 0 0 1.333h2a.333.333 0 0 1 .333.334v6.3a.34.34 0 0 1-.127.26.354.354 0 0 1-.28.066 5.053 5.053 0 0 1-3.393-2.666.153.153 0 0 1 0-.16.16.16 0 0 1 .14-.08.667.667 0 0 0 .46-1.14l-1.02-1.007a.847.847 0 0 0-.94-.16.84.84 0 0 0-.48.82A6.333 6.333 0 0 0 6.315 16Zm-1-13.65a1 1 0 1 1 2 0 1 1 0 0 1-2 0Z", fill: "currentColor" }), (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M9.225 8.08a4.333 4.333 0 0 1 2.408-.73 4.34 4.34 0 0 1 4.333 4.332 4.334 4.334 0 1 1-6.74-3.603Zm4.32 5.016a.5.5 0 0 0-.146-.354l-.94-.94a.168.168 0 0 1 0-.24l.94-.94a.5.5 0 0 0-.706-.706l-.94.94a.168.168 0 0 1-.24 0l-.94-.94a.5.5 0 1 0-.707.707l.94.94a.166.166 0 0 1 0 .24l-.94.94a.5.5 0 0 0 .707.706l.94-.94a.166.166 0 0 1 .24 0l.94.94a.5.5 0 0 0 .853-.353Z", fill: "currentColor" })] })));
});
IconRemoveAnchor.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const ElementIconRemoveAnchor = (IconRemoveAnchor);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/ElementIconWindow.js



/**
 * Semantic vector graphics icon IconWindow.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconWindow size="large" color="green50" />
 */
const IconWindow = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { d: "M24 4.5a3 3 0 0 0-3-3H3a3 3 0 0 0-3 3V19a3 3 0 0 0 3 3h18a3 3 0 0 0 3-3V4.5Zm-14.35-1a1 1 0 0 1 1.7 0 .91.91 0 0 1 0 1 1 1 0 0 1-1.7 0 .91.91 0 0 1 0-1Zm-3.5 0a1 1 0 0 1 1.7 0 .91.91 0 0 1 0 1 1 1 0 0 1-1.7 0 .91.91 0 0 1 0-1Zm-3.56.09a1 1 0 0 1 1.76-.09.91.91 0 0 1 0 1A1 1 0 0 1 2.5 4a1.12 1.12 0 0 1 .09-.41ZM22 19a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V6.75a.25.25 0 0 1 .25-.25h19.5a.25.25 0 0 1 .25.25V19Z", fill: "currentColor" }) })));
});
IconWindow.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const ElementIconWindow = (IconWindow);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/ElementIconWindowList.js



/**
 * Semantic vector graphics icon IconWindowList.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconWindowList size="large" color="green50" />
 */
const IconWindowList = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsxs)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: [(0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M19.121 3.879A3 3 0 0 1 20 6v9.5a3 3 0 0 1-3 3H4.5a3 3 0 0 1-3-3V6a3 3 0 0 1 3-3H17a3 3 0 0 1 2.121.879Zm-7.607.774A1 1 0 0 0 11.15 5a.91.91 0 0 0 0 1 1 1 0 0 0 1.7 0 .91.91 0 0 0 0-1 1 1 0 0 0-1.336-.347Zm-3.5 0A1 1 0 0 0 7.65 5a.91.91 0 0 0 0 1 1 1 0 0 0 1.7 0 .91.91 0 0 0 0-1 1 1 0 0 0-1.336-.347Zm-3.576.033a1 1 0 0 0-.348.404A1.12 1.12 0 0 0 4 5.5a1 1 0 0 0 1.85.5.91.91 0 0 0 0-1 1 1 0 0 0-1.412-.314Zm13.27 11.521A1 1 0 0 0 18 15.5V8.25a.25.25 0 0 0-.25-.25h-14a.25.25 0 0 0-.25.25v7.25a1 1 0 0 0 1 1H17a1 1 0 0 0 .707-.293Z", fill: "currentColor" }), (0,jsx_runtime.jsx)("path", { d: "M20.5 22H8a1 1 0 0 1 0-2h12.5a1 1 0 0 0 1-1V7.5a1 1 0 1 1 2 0V19a3 3 0 0 1-3 3Z", fill: "currentColor" })] })));
});
IconWindowList.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const ElementIconWindowList = (IconWindowList);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/ElementIconCloseWindow.js



/**
 * Semantic vector graphics icon IconCloseWindow.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconCloseWindow size="large" color="green50" />
 */
const IconCloseWindow = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsxs)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: [(0,jsx_runtime.jsx)("path", { d: "M17.34 10.378a6.67 6.67 0 1 0 .516 13.33 6.67 6.67 0 0 0-.516-13.33Zm-3.73 9a.22.22 0 0 1-.2.07.25.25 0 0 1-.19-.12 4.5 4.5 0 0 1-.45-1.17 4.69 4.69 0 0 1 4.58-5.79c.367 0 .732.041 1.09.12.408.092.8.247 1.16.46a.231.231 0 0 1 .13.18.28.28 0 0 1-.07.21l-.31.31-5.43 5.41-.31.32Zm7 1a4.74 4.74 0 0 1-4.42 1.24 4.502 4.502 0 0 1-1.17-.45.282.282 0 0 1-.12-.18.26.26 0 0 1 .07-.21l6.05-6.05a.25.25 0 0 1 .2-.07.26.26 0 0 1 .19.13c.205.363.357.754.45 1.16a4.73 4.73 0 0 1-1.21 4.42l-.04.01Z", fill: "currentColor" }), (0,jsx_runtime.jsx)("path", { d: "M20.74.008H3a3 3 0 0 0-3 3v14.29a3 3 0 0 0 3 3h4.9a1 1 0 0 0 0-2H3a1 1 0 0 1-1-1v-12.1a.25.25 0 0 1 .24-.25h19.24a.25.25 0 0 1 .25.25v3.66a1 1 0 0 0 2 0v-5.89a3 3 0 0 0-2.99-2.96Zm-16.45 3a1 1 0 0 1-.83.5 1 1 0 0 1-.84-.5.91.91 0 0 1-.06-.89 1 1 0 0 1 .9-.59 1 1 0 0 1 .83.5.88.88 0 0 1 0 1v-.02Zm3.46 0a.95.95 0 0 1-1.67 0 .88.88 0 0 1 0-1 .95.95 0 0 1 1.67 0 .88.88 0 0 1 0 1Zm3.46 0a1 1 0 0 1-.84.5 1 1 0 0 1-.83-.5.92.92 0 0 1-.16-.49.92.92 0 0 1 .16-.49 1 1 0 0 1 .83-.5 1 1 0 0 1 .84.5.88.88 0 0 1 0 1v-.02Z", fill: "currentColor" })] })));
});
IconCloseWindow.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const ElementIconCloseWindow = (IconCloseWindow);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/ElementIconAttribute.js



/**
 * Semantic vector graphics icon IconAttribute.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconAttribute size="large" color="green50" />
 */
const IconAttribute = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsxs)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: [(0,jsx_runtime.jsx)("path", { d: "M22.29 16.128a3 3 0 0 0 0-4.24l-11-11a3 3 0 0 0-2.12-.88H2a2 2 0 0 0-2 2v7.17a3 3 0 0 0 .88 2.12l11 11a3 3 0 0 0 4.24 0l6.17-6.17Zm-1.41-1.41-6.18 6.17a1 1 0 0 1-1.41 0l-11-11a1 1 0 0 1-.29-.71v-6.67a.5.5 0 0 1 .5-.5h6.67a1 1 0 0 1 .71.29l11 11a1 1 0 0 1 0 1.42Z", fill: "currentColor" }), (0,jsx_runtime.jsx)("path", { d: "M6 7.508a1.5 1.5 0 1 0 0-3 1.5 1.5 0 0 0 0 3Z", fill: "currentColor" })] })));
});
IconAttribute.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const ElementIconAttribute = (IconAttribute);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/ElementIconAttributeList.js



/**
 * Semantic vector graphics icon IconAttributeList.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconAttributeList size="large" color="green50" />
 */
const IconAttributeList = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsxs)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: [(0,jsx_runtime.jsx)("path", { d: "M19.29 17.008a3 3 0 0 0 0-4.24l-8-8a3 3 0 0 0-2.12-.88H2a2 2 0 0 0-2 2v7.12a3 3 0 0 0 .88 2.12l8 8a3 3 0 0 0 4.24 0l6.17-6.12Zm-1.41-1.41-6.18 6.12a1 1 0 0 1-1.41 0l-8-8a1.001 1.001 0 0 1-.29-.71v-6.67a.5.5 0 0 1 .5-.5h6.67a1 1 0 0 1 .71.29l8 8a1 1 0 0 1 0 1.42v.05Z", fill: "currentColor" }), (0,jsx_runtime.jsx)("path", { d: "M6 11.338a1.5 1.5 0 1 0 0-3 1.5 1.5 0 0 0 0 3ZM3.83 2.258a.25.25 0 0 0 .25.25h1.54a.26.26 0 0 0 .24-.17.49.49 0 0 1 .47-.33H13a1 1 0 0 1 .71.29l8 8a1 1 0 0 1 0 1.42l-.72.71a.26.26 0 0 0 0 .35l1.06 1.06a.249.249 0 0 0 .36 0l.71-.71a3 3 0 0 0 0-4.24l-8-8A3 3 0 0 0 13 .008H5.83a2 2 0 0 0-2 2v.25Z", fill: "currentColor" })] })));
});
IconAttributeList.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const ElementIconAttributeList = (IconAttributeList);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/ElementIconGetValue.js



/**
 * Semantic vector graphics icon IconGetValue.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconGetValue size="large" color="green50" />
 */
const IconGetValue = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsxs)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: [(0,jsx_runtime.jsx)("path", { d: "M12 0a12 12 0 1 0 0 24 12 12 0 0 0 0-24Zm0 2a10 10 0 1 1 0 20 10 10 0 0 1 0-20Z", fill: "currentColor" }), (0,jsx_runtime.jsx)("path", { d: "m11.88 8.38-1.94 1.94a.26.26 0 0 0 0 .28.25.25 0 0 0 .23.15H18a1.25 1.25 0 0 1 0 2.5h-7.88a.25.25 0 0 0-.23.15.26.26 0 0 0 0 .28l1.94 1.94a1.25 1.25 0 1 1-1.77 1.76l-4.5-4.5a1.26 1.26 0 0 1 0-1.76l4.5-4.5a1.25 1.25 0 1 1 1.77 1.76h.05Z", fill: "currentColor" })] })));
});
IconGetValue.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const ElementIconGetValue = (IconGetValue);

// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/ElementIconSetValue.js
var ElementIconSetValue = __webpack_require__(8788);
;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/ElementIconMaximize.js



/**
 * Semantic vector graphics icon IconMaximize.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconMaximize size="large" color="green50" />
 */
const IconMaximize = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { d: "M20.5 5.27a.24.24 0 0 1 .35 0l1.44 1.44A1 1 0 0 0 23 7a1 1 0 0 0 1-1V1a1 1 0 0 0-1-1h-5a1 1 0 0 0-.92.62 1 1 0 0 0 .21 1.09l1.44 1.44a.24.24 0 0 1 0 .35l-6.55 6.55a.25.25 0 0 1-.36 0L5.27 3.5a.24.24 0 0 1 0-.35l1.44-1.44A1 1 0 0 0 6.92.62 1 1 0 0 0 6 0H1a1 1 0 0 0-1 1v5a1 1 0 0 0 .62.92 1 1 0 0 0 .764.006 1 1 0 0 0 .326-.216l1.44-1.44a.24.24 0 0 1 .35 0l6.56 6.55a.27.27 0 0 1 0 .36L3.5 18.73a.24.24 0 0 1-.35 0l-1.44-1.44a1 1 0 0 0-1.09-.21A1 1 0 0 0 0 18v5a1 1 0 0 0 1 1h5a1 1 0 0 0 .92-.62 1 1 0 0 0-.21-1.09l-1.44-1.44a.24.24 0 0 1 0-.35l6.55-6.56a.27.27 0 0 1 .36 0l6.55 6.56a.24.24 0 0 1 0 .35l-1.44 1.44a.999.999 0 0 0-.21 1.09A1 1 0 0 0 18 24h5a1 1 0 0 0 1-1v-5a1 1 0 0 0-.62-.92 1 1 0 0 0-1.09.21l-1.44 1.44a.24.24 0 0 1-.35 0l-6.56-6.55a.27.27 0 0 1 0-.36l6.56-6.55Z", fill: "currentColor" }) })));
});
IconMaximize.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const ElementIconMaximize = (IconMaximize);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/ElementIconMinimize.js



/**
 * Semantic vector graphics icon IconMinimize.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconMinimize size="large" color="green50" />
 */
const IconMinimize = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { d: "M23.38.628a1.24 1.24 0 0 0-1.76 0l-3.42 3.38a.26.26 0 0 1-.2.1.29.29 0 0 1-.15-.1l-1.32-1.3a1 1 0 0 0-1.71.71v4.77a1 1 0 0 0 1 1h4.77a1 1 0 0 0 .92-.62 1 1 0 0 0-.21-1.09L20 6.158a.25.25 0 0 1 0-.36l3.41-3.41a1.239 1.239 0 0 0-.03-1.76ZM.62 23.388a1.21 1.21 0 0 0 .88.37 1.21 1.21 0 0 0 .88-.37l3.42-3.38a.22.22 0 0 1 .2-.1.242.242 0 0 1 .18.07l1.29 1.33a1 1 0 0 0 .71.29.84.84 0 0 0 .38-.08 1 1 0 0 0 .62-.92v-4.77a1 1 0 0 0-1-1H3.41a1 1 0 0 0-.98 1.187 1 1 0 0 0 .27.513l1.3 1.33a.24.24 0 0 1 0 .35l-3.38 3.42a1.24 1.24 0 0 0 0 1.76ZM14.82 20.598a1 1 0 0 0 .62.92.84.84 0 0 0 .38.08 1 1 0 0 0 .71-.29l1.32-1.3a.24.24 0 0 1 .15-.1.22.22 0 0 1 .17.07l3.42 3.41a1.23 1.23 0 0 0 1.76 0 1.238 1.238 0 0 0 0-1.76L20 18.208a.24.24 0 0 1 0-.35l1.33-1.33a.999.999 0 0 0-.71-1.7h-4.8a1 1 0 0 0-1 1v4.77ZM9.18 3.418a1 1 0 0 0-1.71-.71l-1.32 1.3a.29.29 0 0 1-.15.1.26.26 0 0 1-.2-.1L2.38.628a1.245 1.245 0 0 0-1.76 1.76L4 5.798a.25.25 0 0 1 0 .36l-1.3 1.32a1 1 0 0 0-.21 1.09 1 1 0 0 0 .92.62h4.77a1 1 0 0 0 1-1v-4.77Z", fill: "currentColor" }) })));
});
IconMinimize.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const ElementIconMinimize = (IconMinimize);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/ElementIconTree.js



/**
 * Semantic vector graphics icon IconTree.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconTree size="large" color="green50" />
 */
const IconTree = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { d: "M20.75 24.008h-11a1.5 1.5 0 0 1-1.48-1.29.26.26 0 0 0-.27-.21H3.73a2 2 0 0 1-2-2v-19.5a1 1 0 0 1 2 0v5a.5.5 0 0 0 .5.5H8a.26.26 0 0 0 .25-.21 1.5 1.5 0 0 1 1.5-1.29h11a1.5 1.5 0 0 1 1.5 1.5v2a1.5 1.5 0 0 1-1.5 1.5h-11a1.5 1.5 0 0 1-1.48-1.29.26.26 0 0 0-.27-.21H4.23a.5.5 0 0 0-.5.5v4a.5.5 0 0 0 .5.5H8a.26.26 0 0 0 .25-.21 1.5 1.5 0 0 1 1.5-1.29h11a1.5 1.5 0 0 1 1.5 1.5v2a1.5 1.5 0 0 1-1.5 1.5h-11a1.5 1.5 0 0 1-1.48-1.29.26.26 0 0 0-.27-.21H4.23a.5.5 0 0 0-.5.5v4a.5.5 0 0 0 .5.5H8a.26.26 0 0 0 .25-.21 1.5 1.5 0 0 1 1.5-1.29h11a1.5 1.5 0 0 1 1.5 1.5v2a1.5 1.5 0 0 1-1.5 1.5Z", fill: "currentColor" }) })));
});
IconTree.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const ElementIconTree = (IconTree);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/ElementIconSearch.js



/**
 * Semantic vector graphics icon IconSearch.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconSearch size="large" color="green50" />
 */
const IconSearch = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { d: "m24.33 21.403-4.82-4.77a10.65 10.65 0 1 0-8.854 4.739 10.537 10.537 0 0 0 5.913-1.808l4.832 4.832a2.078 2.078 0 0 0 2.93 0 2.08 2.08 0 0 0 0-2.993ZM10.658 3.126a7.534 7.534 0 1 1-7.534 7.543 7.544 7.544 0 0 1 7.533-7.543Z", fill: "currentColor" }) })));
});
IconSearch.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const ElementIconSearch = (IconSearch);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/ElementIconMicrosoftWindows.js



/**
 * Semantic vector graphics icon IconMicrosoftWindows.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconMicrosoftWindows size="large" color="green50" />
 */
const IconMicrosoftWindows = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { d: "M20.79 14.228a11.128 11.128 0 0 1-3.67.7 6.39 6.39 0 0 1-4.1-1.32.49.49 0 0 0-.79.25l-2 7a.5.5 0 0 0 0 .32c.18.45 3 1.78 4.62 1.78a11.559 11.559 0 0 0 4.36-1 .541.541 0 0 0 .29-.32l2-6.84a.51.51 0 0 0-.14-.51.5.5 0 0 0-.57-.06ZM10.76 12.678a7.71 7.71 0 0 0-4.17-1.42 11.922 11.922 0 0 0-4.22 1 .471.471 0 0 0-.29.32l-2.06 7.03a.5.5 0 0 0 .67.6 9.841 9.841 0 0 1 3.64-.83 6.45 6.45 0 0 1 3.78 1.33.49.49 0 0 0 .28.09c.055.01.113.01.17 0a.509.509 0 0 0 .31-.33c.42-1.46 1.84-6.3 2.15-7.22a.51.51 0 0 0-.26-.57ZM3.21 10.168a10 10 0 0 1 3.75-.88 6.4 6.4 0 0 1 3.64 1.32c.084.05.18.078.28.08.055.01.113.01.17 0a.53.53 0 0 0 .31-.33l2.07-7.09a.596.596 0 0 0 0-.14.5.5 0 0 0-.24-.43 7.6 7.6 0 0 0-4.4-1.39 11 11 0 0 0-4 .92.5.5 0 0 0-.29.33l-2 7a.51.51 0 0 0 .15.51.47.47 0 0 0 .56.1ZM23.85 4.188a.51.51 0 0 0-.53-.08 9.3 9.3 0 0 1-3.73.9 6.55 6.55 0 0 1-4.05-1.34.48.48 0 0 0-.78.25l-2.06 7.09a.61.61 0 0 0 .22.57 8.29 8.29 0 0 0 4.66 1.43 9.69 9.69 0 0 0 4.11-1 .47.47 0 0 0 .17-.14.45.45 0 0 0 .11-.19l2-7a.51.51 0 0 0-.12-.49Z", fill: "currentColor" }) })));
});
IconMicrosoftWindows.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const ElementIconMicrosoftWindows = (IconMicrosoftWindows);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/ElementIconDate.js



/**
 * Semantic vector graphics icon IconDate.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconDate size="large" color="green50" />
 */
const IconDate = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { d: "M21.5 3h-2.75a.25.25 0 0 1-.25-.25V1a1 1 0 1 0-2 0v4.75a.75.75 0 1 1-1.5 0V3.5a.5.5 0 0 0-.5-.5H8.25A.25.25 0 0 1 8 2.75V1a1 1 0 1 0-2 0v4.75a.75.75 0 1 1-1.5 0V3.5A.5.5 0 0 0 4 3H2.5a2 2 0 0 0-2 2v17a2 2 0 0 0 2 2h19a2 2 0 0 0 2-2V5a2 2 0 0 0-2-2ZM21 22H3a.5.5 0 0 1-.5-.5v-12A.5.5 0 0 1 3 9h18a.5.5 0 0 1 .5.5v12a.5.5 0 0 1-.5.5Z", fill: "currentColor" }) })));
});
IconDate.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const ElementIconDate = (IconDate);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/ElementIconFileSearch.js



/**
 * Semantic vector graphics icon IconFileSearch.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconFileSearch size="large" color="green50" />
 */
const IconFileSearch = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsxs)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: [(0,jsx_runtime.jsx)("path", { d: "M23.41 3 21 .6a2 2 0 0 0-1.41-.6H8a2 2 0 0 0-2 2v7.3a.24.24 0 0 0 .22.24 7.16 7.16 0 0 1 1.46.31.24.24 0 0 0 .32-.21V2.52A.5.5 0 0 1 8.5 2h10.88a.5.5 0 0 1 .35.14l2.12 2.12a.51.51 0 0 1 .15.36V18a.5.5 0 0 1-.5.5h-9.13a.24.24 0 0 0-.23.17c-.16.43-.36.9-.44 1.11-.08.21.14.28.26.41.12.13.28.31.37.31H22a2 2 0 0 0 2-2V4.43A2 2 0 0 0 23.41 3Z", fill: "currentColor" }), (0,jsx_runtime.jsx)("path", { d: "M10.17 19.77a.24.24 0 0 1 0-.3 5.5 5.5 0 1 0-6.724 2.14 5.49 5.49 0 0 0 5.034-.46.24.24 0 0 1 .3 0l2.51 2.51a1 1 0 0 0 1.41-1.41l-2.53-2.48ZM5.5 20a3.5 3.5 0 1 1 0-7 3.5 3.5 0 0 1 0 7Z", fill: "currentColor" })] })));
});
IconFileSearch.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const ElementIconFileSearch = (IconFileSearch);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/ElementIconCookie.js



/**
 * Semantic vector graphics icon IconCookie.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconCookie size="large" color="green50" />
 */
const IconCookie = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { d: "M22.72 6.53a1 1 0 0 0-1.3-.46 3.5 3.5 0 0 1-4.53-1.62 1 1 0 0 0-1.35-.44 3.43 3.43 0 0 1-1.54.37 3.5 3.5 0 0 1-3.5-3.5.75.75 0 0 0-.91-.74A12 12 0 1 0 24 11.88a11.75 11.75 0 0 0-1.28-5.35Zm-18.8 8.18a1 1 0 1 1 0-2 1 1 0 0 1 0 2Zm4.75-8.16a2 2 0 1 1 0 4 2 2 0 0 1 0-4ZM9 18.88a2 2 0 1 1 0-4 2 2 0 0 1 0 4Zm4.67-7.75a1 1 0 1 1 2 0 1 1 0 0 1-2 0ZM15 19.88a1 1 0 1 1 0-2 1 1 0 0 1 0 2Zm3.5-4a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3Z", fill: "currentColor" }) })));
});
IconCookie.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const ElementIconCookie = (IconCookie);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/ElementIconCopyPaste.js



/**
 * Semantic vector graphics icon IconCopyPaste.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconCopyPaste size="large" color="green50" />
 */
const IconCopyPaste = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsxs)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: [(0,jsx_runtime.jsx)("path", { d: "M13.4 4.73a.24.24 0 0 0 .2.26 1.09 1.09 0 0 1 .82 1.11v1.4a1.24 1.24 0 0 0 1.25 1.24 1.23 1.23 0 0 0 1.24-1.24V4a1.5 1.5 0 0 0-1.49-1.5h-1.73a.29.29 0 0 0-.18.07.26.26 0 0 0-.07.18c0 .45 0 1.47-.04 1.98ZM9 21.26A1.23 1.23 0 0 0 7.71 20H3.48a1.07 1.07 0 0 1-1-1.14V6.1A1.08 1.08 0 0 1 3.33 5a.25.25 0 0 0 .2-.26v-2a.25.25 0 0 0-.25-.25H1.5A1.5 1.5 0 0 0 0 4v17a1.5 1.5 0 0 0 1.49 1.5h6.22A1.24 1.24 0 0 0 9 21.26ZM11.94 4.47v-2a.5.5 0 0 0-.5-.49h-.76a.26.26 0 0 1-.25-.22 2 2 0 0 0-3.95 0 .25.25 0 0 1-.25.24h-.76a.49.49 0 0 0-.47.48v2a.49.49 0 0 0 .49.5h6a.5.5 0 0 0 .45-.51ZM19 17.27h-4a.75.75 0 0 0 0 1.5h4a.75.75 0 0 0 0-1.5ZM14.29 14.54a.76.76 0 0 0 .75.75h2.49a.75.75 0 0 0 0-1.5H15a.76.76 0 0 0-.71.75Z", fill: "currentColor" }), (0,jsx_runtime.jsx)("path", { d: "M23.5 13.46a2 2 0 0 0-.58-1.41l-1.41-1.4a2 2 0 0 0-1.41-.59h-7.61a2 2 0 0 0-2 2V22a2 2 0 0 0 2 2h9a2 2 0 0 0 2-2l.01-8.54Zm-11-.4a1 1 0 0 1 1-1h6.19a.998.998 0 0 1 .71.29l.82.82a1 1 0 0 1 .29.7V21a1 1 0 0 1-1 1h-7a1 1 0 0 1-1-1l-.01-7.94Z", fill: "currentColor" })] })));
});
IconCopyPaste.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const ElementIconCopyPaste = (IconCopyPaste);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/ElementIconTextFile.js



/**
 * Semantic vector graphics icon IconTextFile.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconTextFile size="large" color="green50" />
 */
const IconTextFile = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsxs)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: [(0,jsx_runtime.jsx)("path", { d: "m15.32 2.15 4.53 4.53A.49.49 0 0 1 20 7v14.5a.5.5 0 0 1-.5.5h-15a.5.5 0 0 1-.5-.5v-19a.5.5 0 0 1 .5-.5H15a.49.49 0 0 1 .32.15ZM15.59 0H4a2 2 0 0 0-2 2v20a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V6.41a1 1 0 0 0-.29-.7L16.29.29a1 1 0 0 0-.7-.29Z", fill: "currentColor" }), (0,jsx_runtime.jsx)("path", { d: "M16 11H7a1 1 0 0 1 0-2h9a1 1 0 1 1 0 2ZM16 15H7a1 1 0 0 1 0-2h9a1 1 0 0 1 0 2ZM11.5 19H7a1 1 0 0 1 0-2h4.5a1 1 0 0 1 0 2Z", fill: "currentColor" })] })));
});
IconTextFile.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const ElementIconTextFile = (IconTextFile);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/ElementIconSelect.js



/**
 * Semantic vector graphics icon IconSelect.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconSelect size="large" color="green50" />
 */
const IconSelect = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { d: "M24 12a1.25 1.25 0 0 0-1.25-1.25h-1.59a9.27 9.27 0 0 0-7.91-7.91V1.25a1.25 1.25 0 0 0-2.5 0v1.59a9.27 9.27 0 0 0-7.91 7.91H1.25a1.25 1.25 0 0 0 0 2.5h1.59a9.25 9.25 0 0 0 7.91 7.9v1.6a1.25 1.25 0 0 0 2.5 0v-1.6a9.25 9.25 0 0 0 7.91-7.9h1.59A1.249 1.249 0 0 0 24 12Zm-10.44 6.56a.23.23 0 0 1-.21 0 .239.239 0 0 1-.1-.19v-1.12a1.25 1.25 0 0 0-2.5 0v1.07a.24.24 0 0 1-.1.19.23.23 0 0 1-.21 0 6.74 6.74 0 0 1-5-5 .28.28 0 0 1 0-.22.25.25 0 0 1 .2-.09h1.11a1.25 1.25 0 0 0 0-2.5H5.68a.25.25 0 0 1-.24-.31 6.76 6.76 0 0 1 5-5 .26.26 0 0 1 .31.25v1.11a1.25 1.25 0 0 0 2.5 0V5.68a.26.26 0 0 1 .31-.25 6.76 6.76 0 0 1 5 5 .25.25 0 0 1-.24.31h-1.07a1.25 1.25 0 0 0 0 2.5h1.07a.25.25 0 0 1 .2.09.28.28 0 0 1 0 .22 6.74 6.74 0 0 1-4.96 5.01Z", fill: "currentColor" }) })));
});
IconSelect.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const ElementIconSelect = (IconSelect);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/ElementIconJoin.js



/**
 * Semantic vector graphics icon IconJoin.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconJoin size="large" color="green50" />
 */
const IconJoin = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { d: "M1.44 0A1.43 1.43 0 0 0 0 1.44v4.62a7.36 7.36 0 0 0 2.77 5.75.22.22 0 0 1 .09.19.25.25 0 0 1-.09.19A7.36 7.36 0 0 0 0 17.94v4.62a1.44 1.44 0 1 0 2.88 0v-4.62a4.51 4.51 0 0 1 4.5-4.5H18a.25.25 0 0 1 .25.25v1.19a1.44 1.44 0 0 0 2.46 1L23.58 13a1.45 1.45 0 0 0 0-2L20.7 8.1a1.44 1.44 0 0 0-2.46 1v1.21a.25.25 0 0 1-.25.25H7.38a4.51 4.51 0 0 1-4.5-4.5V1.44A1.43 1.43 0 0 0 1.44 0Z", fill: "currentColor" }) })));
});
IconJoin.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const ElementIconJoin = (IconJoin);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/ElementIconSplit.js



/**
 * Semantic vector graphics icon IconSplit.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconSplit size="large" color="green50" />
 */
const IconSplit = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { d: "m20.7 23.58 2.88-2.88a1.44 1.44 0 0 0-1-2.46h-1.21a.25.25 0 0 1-.25-.25 7.359 7.359 0 0 0-2.77-5.75.251.251 0 0 1 0-.38 7.36 7.36 0 0 0 2.77-5.8V6a.25.25 0 0 1 .25-.25h1.19a1.44 1.44 0 0 0 1.02-2.45L20.7.42a1.45 1.45 0 0 0-2 0L15.78 3.3a1.48 1.48 0 0 0-.42 1c.002.189.04.375.11.55a1.44 1.44 0 0 0 1.33.91H18a.25.25 0 0 1 .24.24 4.51 4.51 0 0 1-4.5 4.5H1.44a1.44 1.44 0 1 0 0 2.88h12.3a4.51 4.51 0 0 1 4.5 4.5.25.25 0 0 1-.25.25H16.8a1.44 1.44 0 0 0-1.44 1.44c.008.375.159.732.42 1l2.88 2.88a1.45 1.45 0 0 0 2 0l.04.13Z", fill: "currentColor" }) })));
});
IconSplit.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const ElementIconSplit = (IconSplit);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/ElementIconEditCode.js



/**
 * Semantic vector graphics icon IconEditCode.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconEditCode size="large" color="green50" />
 */
const IconEditCode = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsxs)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: [(0,jsx_runtime.jsx)("path", { d: "M18.25 11.5V15a.75.75 0 1 0 1.5 0v-3.5a.75.75 0 1 0-1.5 0ZM15.75 14.5V12a1.25 1.25 0 0 0-1.25-1.25H13A1.25 1.25 0 0 0 11.75 12v2.5A1.25 1.25 0 0 0 13 15.75h1.5a1.25 1.25 0 0 0 1.25-1.25Zm-1.5-.5a.25.25 0 0 1-.25.25h-.5a.25.25 0 0 1-.25-.25v-1.5a.25.25 0 0 1 .25-.25h.5a.25.25 0 0 1 .25.25V14ZM14.25 8.5V5a.75.75 0 1 0-1.5 0v3.5a.75.75 0 1 0 1.5 0ZM20.75 8V5.5a1.25 1.25 0 0 0-1.25-1.25H18a1.25 1.25 0 0 0-1.25 1.25V8A1.25 1.25 0 0 0 18 9.25h1.5A1.25 1.25 0 0 0 20.75 8Zm-1.5-.5a.25.25 0 0 1-.25.25h-.5a.25.25 0 0 1-.25-.25V6a.25.25 0 0 1 .25-.25h.5a.25.25 0 0 1 .25.25v1.5Z", fill: "currentColor" }), (0,jsx_runtime.jsx)("path", { d: "M23.91 3 21.5.59A2 2 0 0 0 20.09 0H8.5a2 2 0 0 0-2 2v9.57a.29.29 0 0 0 .07.18l1.5 1.5a.26.26 0 0 0 .43-.18V2.5A.5.5 0 0 1 9 2h10.88a.47.47 0 0 1 .35.15l2.12 2.12a.469.469 0 0 1 .15.35V18a.5.5 0 0 1-.5.5h-8.32a.25.25 0 0 0-.24.34c.17.43.36 1.15.45 1.48a.25.25 0 0 0 .24.18h8.37a2 2 0 0 0 2-2V4.42A2 2 0 0 0 23.91 3ZM11.15 18.45l-6.58-6.58a2.72 2.72 0 0 0-3.61-.28 2.63 2.63 0 0 0-.2 3.88l6.68 6.68a.25.25 0 0 0 .36 0l3.35-3.35a.24.24 0 0 0 0-.35ZM11.94 20.13l-2.81 2.81a.25.25 0 0 0 .13.42l3.14.63h.1a.469.469 0 0 0 .35-.15.49.49 0 0 0 .14-.45l-.63-3.14a.25.25 0 0 0-.42-.12Z", fill: "currentColor" })] })));
});
IconEditCode.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const ElementIconEditCode = (IconEditCode);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/ElementIconFolder.js



/**
 * Semantic vector graphics icon IconFolder.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconFolder size="large" color="green50" />
 */
const IconFolder = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { d: "M24 6.3a2 2 0 0 0-1.95-1.95H12a.51.51 0 0 1-.45-.28l-.74-1.49A2 2 0 0 0 9.06 1.5H2a2 2 0 0 0-2 1.95v17.1a2 2 0 0 0 2 1.95h20.1a2 2 0 0 0 1.9-1.95V6.3ZM22.05 20a.5.5 0 0 1-.5.5l-19 .05a.5.5 0 0 1-.5-.5L2 4a.5.5 0 0 1 .5-.5h6.26a.49.49 0 0 1 .44.28l.77 1.52a1.93 1.93 0 0 0 1.74 1.08h9.84a.5.5 0 0 1 .5.5V20Z", fill: "currentColor" }) })));
});
IconFolder.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const ElementIconFolder = (IconFolder);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/ElementIconExperiment.js



/**
 * Semantic vector graphics icon IconExperiment.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconExperiment size="large" color="green50" />
 */
const IconExperiment = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { d: "M20.5 19.34 16.14 12a1 1 0 0 1-.14-.51V2.5a.5.5 0 0 1 .5-.5H18a1 1 0 1 0 0-2H6a1 1 0 0 0 0 2h1.5a.5.5 0 0 1 .5.5v9a1 1 0 0 1-.14.51l-4.32 7.27A3 3 0 0 0 6 24h12a3 3 0 0 0 2.49-4.66h.01ZM8.67 16a.5.5 0 0 1-.43-.75l1.62-2.74A1 1 0 0 0 10 12V2.5a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v2.75a.5.5 0 0 1-.5.5h-1.32a.75.75 0 1 0 0 1.5h1.32a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-1.32a.75.75 0 1 0 0 1.5h1.32a.5.5 0 0 1 .5.5V12a1 1 0 0 0 .14.51l1.61 2.74a.47.47 0 0 1 0 .5.52.52 0 0 1-.44.25H8.67Zm.82 5.82a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3Zm4.22-3a1 1 0 1 1 0-2 1 1 0 0 1 0 2Zm2.49 3.09a1 1 0 1 1 1-1 1 1 0 0 1-1 .98v.02Z", fill: "currentColor" }) })));
});
IconExperiment.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const ElementIconExperiment = (IconExperiment);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/ElementIconComment.js



/**
 * Semantic vector graphics icon IconComment.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconComment size="large" color="green50" />
 */
const IconComment = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { d: "M21.5 1.5h-19a2 2 0 0 0-2 2v13a2 2 0 0 0 2 2h4v3a1 1 0 0 0 1.71.71l3.71-3.71h9.58a2 2 0 0 0 2-2v-13a2 2 0 0 0-2-2Zm0 14.75a.25.25 0 0 1-.25.25H11.5a1 1 0 0 0-.71.29L8.5 19.08V17.5a1 1 0 0 0-1-1H2.75a.25.25 0 0 1-.25-.25V3.75a.25.25 0 0 1 .25-.25h18.5a.25.25 0 0 1 .25.25v12.5Z", fill: "currentColor" }) })));
});
IconComment.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const ElementIconComment = (IconComment);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/ElementIconLine.js



/**
 * Semantic vector graphics icon IconLine.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconLine size="large" color="green50" />
 */
const IconLine = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { d: "M23 22H7a1 1 0 0 0 0 2h16a1 1 0 1 0 0-2ZM23 17H7a1 1 0 0 0 0 2h16a1 1 0 0 0 0-2ZM24 13a1 1 0 0 0-1-1H7a1 1 0 0 0 0 2h16a1 1 0 0 0 1-1ZM23 2.025H7a1 1 0 1 0 0 2h16a1 1 0 0 0 0-2ZM7.37 7.88 3.7 5.13a.75.75 0 0 0-1.2.6v1.5a.25.25 0 0 1-.25.25H1a1 1 0 1 0 0 2h1.25a.25.25 0 0 1 .25.25v1.5a.75.75 0 0 0 1.2.6l3.67-2.75a.76.76 0 0 0 0-1.2ZM12 8.98h11a1 1 0 1 0 0-2H12a1 1 0 0 0 0 2Z", fill: "currentColor" }) })));
});
IconLine.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const ElementIconLine = (IconLine);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/ElementIconEdit.js



/**
 * Semantic vector graphics icon IconEdit.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconEdit size="large" color="green50" />
 */
const IconEdit = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { d: "M15.07 4a.49.49 0 0 0-.36-.15.5.5 0 0 0-.35.14L3.44 14.91a.5.5 0 0 0 0 .71l4.94 4.94a.491.491 0 0 0 .71 0L20 9.65a.51.51 0 0 0 0-.71L15.07 4ZM2.43 16.8a.51.51 0 0 0-.84.24L.08 23.31a.49.49 0 0 0 .14.47.51.51 0 0 0 .47.14L7 22.41a.49.49 0 0 0 .36-.35.52.52 0 0 0-.12-.49L2.43 16.8ZM23.2 2.92 21.08.8a2.52 2.52 0 0 0-3.54 0l-1.41 1.42a.478.478 0 0 0 0 .7l4.95 5a.48.48 0 0 0 .7 0l1.42-1.47a2.5 2.5 0 0 0 0-3.53Z", fill: "currentColor" }) })));
});
IconEdit.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const ElementIconEdit = (IconEdit);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/ElementIconReplace.js



/**
 * Semantic vector graphics icon IconReplace.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconReplace size="large" color="green50" />
 */
const IconReplace = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { d: "M7 21.75h10a1.25 1.25 0 0 0 0-2.5H7a1.76 1.76 0 0 1-1.75-1.75v-4.25A.25.25 0 0 1 5.5 13h1a.49.49 0 0 0 .5-.29.47.47 0 0 0-.07-.53l-2.5-3a.49.49 0 0 0-.76 0l-2.5 3a.47.47 0 0 0-.07.53.49.49 0 0 0 .4.29h1a.25.25 0 0 1 .25.25v4.25A4.26 4.26 0 0 0 7 21.75ZM20 15a.49.49 0 0 0 .38-.18l2.5-3a.47.47 0 0 0 .07-.53.49.49 0 0 0-.45-.29h-1a.25.25 0 0 1-.25-.25V6.5A4.25 4.25 0 0 0 17 2.25H7a1.25 1.25 0 0 0 0 2.5h10a1.75 1.75 0 0 1 1.75 1.75v4.25a.25.25 0 0 1-.25.25h-1a.49.49 0 0 0-.45.29.47.47 0 0 0 .07.53l2.5 3A.49.49 0 0 0 20 15Z", fill: "currentColor" }) })));
});
IconReplace.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const ElementIconReplace = (IconReplace);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/ElementIconTextBar.js



/**
 * Semantic vector graphics icon IconTextBar.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconTextBar size="large" color="green50" />
 */
const IconTextBar = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { d: "M17.25 21.25h-1.43a2.57 2.57 0 0 1-2.57-2.57v-1.84a.25.25 0 0 1 .25-.25h.89a1.25 1.25 0 0 0 0-2.5h-.89a.25.25 0 0 1-.25-.25V5.32a2.57 2.57 0 0 1 2.57-2.57h1.43a1.25 1.25 0 0 0 0-2.5h-1.43a5 5 0 0 0-3.64 1.54.24.24 0 0 1-.36 0A5 5 0 0 0 8.18.25H6.75a1.25 1.25 0 0 0 0 2.5h1.43a2.57 2.57 0 0 1 2.57 2.57v8.52a.25.25 0 0 1-.25.25h-.89a1.25 1.25 0 0 0 0 2.5h.89a.25.25 0 0 1 .25.25v1.84a2.571 2.571 0 0 1-2.57 2.57H6.75a1.25 1.25 0 0 0 0 2.5h1.43a5 5 0 0 0 3.64-1.55.27.27 0 0 1 .36 0 5 5 0 0 0 3.64 1.55h1.43a1.25 1.25 0 0 0 0-2.5Z", fill: "currentColor" }) })));
});
IconTextBar.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const ElementIconTextBar = (IconTextBar);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/ElementIconDataTable.js



/**
 * Semantic vector graphics icon IconDataTable.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconDataTable size="large" color="green50" />
 */
const IconDataTable = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsxs)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: [(0,jsx_runtime.jsx)("path", { d: "M20.5 2h-17a3 3 0 0 0-3 3v14a3 3 0 0 0 3 3h17a3 3 0 0 0 3-3V5a3 3 0 0 0-3-3Zm-11 11V8h5v5h-5Zm5 2v5h-5v-5h5Zm-12-7h5v5h-5V8Zm14 0h5v5h-5V8Zm-14 11v-4h5v5h-4a1 1 0 0 1-1-1Zm18 1h-4v-5h5v4a1 1 0 0 1-1 1Z", fill: "currentColor" }), (0,jsx_runtime.jsx)("path", { d: "M5 11.5a1 1 0 1 0 0-2 1 1 0 0 0 0 2ZM5 18.5a1 1 0 1 0 0-2 1 1 0 0 0 0 2Z", fill: "currentColor" })] })));
});
IconDataTable.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const ElementIconDataTable = (IconDataTable);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/ElementIconCloseDataTable.js



/**
 * Semantic vector graphics icon IconCloseDataTable.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconCloseDataTable size="large" color="green50" />
 */
const IconCloseDataTable = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsxs)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: [(0,jsx_runtime.jsx)("path", { d: "M17.75 11.5a6.25 6.25 0 1 0 0 12.5 6.25 6.25 0 0 0 0-12.5Zm-3.6 8.29a.23.23 0 0 1-.18-.13 4.12 4.12 0 0 1-.47-1.91 4.26 4.26 0 0 1 4.25-4.25c.665 0 1.32.161 1.91.47a.23.23 0 0 1 .13.18.26.26 0 0 1-.07.22l-5.35 5.35a.26.26 0 0 1-.22.07Zm3.6 2.21a4.12 4.12 0 0 1-1.91-.47.23.23 0 0 1-.13-.18.26.26 0 0 1 .07-.22l5.35-5.35a.26.26 0 0 1 .327-.028.23.23 0 0 1 .073.088c.309.59.47 1.245.47 1.91A4.26 4.26 0 0 1 17.75 22Z", fill: "currentColor" }), (0,jsx_runtime.jsx)("path", { d: "M10.46 15.13H8.61v-2.57H12a7.71 7.71 0 0 1 2.16-1.68V8.5h3.5V10h.09a7.32 7.32 0 0 1 1.41.13V2.39A2.39 2.39 0 0 0 16.78 0H2.39A2.39 2.39 0 0 0 0 2.39v11.86a2.39 2.39 0 0 0 2.39 2.38h7.69a7.502 7.502 0 0 1 .38-1.5Zm3.7-10.7h3.5V7h-3.5V4.43Zm-5.55 0h4.05V7H8.61V4.43Zm0 4.07h4.05v2.56H8.61V8.5Zm-1.5 6.63H2.39a.89.89 0 0 1-.89-.88v-1.69h5.61v2.57Zm0-4.07H1.5V8.5h5.61v2.56Zm0-4.06H1.5V4.43h5.61V7Z", fill: "currentColor" })] })));
});
IconCloseDataTable.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const ElementIconCloseDataTable = (IconCloseDataTable);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/ElementIconDataTableList.js



/**
 * Semantic vector graphics icon IconDataTableList.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconDataTableList size="large" color="green50" />
 */
const IconDataTableList = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsxs)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: [(0,jsx_runtime.jsx)("path", { d: "M21.78 0H9.89a2.22 2.22 0 0 0-2.22 2.22v1.54h10.39a3.43 3.43 0 0 1 2 .66h2.4V7.7h-1v1.5h1v2.56a.72.72 0 0 1-.72.72h-.25V14h.25A2.222 2.222 0 0 0 24 11.76V2.22A2.23 2.23 0 0 0 21.78 0Z", fill: "currentColor" }), (0,jsx_runtime.jsx)("path", { d: "M18.06 5H6.17A2.22 2.22 0 0 0 4 7.22v1.55h10.11a3.46 3.46 0 0 1 2 .65h2.64v3.29h-1.2v1.5h1.2v2.56a.72.72 0 0 1-.72.72h-.48V19h.48a2.22 2.22 0 0 0 2.22-2.22V7.22A2.21 2.21 0 0 0 18.06 5Z", fill: "currentColor" }), (0,jsx_runtime.jsx)("path", { d: "M14.11 10H2.22A2.22 2.22 0 0 0 0 12.24v9.54A2.23 2.23 0 0 0 2.22 24h11.89a2.23 2.23 0 0 0 2.22-2.22v-9.54A2.218 2.218 0 0 0 14.11 10Zm-6.48 7.7v-3.26h3.24v3.28l-3.24-.02Zm3.24 1.5v3.3H7.63v-3.28l3.24-.02ZM1.5 14.44h4.63v3.28H1.5v-3.28Zm10.87 0h2.46v3.28h-2.46v-3.28ZM1.5 21.78v-2.56h4.63v3.28H2.22a.722.722 0 0 1-.72-.72Zm12.61.72h-1.74v-3.28h2.46v2.56a.72.72 0 0 1-.72.72Z", fill: "currentColor" })] })));
});
IconDataTableList.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const ElementIconDataTableList = (IconDataTableList);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/icons/element.js





















































































/***/ }),

/***/ 274:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "IconActivity": () => (/* reexport */ icons_IconActivity),
  "IconAlignCenter": () => (/* reexport */ icons_IconAlignCenter),
  "IconAlignJustify": () => (/* reexport */ icons_IconAlignJustify),
  "IconAlignLeft": () => (/* reexport */ icons_IconAlignLeft),
  "IconAlignRight": () => (/* reexport */ icons_IconAlignRight),
  "IconArchive": () => (/* reexport */ icons_IconArchive),
  "IconAtSign": () => (/* reexport */ icons_IconAtSign),
  "IconAttachment": () => (/* reexport */ icons_IconAttachment),
  "IconBackspace": () => (/* reexport */ icons_IconBackspace),
  "IconBan": () => (/* reexport */ icons_IconBan),
  "IconBarChart": () => (/* reexport */ icons_IconBarChart),
  "IconBarChart2": () => (/* reexport */ icons_IconBarChart2),
  "IconBluetooth": () => (/* reexport */ icons_IconBluetooth),
  "IconBook": () => (/* reexport */ icons_IconBook),
  "IconBookOpen": () => (/* reexport */ icons_IconBookOpen),
  "IconBookmark": () => (/* reexport */ icons_IconBookmark),
  "IconBox": () => (/* reexport */ icons_IconBox),
  "IconBrandgoogle": () => (/* reexport */ icons_IconBrandgoogle),
  "IconBrandlinkedin": () => (/* reexport */ icons_IconBrandlinkedin),
  "IconBrandslack": () => (/* reexport */ icons_IconBrandslack),
  "IconBrandtwitter": () => (/* reexport */ icons_IconBrandtwitter),
  "IconBriefcase": () => (/* reexport */ icons_IconBriefcase),
  "IconCalendar": () => (/* reexport */ icons_IconCalendar),
  "IconCheck": () => (/* reexport */ IconCheck/* default */.Z),
  "IconCheckCircle": () => (/* reexport */ icons_IconCheckCircle),
  "IconCheckSquare": () => (/* reexport */ IconCheckSquare/* default */.Z),
  "IconChevronDown": () => (/* reexport */ IconChevronDown/* default */.Z),
  "IconChevronLeft": () => (/* reexport */ icons_IconChevronLeft),
  "IconChevronRight": () => (/* reexport */ IconChevronRight/* default */.Z),
  "IconChevronUp": () => (/* reexport */ icons_IconChevronUp),
  "IconClipboard": () => (/* reexport */ IconClipboard/* default */.Z),
  "IconClock": () => (/* reexport */ IconClock/* default */.Z),
  "IconCloud": () => (/* reexport */ icons_IconCloud),
  "IconCode": () => (/* reexport */ IconCode/* default */.Z),
  "IconColumns": () => (/* reexport */ icons_IconColumns),
  "IconCommand": () => (/* reexport */ icons_IconCommand),
  "IconCompass": () => (/* reexport */ icons_IconCompass),
  "IconCopy": () => (/* reexport */ icons_IconCopy),
  "IconCornerdownLeft": () => (/* reexport */ icons_IconCornerdownLeft),
  "IconCornerdownRight": () => (/* reexport */ icons_IconCornerdownRight),
  "IconCornerleftDown": () => (/* reexport */ icons_IconCornerleftDown),
  "IconCornerleftUp": () => (/* reexport */ icons_IconCornerleftUp),
  "IconCornerrightDown": () => (/* reexport */ icons_IconCornerrightDown),
  "IconCornerrightUp": () => (/* reexport */ icons_IconCornerrightUp),
  "IconCornerupLeft": () => (/* reexport */ icons_IconCornerupLeft),
  "IconCornerupRight": () => (/* reexport */ icons_IconCornerupRight),
  "IconCpu": () => (/* reexport */ icons_IconCpu),
  "IconCreditCard": () => (/* reexport */ icons_IconCreditCard),
  "IconCrop": () => (/* reexport */ icons_IconCrop),
  "IconCrosshair": () => (/* reexport */ IconCrosshair/* default */.Z),
  "IconCurlyBraces": () => (/* reexport */ icons_IconCurlyBraces),
  "IconDatabase": () => (/* reexport */ icons_IconDatabase),
  "IconDelete": () => (/* reexport */ IconDelete/* default */.Z),
  "IconDeleteBlank": () => (/* reexport */ icons_IconDeleteBlank),
  "IconDocker": () => (/* reexport */ icons_IconDocker),
  "IconDoubleChevronDown": () => (/* reexport */ icons_IconDoubleChevronDown),
  "IconDoubleChevronLeft": () => (/* reexport */ icons_IconDoubleChevronLeft),
  "IconDoubleChevronRight": () => (/* reexport */ icons_IconDoubleChevronRight),
  "IconDoubleChevronUp": () => (/* reexport */ icons_IconDoubleChevronUp),
  "IconDown": () => (/* reexport */ icons_IconDown),
  "IconDownCircle": () => (/* reexport */ icons_IconDownCircle),
  "IconDownLeft": () => (/* reexport */ icons_IconDownLeft),
  "IconDownRight": () => (/* reexport */ icons_IconDownRight),
  "IconDownload": () => (/* reexport */ icons_IconDownload),
  "IconDownloadCloud": () => (/* reexport */ icons_IconDownloadCloud),
  "IconDroplet": () => (/* reexport */ icons_IconDroplet),
  "IconEdit": () => (/* reexport */ IconEdit/* default */.Z),
  "IconEditForm": () => (/* reexport */ IconEditForm/* default */.Z),
  "IconEmpty": () => (/* reexport */ icons_IconEmpty),
  "IconEmptyCircle": () => (/* reexport */ icons_IconEmptyCircle),
  "IconEmptySquare": () => (/* reexport */ icons_IconEmptySquare),
  "IconEmptyTriangle": () => (/* reexport */ icons_IconEmptyTriangle),
  "IconExclamation": () => (/* reexport */ icons_IconExclamation),
  "IconExclamationCircle": () => (/* reexport */ icons_IconExclamationCircle),
  "IconExclamationTriangle": () => (/* reexport */ IconExclamationTriangle/* default */.Z),
  "IconExternalLink": () => (/* reexport */ icons_IconExternalLink),
  "IconEyeOff": () => (/* reexport */ icons_IconEyeOff),
  "IconEyeOn": () => (/* reexport */ icons_IconEyeOn),
  "IconFile": () => (/* reexport */ IconFile/* default */.Z),
  "IconFileInput": () => (/* reexport */ icons_IconFileInput),
  "IconFileMinus": () => (/* reexport */ icons_IconFileMinus),
  "IconFilePlus": () => (/* reexport */ icons_IconFilePlus),
  "IconFileText": () => (/* reexport */ icons_IconFileText),
  "IconFilledCircle": () => (/* reexport */ IconFilledCircle/* default */.Z),
  "IconFilledTriangle": () => (/* reexport */ IconFilledTriangle/* default */.Z),
  "IconFilter": () => (/* reexport */ icons_IconFilter),
  "IconFlag": () => (/* reexport */ icons_IconFlag),
  "IconFocus": () => (/* reexport */ icons_IconFocus),
  "IconFolder": () => (/* reexport */ icons_IconFolder),
  "IconFolderMinus": () => (/* reexport */ icons_IconFolderMinus),
  "IconFolderPlus": () => (/* reexport */ icons_IconFolderPlus),
  "IconFontBold": () => (/* reexport */ icons_IconFontBold),
  "IconFontItalic": () => (/* reexport */ icons_IconFontItalic),
  "IconFontType": () => (/* reexport */ IconFontType/* default */.Z),
  "IconFontUnderline": () => (/* reexport */ icons_IconFontUnderline),
  "IconForwardLeft": () => (/* reexport */ icons_IconForwardLeft),
  "IconForwardRight": () => (/* reexport */ icons_IconForwardRight),
  "IconFrame": () => (/* reexport */ icons_IconFrame),
  "IconFrown": () => (/* reexport */ icons_IconFrown),
  "IconGitBranch": () => (/* reexport */ icons_IconGitBranch),
  "IconGitCommit": () => (/* reexport */ icons_IconGitCommit),
  "IconGitMerge": () => (/* reexport */ icons_IconGitMerge),
  "IconGitPr": () => (/* reexport */ icons_IconGitPr),
  "IconGithub": () => (/* reexport */ icons_IconGithub),
  "IconGitlab": () => (/* reexport */ icons_IconGitlab),
  "IconGlobe": () => (/* reexport */ icons_IconGlobe),
  "IconGrid": () => (/* reexport */ icons_IconGrid),
  "IconHardDrive": () => (/* reexport */ icons_IconHardDrive),
  "IconHash": () => (/* reexport */ icons_IconHash),
  "IconHeart": () => (/* reexport */ icons_IconHeart),
  "IconHighlight": () => (/* reexport */ icons_IconHighlight),
  "IconHome": () => (/* reexport */ icons_IconHome),
  "IconImage": () => (/* reexport */ IconImage/* default */.Z),
  "IconInbox": () => (/* reexport */ icons_IconInbox),
  "IconInfoCircle": () => (/* reexport */ icons_IconInfoCircle),
  "IconLayers": () => (/* reexport */ icons_IconLayers),
  "IconLayout": () => (/* reexport */ icons_IconLayout),
  "IconLeft": () => (/* reexport */ IconLeft/* default */.Z),
  "IconLeftCircle": () => (/* reexport */ icons_IconLeftCircle),
  "IconLifeBuoy": () => (/* reexport */ icons_IconLifeBuoy),
  "IconLink": () => (/* reexport */ IconLink/* default */.Z),
  "IconLink2": () => (/* reexport */ icons_IconLink2),
  "IconLinkedin": () => (/* reexport */ icons_IconLinkedin),
  "IconList": () => (/* reexport */ IconList/* default */.Z),
  "IconLoader": () => (/* reexport */ IconLoader/* default */.Z),
  "IconLockLocked": () => (/* reexport */ IconLockLocked/* default */.Z),
  "IconLogIn": () => (/* reexport */ icons_IconLogIn),
  "IconLogOut": () => (/* reexport */ icons_IconLogOut),
  "IconMail": () => (/* reexport */ icons_IconMail),
  "IconMap": () => (/* reexport */ icons_IconMap),
  "IconMapPin": () => (/* reexport */ icons_IconMapPin),
  "IconMaximize": () => (/* reexport */ icons_IconMaximize),
  "IconMaximize2": () => (/* reexport */ icons_IconMaximize2),
  "IconMeh": () => (/* reexport */ icons_IconMeh),
  "IconMenu": () => (/* reexport */ IconMenu/* default */.Z),
  "IconMessageCircle": () => (/* reexport */ icons_IconMessageCircle),
  "IconMessageSquare": () => (/* reexport */ icons_IconMessageSquare),
  "IconMicOff": () => (/* reexport */ icons_IconMicOff),
  "IconMicOn": () => (/* reexport */ icons_IconMicOn),
  "IconMinimize": () => (/* reexport */ icons_IconMinimize),
  "IconMinimize2": () => (/* reexport */ icons_IconMinimize2),
  "IconMinus": () => (/* reexport */ IconMinus/* default */.Z),
  "IconMinusCircle": () => (/* reexport */ icons_IconMinusCircle),
  "IconMinusSquare": () => (/* reexport */ icons_IconMinusSquare),
  "IconMoon": () => (/* reexport */ icons_IconMoon),
  "IconMoreHorizontal": () => (/* reexport */ IconMoreHorizontal/* default */.Z),
  "IconMoreVertical": () => (/* reexport */ icons_IconMoreVertical),
  "IconMove": () => (/* reexport */ icons_IconMove),
  "IconNavigation": () => (/* reexport */ icons_IconNavigation),
  "IconNavigation2": () => (/* reexport */ icons_IconNavigation2),
  "IconNote": () => (/* reexport */ icons_IconNote),
  "IconNotificationOff": () => (/* reexport */ icons_IconNotificationOff),
  "IconNotificationOn": () => (/* reexport */ icons_IconNotificationOn),
  "IconPartners": () => (/* reexport */ icons_IconPartners),
  "IconPause": () => (/* reexport */ icons_IconPause),
  "IconPauseCircle": () => (/* reexport */ icons_IconPauseCircle),
  "IconPenTool": () => (/* reexport */ icons_IconPenTool),
  "IconPercent": () => (/* reexport */ icons_IconPercent),
  "IconPieChart": () => (/* reexport */ icons_IconPieChart),
  "IconPlay": () => (/* reexport */ icons_IconPlay),
  "IconPlayCircle": () => (/* reexport */ icons_IconPlayCircle),
  "IconPlus": () => (/* reexport */ icons_IconPlus),
  "IconPlusCircle": () => (/* reexport */ icons_IconPlusCircle),
  "IconPlusSquare": () => (/* reexport */ icons_IconPlusSquare),
  "IconPower": () => (/* reexport */ icons_IconPower),
  "IconPrinter": () => (/* reexport */ icons_IconPrinter),
  "IconQuestionCircle": () => (/* reexport */ IconQuestionCircle/* default */.Z),
  "IconRadio": () => (/* reexport */ icons_IconRadio),
  "IconRecCircle": () => (/* reexport */ IconRecCircle/* default */.Z),
  "IconRefreshLeft": () => (/* reexport */ icons_IconRefreshLeft),
  "IconRefreshRight": () => (/* reexport */ icons_IconRefreshRight),
  "IconRepeat": () => (/* reexport */ icons_IconRepeat),
  "IconRight": () => (/* reexport */ IconRight/* default */.Z),
  "IconRightCircle": () => (/* reexport */ icons_IconRightCircle),
  "IconRobocorp": () => (/* reexport */ IconRobocorp/* default */.Z),
  "IconRobocorpOutline": () => (/* reexport */ IconRobocorpOutline/* default */.Z),
  "IconRotationLeft": () => (/* reexport */ icons_IconRotationLeft),
  "IconRotationRight": () => (/* reexport */ icons_IconRotationRight),
  "IconRss": () => (/* reexport */ icons_IconRss),
  "IconSave": () => (/* reexport */ icons_IconSave),
  "IconScissorsTool": () => (/* reexport */ icons_IconScissorsTool),
  "IconSearch": () => (/* reexport */ icons_IconSearch),
  "IconSend": () => (/* reexport */ icons_IconSend),
  "IconServer": () => (/* reexport */ icons_IconServer),
  "IconSettings": () => (/* reexport */ icons_IconSettings),
  "IconShare": () => (/* reexport */ icons_IconShare),
  "IconShieldOff": () => (/* reexport */ icons_IconShieldOff),
  "IconShieldOn": () => (/* reexport */ icons_IconShieldOn),
  "IconShuffle": () => (/* reexport */ icons_IconShuffle),
  "IconSidebar": () => (/* reexport */ icons_IconSidebar),
  "IconSkipBack": () => (/* reexport */ icons_IconSkipBack),
  "IconSkipForward": () => (/* reexport */ icons_IconSkipForward),
  "IconSlack": () => (/* reexport */ icons_IconSlack),
  "IconSliders": () => (/* reexport */ icons_IconSliders),
  "IconSmartphone": () => (/* reexport */ icons_IconSmartphone),
  "IconSmile": () => (/* reexport */ icons_IconSmile),
  "IconSort": () => (/* reexport */ icons_IconSort),
  "IconSortArrow": () => (/* reexport */ IconSortArrow/* default */.Z),
  "IconSortFilled": () => (/* reexport */ IconSortFilled/* default */.Z),
  "IconStar": () => (/* reexport */ icons_IconStar),
  "IconStarFilled": () => (/* reexport */ icons_IconStarFilled),
  "IconStop": () => (/* reexport */ IconStop/* default */.Z),
  "IconStopCircle": () => (/* reexport */ icons_IconStopCircle),
  "IconSun": () => (/* reexport */ icons_IconSun),
  "IconTable": () => (/* reexport */ icons_IconTable),
  "IconTablet": () => (/* reexport */ icons_IconTablet),
  "IconTarget": () => (/* reexport */ icons_IconTarget),
  "IconTerminal": () => (/* reexport */ icons_IconTerminal),
  "IconTrendingDown": () => (/* reexport */ icons_IconTrendingDown),
  "IconTrendingUp": () => (/* reexport */ icons_IconTrendingUp),
  "IconTwitter": () => (/* reexport */ icons_IconTwitter),
  "IconUnlink": () => (/* reexport */ icons_IconUnlink),
  "IconUnlink2": () => (/* reexport */ icons_IconUnlink2),
  "IconUnlocked": () => (/* reexport */ IconUnlocked/* default */.Z),
  "IconUp": () => (/* reexport */ icons_IconUp),
  "IconUpCircle": () => (/* reexport */ icons_IconUpCircle),
  "IconUpLeft": () => (/* reexport */ icons_IconUpLeft),
  "IconUpRight": () => (/* reexport */ icons_IconUpRight),
  "IconUpload": () => (/* reexport */ icons_IconUpload),
  "IconUploadCloud": () => (/* reexport */ icons_IconUploadCloud),
  "IconUser": () => (/* reexport */ icons_IconUser),
  "IconUserCheck": () => (/* reexport */ icons_IconUserCheck),
  "IconUserMinus": () => (/* reexport */ icons_IconUserMinus),
  "IconUserPlus": () => (/* reexport */ icons_IconUserPlus),
  "IconUserX": () => (/* reexport */ icons_IconUserX),
  "IconUsers": () => (/* reexport */ icons_IconUsers),
  "IconVideo": () => (/* reexport */ icons_IconVideo),
  "IconWifiOn": () => (/* reexport */ icons_IconWifiOn),
  "IconWindows": () => (/* reexport */ IconWindows/* default */.Z),
  "IconX": () => (/* reexport */ IconX/* default */.Z),
  "IconXCircle": () => (/* reexport */ icons_IconXCircle),
  "IconXSquare": () => (/* reexport */ icons_IconXSquare),
  "IconZapOff": () => (/* reexport */ icons_IconZapOff),
  "IconZapOn": () => (/* reexport */ icons_IconZapOn),
  "IconZoomIn": () => (/* reexport */ icons_IconZoomIn),
  "IconZoomOut": () => (/* reexport */ icons_IconZoomOut)
});

// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconUnlocked.js
var IconUnlocked = __webpack_require__(2785);
// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconLockLocked.js
var IconLockLocked = __webpack_require__(9438);
// EXTERNAL MODULE: ./node_modules/react/jsx-runtime.js
var jsx_runtime = __webpack_require__(38);
// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/Icon.js
var Icon = __webpack_require__(3170);
// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/helpers/component.js
var component = __webpack_require__(8335);
;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconSort.js



/**
 * Semantic vector graphics icon IconSort.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconSort size="large" color="green50" />
 */
const IconSort = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M12.707 3.293a1 1 0 0 0-1.414 0l-5 5a1 1 0 0 0 1.414 1.414L12 5.414l4.293 4.293a1 1 0 0 0 1.414-1.414l-5-5ZM6.293 15.707l5 5a1 1 0 0 0 1.414 0l5-5a1 1 0 0 0-1.414-1.414L12 18.586l-4.293-4.293a1 1 0 0 0-1.414 1.414Z", fill: "currentColor" }) })));
});
IconSort.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconSort = (IconSort);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconDoubleChevronRight.js



/**
 * Semantic vector graphics icon IconDoubleChevronRight.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconDoubleChevronRight size="large" color="green50" />
 */
const IconDoubleChevronRight = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M6.707 6.293a1 1 0 0 0-1.414 1.414L9.586 12l-4.293 4.293a1 1 0 1 0 1.414 1.414l5-5a1 1 0 0 0 0-1.414l-5-5Zm7 0a1 1 0 1 0-1.414 1.414L16.586 12l-4.293 4.293a1 1 0 0 0 1.414 1.414l5-5a1 1 0 0 0 0-1.414l-5-5Z", fill: "currentColor" }) })));
});
IconDoubleChevronRight.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconDoubleChevronRight = (IconDoubleChevronRight);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconDoubleChevronUp.js



/**
 * Semantic vector graphics icon IconDoubleChevronUp.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconDoubleChevronUp size="large" color="green50" />
 */
const IconDoubleChevronUp = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M12.707 5.293a1 1 0 0 0-1.414 0l-5 5a1 1 0 1 0 1.414 1.414L12 7.414l4.293 4.293a1 1 0 0 0 1.414-1.414l-5-5Zm5 12-5-5a1 1 0 0 0-1.414 0l-5 5a1 1 0 1 0 1.414 1.414L12 14.414l4.293 4.293a1 1 0 0 0 1.414-1.414Z", fill: "currentColor" }) })));
});
IconDoubleChevronUp.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconDoubleChevronUp = (IconDoubleChevronUp);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconDoubleChevronDown.js



/**
 * Semantic vector graphics icon IconDoubleChevronDown.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconDoubleChevronDown size="large" color="green50" />
 */
const IconDoubleChevronDown = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M7.707 5.293a1 1 0 0 0-1.414 1.414l5 5a1 1 0 0 0 1.414 0l5-5a1 1 0 0 0-1.414-1.414L12 9.586 7.707 5.293Zm0 7a1 1 0 0 0-1.414 1.414l5 5a1 1 0 0 0 1.414 0l5-5a1 1 0 0 0-1.414-1.414L12 16.586l-4.293-4.293Z", fill: "currentColor" }) })));
});
IconDoubleChevronDown.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconDoubleChevronDown = (IconDoubleChevronDown);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconDoubleChevronLeft.js



/**
 * Semantic vector graphics icon IconDoubleChevronLeft.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconDoubleChevronLeft size="large" color="green50" />
 */
const IconDoubleChevronLeft = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M11.707 7.707a1 1 0 0 0-1.414-1.414l-5 5a1 1 0 0 0 0 1.414l5 5a1 1 0 0 0 1.414-1.414L7.414 12l4.293-4.293Zm7 0a1 1 0 0 0-1.414-1.414l-5 5a1 1 0 0 0 0 1.414l5 5a1 1 0 0 0 1.414-1.414L14.414 12l4.293-4.293Z", fill: "currentColor" }) })));
});
IconDoubleChevronLeft.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconDoubleChevronLeft = (IconDoubleChevronLeft);

// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconChevronRight.js
var IconChevronRight = __webpack_require__(2554);
;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconChevronUp.js



/**
 * Semantic vector graphics icon IconChevronUp.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconChevronUp size="large" color="green50" />
 */
const IconChevronUp = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M11.293 8.293a1 1 0 0 1 1.414 0l6 6a1 1 0 0 1-1.414 1.414L12 10.414l-5.293 5.293a1 1 0 0 1-1.414-1.414l6-6Z", fill: "currentColor" }) })));
});
IconChevronUp.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconChevronUp = (IconChevronUp);

// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconChevronDown.js
var IconChevronDown = __webpack_require__(3469);
;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconChevronLeft.js



/**
 * Semantic vector graphics icon IconChevronLeft.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconChevronLeft size="large" color="green50" />
 */
const IconChevronLeft = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M15.707 5.293a1 1 0 0 1 0 1.414L10.414 12l5.293 5.293a1 1 0 0 1-1.414 1.414l-6-6a1 1 0 0 1 0-1.414l6-6a1 1 0 0 1 1.414 0Z", fill: "currentColor" }) })));
});
IconChevronLeft.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconChevronLeft = (IconChevronLeft);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconWifiOn.js



/**
 * Semantic vector graphics icon IconWifiOn.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconWifiOn size="large" color="green50" />
 */
const IconWifiOn = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M2.081 9.75a15 15 0 0 1 19.838 0 1 1 0 1 0 1.322-1.5 17 17 0 0 0-22.482 0 1 1 0 0 0 1.322 1.5Zm3.559 3.568a10 10 0 0 1 12.8 0 1 1 0 1 0 1.28-1.536 12 12 0 0 0-15.36 0 1 1 0 1 0 1.28 1.536Zm6.365 2.683a5 5 0 0 0-2.896.924 1 1 0 0 1-1.158-1.63 7 7 0 0 1 8.108 0 1 1 0 1 1-1.158 1.63 5 5 0 0 0-2.896-.924ZM12 19a1 1 0 1 0 0 2h.01a1 1 0 1 0 0-2H12Z", fill: "currentColor" }) })));
});
IconWifiOn.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconWifiOn = (IconWifiOn);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconShieldOff.js



/**
 * Semantic vector graphics icon IconShieldOff.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconShieldOff size="large" color="green50" />
 */
const IconShieldOff = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M1.707.293A1 1 0 0 0 .293 1.707l2.824 2.824A.998.998 0 0 0 3 5v7c0 3.446 2.282 6.2 4.341 8.003a22.686 22.686 0 0 0 4.104 2.836l.024.013.052.026.022.011.006.004h.002s.002.001.449-.893l-.447.894a1 1 0 0 0 .914-.01 21.287 21.287 0 0 0 5.173-3.83l4.653 4.653a1 1 0 0 0 1.414-1.414l-5.373-5.373a.702.702 0 0 0-.012-.013L5.453 4.04a.989.989 0 0 0-.031-.032L1.707.293ZM5 6.414V12c0 2.553 1.718 4.8 3.659 6.497a20.69 20.69 0 0 0 3.34 2.365 19.287 19.287 0 0 0 4.227-3.222L5 6.414Zm6.65-5.35a1 1 0 0 1 .701 0l8 3A1 1 0 0 1 21 5v7.007a7.9 7.9 0 0 1-.355 2.29 1 1 0 1 1-1.91-.593A5.9 5.9 0 0 0 19 11.997V5.693l-7-2.625-2.81 1.049a1 1 0 0 1-.7-1.874l3.16-1.18Z", fill: "currentColor" }) })));
});
IconShieldOff.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconShieldOff = (IconShieldOff);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconShieldOn.js



/**
 * Semantic vector graphics icon IconShieldOn.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconShieldOn size="large" color="green50" />
 */
const IconShieldOn = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M11.649 1.064a1 1 0 0 1 .702 0l8 3A1 1 0 0 1 21 5v7c0 3.446-2.282 6.2-4.341 8.003a22.684 22.684 0 0 1-4.104 2.836 8.28 8.28 0 0 1-.076.04l-.022.01-.006.004h-.002s-.002.001-.449-.893l-.448.894-.003-.001-.006-.004-.022-.01a8.28 8.28 0 0 1-.35-.188 22.686 22.686 0 0 1-3.83-2.689C5.281 18.2 3 15.447 3 12V5a1 1 0 0 1 .649-.936l8-3ZM12 22l-.448.894c.282.14.614.141.895 0L12 22Zm0-1.137a20.69 20.69 0 0 0 3.341-2.365C17.282 16.8 19 14.553 19 12V5.693l-7-2.625-7 2.625V12c0 2.554 1.718 4.8 3.659 6.497A20.692 20.692 0 0 0 12 20.863Z", fill: "currentColor" }) })));
});
IconShieldOn.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconShieldOn = (IconShieldOn);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconNotificationOff.js



/**
 * Semantic vector graphics icon IconNotificationOff.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconNotificationOff size="large" color="green50" />
 */
const IconNotificationOff = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M.293.293a1 1 0 0 1 1.414 0L17.7 16.286l.014.014 5.993 5.993a1 1 0 0 1-1.414 1.414L16.586 18H3a1 1 0 0 1-.566-1.824l.003-.002.052-.042c.053-.044.141-.123.254-.242.224-.237.547-.636.88-1.244C4.282 13.435 5 11.353 5 8c0-.486.05-.968.15-1.437L.292 1.707a1 1 0 0 1 0-1.414ZM6.997 8.41c-.057 3.419-.812 5.713-1.619 7.193-.076.14-.153.271-.229.396h9.437l-7.59-7.59Zm8.31-6.59a7 7 0 0 0-7.192.347 1 1 0 1 0 1.11 1.664A5 5 0 0 1 17 7.98v.003c-.029 1.782.195 3.56.665 5.28a1 1 0 1 0 1.93-.527 16.893 16.893 0 0 1-.596-4.702v-.02L19 8a7 7 0 0 0-3.694-6.18ZM9.768 20.135a1 1 0 0 1 1.367.363 1 1 0 0 0 1.73 0 1 1 0 1 1 1.73 1.004 3 3 0 0 1-5.19 0 1 1 0 0 1 .363-1.367Z", fill: "currentColor" }) })));
});
IconNotificationOff.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconNotificationOff = (IconNotificationOff);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconNotificationOn.js



/**
 * Semantic vector graphics icon IconNotificationOn.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconNotificationOn size="large" color="green50" />
 */
const IconNotificationOn = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M12 1a7 7 0 0 0-7 7c0 3.353-.717 5.435-1.378 6.646a5.937 5.937 0 0 1-.88 1.244 3.037 3.037 0 0 1-.305.284l-.003.002A1 1 0 0 0 3 18h18a1 1 0 0 0 .566-1.824l-.003-.002a3.026 3.026 0 0 1-.306-.283 5.939 5.939 0 0 1-.88-1.245C19.718 13.435 19 11.353 19 8a7 7 0 0 0-7-7Zm6.622 14.604c.076.14.153.271.229.396H5.149c.076-.125.153-.257.229-.396C6.218 14.065 7 11.647 7 8a5 5 0 1 1 10 0c0 3.647.783 6.065 1.622 7.604Zm-7.487 4.894a1 1 0 0 0-1.73 1.004 3 3 0 0 0 5.19 0 1 1 0 0 0-1.73-1.004 1 1 0 0 1-1.73 0Z", fill: "currentColor" }) })));
});
IconNotificationOn.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconNotificationOn = (IconNotificationOn);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconMinimize.js



/**
 * Semantic vector graphics icon IconMinimize.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconMinimize size="large" color="green50" />
 */
const IconMinimize = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M21.707 3.707 16.414 9H20a1 1 0 1 1 0 2h-6.003a.997.997 0 0 1-.702-.29l-.004-.005a.997.997 0 0 1-.291-.702V4a1 1 0 1 1 2 0v3.586l5.293-5.293a1 1 0 1 1 1.414 1.414ZM4 13a1 1 0 1 0 0 2h3.586l-5.293 5.293a1 1 0 1 0 1.414 1.414L9 16.414V20a1 1 0 1 0 2 0v-6.003a.997.997 0 0 0-.997-.997H4Z", fill: "currentColor" }) })));
});
IconMinimize.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconMinimize = (IconMinimize);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconMaximize.js



/**
 * Semantic vector graphics icon IconMaximize.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconMaximize size="large" color="green50" />
 */
const IconMaximize = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M15 4a1 1 0 1 1 0-2h6a1 1 0 0 1 1 1v6a1 1 0 1 1-2 0V5.414l-5.293 5.293a1 1 0 0 1-1.414-1.414L18.586 4H15Zm-5.707 9.293a1 1 0 0 1 1.414 1.414L5.414 20H9a1 1 0 1 1 0 2H3a1 1 0 0 1-1-1v-6a1 1 0 1 1 2 0v3.586l5.293-5.293Z", fill: "currentColor" }) })));
});
IconMaximize.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconMaximize = (IconMaximize);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconMove.js



/**
 * Semantic vector graphics icon IconMove.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconMove size="large" color="green50" />
 */
const IconMove = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M11.293 1.293a1 1 0 0 1 1.414 0l3 3a1 1 0 0 1-1.414 1.414L13 4.414V11h6.586l-1.293-1.293a1 1 0 0 1 1.414-1.414l3 3a1 1 0 0 1 0 1.414l-3 3a1 1 0 0 1-1.414-1.414L19.586 13H13v6.586l1.293-1.293a1 1 0 0 1 1.414 1.414l-3 3a1 1 0 0 1-1.414 0l-3-3a1 1 0 1 1 1.414-1.414L11 19.586V13H4.414l1.293 1.293a1 1 0 1 1-1.414 1.414l-3-3a1 1 0 0 1 0-1.414l3-3a1 1 0 0 1 1.414 1.414L4.414 11H11V4.414L9.707 5.707a1 1 0 0 1-1.414-1.414l3-3Z", fill: "currentColor" }) })));
});
IconMove.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconMove = (IconMove);

// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconSortArrow.js
var IconSortArrow = __webpack_require__(530);
;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconLogOut.js



/**
 * Semantic vector graphics icon IconLogOut.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconLogOut size="large" color="green50" />
 */
const IconLogOut = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M4.293 4.293A1 1 0 0 1 5 4h4a1 1 0 0 0 0-2H5a3 3 0 0 0-3 3v14a3 3 0 0 0 3 3h4a1 1 0 1 0 0-2H5a1 1 0 0 1-1-1V5a1 1 0 0 1 .293-.707Zm12.414 2a1 1 0 1 0-1.414 1.414L18.586 11H9a1 1 0 1 0 0 2h9.586l-3.293 3.293a1 1 0 0 0 1.414 1.414l5-5a1 1 0 0 0 0-1.414l-5-5Z", fill: "currentColor" }) })));
});
IconLogOut.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconLogOut = (IconLogOut);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconLogIn.js



/**
 * Semantic vector graphics icon IconLogIn.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconLogIn size="large" color="green50" />
 */
const IconLogIn = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M14 3a1 1 0 0 1 1-1h4a3 3 0 0 1 3 3v14a3 3 0 0 1-3 3h-4a1 1 0 1 1 0-2h4a1 1 0 0 0 1-1V5a1 1 0 0 0-1-1h-4a1 1 0 0 1-1-1ZM9.293 6.293a1 1 0 0 1 1.414 0l5 5 .007.007c.176.18.285.425.286.697v.006a.996.996 0 0 1-.286.697l-.008.008-4.999 5a1 1 0 0 1-1.414-1.415L12.586 13H3a1 1 0 1 1 0-2h9.586L9.293 7.707a1 1 0 0 1 0-1.414Z", fill: "currentColor" }) })));
});
IconLogIn.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconLogIn = (IconLogIn);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconCornerupRight.js



/**
 * Semantic vector graphics icon IconCornerupRight.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconCornerupRight size="large" color="green50" />
 */
const IconCornerupRight = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M14.293 3.293a1 1 0 0 1 1.414 0l5 5a1 1 0 0 1 0 1.414l-5 5a1 1 0 0 1-1.414-1.414L17.586 10H8a3 3 0 0 0-3 3v7a1 1 0 1 1-2 0v-7a5 5 0 0 1 5-5h9.586l-3.293-3.293a1 1 0 0 1 0-1.414Z", fill: "currentColor" }) })));
});
IconCornerupRight.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconCornerupRight = (IconCornerupRight);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconCornerupLeft.js



/**
 * Semantic vector graphics icon IconCornerupLeft.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconCornerupLeft size="large" color="green50" />
 */
const IconCornerupLeft = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M9.707 3.293a1 1 0 0 1 0 1.414L6.414 8H16a5 5 0 0 1 5 5v7a1 1 0 1 1-2 0v-7a3 3 0 0 0-3-3H6.414l3.293 3.293a1 1 0 0 1-1.414 1.414l-5-5a1 1 0 0 1 0-1.414l5-5a1 1 0 0 1 1.414 0Z", fill: "currentColor" }) })));
});
IconCornerupLeft.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconCornerupLeft = (IconCornerupLeft);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconCornerrightUp.js



/**
 * Semantic vector graphics icon IconCornerrightUp.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconCornerrightUp size="large" color="green50" />
 */
const IconCornerrightUp = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M14.293 3.293a1 1 0 0 1 1.414 0l5 5a1 1 0 0 1-1.414 1.414L16 6.414V16a5 5 0 0 1-5 5H4a1 1 0 1 1 0-2h7a3 3 0 0 0 3-3V6.414l-3.293 3.293a1 1 0 0 1-1.414-1.414l5-5Z", fill: "currentColor" }) })));
});
IconCornerrightUp.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconCornerrightUp = (IconCornerrightUp);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconCornerleftUp.js



/**
 * Semantic vector graphics icon IconCornerleftUp.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconCornerleftUp size="large" color="green50" />
 */
const IconCornerleftUp = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M8.293 3.293a1 1 0 0 1 1.414 0l5 5a1 1 0 0 1-1.414 1.414L10 6.414V16a3 3 0 0 0 3 3h7a1 1 0 1 1 0 2h-7a5 5 0 0 1-5-5V6.414L4.707 9.707a1 1 0 0 1-1.414-1.414l5-5Z", fill: "currentColor" }) })));
});
IconCornerleftUp.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconCornerleftUp = (IconCornerleftUp);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconCornerrightDown.js



/**
 * Semantic vector graphics icon IconCornerrightDown.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconCornerrightDown size="large" color="green50" />
 */
const IconCornerrightDown = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M3 4a1 1 0 0 1 1-1h7a5 5 0 0 1 5 5v9.586l3.293-3.293a1 1 0 0 1 1.414 1.414l-5 5a1 1 0 0 1-1.414 0l-5-5a1 1 0 1 1 1.414-1.414L14 17.586V8a3 3 0 0 0-3-3H4a1 1 0 0 1-1-1Z", fill: "currentColor" }) })));
});
IconCornerrightDown.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconCornerrightDown = (IconCornerrightDown);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconCornerleftDown.js



/**
 * Semantic vector graphics icon IconCornerleftDown.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconCornerleftDown size="large" color="green50" />
 */
const IconCornerleftDown = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M9.464 4.464A5 5 0 0 1 13 3h7a1 1 0 1 1 0 2h-7a3 3 0 0 0-3 3v9.586l3.293-3.293a1 1 0 0 1 1.414 1.414l-5 5a1 1 0 0 1-1.414 0l-5-5a1 1 0 1 1 1.414-1.414L8 17.586V8a5 5 0 0 1 1.464-3.536Z", fill: "currentColor" }) })));
});
IconCornerleftDown.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconCornerleftDown = (IconCornerleftDown);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconCornerdownRight.js



/**
 * Semantic vector graphics icon IconCornerdownRight.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconCornerdownRight size="large" color="green50" />
 */
const IconCornerdownRight = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M4 3a1 1 0 0 1 1 1v7a3 3 0 0 0 3 3h9.586l-3.293-3.293a1 1 0 0 1 1.414-1.414l5 5a1 1 0 0 1 0 1.414l-5 5a1 1 0 0 1-1.414-1.414L17.586 16H8a5 5 0 0 1-5-5V4a1 1 0 0 1 1-1Z", fill: "currentColor" }) })));
});
IconCornerdownRight.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconCornerdownRight = (IconCornerdownRight);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconCornerdownLeft.js



/**
 * Semantic vector graphics icon IconCornerdownLeft.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconCornerdownLeft size="large" color="green50" />
 */
const IconCornerdownLeft = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M20 3a1 1 0 0 1 1 1v7a5 5 0 0 1-5 5H6.414l3.293 3.293a1 1 0 0 1-1.414 1.414l-5-5a1 1 0 0 1 0-1.414l5-5a1 1 0 0 1 1.414 1.414L6.414 14H16a3 3 0 0 0 3-3V4a1 1 0 0 1 1-1Z", fill: "currentColor" }) })));
});
IconCornerdownLeft.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconCornerdownLeft = (IconCornerdownLeft);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconEyeOff.js



/**
 * Semantic vector graphics icon IconEyeOff.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconEyeOff size="large" color="green50" />
 */
const IconEyeOff = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M.293.293a1 1 0 0 1 1.414 0l22 22a1 1 0 0 1-1.414 1.414l-4.467-4.467a11.07 11.07 0 0 1-5.81 1.76H12c-3.9 0-6.896-2.226-8.855-4.316a20.676 20.676 0 0 1-2.831-3.85 12.339 12.339 0 0 1-.192-.354l-.011-.022-.003-.007-.002-.002v-.001L1 12l-.894.447a1 1 0 0 1 .013-.92 19.45 19.45 0 0 1 4.45-5.544L.293 1.707a1 1 0 0 1 0-1.414Zm1.85 11.71a18.669 18.669 0 0 0 2.462 3.313c1.789 1.909 4.29 3.68 7.387 3.684a9.07 9.07 0 0 0 4.38-1.214l-2.322-2.322a3.993 3.993 0 0 1-3.623.32A4 4 0 0 1 8.536 9.95L5.987 7.401a17.45 17.45 0 0 0-3.844 4.602Zm7.885-.56a2 2 0 0 0 2.53 2.53l-2.53-2.53Zm.19-6.245A8.113 8.113 0 0 1 12 5c3.1 0 5.605 1.774 7.395 3.684A18.681 18.681 0 0 1 21.86 12a19.027 19.027 0 0 1-1.765 2.524 1 1 0 0 0 1.54 1.276 21.022 21.022 0 0 0 1.672-2.324 17.163 17.163 0 0 0 .575-1.003l.01-.017.002-.006v-.002h.001L23 12l.894.447a1 1 0 0 0 0-.894L23 12l.894-.448-.002-.003-.003-.007-.011-.022a10.615 10.615 0 0 0-.192-.354 20.675 20.675 0 0 0-2.831-3.85C18.895 5.226 15.899 3 12 3c-.773 0-1.514.088-2.219.246a1 1 0 1 0 .438 1.952Z", fill: "currentColor" }) })));
});
IconEyeOff.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconEyeOff = (IconEyeOff);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconEyeOn.js



/**
 * Semantic vector graphics icon IconEyeOn.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconEyeOn size="large" color="green50" />
 */
const IconEyeOn = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M2.574 12.707c-.18-.277-.324-.518-.433-.707a18.678 18.678 0 0 1 2.464-3.316C6.395 6.774 8.9 5 12 5c3.1 0 5.605 1.774 7.395 3.684A18.681 18.681 0 0 1 21.86 12a18.684 18.684 0 0 1-2.464 3.316C17.605 17.226 15.101 19 12 19c-3.1 0-5.604-1.774-7.395-3.684a18.68 18.68 0 0 1-2.03-2.609Zm21.32-1.155L23 12l.894.448-.002.003-.003.007-.011.022a10.615 10.615 0 0 1-.192.354 20.672 20.672 0 0 1-2.831 3.85C18.895 18.774 15.899 21 12 21c-3.9 0-6.896-2.226-8.855-4.316a20.67 20.67 0 0 1-2.831-3.85 12.375 12.375 0 0 1-.192-.354l-.011-.022-.003-.007-.002-.002v-.001L1 12l-.894-.448.002-.003.003-.007.011-.022a8.267 8.267 0 0 1 .192-.354 20.674 20.674 0 0 1 2.831-3.85C5.105 5.226 8.1 3 12 3c3.9 0 6.895 2.226 8.855 4.316a20.675 20.675 0 0 1 2.831 3.85 11.81 11.81 0 0 1 .192.354l.011.022.003.007.002.002v.001ZM23 12l.894-.447a1 1 0 0 1 0 .894L23 12ZM.106 11.553 1 12l-.894.447a1 1 0 0 1 0-.894ZM10 12a2 2 0 1 1 4 0 2 2 0 0 1-4 0Zm2-4a4 4 0 1 0 0 8 4 4 0 0 0 0-8Z", fill: "currentColor" }) })));
});
IconEyeOn.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconEyeOn = (IconEyeOn);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconMicOff.js



/**
 * Semantic vector graphics icon IconMicOff.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconMicOff size="large" color="green50" />
 */
const IconMicOff = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M9.628.78A4 4 0 0 1 16 4.002m0 .001v5.339a1 1 0 1 1-2 0V4.002a2 2 0 0 0-3.96-.4 1 1 0 1 1-1.96-.398A4 4 0 0 1 9.628.779M.293.296a1 1 0 0 1 1.414 0l15.788 15.788a.997.997 0 0 1 .374.374l5.838 5.838a1 1 0 0 1-1.414 1.414l-5.359-5.359A8 8 0 0 1 13 19.991v2.012h3a1 1 0 1 1 0 2H8a1 1 0 1 1 0-2h3v-2.012A7.997 7.997 0 0 1 4 12v-1.996a1 1 0 0 1 2 0v2.007a6 6 0 0 0 5.706 6.037 1 1 0 0 1 .588 0 6.003 6.003 0 0 0 3.212-1.124l-1.476-1.476a3.998 3.998 0 0 1-5.355-1.223A4 4 0 0 1 8 12.004V9.417L.293 1.71a1 1 0 0 1 0-1.414ZM10 11.417v.585a2 2 0 0 0 2.516 1.93L10 11.418Zm9-2.414a1 1 0 0 1 1 1v2c0 .471-.043.943-.126 1.407a1 1 0 0 1-1.968-.354A6 6 0 0 0 18 12.002v-1.999a1 1 0 0 1 1-1Z", fill: "currentColor" }) })));
});
IconMicOff.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconMicOff = (IconMicOff);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconMicOn.js



/**
 * Semantic vector graphics icon IconMicOn.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconMicOn size="large" color="green50" />
 */
const IconMicOn = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M9.172 1.172A4 4 0 0 1 16 4v8a4 4 0 1 1-8 0V4a4 4 0 0 1 1.172-2.828ZM12 2a2 2 0 0 0-2 2v8a2 2 0 0 0 4 0V4a2 2 0 0 0-2-2ZM5 9a1 1 0 0 1 1 1v2a6 6 0 1 0 12 0v-2a1 1 0 1 1 2 0v2a8 8 0 0 1-7 7.937V22h3a1 1 0 1 1 0 2H8a1 1 0 1 1 0-2h3v-2.063A8 8 0 0 1 4 12v-2a1 1 0 0 1 1-1Z", fill: "currentColor" }) })));
});
IconMicOn.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconMicOn = (IconMicOn);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconZapOff.js



/**
 * Semantic vector graphics icon IconZapOff.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconZapOff size="large" color="green50" />
 */
const IconZapOff = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M.293.293a1 1 0 0 1 1.414 0L8.7 7.286l.016.016 7.984 7.984.016.016 6.991 6.99a1 1 0 0 1-1.414 1.415l-6.226-6.226-4.299 5.16a1 1 0 0 1-1.76-.765l.86-6.876H3a1 1 0 0 1-.768-1.64L6.647 8.06.293 1.707a1 1 0 0 1 0-1.414ZM8.067 9.48 5.135 13h6.45L8.068 9.481Zm4.894 4.894-.546 4.364 2.232-2.678-1.686-1.686Zm.437-13.293a1 1 0 0 1 .594 1.041l-.59 4.75a1 1 0 0 1-1.984-.246l.17-1.366-.25.299a1 1 0 0 1-1.537-1.28l2.43-2.92a1 1 0 0 1 1.167-.278ZM14.66 10a1 1 0 0 1 1-1H21a1 1 0 0 1 .768 1.641l-2.43 2.91a1 1 0 0 1-1.536-1.282L18.862 11H15.66a1 1 0 0 1-1-1Z", fill: "currentColor" }) })));
});
IconZapOff.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconZapOff = (IconZapOff);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconZapOn.js



/**
 * Semantic vector graphics icon IconZapOn.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconZapOn size="large" color="green50" />
 */
const IconZapOn = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M13.398 1.083a1 1 0 0 1 .594 1.041L13.132 9H21a1 1 0 0 1 .768 1.64l-10 12a1 1 0 0 1-1.76-.764l.86-6.876H3a1 1 0 0 1-.768-1.64l10-12a1 1 0 0 1 1.166-.277ZM5.135 13H12a1 1 0 0 1 .992 1.124l-.577 4.615L18.865 11H12a1 1 0 0 1-.992-1.124l.577-4.616L5.135 13Z", fill: "currentColor" }) })));
});
IconZapOn.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconZapOn = (IconZapOn);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconUpload.js



/**
 * Semantic vector graphics icon IconUpload.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconUpload size="large" color="green50" />
 */
const IconUpload = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M11.293 2.293a1 1 0 0 1 1.414 0l5 5a1 1 0 0 1-1.414 1.414L13 5.414V15a1 1 0 1 1-2 0V5.414L7.707 8.707a1 1 0 0 1-1.414-1.414l5-5ZM3 14a1 1 0 0 1 1 1v4a1 1 0 0 0 1 1h14a1 1 0 0 0 1-1v-4a1 1 0 1 1 2 0v4a3 3 0 0 1-3 3H5a3 3 0 0 1-3-3v-4a1 1 0 0 1 1-1Z", fill: "currentColor" }) })));
});
IconUpload.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconUpload = (IconUpload);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconDownload.js



/**
 * Semantic vector graphics icon IconDownload.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconDownload size="large" color="green50" />
 */
const IconDownload = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M12 2a1 1 0 0 1 1 1v9.586l3.293-3.293a1 1 0 1 1 1.414 1.414l-5 5a1 1 0 0 1-1.414 0l-5-5a1 1 0 0 1 1.414-1.414L11 12.586V3a1 1 0 0 1 1-1ZM3 14a1 1 0 0 1 1 1v4a1 1 0 0 0 1 1h14a1 1 0 0 0 1-1v-4a1 1 0 1 1 2 0v4a3 3 0 0 1-3 3H5a3 3 0 0 1-3-3v-4a1 1 0 0 1 1-1Z", fill: "currentColor" }) })));
});
IconDownload.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconDownload = (IconDownload);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconUploadCloud.js



/**
 * Semantic vector graphics icon IconUploadCloud.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconUploadCloud size="large" color="green50" />
 */
const IconUploadCloud = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M8.669 2.009A9 9 0 0 1 17.484 8h.521a6.002 6.002 0 0 1 5.497 8.398 6 6 0 0 1-2.628 2.87 1 1 0 1 1-.957-1.756A4 4 0 0 0 18.005 10h-1.26a1 1 0 0 1-.968-.75 7 7 0 1 0-12.022 6.388 1 1 0 1 1-1.499 1.324A9 9 0 0 1 8.669 2.01Zm2.63 9.284a1 1 0 0 1 1.413 0l4 4a1 1 0 1 1-1.414 1.414l-2.293-2.293V21a1 1 0 1 1-2 0v-6.586l-2.293 2.293a1 1 0 0 1-1.414-1.414l4-4Z", fill: "currentColor" }) })));
});
IconUploadCloud.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconUploadCloud = (IconUploadCloud);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconDownloadCloud.js



/**
 * Semantic vector graphics icon IconDownloadCloud.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconDownloadCloud size="large" color="green50" />
 */
const IconDownloadCloud = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M8.677 1.994A9 9 0 0 1 17.489 8h.52a6.003 6.003 0 0 1 5.724 4.188 6 6 0 0 1-2.269 6.72 1 1 0 1 1-1.15-1.636A4 4 0 0 0 18.01 10h-1.261a1 1 0 0 1-.969-.751 6.999 6.999 0 0 0-13.668.491 7 7 0 0 0 1.646 5.887 1 1 0 0 1-1.498 1.326A9 9 0 0 1 8.677 1.994ZM12.009 11a1 1 0 0 1 1 1v6.586l2.293-2.293a1 1 0 0 1 1.414 1.414l-4 4a1 1 0 0 1-1.414 0l-4-4a1 1 0 1 1 1.414-1.414l2.293 2.293V12a1 1 0 0 1 1-1Z", fill: "currentColor" }) })));
});
IconDownloadCloud.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconDownloadCloud = (IconDownloadCloud);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconRotationRight.js



/**
 * Semantic vector graphics icon IconRotationRight.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconRotationRight size="large" color="green50" />
 */
const IconRotationRight = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M13.127 4.081a8 8 0 1 0 6.42 10.586 1 1 0 0 1 1.886.666 10 10 0 1 1-2.367-10.41L22 7.684V4a1 1 0 1 1 2 0v6a1 1 0 0 1-1 1h-6a1 1 0 1 1 0-2h3.48l-2.796-2.632a8 8 0 0 0-4.557-2.287Z", fill: "currentColor" }) })));
});
IconRotationRight.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconRotationRight = (IconRotationRight);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconRotationLeft.js



/**
 * Semantic vector graphics icon IconRotationLeft.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconRotationLeft size="large" color="green50" />
 */
const IconRotationLeft = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M10.605 2.107a10 10 0 1 1-8.038 13.225 1 1 0 0 1 1.886-.664 8 8 0 1 0 1.872-8.3L3.525 9H7a1 1 0 0 1 0 2H1a1 1 0 0 1-1-1V4a1 1 0 0 1 2 0v3.688l2.944-2.767a10 10 0 0 1 5.661-2.814Z", fill: "currentColor" }) })));
});
IconRotationLeft.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconRotationLeft = (IconRotationLeft);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconRightCircle.js



/**
 * Semantic vector graphics icon IconRightCircle.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconRightCircle size="large" color="green50" />
 */
const IconRightCircle = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M21 12a9 9 0 1 0-18 0 9 9 0 0 0 18 0ZM12 1c6.075 0 11 4.925 11 11s-4.925 11-11 11S1 18.075 1 12 5.925 1 12 1Zm-.707 7.707a1 1 0 0 1 1.414-1.414l4 4a1 1 0 0 1 0 1.414l-4 4a1 1 0 0 1-1.414-1.414L13.586 13H8a1 1 0 1 1 0-2h5.586l-2.293-2.293Z", fill: "currentColor" }) })));
});
IconRightCircle.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconRightCircle = (IconRightCircle);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconUpCircle.js



/**
 * Semantic vector graphics icon IconUpCircle.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconUpCircle size="large" color="green50" />
 */
const IconUpCircle = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M3 12a9 9 0 1 0 18 0 9 9 0 0 0-18 0Zm9 11C5.925 23 1 18.075 1 12S5.925 1 12 1s11 4.925 11 11-4.925 11-11 11Zm1-7a1 1 0 1 1-2 0v-5.586l-2.293 2.293a1 1 0 0 1-1.414-1.414l4-4a1 1 0 0 1 1.414 0l4 4a1 1 0 0 1-1.414 1.414L13 10.414V16Z", fill: "currentColor" }) })));
});
IconUpCircle.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconUpCircle = (IconUpCircle);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconDownCircle.js



/**
 * Semantic vector graphics icon IconDownCircle.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconDownCircle size="large" color="green50" />
 */
const IconDownCircle = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M3 12a9 9 0 1 1 18 0 9 9 0 0 1-18 0Zm9-11C5.925 1 1 5.925 1 12s4.925 11 11 11 11-4.925 11-11S18.075 1 12 1Zm1 7a1 1 0 1 0-2 0v5.586l-2.293-2.293a1 1 0 0 0-1.414 1.414l4 4a1 1 0 0 0 1.414 0l4-4a1 1 0 0 0-1.414-1.414L13 13.586V8Z", fill: "currentColor" }) })));
});
IconDownCircle.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconDownCircle = (IconDownCircle);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconLeftCircle.js



/**
 * Semantic vector graphics icon IconLeftCircle.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconLeftCircle size="large" color="green50" />
 */
const IconLeftCircle = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M3 12a9 9 0 1 1 18 0 9 9 0 0 1-18 0Zm9-11C5.925 1 1 5.925 1 12s4.925 11 11 11 11-4.925 11-11S18.075 1 12 1Zm.707 7.707a1 1 0 0 0-1.414-1.414l-4 4a1 1 0 0 0 0 1.414l4 4a1 1 0 0 0 1.414-1.414L10.414 13H16a1 1 0 1 0 0-2h-5.586l2.293-2.293Z", fill: "currentColor" }) })));
});
IconLeftCircle.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconLeftCircle = (IconLeftCircle);

// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconRight.js
var IconRight = __webpack_require__(8746);
;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconUpRight.js



/**
 * Semantic vector graphics icon IconUpRight.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconUpRight size="large" color="green50" />
 */
const IconUpRight = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M7.707 17.707a1 1 0 0 1-1.414-1.414L14.586 8H7a1 1 0 1 1 0-2h10.003a.997.997 0 0 1 .997.997V17a1 1 0 1 1-2 0V9.414l-8.293 8.293Z", fill: "currentColor" }) })));
});
IconUpRight.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconUpRight = (IconUpRight);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconUp.js



/**
 * Semantic vector graphics icon IconUp.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconUp size="large" color="green50" />
 */
const IconUp = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M11.293 4.293a1 1 0 0 1 1.414 0l7 7a1 1 0 0 1-1.414 1.414L13 7.414V19a1 1 0 1 1-2 0V7.414l-5.293 5.293a1 1 0 0 1-1.414-1.414l7-7Z", fill: "currentColor" }) })));
});
IconUp.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconUp = (IconUp);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconUpLeft.js



/**
 * Semantic vector graphics icon IconUpLeft.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconUpLeft size="large" color="green50" />
 */
const IconUpLeft = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M16.293 17.707a1 1 0 0 0 1.414-1.414L9.414 8H17a1 1 0 1 0 0-2H6.997A.997.997 0 0 0 6 6.997V17a1 1 0 1 0 2 0V9.414l8.293 8.293Z", fill: "currentColor" }) })));
});
IconUpLeft.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconUpLeft = (IconUpLeft);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconDownRight.js



/**
 * Semantic vector graphics icon IconDownRight.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconDownRight size="large" color="green50" />
 */
const IconDownRight = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M7.707 6.293a1 1 0 0 0-1.414 1.414L14.586 16H7a1 1 0 1 0 0 2h10.003a.996.996 0 0 0 .71-.3.997.997 0 0 0 .287-.697V7a1 1 0 1 0-2 0v7.586L7.707 6.293Z", fill: "currentColor" }) })));
});
IconDownRight.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconDownRight = (IconDownRight);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconDown.js



/**
 * Semantic vector graphics icon IconDown.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconDown size="large" color="green50" />
 */
const IconDown = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M12 4a1 1 0 0 1 1 1v11.586l5.293-5.293a1 1 0 0 1 1.414 1.414l-7 7a1 1 0 0 1-1.414 0l-7-7a1 1 0 1 1 1.414-1.414L11 16.586V5a1 1 0 0 1 1-1Z", fill: "currentColor" }) })));
});
IconDown.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconDown = (IconDown);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconDownLeft.js



/**
 * Semantic vector graphics icon IconDownLeft.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconDownLeft size="large" color="green50" />
 */
const IconDownLeft = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "m9.414 16 8.293-8.293a1 1 0 0 0-1.414-1.414L8 14.586V7a1 1 0 0 0-2 0v10a.997.997 0 0 0 .997 1H17a1 1 0 1 0 0-2H9.414Z", fill: "currentColor" }) })));
});
IconDownLeft.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconDownLeft = (IconDownLeft);

// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconLeft.js
var IconLeft = __webpack_require__(563);
;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconStar.js



/**
 * Semantic vector graphics icon IconStar.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconStar size="large" color="green50" />
 */
const IconStar = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M12 1a1 1 0 0 1 .897.557l2.857 5.79 6.39.934a1 1 0 0 1 .554 1.705l-4.623 4.503 1.09 6.362a1 1 0 0 1-1.45 1.054L12 18.9l-5.715 3.005a1 1 0 0 1-1.45-1.054l1.09-6.362-4.623-4.503a1 1 0 0 1 .553-1.705l6.39-.935 2.858-5.789A1 1 0 0 1 12 1Zm0 3.26L9.807 8.702a1 1 0 0 1-.752.546l-4.907.718 3.55 3.457a1 1 0 0 1 .288.885l-.838 4.883 4.386-2.307a1 1 0 0 1 .931 0l4.387 2.307-.838-4.883a1 1 0 0 1 .288-.885l3.55-3.457-4.907-.718a1 1 0 0 1-.752-.546L12 4.259Z", fill: "currentColor" }) })));
});
IconStar.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconStar = (IconStar);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconStarFilled.js



/**
 * Semantic vector graphics icon IconStarFilled.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconStarFilled size="large" color="green50" />
 */
const IconStarFilled = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { d: "M12 1a1 1 0 0 1 .897.557l2.857 5.79 6.39.934a1 1 0 0 1 .554 1.705l-4.623 4.503 1.09 6.362a1 1 0 0 1-1.45 1.054L12 18.9l-5.715 3.005a1 1 0 0 1-1.45-1.054l1.09-6.362-4.623-4.503a1 1 0 0 1 .553-1.705l6.39-.935 2.858-5.789A1 1 0 0 1 12 1Z", fill: "currentColor" }) })));
});
IconStarFilled.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconStarFilled = (IconStarFilled);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconHeart.js



/**
 * Semantic vector graphics icon IconHeart.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconHeart size="large" color="green50" />
 */
const IconHeart = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M14.462 2.493a6.5 6.5 0 0 1 8.495 8.495 6.498 6.498 0 0 1-1.41 2.11s0-.001 0 0l-8.84 8.84a1 1 0 0 1-1.414 0l-8.84-8.84a6.501 6.501 0 0 1 9.194-9.195l.353.353.353-.353a6.501 6.501 0 0 1 2.109-1.41Zm2.488 1.505a4.5 4.5 0 0 0-3.183 1.319l-1.06 1.06a1 1 0 0 1-1.414 0l-1.06-1.06a4.501 4.501 0 1 0-6.366 6.366L12 19.816l8.133-8.133a4.501 4.501 0 0 0-3.183-7.685Z", fill: "currentColor" }) })));
});
IconHeart.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconHeart = (IconHeart);

// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconDelete.js
var IconDelete = __webpack_require__(1246);
;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconDeleteBlank.js



/**
 * Semantic vector graphics icon IconDeleteBlank.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconDeleteBlank size="large" color="green50" />
 */
const IconDeleteBlank = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M9.293 3.293A1 1 0 0 1 10 3h4a1 1 0 0 1 1 1v1H9V4a1 1 0 0 1 .293-.707ZM7 5V4a3 3 0 0 1 3-3h4a3 3 0 0 1 3 3v1h4a1 1 0 1 1 0 2h-1v13a3 3 0 0 1-3 3H7a3 3 0 0 1-3-3V7H3a1 1 0 0 1 0-2h4ZM6 7v13a1 1 0 0 0 1 1h10a1 1 0 0 0 1-1V7H6Z", fill: "currentColor" }) })));
});
IconDeleteBlank.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconDeleteBlank = (IconDeleteBlank);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconSliders.js



/**
 * Semantic vector graphics icon IconSliders.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconSliders size="large" color="green50" />
 */
const IconSliders = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M4 2a1 1 0 0 1 1 1v7a1 1 0 1 1-2 0V3a1 1 0 0 1 1-1Zm1 13h2a1 1 0 1 0 0-2H1a1 1 0 1 0 0 2h2v6a1 1 0 1 0 2 0v-6Zm8-3a1 1 0 1 0-2 0v9a1 1 0 1 0 2 0v-9ZM12 2a1 1 0 0 1 1 1v4h2a1 1 0 1 1 0 2H9a1 1 0 1 1 0-2h2V3a1 1 0 0 1 1-1Zm8 13h3a1 1 0 1 1 0 2h-2v4a1 1 0 1 1-2 0v-4h-2a1 1 0 1 1 0-2h3Zm0-13a1 1 0 0 1 1 1v9a1 1 0 1 1-2 0V3a1 1 0 0 1 1-1Z", fill: "currentColor" }) })));
});
IconSliders.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconSliders = (IconSliders);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconSettings.js



/**
 * Semantic vector graphics icon IconSettings.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconSettings size="large" color="green50" />
 */
const IconSettings = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M11.293 2.293A1 1 0 0 1 13 3v.094a2.65 2.65 0 0 0 1.601 2.423 2.65 2.65 0 0 0 2.918-.532l.008-.008.06-.06a1 1 0 0 1 1.416 0 .999.999 0 0 1 0 1.415l-.06.06-.008.009a2.65 2.65 0 0 0-.607 2.729c.012.09.037.18.073.264A2.65 2.65 0 0 0 20.826 11H21a1 1 0 0 1 0 2h-.094a2.65 2.65 0 0 0-2.423 1.601 2.65 2.65 0 0 0 .532 2.918l.008.008.06.06a1 1 0 0 1 0 1.416 1 1 0 0 1-1.415 0l-.06-.06-.009-.008a2.651 2.651 0 0 0-2.918-.532 2.65 2.65 0 0 0-1.601 2.423V21a1 1 0 0 1-2 0V20.887a2.65 2.65 0 0 0-1.705-2.415 2.651 2.651 0 0 0-2.894.543l-.008.008-.06.06a.999.999 0 0 1-1.416 0 1 1 0 0 1 0-1.415l.06-.06.008-.009a2.65 2.65 0 0 0 .532-2.918 2.65 2.65 0 0 0-2.423-1.601H3a1 1 0 0 1 0-2H3.113a2.65 2.65 0 0 0 2.414-1.705 2.65 2.65 0 0 0-.542-2.894l-.008-.008-.06-.06a1 1 0 0 1 0-1.416 1 1 0 0 1 1.415 0l.06.06.009.008a2.65 2.65 0 0 0 2.729.607 1 1 0 0 0 .264-.073A2.65 2.65 0 0 0 11 3.174V3a1 1 0 0 1 .293-.707Zm9.022 13.11L19.4 15l.92.394a.65.65 0 0 1 .593-.394H21a3 3 0 0 0 0-6h-.168a.65.65 0 0 1-.533-.285 1.006 1.006 0 0 0-.064-.199.65.65 0 0 1 .127-.714l.055-.054a2.999 2.999 0 0 0-.973-4.896 3 3 0 0 0-3.271.651l-.055.055a.65.65 0 0 1-.714.127l-.01-.004A.65.65 0 0 1 15 3.087V3a3 3 0 0 0-6 0v.167a.65.65 0 0 1-.285.534 1 1 0 0 0-.199.064.65.65 0 0 1-.714-.127l-.054-.055a3 3 0 1 0-4.245 4.244l.055.055a.65.65 0 0 1 .127.714l-.024.059a.65.65 0 0 1-.585.425H3a3 3 0 1 0 0 6h.167a.65.65 0 0 1 .594.394l.004.01a.65.65 0 0 1-.127.714l-.055.055a3 3 0 0 0 3.27 4.895 3 3 0 0 0 .974-.65v-.001l.055-.055a.65.65 0 0 1 .714-.127l.059.023a.651.651 0 0 1 .425.586V21a3 3 0 1 0 6 0v-.168a.65.65 0 0 1 .394-.593l.01-.004a.65.65 0 0 1 .714.127l.055.055a2.999 2.999 0 0 0 4.244 0l-.707-.707.707.707a2.999 2.999 0 0 0 0-4.244l-.055-.055a.65.65 0 0 1-.127-.714ZM10 12a2 2 0 1 1 4 0 2 2 0 0 1-4 0Zm2-4a4 4 0 1 0 0 8 4 4 0 0 0 0-8Z", fill: "currentColor" }) })));
});
IconSettings.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconSettings = (IconSettings);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconSend.js



/**
 * Semantic vector graphics icon IconSend.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconSend size="large" color="green50" />
 */
const IconSend = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M22.707 1.293a.998.998 0 0 1 .23 1.058l-6.993 19.98a1 1 0 0 1-1.858.075l-3.844-8.648-8.648-3.844a1 1 0 0 1 .076-1.858l19.979-6.993a1 1 0 0 1 1.058.23ZM18.194 4.39 4.711 9.111l6.067 2.696 7.416-7.416Zm-6.001 8.83 7.415-7.415-4.719 13.483-2.696-6.068Z", fill: "currentColor" }) })));
});
IconSend.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconSend = (IconSend);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconSearch.js



/**
 * Semantic vector graphics icon IconSearch.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconSearch size="large" color="green50" />
 */
const IconSearch = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M4 11a7 7 0 1 1 12.042 4.856 1.005 1.005 0 0 0-.186.186A7 7 0 0 1 4 11Zm12.618 7.032a9 9 0 1 1 1.414-1.414l3.675 3.675a1 1 0 0 1-1.414 1.414l-3.675-3.675Z", fill: "currentColor" }) })));
});
IconSearch.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconSearch = (IconSearch);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconShare.js



/**
 * Semantic vector graphics icon IconShare.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconShare size="large" color="green50" />
 */
const IconShare = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M18 3a2 2 0 1 0 0 4 2 2 0 0 0 0-4Zm-2.842 4.815a4 4 0 1 0-1.008-1.727L8.842 9.185a4 4 0 1 0 0 5.63l5.309 3.093a4 4 0 1 0 1.01-1.726l-5.31-3.095a4.003 4.003 0 0 0 0-2.175l5.307-3.097Zm-7.46 3.129a1.008 1.008 0 0 0 .059.099c.155.284.243.61.243.957a1.99 1.99 0 0 1-.301 1.056 2 2 0 1 1 0-2.112ZM16 19c0-.325.078-.633.216-.904a1.017 1.017 0 0 0 .121-.208A2 2 0 1 1 16 19Z", fill: "currentColor" }) })));
});
IconShare.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconShare = (IconShare);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconMoreVertical.js



/**
 * Semantic vector graphics icon IconMoreVertical.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconMoreVertical size="large" color="green50" />
 */
const IconMoreVertical = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M10 5a2 2 0 1 1 4 0 2 2 0 0 1-4 0Zm0 7a2 2 0 1 1 4 0 2 2 0 0 1-4 0Zm2 5a2 2 0 1 0 0 4 2 2 0 0 0 0-4Z", fill: "currentColor" }) })));
});
IconMoreVertical.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconMoreVertical = (IconMoreVertical);

// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconMoreHorizontal.js
var IconMoreHorizontal = __webpack_require__(1364);
// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconMenu.js
var IconMenu = __webpack_require__(4557);
;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconDroplet.js



/**
 * Semantic vector graphics icon IconDroplet.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconDroplet size="large" color="green50" />
 */
const IconDroplet = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M12 1.69a1 1 0 0 1 .707.293l5.66 5.66a9 9 0 1 1-12.724 0l5.65-5.66A1 1 0 0 1 12 1.69Zm0 2.415L7.058 9.057a7 7 0 1 0 9.896 0l-4.952-4.952Z", fill: "currentColor" }) })));
});
IconDroplet.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconDroplet = (IconDroplet);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconBackspace.js



/**
 * Semantic vector graphics icon IconBackspace.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconBackspace size="large" color="green50" />
 */
const IconBackspace = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M7.247 3.341A1 1 0 0 1 8 3h13a3 3 0 0 1 3 3v12a3 3 0 0 1-3 3H8a1 1 0 0 1-.753-.341l-7-8a1 1 0 0 1 0-1.318l7-8ZM8.454 5l-6.125 7 6.125 7H21a1 1 0 0 0 1-1V6a1 1 0 0 0-1-1H8.454Zm10.253 3.293a1 1 0 0 1 0 1.414L16.414 12l2.293 2.293a1 1 0 0 1-1.414 1.414L15 13.414l-2.293 2.293a1 1 0 0 1-1.414-1.414L13.586 12l-2.293-2.293a1 1 0 0 1 1.414-1.414L15 10.586l2.293-2.293a1 1 0 0 1 1.414 0Z", fill: "currentColor" }) })));
});
IconBackspace.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconBackspace = (IconBackspace);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconFilter.js



/**
 * Semantic vector graphics icon IconFilter.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconFilter size="large" color="green50" />
 */
const IconFilter = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M1.093 2.58A1 1 0 0 1 2 2h20a1 1 0 0 1 .764 1.646L15 12.826V21a1 1 0 0 1-1.447.894l-4-2A1 1 0 0 1 9 19v-6.174l-7.764-9.18a1 1 0 0 1-.143-1.067ZM4.155 4l6.609 7.814a1 1 0 0 1 .236.646v5.922l2 1V12.46a1 1 0 0 1 .236-.646L19.845 4H4.155Z", fill: "currentColor" }) })));
});
IconFilter.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconFilter = (IconFilter);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconCrop.js



/**
 * Semantic vector graphics icon IconCrop.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconCrop size="large" color="green50" />
 */
const IconCrop = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M7.13 1.009a1 1 0 1 0-2-.018l-.036 4.103-4.103.036a1 1 0 1 0 .018 2l4.068-.035L5 15.99V16a3 3 0 0 0 3 3h9v4a1 1 0 1 0 2 0v-4h4a1 1 0 1 0 0-2h-4V8a3 3 0 0 0-3-3h-.009l-8.896.077.035-4.068Zm-.053 6.068L7 16.004A1 1 0 0 0 8 17h9V8a1 1 0 0 0-.996-1l-8.927.077Z", fill: "currentColor" }) })));
});
IconCrop.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconCrop = (IconCrop);

// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconClock.js
var IconClock = __webpack_require__(1747);
;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconCalendar.js



/**
 * Semantic vector graphics icon IconCalendar.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconCalendar size="large" color="green50" />
 */
const IconCalendar = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M17 2a1 1 0 1 0-2 0v1H9V2a1 1 0 0 0-2 0v1H5a3 3 0 0 0-3 3v14a3 3 0 0 0 3 3h14a3 3 0 0 0 3-3V6a3 3 0 0 0-3-3h-2V2Zm3 7V6a1 1 0 0 0-1-1h-2v1a1 1 0 1 1-2 0V5H9v1a1 1 0 0 1-2 0V5H5a1 1 0 0 0-1 1v3h16ZM4 11h16v9a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1v-9Z", fill: "currentColor" }) })));
});
IconCalendar.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconCalendar = (IconCalendar);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconLinkedin.js



/**
 * Semantic vector graphics icon IconLinkedin.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconLinkedin size="large" color="green50" />
 */
const IconLinkedin = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { d: "M22.224 0C23.203 0 24 .775 24 1.73v20.538c0 .956-.797 1.732-1.776 1.732H1.77C.794 24 0 23.224 0 22.268V1.73C0 .775.794 0 1.771 0h20.453ZM16.18 8.713c-1.732 0-2.893.949-3.368 1.85h-.048V8.997H9.351V20.45h3.557v-5.666c0-1.494.283-2.941 2.136-2.941 1.825 0 1.85 1.708 1.85 3.037v5.57h3.557v-6.283c0-3.083-.666-5.455-4.27-5.455Zm-9.063.285h-3.56V20.45h3.56V8.998Zm-1.78-5.694a2.064 2.064 0 1 0 0 4.128 2.064 2.064 0 0 0 0-4.128Z", fill: "currentColor" }) })));
});
IconLinkedin.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconLinkedin = (IconLinkedin);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconTwitter.js



/**
 * Semantic vector graphics icon IconTwitter.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconTwitter size="large" color="green50" />
 */
const IconTwitter = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { d: "M21.557 7.891c0 6.509-4.953 14.012-14.009 14.012-2.782 0-5.368-.816-7.548-2.214a10 10 0 0 0 1.174.07c2.309 0 4.43-.788 6.115-2.107a4.929 4.929 0 0 1-4.6-3.419 5.031 5.031 0 0 0 2.224-.085 4.929 4.929 0 0 1-3.95-4.83v-.061c.665.37 1.425.59 2.231.617a4.924 4.924 0 0 1-1.523-6.575A13.977 13.977 0 0 0 11.82 8.444a4.972 4.972 0 0 1-.127-1.123A4.921 4.921 0 0 1 16.617 2.4c1.417 0 2.696.596 3.595 1.554a9.916 9.916 0 0 0 3.126-1.195 4.942 4.942 0 0 1-2.165 2.723A9.849 9.849 0 0 0 24 4.707a9.944 9.944 0 0 1-2.457 2.548c.01.211.014.425.014.636Z", fill: "currentColor" }) })));
});
IconTwitter.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconTwitter = (IconTwitter);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconSlack.js



/**
 * Semantic vector graphics icon IconSlack.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconSlack size="large" color="green50" />
 */
const IconSlack = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M6.41 2.4A2.397 2.397 0 0 1 8.804 0a2.4 2.4 0 0 1 2.397 2.4V4.8H8.805a2.398 2.398 0 0 1-2.395-2.4Zm-3.992 4h6.386A2.398 2.398 0 0 1 11.2 8.8a2.398 2.398 0 0 1-2.396 2.4H2.417A2.398 2.398 0 0 1 .022 8.8a2.398 2.398 0 0 1 2.396-2.4Zm19.161 0a2.398 2.398 0 0 1 2.396 2.4 2.398 2.398 0 0 1-2.396 2.4h-2.396V8.8a2.398 2.398 0 0 1 2.396-2.4Zm-3.992-4v6.4c.001 1.324-1.071 2.399-2.395 2.4a2.398 2.398 0 0 1-2.395-2.4V2.4A2.398 2.398 0 0 1 15.193 0a2.398 2.398 0 0 1 2.394 2.4ZM15.192 24a2.398 2.398 0 0 0 2.395-2.4 2.398 2.398 0 0 0-2.395-2.399h-2.396v2.4A2.399 2.399 0 0 0 15.192 24Zm0-6.401h6.387a2.398 2.398 0 0 0 2.395-2.4 2.398 2.398 0 0 0-2.394-2.4h-6.387a2.398 2.398 0 0 0-2.396 2.4 2.397 2.397 0 0 0 2.395 2.4Zm-12.774 0a2.398 2.398 0 0 1-2.396-2.4 2.398 2.398 0 0 1 2.396-2.4h2.396v2.4a2.398 2.398 0 0 1-2.396 2.4Zm3.992 4v-6.4a2.396 2.396 0 1 1 4.79.002v6.4A2.398 2.398 0 0 1 8.804 24a2.398 2.398 0 0 1-2.394-2.4Z", fill: "currentColor" }) })));
});
IconSlack.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconSlack = (IconSlack);

// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconWindows.js
var IconWindows = __webpack_require__(8404);
;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconUnlink.js



/**
 * Semantic vector graphics icon IconUnlink.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconUnlink size="large" color="green50" />
 */
const IconUnlink = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M7 8a4 4 0 0 0 0 8h2a1 1 0 1 1 0 2H7A6 6 0 1 1 7 6h2a1 1 0 0 1 0 2H7Zm7-1a1 1 0 0 1 1-1h2a6 6 0 1 1 0 12h-2a1 1 0 1 1 0-2h2a4 4 0 1 0 0-8h-2a1 1 0 0 1-1-1Z", fill: "currentColor" }) })));
});
IconUnlink.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconUnlink = (IconUnlink);

// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconImage.js
var IconImage = __webpack_require__(9339);
// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconList.js
var IconList = __webpack_require__(591);
;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconAttachment.js



/**
 * Semantic vector graphics icon IconAttachment.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconAttachment size="large" color="green50" />
 */
const IconAttachment = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M15.78 2.388c-.796 0-1.56.316-2.123.88l-9.19 9.19a5.003 5.003 0 1 0 7.076 7.075l9.19-9.19a1 1 0 0 1 1.414 1.414l-9.19 9.19a7.003 7.003 0 0 1-9.904-9.904l9.19-9.19a5.002 5.002 0 0 1 7.074 7.074l-9.2 9.19a3.001 3.001 0 0 1-4.244-4.244l8.49-8.48a1 1 0 1 1 1.414 1.415l-8.49 8.48a1.003 1.003 0 0 0 .708 1.708c.266 0 .52-.105.708-.293l9.2-9.19a3.004 3.004 0 0 0-2.123-5.125Z", fill: "currentColor" }) })));
});
IconAttachment.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconAttachment = (IconAttachment);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconLink2.js



/**
 * Semantic vector graphics icon IconLink2.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconLink2 size="large" color="green50" />
 */
const IconLink2 = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M16.996 1.067a6 6 0 0 0-4.22 1.684l-.011.01-1.72 1.71a1 1 0 0 0 1.41 1.418l1.715-1.704a4 4 0 0 1 5.656 5.654l-2.993 2.994a4 4 0 0 1-6.032-.432 1 1 0 0 0-1.602 1.198 6 6 0 0 0 9.048.648l3-3 .012-.012a6 6 0 0 0-4.263-10.168ZM10.425 8.01a6 6 0 0 0-4.672 1.743l-3 3-.012.012a6 6 0 0 0 8.484 8.484l.012-.012 1.71-1.71a1 1 0 0 0-1.414-1.414L9.83 19.816a4 4 0 0 1-5.656-5.655l2.993-2.994a4 4 0 0 1 6.032.432 1 1 0 0 0 1.602-1.198 6.001 6.001 0 0 0-4.376-2.39Z", fill: "currentColor" }) })));
});
IconLink2.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconLink2 = (IconLink2);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconScissorsTool.js



/**
 * Semantic vector graphics icon IconScissorsTool.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconScissorsTool size="large" color="green50" />
 */
const IconScissorsTool = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M6 4a2 2 0 1 0 0 4 2 2 0 0 0 0-4Zm3.446 4.032a4 4 0 1 0-1.414 1.414L10.586 12l-2.554 2.554a4 4 0 1 0 1.414 1.414l3.261-3.26 8-8a1 1 0 0 0-1.414-1.415L12 10.586 9.446 8.032ZM6 16a2 2 0 1 0 0 4 2 2 0 0 0 0-4Zm7.762-2.226a1 1 0 0 1 1.414-.002l5.53 5.52a1 1 0 0 1-1.413 1.416l-5.53-5.52a1 1 0 0 1-.001-1.415Z", fill: "currentColor" }) })));
});
IconScissorsTool.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconScissorsTool = (IconScissorsTool);

// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconLink.js
var IconLink = __webpack_require__(6632);
;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconPenTool.js



/**
 * Semantic vector graphics icon IconPenTool.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconPenTool size="large" color="green50" />
 */
const IconPenTool = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M2.077 1.003c.06.005.118.014.175.03l14.483 3.495a1 1 0 0 1 .746.776l1.153 5.765a1 1 0 0 1 1.073.224l3 3a1 1 0 0 1 0 1.414l-7 7a1 1 0 0 1-1.414 0l-3-3a1 1 0 0 1-.224-1.073L5.304 17.48a1 1 0 0 1-.776-.746L1.032 2.252a1.003 1.003 0 0 1 .26-.96.996.996 0 0 1 .785-.289Zm6.215 8.704L3.806 5.22l2.516 10.425 6.35 1.27 4.242-4.244-1.27-6.349L5.22 3.806l4.487 4.486a3 3 0 1 1-1.414 1.414Zm1.989.598a1 1 0 1 0 .025-.025l-.013.013-.012.012Zm8.427 3.401v.001l-5 5-.002.002-.292.291L15 20.586 20.586 15 19 13.414l-.292.292Z", fill: "currentColor" }) })));
});
IconPenTool.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconPenTool = (IconPenTool);

// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconEditForm.js
var IconEditForm = __webpack_require__(7760);
;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconZoomOut.js



/**
 * Semantic vector graphics icon IconZoomOut.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconZoomOut size="large" color="green50" />
 */
const IconZoomOut = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M11 4a7 7 0 1 0 4.858 12.04 1.007 1.007 0 0 1 .182-.182A7 7 0 0 0 11 4Zm0 16a8.962 8.962 0 0 0 5.618-1.968l3.675 3.675a1 1 0 1 0 1.415-1.414l-3.676-3.675A9 9 0 1 0 11 20ZM8 10a1 1 0 1 0 0 2h6a1 1 0 1 0 0-2H8Z", fill: "currentColor" }) })));
});
IconZoomOut.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconZoomOut = (IconZoomOut);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconZoomIn.js



/**
 * Semantic vector graphics icon IconZoomIn.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconZoomIn size="large" color="green50" />
 */
const IconZoomIn = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M4 11a7 7 0 1 1 12.04 4.858.993.993 0 0 0-.182.182A7 7 0 0 1 4 11Zm12.618 7.032a9 9 0 1 1 1.414-1.414l3.675 3.675a1 1 0 0 1-1.414 1.414l-3.675-3.675ZM11 7a1 1 0 0 1 1 1v2h2a1 1 0 1 1 0 2h-2v2a1 1 0 1 1-2 0v-2H8a1 1 0 1 1 0-2h2V8a1 1 0 0 1 1-1Z", fill: "currentColor" }) })));
});
IconZoomIn.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconZoomIn = (IconZoomIn);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconSave.js



/**
 * Semantic vector graphics icon IconSave.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconSave size="large" color="green50" />
 */
const IconSave = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M5 4a1 1 0 0 0-1 1v14a1 1 0 0 0 1 1h1v-7a1 1 0 0 1 1-1h10a1 1 0 0 1 1 1v7h1a1 1 0 0 0 1-1V8.414L15.586 4H8v3h7a1 1 0 1 1 0 2H7a1 1 0 0 1-1-1V4H5Zm2-2H5a3 3 0 0 0-3 3v14a3 3 0 0 0 3 3h14a3 3 0 0 0 3-3V8a1 1 0 0 0-.293-.707l-5-5A1 1 0 0 0 16 2H7Zm1 12v6h8v-6H8Z", fill: "currentColor" }) })));
});
IconSave.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconSave = (IconSave);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconCopy.js



/**
 * Semantic vector graphics icon IconCopy.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconCopy size="large" color="green50" />
 */
const IconCopy = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M3.293 3.293A1 1 0 0 1 4 3h9a1 1 0 0 1 1 1v1a1 1 0 1 0 2 0V4a3 3 0 0 0-3-3H4a3 3 0 0 0-3 3v9a3 3 0 0 0 3 3h1a1 1 0 1 0 0-2H4a1 1 0 0 1-1-1V4a1 1 0 0 1 .293-.707ZM10 11a1 1 0 0 1 1-1h9a1 1 0 0 1 1 1v9a1 1 0 0 1-1 1h-9a1 1 0 0 1-1-1v-9Zm1-3a3 3 0 0 0-3 3v9a3 3 0 0 0 3 3h9a3 3 0 0 0 3-3v-9a3 3 0 0 0-3-3h-9Z", fill: "currentColor" }) })));
});
IconCopy.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconCopy = (IconCopy);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconHighlight.js



/**
 * Semantic vector graphics icon IconHighlight.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconHighlight size="large" color="green50" />
 */
const IconHighlight = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M17.207 4.207a1.121 1.121 0 0 1 1.586 1.586L6.489 18.097l-2.115.529.529-2.115L17.207 4.207ZM18 1.88c-.828 0-1.622.329-2.207.914l-12.5 12.5a1 1 0 0 0-.263.464l-1 4a1 1 0 0 0 1.213 1.213l4-1a1 1 0 0 0 .464-.263l12.5-12.5a3.12 3.12 0 0 0-1.012-5.09A3.121 3.121 0 0 0 18 1.878ZM12 19a1 1 0 1 0 0 2h9a1 1 0 1 0 0-2h-9Z", fill: "currentColor" }) })));
});
IconHighlight.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconHighlight = (IconHighlight);

// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconEdit.js
var IconEdit = __webpack_require__(6108);
// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconFontType.js
var IconFontType = __webpack_require__(6370);
;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconFontUnderline.js



/**
 * Semantic vector graphics icon IconFontUnderline.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconFontUnderline size="large" color="green50" />
 */
const IconFontUnderline = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M7 3a1 1 0 0 0-2 0v7a7 7 0 1 0 14 0V3a1 1 0 1 0-2 0v7a5 5 0 1 1-10 0V3ZM4 20a1 1 0 1 0 0 2h16a1 1 0 1 0 0-2H4Z", fill: "currentColor" }) })));
});
IconFontUnderline.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconFontUnderline = (IconFontUnderline);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconFontItalic.js



/**
 * Semantic vector graphics icon IconFontItalic.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconFontItalic size="large" color="green50" />
 */
const IconFontItalic = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M15.023 3H19a1 1 0 1 1 0 2h-3.307l-5.25 14H14a1 1 0 1 1 0 2H5a1 1 0 1 1 0-2h3.307l5.25-14H10a1 1 0 0 1 0-2H15.023Z", fill: "currentColor" }) })));
});
IconFontItalic.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconFontItalic = (IconFontItalic);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconFontBold.js



/**
 * Semantic vector graphics icon IconFontBold.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconFontBold size="large" color="green50" />
 */
const IconFontBold = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M6 3a1 1 0 0 0-1 1v16a1 1 0 0 0 1 1h9a5 5 0 0 0 2.435-9.367A5 5 0 0 0 14 3H6Zm8 8a3 3 0 0 0 0-6H7v6h7Zm-7 2v6h8a3 3 0 0 0 0-6H7Z", fill: "currentColor" }) })));
});
IconFontBold.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconFontBold = (IconFontBold);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconAlignJustify.js



/**
 * Semantic vector graphics icon IconAlignJustify.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconAlignJustify size="large" color="green50" />
 */
const IconAlignJustify = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M3 5a1 1 0 0 0 0 2h18a1 1 0 1 0 0-2H3Zm0 4a1 1 0 0 0 0 2h18a1 1 0 1 0 0-2H3Zm-1 5a1 1 0 0 1 1-1h18a1 1 0 1 1 0 2H3a1 1 0 0 1-1-1Zm1 3a1 1 0 1 0 0 2h18a1 1 0 1 0 0-2H3Z", fill: "currentColor" }) })));
});
IconAlignJustify.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconAlignJustify = (IconAlignJustify);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconAlignRight.js



/**
 * Semantic vector graphics icon IconAlignRight.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconAlignRight size="large" color="green50" />
 */
const IconAlignRight = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M3 5a1 1 0 0 0 0 2h18a1 1 0 1 0 0-2H3Zm4 4a1 1 0 0 0 0 2h14a1 1 0 1 0 0-2H7Zm-5 5a1 1 0 0 1 1-1h18a1 1 0 1 1 0 2H3a1 1 0 0 1-1-1Zm5 3a1 1 0 1 0 0 2h14a1 1 0 1 0 0-2H7Z", fill: "currentColor" }) })));
});
IconAlignRight.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconAlignRight = (IconAlignRight);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconAlignCenter.js



/**
 * Semantic vector graphics icon IconAlignCenter.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconAlignCenter size="large" color="green50" />
 */
const IconAlignCenter = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M3 5a1 1 0 0 0 0 2h18a1 1 0 1 0 0-2H3Zm3 4a1 1 0 0 0 0 2h12a1 1 0 1 0 0-2H6Zm-4 5a1 1 0 0 1 1-1h18a1 1 0 1 1 0 2H3a1 1 0 0 1-1-1Zm4 3a1 1 0 1 0 0 2h12a1 1 0 1 0 0-2H6Z", fill: "currentColor" }) })));
});
IconAlignCenter.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconAlignCenter = (IconAlignCenter);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconAlignLeft.js



/**
 * Semantic vector graphics icon IconAlignLeft.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconAlignLeft size="large" color="green50" />
 */
const IconAlignLeft = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M3 5a1 1 0 0 0 0 2h18a1 1 0 1 0 0-2H3Zm0 4a1 1 0 0 0 0 2h14a1 1 0 1 0 0-2H3Zm-1 5a1 1 0 0 1 1-1h18a1 1 0 1 1 0 2H3a1 1 0 0 1-1-1Zm1 3a1 1 0 1 0 0 2h14a1 1 0 1 0 0-2H3Z", fill: "currentColor" }) })));
});
IconAlignLeft.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconAlignLeft = (IconAlignLeft);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconVideo.js



/**
 * Semantic vector graphics icon IconVideo.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconVideo size="large" color="green50" />
 */
const IconVideo = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M17 10.057V7a3 3 0 0 0-3-3H3a3 3 0 0 0-3 3v10a3 3 0 0 0 3 3h11a3 3 0 0 0 3-3v-3.057l5.419 3.87A1 1 0 0 0 24 17V7a1 1 0 0 0-1.581-.814L17 10.056ZM2 7a1 1 0 0 1 1-1h11a1 1 0 0 1 1 1v10a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V7Zm20 8.057L17.72 12 22 8.943v6.114Z", fill: "currentColor" }) })));
});
IconVideo.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconVideo = (IconVideo);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconExternalLink.js



/**
 * Semantic vector graphics icon IconExternalLink.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconExternalLink size="large" color="green50" />
 */
const IconExternalLink = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M15 4a1 1 0 1 1 0-2h6a1 1 0 0 1 1 1v6a1 1 0 1 1-2 0V5.414l-9.293 9.293a1 1 0 0 1-1.414-1.414L18.586 4H15ZM5 7a1 1 0 0 0-1 1v11a1 1 0 0 0 1 1h11a1 1 0 0 0 1-1v-6a1 1 0 1 1 2 0v6a3 3 0 0 1-3 3H5a3 3 0 0 1-3-3V8a3 3 0 0 1 3-3h6a1 1 0 1 1 0 2H5Z", fill: "currentColor" }) })));
});
IconExternalLink.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconExternalLink = (IconExternalLink);

// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconLoader.js
var IconLoader = __webpack_require__(8530);
;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconTarget.js



/**
 * Semantic vector graphics icon IconTarget.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconTarget size="large" color="green50" />
 */
const IconTarget = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M12 3a9 9 0 1 0 0 18 9 9 0 0 0 0-18ZM1 12C1 5.925 5.925 1 12 1s11 4.925 11 11-4.925 11-11 11S1 18.075 1 12Zm11-5a5 5 0 1 0 0 10 5 5 0 0 0 0-10Zm-7 5a7 7 0 1 1 14 0 7 7 0 0 1-14 0Zm6 0a1 1 0 1 1 2 0 1 1 0 0 1-2 0Zm1-3a3 3 0 1 0 0 6 3 3 0 0 0 0-6Z", fill: "currentColor" }) })));
});
IconTarget.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconTarget = (IconTarget);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconPercent.js



/**
 * Semantic vector graphics icon IconPercent.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconPercent size="large" color="green50" />
 */
const IconPercent = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M6.5 5a1.5 1.5 0 1 0 0 3 1.5 1.5 0 0 0 0-3ZM3 6.5a3.5 3.5 0 1 1 7 0 3.5 3.5 0 0 1-7 0Zm16.707-.793-14 14a1 1 0 0 1-1.414-1.414l14-14a1 1 0 1 1 1.414 1.414ZM16 17.5a1.5 1.5 0 1 1 3 0 1.5 1.5 0 0 1-3 0Zm1.5-3.5a3.5 3.5 0 1 0 0 7 3.5 3.5 0 0 0 0-7Z", fill: "currentColor" }) })));
});
IconPercent.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconPercent = (IconPercent);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconCreditCard.js



/**
 * Semantic vector graphics icon IconCreditCard.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconCreditCard size="large" color="green50" />
 */
const IconCreditCard = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M2 6a1 1 0 0 1 1-1h18a1 1 0 0 1 1 1v3H2V6Zm-2 4V6a3 3 0 0 1 3-3h18a3 3 0 0 1 3 3v12a3 3 0 0 1-3 3H3a3 3 0 0 1-3-3v-8Zm22 1v7a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1v-7h20Z", fill: "currentColor" }) })));
});
IconCreditCard.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconCreditCard = (IconCreditCard);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconBox.js



/**
 * Semantic vector graphics icon IconBox.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconBox size="large" color="green50" />
 */
const IconBox = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M10.502 1.403a3 3 0 0 1 2.996 0l.002.001 6.996 3.998.004.002a3 3 0 0 1 .937.848 1 1 0 0 1 .249.414A3 3 0 0 1 22 7.999V16.001a3 3 0 0 1-1.5 2.595l-.004.002-6.996 3.998-.002.001a3.002 3.002 0 0 1-1.023.363.995.995 0 0 1-.95 0 2.999 2.999 0 0 1-1.023-.363H10.5l-6.996-3.999-.004-.002A3 3 0 0 1 2 16.001V8a3 3 0 0 1 .314-1.333 1.003 1.003 0 0 1 .249-.414 3 3 0 0 1 .937-.848l.004-.002 6.998-4ZM13 20.578l6.5-3.714h.002a1.001 1.001 0 0 0 .498-.865V8.538l-7 4.049v7.991Zm-2-7.991v7.991l-6.5-3.714h-.002A1 1 0 0 1 4 15.998V8.538l7 4.049Zm1.504-9.449 6.457 3.69L12 10.855 5.039 6.828l6.457-3.69.004-.002a1 1 0 0 1 1 0l.004.002Z", fill: "currentColor" }) })));
});
IconBox.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconBox = (IconBox);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconBriefcase.js



/**
 * Semantic vector graphics icon IconBriefcase.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconBriefcase size="large" color="green50" />
 */
const IconBriefcase = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M10 2a3 3 0 0 0-3 3v1H4a3 3 0 0 0-3 3v10a3 3 0 0 0 3 3h16a3 3 0 0 0 3-3V9a3 3 0 0 0-3-3h-3V5a3 3 0 0 0-3-3h-4Zm5 4V5a1 1 0 0 0-1-1h-4a1 1 0 0 0-1 1v1h6ZM9 8h6v12H9V8ZM7 8H4a1 1 0 0 0-1 1v10a1 1 0 0 0 1 1h3V8Zm10 12V8h3a1 1 0 0 1 1 1v10a1 1 0 0 1-1 1h-3Z", fill: "currentColor" }) })));
});
IconBriefcase.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconBriefcase = (IconBriefcase);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconLifeBuoy.js



/**
 * Semantic vector graphics icon IconLifeBuoy.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconLifeBuoy size="large" color="green50" />
 */
const IconLifeBuoy = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M4.968 6.382A8.962 8.962 0 0 0 3 12c0 2.125.737 4.078 1.968 5.618l2.86-2.86A4.977 4.977 0 0 1 7 12c0-1.02.305-1.967.828-2.758l-2.86-2.86Zm4.275 9.79-2.86 2.86A8.962 8.962 0 0 0 12 21a8.962 8.962 0 0 0 5.618-1.968l-2.86-2.86A4.977 4.977 0 0 1 12 17a4.976 4.976 0 0 1-2.757-.828ZM21 12a8.962 8.962 0 0 1-1.968 5.618l-2.86-2.86c.523-.791.828-1.739.828-2.758 0-1.02-.305-1.967-.828-2.757l2.86-2.86A8.962 8.962 0 0 1 21 12Zm-3.382-7.032-2.86 2.86A4.977 4.977 0 0 0 12 7a4.977 4.977 0 0 0-2.757.828l-2.86-2.86A8.962 8.962 0 0 1 12 3c2.125 0 4.078.736 5.618 1.968ZM1 12C1 5.925 5.925 1 12 1s11 4.925 11 11-4.925 11-11 11S1 18.075 1 12Zm11-3a3 3 0 1 0 0 6 3 3 0 0 0 0-6Z", fill: "currentColor" }) })));
});
IconLifeBuoy.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconLifeBuoy = (IconLifeBuoy);

// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconClipboard.js
var IconClipboard = __webpack_require__(4222);
;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconActivity.js



/**
 * Semantic vector graphics icon IconActivity.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconActivity size="large" color="green50" />
 */
const IconActivity = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M9 2a1 1 0 0 1 .949.684L15 17.838l2.051-6.154A1 1 0 0 1 18 11h4a1 1 0 1 1 0 2h-3.28l-2.771 8.316a1 1 0 0 1-1.898 0L9 6.162l-2.051 6.154A1 1 0 0 1 6 13H2a1 1 0 1 1 0-2h3.28L8.05 2.684A1 1 0 0 1 9 2Z", fill: "currentColor" }) })));
});
IconActivity.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconActivity = (IconActivity);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconMessageSquare.js



/**
 * Semantic vector graphics icon IconMessageSquare.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconMessageSquare size="large" color="green50" />
 */
const IconMessageSquare = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M5 4a1 1 0 0 0-1 1v13.586l2.293-2.293A1 1 0 0 1 7 16h12a1 1 0 0 0 1-1V5a1 1 0 0 0-1-1H5ZM2.879 2.879A3 3 0 0 1 5 2h14a3 3 0 0 1 3 3v10a3 3 0 0 1-3 3H7.414l-3.707 3.707A1 1 0 0 1 2 21V5a3 3 0 0 1 .879-2.121Z", fill: "currentColor" }) })));
});
IconMessageSquare.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconMessageSquare = (IconMessageSquare);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconMessageCircle.js



/**
 * Semantic vector graphics icon IconMessageCircle.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconMessageCircle size="large" color="green50" />
 */
const IconMessageCircle = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M12.5 4a7.5 7.5 0 0 0-6.725 10.825 1 1 0 0 1 .055.756L4.59 19.357l3.564-1.297a1 1 0 0 1 .813.058A7.5 7.5 0 1 0 12.5 4ZM3 11.5a9.5 9.5 0 1 1 5.433 8.587L3.342 21.94a1 1 0 0 1-1.292-1.252l1.756-5.354A9.47 9.47 0 0 1 3 11.5Z", fill: "currentColor" }) })));
});
IconMessageCircle.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconMessageCircle = (IconMessageCircle);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconGrid.js



/**
 * Semantic vector graphics icon IconGrid.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconGrid size="large" color="green50" />
 */
const IconGrid = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M3 2a1 1 0 0 0-1 1v7a1 1 0 0 0 1 1h7a1 1 0 0 0 1-1V3a1 1 0 0 0-1-1H3Zm1 7V4h5v5H4Zm10-7a1 1 0 0 0-1 1v7a1 1 0 0 0 1 1h7a1 1 0 0 0 1-1V3a1 1 0 0 0-1-1h-7Zm1 7V4h5v5h-5Zm-2 5a1 1 0 0 1 1-1h7a1 1 0 0 1 1 1v7a1 1 0 0 1-1 1h-7a1 1 0 0 1-1-1v-7Zm2 1v5h5v-5h-5ZM3 13a1 1 0 0 0-1 1v7a1 1 0 0 0 1 1h7a1 1 0 0 0 1-1v-7a1 1 0 0 0-1-1H3Zm1 7v-5h5v5H4Z", fill: "currentColor" }) })));
});
IconGrid.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconGrid = (IconGrid);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconLayout.js



/**
 * Semantic vector graphics icon IconLayout.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconLayout size="large" color="green50" />
 */
const IconLayout = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M5 4a1 1 0 0 0-1 1v3h16V5a1 1 0 0 0-1-1H5Zm3 6H4v9a1 1 0 0 0 1 1h3V10Zm2 10V10h10v9a1 1 0 0 1-1 1h-9Zm-1 2H5a3 3 0 0 1-3-3V5a3 3 0 0 1 3-3h14a3 3 0 0 1 3 3v14a3 3 0 0 1-3 3H9Z", fill: "currentColor" }) })));
});
IconLayout.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconLayout = (IconLayout);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconColumns.js



/**
 * Semantic vector graphics icon IconColumns.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconColumns size="large" color="green50" />
 */
const IconColumns = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M2.879 2.879A3 3 0 0 1 5 2h14a3 3 0 0 1 3 3v14a3 3 0 0 1-3 3H5a3 3 0 0 1-3-3V5a3 3 0 0 1 .879-2.121ZM13 20h6a1 1 0 0 0 1-1V5a1 1 0 0 0-1-1h-6v16ZM11 4v16H5a1 1 0 0 1-1-1V5a1 1 0 0 1 1-1h6Z", fill: "currentColor" }) })));
});
IconColumns.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconColumns = (IconColumns);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconSidebar.js



/**
 * Semantic vector graphics icon IconSidebar.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconSidebar size="large" color="green50" />
 */
const IconSidebar = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M4 5a1 1 0 0 1 1-1h3v16H5a1 1 0 0 1-1-1V5Zm6 15V4h9a1 1 0 0 1 1 1v14a1 1 0 0 1-1 1h-9Zm-1 2H5a3 3 0 0 1-3-3V5a3 3 0 0 1 3-3h14a3 3 0 0 1 3 3v14a3 3 0 0 1-3 3H9Z", fill: "currentColor" }) })));
});
IconSidebar.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconSidebar = (IconSidebar);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconLayers.js



/**
 * Semantic vector graphics icon IconLayers.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconLayers size="large" color="green50" />
 */
const IconLayers = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M11.553 1.106a1 1 0 0 1 .894 0l10 5a1 1 0 0 1 0 1.788l-10 5a1 1 0 0 1-.894 0l-10-5a1 1 0 0 1 0-1.788l10-5ZM4.236 7 12 10.882 19.764 7 12 3.118 4.236 7Zm-3.13 9.553a1 1 0 0 1 1.341-.447L12 20.882l9.553-4.776a1 1 0 1 1 .894 1.788l-10 5a1 1 0 0 1-.894 0l-10-5a1 1 0 0 1-.447-1.341Zm1.341-5.447a1 1 0 1 0-.894 1.788l10 5a1 1 0 0 0 .894 0l10-5a1 1 0 1 0-.894-1.788L12 15.882l-9.553-4.776Z", fill: "currentColor" }) })));
});
IconLayers.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconLayers = (IconLayers);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconPrinter.js



/**
 * Semantic vector graphics icon IconPrinter.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconPrinter size="large" color="green50" />
 */
const IconPrinter = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M5 2a1 1 0 0 1 1-1h12a1 1 0 0 1 1 1v6h1a3 3 0 0 1 3 3v5a3 3 0 0 1-3 3h-1v3a1 1 0 0 1-1 1H6a1 1 0 0 1-1-1v-3H4a3 3 0 0 1-3-3v-5a3 3 0 0 1 3-3h1V2Zm2 16v3h10v-6H7v3Zm12-1v-3a1 1 0 0 0-1-1H6a1 1 0 0 0-1 1v3H4a1 1 0 0 1-1-1v-5a1 1 0 0 1 1-1h16a1 1 0 0 1 1 1v5a1 1 0 0 1-1 1h-1ZM17 3v5H7V3h10Z", fill: "currentColor" }) })));
});
IconPrinter.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconPrinter = (IconPrinter);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconMail.js



/**
 * Semantic vector graphics icon IconMail.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconMail size="large" color="green50" />
 */
const IconMail = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M3.107 5.554C3.272 5.227 3.612 5 4 5h16c.388 0 .728.227.893.554L12 11.779 3.107 5.554ZM1 5.983V18c0 1.652 1.348 3 3 3h16c1.652 0 3-1.348 3-3V5.982A3.006 3.006 0 0 0 20 3H4a3.006 3.006 0 0 0-3 2.983ZM21 7.92V18c0 .548-.452 1-1 1H4c-.548 0-1-.452-1-1V7.92l8.427 5.9a1 1 0 0 0 1.146 0L21 7.92Z", fill: "currentColor" }) })));
});
IconMail.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconMail = (IconMail);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconInbox.js



/**
 * Semantic vector graphics icon IconInbox.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconInbox size="large" color="green50" />
 */
const IconInbox = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M7.24 3a3 3 0 0 0-2.685 1.664v.001l-3.44 6.87A.995.995 0 0 0 1 12v6a3 3 0 0 0 3 3h16a3 3 0 0 0 3-3v-6.038a.996.996 0 0 0-.115-.428l-3.44-6.869v-.001A3 3 0 0 0 16.76 3H7.24Zm13.14 8-2.724-5.442-.002-.003A1 1 0 0 0 16.76 5H7.24a1 1 0 0 0-.894.555L5.45 5.11l.894.448L3.62 11H8a1 1 0 0 1 .832.445L10.535 14h2.93l1.703-2.555A1 1 0 0 1 16 11h4.38ZM3 13v5a1 1 0 0 0 1 1h16a1 1 0 0 0 1-1v-5h-4.465l-1.703 2.555A1 1 0 0 1 14 16h-4a1 1 0 0 1-.832-.445L7.465 13H3Z", fill: "currentColor" }) })));
});
IconInbox.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconInbox = (IconInbox);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconArchive.js



/**
 * Semantic vector graphics icon IconArchive.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconArchive size="large" color="green50" />
 */
const IconArchive = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M0 3a1 1 0 0 1 1-1h22a1 1 0 0 1 1 1v5a1 1 0 0 1-1 1h-1v12a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V9H1a1 1 0 0 1-1-1V3Zm20 17V9H4v11h16Zm2-13H2V4h20v3Zm-12 4a1 1 0 1 0 0 2h4a1 1 0 1 0 0-2h-4Z", fill: "currentColor" }) })));
});
IconArchive.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconArchive = (IconArchive);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconAtSign.js



/**
 * Semantic vector graphics icon IconAtSign.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconAtSign size="large" color="green50" />
 */
const IconAtSign = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M14.5 1.288a11 11 0 1 0 4.188 19.446 1 1 0 1 0-1.216-1.588A9 9 0 1 1 21 12v1a2 2 0 0 1-4 0V8a1 1 0 0 0-2 0 5 5 0 1 0 .74 7.319A3.996 3.996 0 0 0 19 17a4 4 0 0 0 4-4v-1a11 11 0 0 0-8.5-10.712ZM9 12a3 3 0 1 1 6 0 3 3 0 0 1-6 0Z", fill: "currentColor" }) })));
});
IconAtSign.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconAtSign = (IconAtSign);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconSmile.js



/**
 * Semantic vector graphics icon IconSmile.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconSmile size="large" color="green50" />
 */
const IconSmile = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M3 12a9 9 0 1 1 18 0 9 9 0 0 1-18 0Zm9-11C5.925 1 1 5.925 1 12s4.925 11 11 11 11-4.925 11-11S18.075 1 12 1ZM7.4 13.2a1 1 0 0 1 1.397.196l.005.006.033.041a4.952 4.952 0 0 0 .815.748c.578.42 1.376.809 2.35.809.975 0 1.772-.39 2.35-.809a4.953 4.953 0 0 0 .815-.748l.034-.041.004-.006A1 1 0 0 1 16.8 14.6L16 14l.8.6-.001.001-.001.002-.003.004-.007.009-.021.027-.07.086a6.944 6.944 0 0 1-1.17 1.08c-.8.58-2.002 1.191-3.527 1.191-1.525 0-2.728-.61-3.526-1.191a6.942 6.942 0 0 1-1.17-1.08 4.174 4.174 0 0 1-.07-.086l-.022-.027-.007-.01-.003-.003-.001-.002S7.2 14.6 8 14l-.8.6a1 1 0 0 1 .2-1.4ZM8 9a1 1 0 0 1 1-1h.01a1 1 0 1 1 0 2H9a1 1 0 0 1-1-1Zm7-1a1 1 0 1 0 0 2h.01a1 1 0 1 0 0-2H15Z", fill: "currentColor" }) })));
});
IconSmile.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconSmile = (IconSmile);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconMeh.js



/**
 * Semantic vector graphics icon IconMeh.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconMeh size="large" color="green50" />
 */
const IconMeh = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M3 12a9 9 0 1 1 18 0 9 9 0 0 1-18 0Zm9-11C5.925 1 1 5.925 1 12s4.925 11 11 11 11-4.925 11-11S18.075 1 12 1ZM8 14a1 1 0 1 0 0 2h8a1 1 0 1 0 0-2H8Zm0-5a1 1 0 0 1 1-1h.01a1 1 0 1 1 0 2H9a1 1 0 0 1-1-1Zm7-1a1 1 0 1 0 0 2h.01a1 1 0 1 0 0-2H15Z", fill: "currentColor" }) })));
});
IconMeh.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconMeh = (IconMeh);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconFrown.js



/**
 * Semantic vector graphics icon IconFrown.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconFrown size="large" color="green50" />
 */
const IconFrown = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M12 3a9 9 0 1 0 0 18 9 9 0 0 0 0-18ZM1 12C1 5.925 5.925 1 12 1s11 4.925 11 11-4.925 11-11 11S1 18.075 1 12Zm7-3a1 1 0 0 1 1-1h.01a1 1 0 0 1 0 2H9a1 1 0 0 1-1-1Zm6 0a1 1 0 0 1 1-1h.01a1 1 0 1 1 0 2H15a1 1 0 0 1-1-1Zm-5.526 5.191c.798-.58 2-1.191 3.526-1.191 1.525 0 2.728.61 3.526 1.191a6.944 6.944 0 0 1 1.17 1.08c.03.035.053.064.07.086l.022.027.007.01.003.003.001.002S16.8 15.4 16 16l.8-.6a1 1 0 0 1-1.597 1.204l-.005-.006a3.709 3.709 0 0 0-.194-.219 4.953 4.953 0 0 0-.655-.57C13.772 15.389 12.975 15 12 15c-.975 0-1.772.39-2.35.809a4.952 4.952 0 0 0-.815.748l-.034.041-.004.006.001-.002H8.8m0 0-.002.002A1 1 0 0 1 7.2 15.4l.8.6-.8-.6.002-.003.003-.004.007-.009.021-.027.07-.086a6.942 6.942 0 0 1 1.171-1.08", fill: "currentColor" }) })));
});
IconFrown.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconFrown = (IconFrown);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconUsers.js



/**
 * Semantic vector graphics icon IconUsers.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconUsers size="large" color="green50" />
 */
const IconUsers = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M6 7a3 3 0 1 1 6 0 3 3 0 0 1-6 0Zm3-5a5 5 0 1 0 0 10A5 5 0 0 0 9 2ZM5 14a5 5 0 0 0-5 5v2a1 1 0 1 0 2 0v-2a3 3 0 0 1 3-3h8a3 3 0 0 1 3 3v2a1 1 0 1 0 2 0v-2a5 5 0 0 0-5-5H5Zm14.032.88a1 1 0 0 1 1.218-.718A5 5 0 0 1 24 18.999V21a1 1 0 1 1-2 0v-2a3 3 0 0 0-2.25-2.902 1 1 0 0 1-.718-1.218ZM16.248 2.161a1 1 0 1 0-.496 1.938 3 3 0 0 1 0 5.812 1 1 0 1 0 .496 1.938 5 5 0 0 0 0-9.688Z", fill: "currentColor" }) })));
});
IconUsers.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconUsers = (IconUsers);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconUser.js



/**
 * Semantic vector graphics icon IconUser.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconUser size="large" color="green50" />
 */
const IconUser = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M9 7a3 3 0 1 1 6 0 3 3 0 0 1-6 0Zm3-5a5 5 0 1 0 0 10 5 5 0 0 0 0-10ZM8 14a5 5 0 0 0-5 5v2a1 1 0 1 0 2 0v-2a3 3 0 0 1 3-3h8a3 3 0 0 1 3 3v2a1 1 0 1 0 2 0v-2a5 5 0 0 0-5-5H8Z", fill: "currentColor" }) })));
});
IconUser.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconUser = (IconUser);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconUserX.js



/**
 * Semantic vector graphics icon IconUserX.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconUserX size="large" color="green50" />
 */
const IconUserX = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M5.5 7a3 3 0 1 1 6 0 3 3 0 0 1-6 0Zm3-5a5 5 0 1 0 0 10 5 5 0 0 0 0-10ZM5 14a5 5 0 0 0-5 5v2a1 1 0 1 0 2 0v-2a3 3 0 0 1 3-3h7a3 3 0 0 1 3 3v2a1 1 0 1 0 2 0v-2a5 5 0 0 0-5-5H5Zm12.293-6.707a1 1 0 0 1 1.414 0L20.5 9.086l1.793-1.793a1 1 0 1 1 1.414 1.414L21.914 10.5l1.793 1.793a1 1 0 0 1-1.414 1.414L20.5 11.914l-1.793 1.793a1 1 0 0 1-1.414-1.414l1.793-1.793-1.793-1.793a1 1 0 0 1 0-1.414Z", fill: "currentColor" }) })));
});
IconUserX.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconUserX = (IconUserX);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconUserPlus.js



/**
 * Semantic vector graphics icon IconUserPlus.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconUserPlus size="large" color="green50" />
 */
const IconUserPlus = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M5.5 7a3 3 0 1 1 6 0 3 3 0 0 1-6 0Zm3-5a5 5 0 1 0 0 10 5 5 0 0 0 0-10ZM5 14a5 5 0 0 0-5 5v2a1 1 0 1 0 2 0v-2a3 3 0 0 1 3-3h7a3 3 0 0 1 3 3v2a1 1 0 1 0 2 0v-2a5 5 0 0 0-5-5H5Zm15-7a1 1 0 0 1 1 1v2h2a1 1 0 1 1 0 2h-2v2a1 1 0 1 1-2 0v-2h-2a1 1 0 1 1 0-2h2V8a1 1 0 0 1 1-1Z", fill: "currentColor" }) })));
});
IconUserPlus.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconUserPlus = (IconUserPlus);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconUserMinus.js



/**
 * Semantic vector graphics icon IconUserMinus.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconUserMinus size="large" color="green50" />
 */
const IconUserMinus = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M8.5 4a3 3 0 1 0 0 6 3 3 0 0 0 0-6Zm-5 3a5 5 0 1 1 10 0 5 5 0 0 1-10 0Zm-2.036 8.464A5 5 0 0 1 5 14h7a5 5 0 0 1 5 5v2a1 1 0 1 1-2 0v-2a3 3 0 0 0-3-3H5a3 3 0 0 0-3 3v2a1 1 0 1 1-2 0v-2a5 5 0 0 1 1.464-3.536ZM17 10a1 1 0 1 0 0 2h6a1 1 0 1 0 0-2h-6Z", fill: "currentColor" }) })));
});
IconUserMinus.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconUserMinus = (IconUserMinus);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconUserCheck.js



/**
 * Semantic vector graphics icon IconUserCheck.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconUserCheck size="large" color="green50" />
 */
const IconUserCheck = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M8.5 4a3 3 0 1 0 0 6 3 3 0 0 0 0-6Zm-5 3a5 5 0 1 1 10 0 5 5 0 0 1-10 0Zm-2.036 8.464A5 5 0 0 1 5 14h7a5 5 0 0 1 5 5v2a1 1 0 1 1-2 0v-2a3 3 0 0 0-3-3H5a3 3 0 0 0-3 3v2a1 1 0 1 1-2 0v-2a5 5 0 0 1 1.464-3.536Zm22.243-5.757a1 1 0 0 0-1.414-1.414L19 11.586l-1.293-1.293a1 1 0 1 0-1.414 1.414l2 2a1 1 0 0 0 1.414 0l4-4Z", fill: "currentColor" }) })));
});
IconUserCheck.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconUserCheck = (IconUserCheck);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconBookOpen.js



/**
 * Semantic vector graphics icon IconBookOpen.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconBookOpen size="large" color="green50" />
 */
const IconBookOpen = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M2 2a1 1 0 0 0-1 1v15a1 1 0 0 0 1 1h7a2 2 0 0 1 2 2 1 1 0 1 0 2 0 2 2 0 0 1 2-2h7a1 1 0 0 0 1-1V3a1 1 0 0 0-1-1h-6a5 5 0 0 0-4 2 5 5 0 0 0-4-2H2Zm11 15.536A4 4 0 0 1 15 17h6V4h-5a3 3 0 0 0-3 3v10.536Zm-2 0V7a3 3 0 0 0-3-3H3v13h6a4 4 0 0 1 2 .536Z", fill: "currentColor" }) })));
});
IconBookOpen.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconBookOpen = (IconBookOpen);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconBook.js



/**
 * Semantic vector graphics icon IconBook.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconBook size="large" color="green50" />
 */
const IconBook = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M5.44 3.44A1.5 1.5 0 0 1 6.5 3H19v13H6.5a3.5 3.5 0 0 0-1.5.338V4.5c0-.398.158-.78.44-1.06ZM5 19.5A1.5 1.5 0 0 0 6.5 21H19v-3H6.5A1.5 1.5 0 0 0 5 19.5ZM21 17V2a1 1 0 0 0-1-1H6.5A3.5 3.5 0 0 0 3 4.5v15A3.5 3.5 0 0 0 6.5 23H20a1 1 0 0 0 1-1v-5Z", fill: "currentColor" }) })));
});
IconBook.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconBook = (IconBook);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconBookmark.js



/**
 * Semantic vector graphics icon IconBookmark.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconBookmark size="large" color="green50" />
 */
const IconBookmark = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M7 4a1 1 0 0 0-1 1v14.057l5.419-3.87a1 1 0 0 1 1.162 0L18 19.056V5a1 1 0 0 0-1-1H7ZM4.879 2.879A3 3 0 0 1 7 2h10a3 3 0 0 1 3 3v16a1 1 0 0 1-1.581.814L12 17.229l-6.419 4.585A1 1 0 0 1 4 21V5a3 3 0 0 1 .879-2.121Z", fill: "currentColor" }) })));
});
IconBookmark.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconBookmark = (IconBookmark);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconFolderPlus.js



/**
 * Semantic vector graphics icon IconFolderPlus.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconFolderPlus size="large" color="green50" />
 */
const IconFolderPlus = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M4 4a1 1 0 0 0-1 1v14a1 1 0 0 0 1 1h16a1 1 0 0 0 1-1V8a1 1 0 0 0-1-1h-9a1 1 0 0 1-.832-.445L8.465 4H4ZM1.879 2.879A3 3 0 0 1 4 2h5a1 1 0 0 1 .832.445L11.535 5H20a3 3 0 0 1 3 3v11a3 3 0 0 1-3 3H4a3 3 0 0 1-3-3V5a3 3 0 0 1 .879-2.121ZM12 10a1 1 0 0 1 1 1v2h2a1 1 0 1 1 0 2h-2v2a1 1 0 1 1-2 0v-2H9a1 1 0 1 1 0-2h2v-2a1 1 0 0 1 1-1Z", fill: "currentColor" }) })));
});
IconFolderPlus.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconFolderPlus = (IconFolderPlus);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconFolderMinus.js



/**
 * Semantic vector graphics icon IconFolderMinus.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconFolderMinus size="large" color="green50" />
 */
const IconFolderMinus = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M3.293 4.293A1 1 0 0 1 4 4h4.465l1.703 2.555A1 1 0 0 0 11 7h9a1 1 0 0 1 1 1v11a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1V5a1 1 0 0 1 .293-.707ZM4 2a3 3 0 0 0-3 3v14a3 3 0 0 0 3 3h16a3 3 0 0 0 3-3V8a3 3 0 0 0-3-3h-8.465L9.832 2.445A1 1 0 0 0 9 2H4Zm5 11a1 1 0 1 0 0 2h6a1 1 0 1 0 0-2H9Z", fill: "currentColor" }) })));
});
IconFolderMinus.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconFolderMinus = (IconFolderMinus);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconFolder.js



/**
 * Semantic vector graphics icon IconFolder.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconFolder size="large" color="green50" />
 */
const IconFolder = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M4 4a1 1 0 0 0-1 1v14a1 1 0 0 0 1 1h16a1 1 0 0 0 1-1V8a1 1 0 0 0-1-1h-9a1 1 0 0 1-.832-.445L8.465 4H4ZM1.879 2.879A3 3 0 0 1 4 2h5a1 1 0 0 1 .832.445L11.535 5H20a3 3 0 0 1 3 3v11a3 3 0 0 1-3 3H4a3 3 0 0 1-3-3V5a3 3 0 0 1 .879-2.121Z", fill: "currentColor" }) })));
});
IconFolder.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconFolder = (IconFolder);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconFileText.js



/**
 * Semantic vector graphics icon IconFileText.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconFileText size="large" color="green50" />
 */
const IconFileText = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M6 1a3 3 0 0 0-3 3v16a3 3 0 0 0 3 3h12a3 3 0 0 0 3-3V8a1 1 0 0 0-.293-.707l-6-6A1 1 0 0 0 14 1H6Zm-.707 2.293A1 1 0 0 1 6 3h7v5a1 1 0 0 0 1 1h5v11a1 1 0 0 1-1 1H6a1 1 0 0 1-1-1V4a1 1 0 0 1 .293-.707ZM17.586 7 15 4.414V7h2.586ZM8 12a1 1 0 1 0 0 2h8a1 1 0 1 0 0-2H8Zm-1 5a1 1 0 0 1 1-1h8a1 1 0 1 1 0 2H8a1 1 0 0 1-1-1Zm1-9a1 1 0 0 0 0 2h2a1 1 0 1 0 0-2H8Z", fill: "currentColor" }) })));
});
IconFileText.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconFileText = (IconFileText);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconFilePlus.js



/**
 * Semantic vector graphics icon IconFilePlus.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconFilePlus size="large" color="green50" />
 */
const IconFilePlus = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M3.879 1.879A3 3 0 0 1 6 1h8a1 1 0 0 1 .707.293l6 6A1 1 0 0 1 21 8v12a3 3 0 0 1-3 3H6a3 3 0 0 1-3-3V4a3 3 0 0 1 .879-2.121ZM6 3a1 1 0 0 0-1 1v16a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1V9h-5a1 1 0 0 1-1-1V3H6Zm9 1.414L17.586 7H15V4.414ZM12 11a1 1 0 0 1 1 1v2h2a1 1 0 1 1 0 2h-2v2a1 1 0 1 1-2 0v-2H9a1 1 0 1 1 0-2h2v-2a1 1 0 0 1 1-1Z", fill: "currentColor" }) })));
});
IconFilePlus.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconFilePlus = (IconFilePlus);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconFileMinus.js



/**
 * Semantic vector graphics icon IconFileMinus.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconFileMinus size="large" color="green50" />
 */
const IconFileMinus = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M6 1a3 3 0 0 0-3 3v16a3 3 0 0 0 3 3h12a3 3 0 0 0 3-3V8a1 1 0 0 0-.293-.707l-6-6A1 1 0 0 0 14 1H6Zm-.707 2.293A1 1 0 0 1 6 3h7v5a1 1 0 0 0 1 1h5v11a1 1 0 0 1-1 1H6a1 1 0 0 1-1-1V4a1 1 0 0 1 .293-.707ZM17.586 7 15 4.414V7h2.586ZM9 14a1 1 0 1 0 0 2h6a1 1 0 1 0 0-2H9Z", fill: "currentColor" }) })));
});
IconFileMinus.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconFileMinus = (IconFileMinus);

// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconFile.js
var IconFile = __webpack_require__(4103);
;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconPieChart.js



/**
 * Semantic vector graphics icon IconPieChart.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconPieChart size="large" color="green50" />
 */
const IconPieChart = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M12 1a1 1 0 0 0-1 1v10a1 1 0 0 0 1 1h10a1 1 0 0 0 1-1A11 11 0 0 0 12 1Zm1 10V3.056A9 9 0 0 1 20.944 11H13ZM8.4 3.747a1 1 0 0 0-.8-1.834A11 11 0 1 0 22.131 16.28a1 1 0 1 0-1.842-.778A9 9 0 1 1 8.399 3.747Z", fill: "currentColor" }) })));
});
IconPieChart.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconPieChart = (IconPieChart);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconBarChart2.js



/**
 * Semantic vector graphics icon IconBarChart2.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconBarChart2 size="large" color="green50" />
 */
const IconBarChart2 = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M18 3a1 1 0 0 1 1 1v16a1 1 0 1 1-2 0V4a1 1 0 0 1 1-1Zm-6 6a1 1 0 0 1 1 1v10a1 1 0 1 1-2 0V10a1 1 0 0 1 1-1Zm-5 7a1 1 0 1 0-2 0v4a1 1 0 1 0 2 0v-4Z", fill: "currentColor" }) })));
});
IconBarChart2.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconBarChart2 = (IconBarChart2);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconBarChart.js



/**
 * Semantic vector graphics icon IconBarChart.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconBarChart size="large" color="green50" />
 */
const IconBarChart = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M12 3a1 1 0 0 1 1 1v16a1 1 0 1 1-2 0V4a1 1 0 0 1 1-1Zm6 6a1 1 0 0 1 1 1v10a1 1 0 1 1-2 0V10a1 1 0 0 1 1-1ZM7 14a1 1 0 1 0-2 0v6a1 1 0 1 0 2 0v-6Z", fill: "currentColor" }) })));
});
IconBarChart.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconBarChart = (IconBarChart);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconRss.js



/**
 * Semantic vector graphics icon IconRss.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconRss size="large" color="green50" />
 */
const IconRss = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M3 4a1 1 0 0 1 1-1 17 17 0 0 1 17 17 1 1 0 1 1-2 0A15 15 0 0 0 4 5a1 1 0 0 1-1-1Zm0 7a1 1 0 0 1 1-1 10 10 0 0 1 10 10 1 1 0 1 1-2 0 8 8 0 0 0-8-8 1 1 0 0 1-1-1Zm2 6a2 2 0 1 0 0 4 2 2 0 0 0 0-4Z", fill: "currentColor" }) })));
});
IconRss.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconRss = (IconRss);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconRadio.js



/**
 * Semantic vector graphics icon IconRadio.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconRadio size="large" color="green50" />
 */
const IconRadio = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M5.637 5.637a1 1 0 1 0-1.414-1.414 11 11 0 0 0 0 15.554 1 1 0 1 0 1.414-1.414 9 9 0 0 1 0-12.726Zm14.14-1.414a1 1 0 1 0-1.414 1.414 9 9 0 0 1 0 12.726 1 1 0 1 0 1.414 1.414 11 11 0 0 0 0-15.554ZM8.467 8.457a1 1 0 1 0-1.414-1.415 7 7 0 0 0 0 9.905 1 1 0 0 0 1.414-1.414 5 5 0 0 1 0-7.076Zm8.48-1.405a1 1 0 1 0-1.414 1.415 5 5 0 0 1 0 7.075 1 1 0 0 0 1.414 1.415 7 7 0 0 0 0-9.905ZM11 12a1 1 0 1 1 2 0 1 1 0 0 1-2 0Zm1-3a3 3 0 1 0 0 6 3 3 0 0 0 0-6Z", fill: "currentColor" }) })));
});
IconRadio.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconRadio = (IconRadio);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconBluetooth.js



/**
 * Semantic vector graphics icon IconBluetooth.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconBluetooth size="large" color="green50" />
 */
const IconBluetooth = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M11.617.076a1 1 0 0 1 1.09.217l5.5 5.5a1 1 0 0 1 0 1.414L13.414 12l4.793 4.793a1 1 0 0 1 0 1.414l-5.5 5.5A1 1 0 0 1 11 23v-8.586l-3.793 3.793a1 1 0 0 1-1.414-1.414L10.586 12 5.793 7.207a1 1 0 0 1 1.414-1.414L11 9.586V1a1 1 0 0 1 .617-.924ZM13 14.414l3.086 3.086L13 20.586v-6.172Zm0-4.828V3.414L16.086 6.5 13 9.586Z", fill: "currentColor" }) })));
});
IconBluetooth.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconBluetooth = (IconBluetooth);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconPower.js



/**
 * Semantic vector graphics icon IconPower.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconPower size="large" color="green50" />
 */
const IconPower = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M13 2a1 1 0 1 0-2 0v10a1 1 0 1 0 2 0V2ZM6.337 7.347a1 1 0 0 0-1.414-1.414 10 10 0 1 0 14.144 0 1 1 0 1 0-1.414 1.414 8 8 0 1 1-11.316 0Z", fill: "currentColor" }) })));
});
IconPower.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconPower = (IconPower);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconTablet.js



/**
 * Semantic vector graphics icon IconTablet.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconTablet size="large" color="green50" />
 */
const IconTablet = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M5 4a1 1 0 0 1 1-1h12a1 1 0 0 1 1 1v16a1 1 0 0 1-1 1H6a1 1 0 0 1-1-1V4Zm1-3a3 3 0 0 0-3 3v16a3 3 0 0 0 3 3h12a3 3 0 0 0 3-3V4a3 3 0 0 0-3-3H6Zm6 16a1 1 0 1 0 0 2h.01a1 1 0 1 0 0-2H12Z", fill: "currentColor" }) })));
});
IconTablet.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconTablet = (IconTablet);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconSmartphone.js



/**
 * Semantic vector graphics icon IconSmartphone.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconSmartphone size="large" color="green50" />
 */
const IconSmartphone = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M6 4a1 1 0 0 1 1-1h10a1 1 0 0 1 1 1v16a1 1 0 0 1-1 1H7a1 1 0 0 1-1-1V4Zm1-3a3 3 0 0 0-3 3v16a3 3 0 0 0 3 3h10a3 3 0 0 0 3-3V4a3 3 0 0 0-3-3H7Zm5 16a1 1 0 1 0 0 2h.01a1 1 0 1 0 0-2H12Z", fill: "currentColor" }) })));
});
IconSmartphone.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconSmartphone = (IconSmartphone);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconTerminal.js



/**
 * Semantic vector graphics icon IconTerminal.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconTerminal size="large" color="green50" />
 */
const IconTerminal = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M4.707 4.293a1 1 0 0 0-1.414 1.414L8.586 11l-5.293 5.293a1 1 0 1 0 1.414 1.414l6-6a1 1 0 0 0 0-1.414l-6-6ZM12 18a1 1 0 1 0 0 2h8a1 1 0 1 0 0-2h-8Z", fill: "currentColor" }) })));
});
IconTerminal.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconTerminal = (IconTerminal);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconServer.js



/**
 * Semantic vector graphics icon IconServer.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconServer size="large" color="green50" />
 */
const IconServer = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M3 4a1 1 0 0 1 1-1h16a1 1 0 0 1 1 1v4a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1V4Zm1-3a3 3 0 0 0-3 3v4a3 3 0 0 0 3 3h16a3 3 0 0 0 3-3V4a3 3 0 0 0-3-3H4ZM3 16a1 1 0 0 1 1-1h16a1 1 0 0 1 1 1v4a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1v-4Zm1-3a3 3 0 0 0-3 3v4a3 3 0 0 0 3 3h16a3 3 0 0 0 3-3v-4a3 3 0 0 0-3-3H4Zm1-7a1 1 0 0 1 1-1h.01a1 1 0 0 1 0 2H6a1 1 0 0 1-1-1Zm1 11a1 1 0 1 0 0 2h.01a1 1 0 1 0 0-2H6Z", fill: "currentColor" }) })));
});
IconServer.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconServer = (IconServer);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconDatabase.js



/**
 * Semantic vector graphics icon IconDatabase.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconDatabase size="large" color="green50" />
 */
const IconDatabase = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M4.003 4.985 4 5c0 .002 0 .006.003.015a.296.296 0 0 0 .032.066c.043.07.13.174.291.301.33.26.87.539 1.626.79C7.454 6.674 9.592 7 12 7s4.546-.327 6.048-.827c.756-.252 1.296-.53 1.626-.79.162-.128.248-.232.29-.302a.293.293 0 0 0 .033-.066A.052.052 0 0 0 20 5l-.003-.015a.293.293 0 0 0-.032-.066 1.235 1.235 0 0 0-.291-.301c-.33-.26-.87-.539-1.626-.79C16.546 3.326 14.408 3 12 3s-4.546.327-6.048.827c-.756.252-1.296.53-1.626.79a1.236 1.236 0 0 0-.29.302.296.296 0 0 0-.033.066ZM20 7.527a9.536 9.536 0 0 1-1.32.543C16.925 8.655 14.563 9 12 9c-2.563 0-4.925-.345-6.68-.93A9.536 9.536 0 0 1 4 7.527V12c0 .002 0 .007.003.018a.298.298 0 0 0 .033.067c.042.07.127.173.288.3.328.26.864.537 1.618.789 1.497.5 3.635.826 6.058.826s4.561-.326 6.058-.826c.754-.252 1.29-.53 1.618-.789.16-.127.246-.23.288-.3a.298.298 0 0 0 .033-.067A.061.061 0 0 0 20 12V7.527ZM22 12V5c0-.852-.519-1.504-1.088-1.953-.581-.458-1.36-.826-2.232-1.117C16.925 1.345 14.563 1 12 1c-2.563 0-4.925.345-6.68.93-.873.29-1.651.66-2.232 1.117C2.518 3.496 2 4.148 2 5v14c0 .85.513 1.502 1.082 1.953.579.459 1.355.827 2.226 1.118C7.061 22.656 9.423 23 12 23s4.939-.344 6.692-.929c.87-.29 1.647-.66 2.226-1.118C21.487 20.502 22 19.849 22 19v-7Zm-2 2.532c-.398.203-.84.383-1.308.539-1.753.585-4.115.929-6.692.929s-4.939-.344-6.692-.929A9.461 9.461 0 0 1 4 14.531V19c0 .002 0 .007.003.018a.298.298 0 0 0 .033.067c.042.07.127.173.288.3.328.26.864.537 1.618.789 1.497.5 3.635.826 6.058.826s4.561-.326 6.058-.826c.754-.252 1.29-.53 1.618-.789.16-.127.246-.23.288-.3a.298.298 0 0 0 .033-.067A.061.061 0 0 0 20 19v-4.468Z", fill: "currentColor" }) })));
});
IconDatabase.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconDatabase = (IconDatabase);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconHardDrive.js



/**
 * Semantic vector graphics icon IconHardDrive.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconHardDrive size="large" color="green50" />
 */
const IconHardDrive = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M7.24 3a3 3 0 0 0-2.685 1.664v.001l-3.44 6.87A.995.995 0 0 0 1 12v6a3 3 0 0 0 3 3h16a3 3 0 0 0 3-3v-6.038a.996.996 0 0 0-.115-.428l-3.44-6.869v-.001A3 3 0 0 0 16.76 3H7.24Zm13.14 8-2.724-5.442-.002-.003A1 1 0 0 0 16.76 5H7.24a1 1 0 0 0-.894.555L5.45 5.11l.894.448L3.62 11h16.762ZM3 13v5a1 1 0 0 0 1 1h16a1 1 0 0 0 1-1v-5H3Zm2 3a1 1 0 0 1 1-1h.01a1 1 0 1 1 0 2H6a1 1 0 0 1-1-1Zm5-1a1 1 0 1 0 0 2h.01a1 1 0 1 0 0-2H10Z", fill: "currentColor" }) })));
});
IconHardDrive.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconHardDrive = (IconHardDrive);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconHash.js



/**
 * Semantic vector graphics icon IconHash.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconHash size="large" color="green50" />
 */
const IconHash = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M10.11 2.006a1 1 0 0 1 .884 1.104L10.45 8h3.987l.568-5.11a1 1 0 1 1 1.988.22L16.45 8H20a1 1 0 1 1 0 2h-3.772l-.444 4H20a1 1 0 1 1 0 2h-4.438l-.568 5.11a1 1 0 0 1-1.988-.22L13.55 16H9.562l-.568 5.11a1 1 0 0 1-1.988-.22L7.55 16H4a1 1 0 1 1 0-2h3.772l.444-4H4a1 1 0 0 1 0-2h4.438l.568-5.11a1 1 0 0 1 1.104-.884ZM13.772 14l.444-4h-3.988l-.444 4h3.988Z", fill: "currentColor" }) })));
});
IconHash.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconHash = (IconHash);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconGitPr.js



/**
 * Semantic vector graphics icon IconGitPr.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconGitPr size="large" color="green50" />
 */
const IconGitPr = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M4 6a2 2 0 1 1 4 0 2 2 0 0 1-4 0Zm3 3.874A4.002 4.002 0 0 0 6 2a4 4 0 0 0-1 7.874V21a1 1 0 1 0 2 0V9.874ZM16 18a2 2 0 1 1 4 0 2 2 0 0 1-4 0Zm-2 0a4.002 4.002 0 0 1 3-3.874V8a1 1 0 0 0-1-1h-3a1 1 0 1 1 0-2h3a3 3 0 0 1 3 3v6.126A4.002 4.002 0 0 1 18 22a4 4 0 0 1-4-4Z", fill: "currentColor" }) })));
});
IconGitPr.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconGitPr = (IconGitPr);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconGitMerge.js



/**
 * Semantic vector graphics icon IconGitMerge.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconGitMerge size="large" color="green50" />
 */
const IconGitMerge = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M6 4a2 2 0 1 0 0 4 2 2 0 0 0 0-4Zm1.047 5.862A4.002 4.002 0 0 0 6 2a4 4 0 0 0-1 7.874V21a1 1 0 1 0 2 0v-6a10 10 0 0 0 7.116 3.96A4.002 4.002 0 0 0 22 18a4 4 0 0 0-7.862-1.047 8 8 0 0 1-7.091-7.091ZM16 18a2 2 0 1 0 4 0 2 2 0 0 0-4 0Z", fill: "currentColor" }) })));
});
IconGitMerge.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconGitMerge = (IconGitMerge);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconGitCommit.js



/**
 * Semantic vector graphics icon IconGitCommit.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconGitCommit size="large" color="green50" />
 */
const IconGitCommit = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M12 9a3 3 0 1 0 0 6 3 3 0 0 0 0-6Zm-5 4a.986.986 0 0 0 .099-.005 5.002 5.002 0 0 0 9.802 0c.036.003.072.005.109.005h5.95a1 1 0 0 0 0-2h-5.95c-.037 0-.073.002-.109.006a5.002 5.002 0 0 0-9.802-.001.986.986 0 0 0-.1-.005H1.05a1 1 0 1 0 0 2H7Z", fill: "currentColor" }) })));
});
IconGitCommit.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconGitCommit = (IconGitCommit);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconGitBranch.js



/**
 * Semantic vector graphics icon IconGitBranch.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconGitBranch size="large" color="green50" />
 */
const IconGitBranch = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M7 3a1 1 0 0 0-2 0v11.126A4.002 4.002 0 0 0 6 22a4.002 4.002 0 0 0 3.884-3.04 10 10 0 0 0 9.077-9.076A4.002 4.002 0 0 0 18 2a4 4 0 0 0-1.047 7.862 8 8 0 0 1-7.091 7.091A4.007 4.007 0 0 0 7 14.126V3Zm1 15a2 2 0 1 0-4 0 2 2 0 0 0 4 0ZM18 8a2 2 0 1 0 0-4 2 2 0 0 0 0 4Z", fill: "currentColor" }) })));
});
IconGitBranch.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconGitBranch = (IconGitBranch);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconCommand.js



/**
 * Semantic vector graphics icon IconCommand.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconCommand size="large" color="green50" />
 */
const IconCommand = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M3.172 3.172A4 4 0 0 1 10 6v2h4V6a4 4 0 1 1 4 4h-2v4h2a4 4 0 1 1-4 4v-2h-4v2a4 4 0 1 1-4-4h2v-4H6a4 4 0 0 1-2.828-6.828ZM8 8V6a2 2 0 1 0-2 2h2Zm2 2v4h4v-4h-4Zm-2 6H6a2 2 0 1 0 2 2v-2Zm8 0v2a2 2 0 1 0 2-2h-2Zm0-8h2a2 2 0 1 0-2-2v2Z", fill: "currentColor" }) })));
});
IconCommand.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconCommand = (IconCommand);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconCpu.js



/**
 * Semantic vector graphics icon IconCpu.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconCpu size="large" color="green50" />
 */
const IconCpu = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M9 0a1 1 0 0 1 1 1v2h4V1a1 1 0 1 1 2 0v2h2a3 3 0 0 1 3 3v2h2a1 1 0 1 1 0 2h-2v3h2a1 1 0 1 1 0 2h-2v3a3 3 0 0 1-3 3h-2v2a1 1 0 1 1-2 0v-2h-4v2a1 1 0 1 1-2 0v-2H6a3 3 0 0 1-3-3v-3H1a1 1 0 1 1 0-2h2v-3H1a1 1 0 1 1 0-2h2V6a3 3 0 0 1 3-3h2V1a1 1 0 0 1 1-1ZM5 14v4a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1V6a1 1 0 0 0-1-1H6a1 1 0 0 0-1 1v8Zm4-6a1 1 0 0 0-1 1v6a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1V9a1 1 0 0 0-1-1H9Zm1 6v-4h4v4h-4Z", fill: "currentColor" }) })));
});
IconCpu.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconCpu = (IconCpu);

// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconCode.js
var IconCode = __webpack_require__(878);
// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconRobocorpOutline.js
var IconRobocorpOutline = __webpack_require__(2111);
// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconRobocorp.js
var IconRobocorp = __webpack_require__(5950);
;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconCloud.js



/**
 * Semantic vector graphics icon IconCloud.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconCloud size="large" color="green50" />
 */
const IconCloud = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { d: "M8.996 21a8.983 8.983 0 0 1-8.707-6.75c-.6-2.33-.26-4.75.96-6.82a8.945 8.945 0 0 1 5.498-4.14c2.329-.6 4.748-.26 6.817.96A9.023 9.023 0 0 1 17.483 9h.52A6.004 6.004 0 0 1 24 15c0 3.31-2.689 6-5.998 6H8.996c.01 0 0 0 0 0Zm0-16c-.57 0-1.16.08-1.75.23a6.926 6.926 0 0 0-4.278 3.22A6.994 6.994 0 0 0 8.996 19h9.006c2.21 0 3.999-1.79 3.999-4s-1.79-4-3.999-4h-1.26c-.459 0-.849-.31-.969-.75C14.963 7.1 12.115 5 8.996 5Z", fill: "currentColor" }) })));
});
IconCloud.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconCloud = (IconCloud);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconFlag.js



/**
 * Semantic vector graphics icon IconFlag.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconFlag size="large" color="green50" />
 */
const IconFlag = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "m4.52 2.145-.189-.53c-.29.103-.545.268-.752.478A1 1 0 0 0 3 3v19a1 1 0 1 0 2 0v-6.5a2 2 0 0 0 .657-.111l.005-.002.066-.02c.068-.02.179-.051.327-.086.3-.07.74-.152 1.273-.19 1.076-.075 2.443.034 3.78.7 2.163 1.075 4.296 1.217 5.845 1.107.78-.055 1.433-.175 1.9-.284a9.592 9.592 0 0 0 .73-.2l.053-.018.019-.006.008-.003.003-.001h.001c.001-.001.002-.001-.667-1.886l.669 1.885A2 2 0 0 0 21 14.5v-10a2 2 0 0 0-2.657-1.889l-.005.002-.067.02c-.067.02-.178.051-.326.086-.3.07-.74.151-1.273.19-1.076.075-2.443-.033-3.78-.7C10.728 1.134 8.595.992 7.046 1.102c-.78.055-1.433.175-1.9.283a9.634 9.634 0 0 0-.783.219l-.019.006-.008.003-.003.001h-.001s-.001.001.187.531ZM5 3.5v10s.792-.281 2-.388c1.33-.118 3.165-.025 5 .888 3.5 1.742 7 .5 7 .5V4.499s-.792.282-2 .39c-1.33.117-3.165.024-5-.889-3.5-1.742-7-.5-7-.5Z", fill: "currentColor" }) })));
});
IconFlag.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconFlag = (IconFlag);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconHome.js



/**
 * Semantic vector graphics icon IconHome.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconHome size="large" color="green50" />
 */
const IconHome = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M12.614 1.21a1 1 0 0 0-1.228 0l-9 7A1 1 0 0 0 2 9v11a3 3 0 0 0 3 3h14a3 3 0 0 0 3-3V9a1 1 0 0 0-.386-.79l-9-7ZM16 21h3a1 1 0 0 0 1-1V9.49l-8-6.223-8 6.222V20a1 1 0 0 0 1 1h3v-9a1 1 0 0 1 1-1h6a1 1 0 0 1 1 1v9Zm-6 0v-8h4v8h-4Z", fill: "currentColor" }) })));
});
IconHome.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconHome = (IconHome);

// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconCrosshair.js
var IconCrosshair = __webpack_require__(7457);
;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconCompass.js



/**
 * Semantic vector graphics icon IconCompass.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconCompass size="large" color="green50" />
 */
const IconCompass = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M3 12a9 9 0 1 1 18 0 9 9 0 0 1-18 0Zm9-11C5.925 1 1 5.925 1 12s4.925 11 11 11 11-4.925 11-11S18.075 1 12 1Zm5.188 7.076a1 1 0 0 0-1.264-1.265l-6.36 2.12a1 1 0 0 0-.633.633l-2.12 6.36a1 1 0 0 0 1.265 1.265l6.36-2.12a1 1 0 0 0 .632-.633l2.12-6.36ZM9.341 14.66l1.33-3.988 3.988-1.33-1.33 3.988-3.988 1.33Z", fill: "currentColor" }) })));
});
IconCompass.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconCompass = (IconCompass);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconNavigation2.js



/**
 * Semantic vector graphics icon IconNavigation2.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconNavigation2 size="large" color="green50" />
 */
const IconNavigation2 = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M22.707 1.293a1 1 0 0 1 .197 1.135l-9 19a1 1 0 0 1-1.874-.186l-1.855-7.417-7.418-1.855a1 1 0 0 1-.185-1.874l19-9a1 1 0 0 1 1.135.197ZM5.953 10.708l5.29 1.322a1 1 0 0 1 .727.728l1.322 5.289 6.606-13.945-13.945 6.606Z", fill: "currentColor" }) })));
});
IconNavigation2.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconNavigation2 = (IconNavigation2);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconNavigation.js



/**
 * Semantic vector graphics icon IconNavigation.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconNavigation size="large" color="green50" />
 */
const IconNavigation = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M12 1a1 1 0 0 1 .938.654l7 19a1 1 0 0 1-1.434 1.214L12 18.152l-6.504 3.716a1 1 0 0 1-1.434-1.214l7-19A1 1 0 0 1 12 1ZM6.887 18.77l4.617-2.638a1 1 0 0 1 .992 0l4.617 2.638L12 4.893 6.887 18.77Z", fill: "currentColor" }) })));
});
IconNavigation.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconNavigation = (IconNavigation);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconMap.js



/**
 * Semantic vector graphics icon IconMap.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconMap size="large" color="green50" />
 */
const IconMap = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M8 1a.995.995 0 0 0-.511.14L.504 5.132A1 1 0 0 0 0 6v16a1 1 0 0 0 1.496.868l6.535-3.734 7.504 3.751a.994.994 0 0 0 .976-.026l6.985-3.99A1 1 0 0 0 24 18V2a1 1 0 0 0-1.496-.868l-6.536 3.734-7.503-3.751A.995.995 0 0 0 8.008 1H8Zm9 19.277 5-2.857V3.723L17 6.58v13.697ZM15 6.618l-6-3v13.764l6 3V6.618ZM2 6.58l5-2.857V17.42l-5 2.857V6.58Z", fill: "currentColor" }) })));
});
IconMap.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconMap = (IconMap);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconMapPin.js



/**
 * Semantic vector graphics icon IconMapPin.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconMapPin size="large" color="green50" />
 */
const IconMapPin = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M6.343 4.343A8 8 0 0 1 20 10c0 3.098-2.016 6.104-4.226 8.437A29.412 29.412 0 0 1 12 21.773a29.419 29.419 0 0 1-3.774-3.335C6.016 16.103 4 13.097 4 10a8 8 0 0 1 2.343-5.657Zm5.102 19.489L12 23l-.555.832a1 1 0 0 0 1.11 0L12 23l.555.832h.001l.002-.002.007-.005.023-.015.082-.057c.072-.05.174-.12.302-.214a31.433 31.433 0 0 0 4.254-3.727C19.516 17.397 22 13.903 22 10a10 10 0 0 0-20 0c0 3.902 2.484 7.396 4.774 9.813a31.428 31.428 0 0 0 4.254 3.726 18.887 18.887 0 0 0 .384.27l.023.016.007.005.002.001ZM10 10a2 2 0 1 1 4 0 2 2 0 0 1-4 0Zm2-4a4 4 0 1 0 0 8 4 4 0 0 0 0-8Z", fill: "currentColor" }) })));
});
IconMapPin.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconMapPin = (IconMapPin);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconGlobe.js



/**
 * Semantic vector graphics icon IconGlobe.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconGlobe size="large" color="green50" />
 */
const IconGlobe = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M9.726 3.29A9.008 9.008 0 0 0 3.055 11H7.05a16.3 16.3 0 0 1 2.676-7.71Zm4.548 0A16.3 16.3 0 0 1 16.95 11h3.995a9.008 9.008 0 0 0-6.67-7.71Zm.668 7.71A14.3 14.3 0 0 0 12 3.55 14.3 14.3 0 0 0 9.058 11h5.884Zm-5.884 2h5.884A14.3 14.3 0 0 1 12 20.45 14.3 14.3 0 0 1 9.058 13ZM7.05 13H3.055a9.008 9.008 0 0 0 6.67 7.71A16.3 16.3 0 0 1 7.05 13Zm7.224 7.71A16.3 16.3 0 0 0 16.95 13h3.995a9.008 9.008 0 0 1-6.67 7.71ZM12 23c6.075 0 11-4.925 11-11S18.075 1 12 1 1 5.925 1 12s4.925 11 11 11Z", fill: "currentColor" }) })));
});
IconGlobe.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconGlobe = (IconGlobe);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconStopCircle.js



/**
 * Semantic vector graphics icon IconStopCircle.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconStopCircle size="large" color="green50" />
 */
const IconStopCircle = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M3 12a9 9 0 1 1 18 0 9 9 0 0 1-18 0Zm9-11C5.925 1 1 5.925 1 12s4.925 11 11 11 11-4.925 11-11S18.075 1 12 1ZM9 8a1 1 0 0 0-1 1v6a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1V9a1 1 0 0 0-1-1H9Zm1 6v-4h4v4h-4Z", fill: "currentColor" }) })));
});
IconStopCircle.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconStopCircle = (IconStopCircle);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconPlayCircle.js



/**
 * Semantic vector graphics icon IconPlayCircle.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconPlayCircle size="large" color="green50" />
 */
const IconPlayCircle = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M3 12a9 9 0 1 1 18 0 9 9 0 0 1-18 0Zm9-11C5.925 1 1 5.925 1 12s4.925 11 11 11 11-4.925 11-11S18.075 1 12 1Zm-1.445 6.168A1 1 0 0 0 9 8v8a1 1 0 0 0 1.555.832l6-4a1 1 0 0 0 0-1.664l-6-4ZM14.197 12 11 14.132V9.869L14.197 12Z", fill: "currentColor" }) })));
});
IconPlayCircle.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconPlayCircle = (IconPlayCircle);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconPauseCircle.js



/**
 * Semantic vector graphics icon IconPauseCircle.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconPauseCircle size="large" color="green50" />
 */
const IconPauseCircle = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M12 3a9 9 0 1 0 0 18 9 9 0 0 0 0-18ZM1 12C1 5.925 5.925 1 12 1s11 4.925 11 11-4.925 11-11 11S1 18.075 1 12Zm9-4a1 1 0 0 1 1 1v6a1 1 0 1 1-2 0V9a1 1 0 0 1 1-1Zm5 1a1 1 0 1 0-2 0v6a1 1 0 1 0 2 0V9Z", fill: "currentColor" }) })));
});
IconPauseCircle.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconPauseCircle = (IconPauseCircle);

// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconStop.js
var IconStop = __webpack_require__(8166);
;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconPlay.js



/**
 * Semantic vector graphics icon IconPlay.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconPlay size="large" color="green50" />
 */
const IconPlay = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M4.52 2.122a1 1 0 0 1 1.02.037l14 9a1 1 0 0 1 0 1.682l-14 9A1 1 0 0 1 4 21V3a1 1 0 0 1 .52-.878ZM6 4.832v14.336L17.15 12 6 4.832Z", fill: "currentColor" }) })));
});
IconPlay.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconPlay = (IconPlay);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconPause.js



/**
 * Semantic vector graphics icon IconPause.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconPause size="large" color="green50" />
 */
const IconPause = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M6 3a1 1 0 0 0-1 1v16a1 1 0 0 0 1 1h4a1 1 0 0 0 1-1V4a1 1 0 0 0-1-1H6Zm1 16V5h2v14H7Zm7-16a1 1 0 0 0-1 1v16a1 1 0 0 0 1 1h4a1 1 0 0 0 1-1V4a1 1 0 0 0-1-1h-4Zm1 16V5h2v14h-2Z", fill: "currentColor" }) })));
});
IconPause.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconPause = (IconPause);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconSkipForward.js



/**
 * Semantic vector graphics icon IconSkipForward.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconSkipForward size="large" color="green50" />
 */
const IconSkipForward = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M5.625 3.22A1 1 0 0 0 4 4v16a1 1 0 0 0 1.625.78l10-8a1 1 0 0 0 0-1.56l-10-8ZM13.399 12 6 17.92V6.08L13.4 12ZM20 5a1 1 0 1 0-2 0v14a1 1 0 1 0 2 0V5Z", fill: "currentColor" }) })));
});
IconSkipForward.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconSkipForward = (IconSkipForward);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconSkipBack.js



/**
 * Semantic vector graphics icon IconSkipBack.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconSkipBack size="large" color="green50" />
 */
const IconSkipBack = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M20 4a1 1 0 0 0-1.625-.78l-10 8a1 1 0 0 0 0 1.56l10 8A1 1 0 0 0 20 20V4Zm-2 13.92L10.6 12 18 6.08v11.84ZM6 5a1 1 0 1 0-2 0v14a1 1 0 1 0 2 0V5Z", fill: "currentColor" }) })));
});
IconSkipBack.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconSkipBack = (IconSkipBack);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconForwardRight.js



/**
 * Semantic vector graphics icon IconForwardRight.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconForwardRight size="large" color="green50" />
 */
const IconForwardRight = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M2.614 4.21A1 1 0 0 0 1 5v14a1 1 0 0 0 1.614.79l9-7A1 1 0 0 0 12 12v7a1 1 0 0 0 1.614.79l9-7a1 1 0 0 0 0-1.58l-9-7A1 1 0 0 0 12 5v7a1 1 0 0 0-.386-.79l-9-7ZM9.37 12 3 16.955v-9.91L9.371 12Zm11 0L14 16.955v-9.91L20.371 12Z", fill: "currentColor" }) })));
});
IconForwardRight.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconForwardRight = (IconForwardRight);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconForwardLeft.js



/**
 * Semantic vector graphics icon IconForwardLeft.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconForwardLeft size="large" color="green50" />
 */
const IconForwardLeft = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M12 5a1 1 0 0 0-1.614-.79l-9 7a1 1 0 0 0 0 1.58l9 7A1 1 0 0 0 12 19v-7a1 1 0 0 0 .386.79l9 7A1 1 0 0 0 23 19V5a1 1 0 0 0-1.614-.79l-9 7A1 1 0 0 0 12 12V5Zm-2 11.955L3.629 12 10 7.045v9.91Zm11 0L14.629 12 21 7.045v9.91Z", fill: "currentColor" }) })));
});
IconForwardLeft.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconForwardLeft = (IconForwardLeft);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconShuffle.js



/**
 * Semantic vector graphics icon IconShuffle.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconShuffle size="large" color="green50" />
 */
const IconShuffle = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M16 4a1 1 0 1 1 0-2h5a1 1 0 0 1 1 1v5a1 1 0 1 1-2 0V5.414L4.707 20.707a1 1 0 0 1-1.414-1.414L18.586 4H16ZM3.293 3.293a1 1 0 0 1 1.414 0l5 5a1 1 0 0 1-1.414 1.414l-5-5a1 1 0 0 1 0-1.414Zm11 12.414a1 1 0 0 1 1.414-1.414L20 18.586V16a1 1 0 1 1 2 0v5a1 1 0 0 1-1 1h-5a1 1 0 1 1 0-2h2.586l-4.293-4.293Z", fill: "currentColor" }) })));
});
IconShuffle.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconShuffle = (IconShuffle);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconRepeat.js



/**
 * Semantic vector graphics icon IconRepeat.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconRepeat size="large" color="green50" />
 */
const IconRepeat = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M16.293.293a1 1 0 0 1 1.414 0l4 4a1 1 0 0 1 0 1.414l-4 4a1 1 0 0 1-1.414-1.414L18.586 6H7a3 3 0 0 0-3 3v2a1 1 0 1 1-2 0V9a5 5 0 0 1 5-5h11.586l-2.293-2.293a1 1 0 0 1 0-1.414ZM20 15v-2a1 1 0 1 1 2 0v2a5 5 0 0 1-5 5H5.414l2.293 2.293a1 1 0 1 1-1.414 1.414l-4-4a1 1 0 0 1 0-1.414l4-4a1 1 0 0 1 1.414 1.414L5.414 18H17a3 3 0 0 0 3-3Z", fill: "currentColor" }) })));
});
IconRepeat.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconRepeat = (IconRepeat);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconRefreshLeft.js



/**
 * Semantic vector graphics icon IconRefreshLeft.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconRefreshLeft size="large" color="green50" />
 */
const IconRefreshLeft = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M9.227 2.396a10 10 0 0 1 12.206 6.27 1 1 0 1 1-1.886.668A8 8 0 0 0 6.325 6.369L3.525 9H7a1 1 0 0 1 0 2H1a1 1 0 0 1-1-1V4a1 1 0 0 1 2 0v3.688l2.944-2.766a10 10 0 0 1 4.283-2.526ZM16 14a1 1 0 0 1 1-1h6a1 1 0 0 1 1 1v6a1 1 0 1 1-2 0v-3.688l-2.944 2.766a10 10 0 0 1-16.489-3.744 1 1 0 0 1 1.886-.668 8 8 0 0 0 13.213 2.974l.01-.009 2.8-2.631H17a1 1 0 0 1-1-1Z", fill: "currentColor" }) })));
});
IconRefreshLeft.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconRefreshLeft = (IconRefreshLeft);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconRefreshRight.js



/**
 * Semantic vector graphics icon IconRefreshRight.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconRefreshRight size="large" color="green50" />
 */
const IconRefreshRight = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M14.217 4.317a8 8 0 0 0-9.764 5.017 1 1 0 1 1-1.886-.668 10 10 0 0 1 16.489-3.744L22 7.688V4a1 1 0 1 1 2 0v6a1 1 0 0 1-1 1h-6a1 1 0 1 1 0-2h3.476l-2.8-2.631a8 8 0 0 0-3.458-2.051ZM0 14a1 1 0 0 1 1-1h6a1 1 0 1 1 0 2H3.525l2.8 2.631a8 8 0 0 0 13.223-2.965 1 1 0 0 1 1.885.668 10 10 0 0 1-16.489 3.744L2 16.312V20a1 1 0 1 1-2 0v-6Z", fill: "currentColor" }) })));
});
IconRefreshRight.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconRefreshRight = (IconRefreshRight);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconGithub.js



/**
 * Semantic vector graphics icon IconGithub.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconGithub size="large" color="green50" />
 */
const IconGithub = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M12 0C5.37 0 0 5.506 0 12.303c0 5.445 3.435 10.043 8.205 11.674.6.107.825-.262.825-.585 0-.292-.015-1.261-.015-2.291C6 21.67 5.22 20.346 4.98 19.654c-.135-.354-.72-1.446-1.23-1.738-.42-.23-1.02-.8-.015-.815.945-.015 1.62.892 1.845 1.261 1.08 1.86 2.805 1.338 3.495 1.015.105-.8.42-1.338.765-1.645-2.67-.308-5.46-1.37-5.46-6.075 0-1.338.465-2.446 1.23-3.307-.12-.308-.54-1.569.12-3.26 0 0 1.005-.323 3.3 1.26.96-.276 1.98-.415 3-.415s2.04.139 3 .416c2.295-1.6 3.3-1.261 3.3-1.261.66 1.691.24 2.952.12 3.26.765.861 1.23 1.953 1.23 3.307 0 4.721-2.805 5.767-5.475 6.075.435.384.81 1.122.81 2.276 0 1.645-.015 2.968-.015 3.383 0 .323.225.707.825.585a12.047 12.047 0 0 0 5.919-4.489A12.536 12.536 0 0 0 24 12.304C24 5.505 18.63 0 12 0Z", fill: "currentColor" }) })));
});
IconGithub.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconGithub = (IconGithub);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconDocker.js



/**
 * Semantic vector graphics icon IconDocker.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconDocker size="large" color="green50" />
 */
const IconDocker = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { d: "M23.723 10.413a3.803 3.803 0 0 0-2.852-.342 3.693 3.693 0 0 0-1.551-2.428l-.314-.24-.25.305a3.351 3.351 0 0 0-.618 2.363c.054.556.248 1.09.563 1.551-.249.13-.563.25-.812.379-.54.17-1.105.25-1.671.24H.137l-.102.35A6.997 6.997 0 0 0 .6 16.127l.24.434v.064c1.495 2.484 4.163 3.6 7.08 3.6 5.539 0 10.155-2.418 12.351-7.634 1.431.065 2.862-.313 3.545-1.68l.185-.304-.277-.194ZM4.854 16.875a1.302 1.302 0 0 1-1.301-1.265 1.302 1.302 0 0 1 2.603 0 1.302 1.302 0 0 1-1.302 1.265Zm8.004-7.727h-2.419v2.419h2.419V9.148Zm0-3.037h-2.419V8.53h2.419V6.11Zm0-3.111h-2.419v2.428h2.419V3Zm2.981 6.148h-2.418v2.419h2.418V9.148Zm-9 0H4.42v2.419H6.84V9.148Zm3.046 0H7.421v2.419h2.427l.037-2.419Zm-6.028 0H1.44v2.419h2.418V9.148Zm6.028-3.037H7.421V8.53h2.427l.037-2.419Zm-3.046 0H4.42V8.53H6.84V6.074v.037Z", fill: "currentColor" }) })));
});
IconDocker.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconDocker = (IconDocker);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconGitlab.js



/**
 * Semantic vector graphics icon IconGitlab.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconGitlab size="large" color="green50" />
 */
const IconGitlab = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M4.557 2.482a.63.63 0 0 1-.004-.012l.004.012Zm.55 1.69L7 9.98a1 1 0 0 0 .951.69h8.1a1 1 0 0 0 .951-.691l1.886-5.804L20.779 10l1.224 3.625L12 20.894l-9.964-7.242 3.071-9.48Zm17.04 9.526-.08-.11a.157.157 0 0 1 .04-.037l.087.134-.047.013Zm.024.032.479.66-.436-.674-.043.014Zm1.05 1.482-10.633 7.727a1 1 0 0 1-1.176 0l-10.65-7.74-.004-.003a1.84 1.84 0 0 1-.659-2.056L3.76 1.851a1.42 1.42 0 0 1 .388-.591 1.43 1.43 0 0 1 1.948.021c.17.165.297.37.368.596L8.676 8.67h6.647l2.216-6.819a1.421 1.421 0 0 1 .388-.591 1.43 1.43 0 0 1 1.948.021c.17.165.297.37.368.597l2.436 7.497 1.268 3.755a.938.938 0 0 1 .006.018l.007.022a1.84 1.84 0 0 1-.74 2.042ZM17.926 1.26l.002-.002L18.6 2l-.674-.738.001-.002Zm1.344 1.482.003-.004-.003.004Z", fill: "currentColor" }) })));
});
IconGitlab.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconGitlab = (IconGitlab);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconMoon.js



/**
 * Semantic vector graphics icon IconMoon.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconMoon size="large" color="green50" />
 */
const IconMoon = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M12.043 2.509a1 1 0 0 1-.067 1.085 6 6 0 0 0 8.391 8.392 1 1 0 0 1 1.59.896A10 10 0 1 1 11.08 2.004a1 1 0 0 1 .963.505Zm-2.765 1.93a8 8 0 1 0 10.245 10.245A8 8 0 0 1 9.278 4.439Z", fill: "currentColor" }) })));
});
IconMoon.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconMoon = (IconMoon);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconSun.js



/**
 * Semantic vector graphics icon IconSun.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconSun size="large" color="green50" />
 */
const IconSun = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M12 0a1 1 0 0 1 1 1v2a1 1 0 1 1-2 0V1a1 1 0 0 1 1-1ZM3.513 3.513a1 1 0 0 1 1.414 0l1.42 1.42a1 1 0 0 1-1.414 1.414l-1.42-1.42a1 1 0 0 1 0-1.414Zm16.974 0a1 1 0 0 1 0 1.414l-1.42 1.42a1 1 0 1 1-1.414-1.414l1.42-1.42a1 1 0 0 1 1.414 0ZM12 8a4 4 0 1 0 0 8 4 4 0 0 0 0-8Zm-6 4a6 6 0 1 1 12 0 6 6 0 0 1-12 0Zm-6 0a1 1 0 0 1 1-1h2a1 1 0 1 1 0 2H1a1 1 0 0 1-1-1Zm20 0a1 1 0 0 1 1-1h2a1 1 0 1 1 0 2h-2a1 1 0 0 1-1-1ZM6.347 17.653a1 1 0 0 1 0 1.414l-1.42 1.42a1 1 0 0 1-1.414-1.414l1.42-1.42a1 1 0 0 1 1.414 0Zm11.306 0a1 1 0 0 1 1.414 0l1.42 1.42a1 1 0 0 1-1.414 1.414l-1.42-1.42a1 1 0 0 1 0-1.414ZM12 20a1 1 0 0 1 1 1v2a1 1 0 1 1-2 0v-2a1 1 0 0 1 1-1Z", fill: "currentColor" }) })));
});
IconSun.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconSun = (IconSun);

// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconRecCircle.js
var IconRecCircle = __webpack_require__(3581);
// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconFilledTriangle.js
var IconFilledTriangle = __webpack_require__(7185);
;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconPartners.js



/**
 * Semantic vector graphics icon IconPartners.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconPartners size="large" color="green50" />
 */
const IconPartners = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "m8.008 4 1-.009-.017-2-1 .009a8.072 8.072 0 0 0-5.627 13.778l5.686 5.685a6.999 6.999 0 0 0 9.9 0l1.636-1.636a4 4 0 0 0 0-5.655l-3.613-3.613-.708-.707-1.414 1.414.707.707 3.613 3.613a2 2 0 0 1 .202 2.591l-3.166-3.166-1.414 1.415 3.183 3.183-.44.44a5 5 0 0 1-.845.68l-3.101-3.102-1.414 1.415 2.435 2.435a5.003 5.003 0 0 1-4.147-1.428l-5.686-5.685a6.072 6.072 0 0 1 0-8.586l-.707-.707.708.706A6.048 6.048 0 0 1 8.009 4Zm3.628 1.778a6.072 6.072 0 0 1 9.505 7.409l-.513.858 1.717 1.026.513-.859a8.074 8.074 0 0 0-1.223-9.848l-.706.707.706-.707a8.072 8.072 0 0 0-11.413 0l-4.93 4.929-.706.707.707.707.172.172a5 5 0 0 0 7.07 0l2.172-2.172.707-.707L14 6.586l-.707.707-2.172 2.172a3 3 0 0 1-3.638.466l4.153-4.153Z", fill: "currentColor" }) })));
});
IconPartners.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconPartners = (IconPartners);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconUnlink2.js



/**
 * Semantic vector graphics icon IconUnlink2.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconUnlink2 size="large" color="green50" />
 */
const IconUnlink2 = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M8 1a1 1 0 0 1 1 1v3a1 1 0 0 1-2 0V2a1 1 0 0 1 1-1Zm4.776 1.75a6.006 6.006 0 0 1 8.338 0l.002.002a6.004 6.004 0 0 1 .281 8.335.998.998 0 0 1-.132.162l-1.72 1.71a1 1 0 0 1-1.41-1.418l1.591-1.582a1 1 0 0 1 .094-.113 4.004 4.004 0 0 0-.095-5.657 4.006 4.006 0 0 0-5.556-.004l-1.714 1.704a1 1 0 1 1-1.41-1.418l1.72-1.71.01-.01ZM1 8a1 1 0 0 1 1-1h3a1 1 0 0 1 0 2H2a1 1 0 0 1-1-1Zm4.877 3.043a1 1 0 0 1 0 1.414l-1.703 1.704a4.004 4.004 0 0 0 .1 5.65 4.006 4.006 0 0 0 5.556.005l1.703-1.703a1 1 0 0 1 1.414 1.414l-1.71 1.71-.013.013a6.006 6.006 0 0 1-8.338 0l-.002-.002a6.004 6.004 0 0 1-.143-8.482l.012-.013 1.71-1.71a1 1 0 0 1 1.414 0ZM18 16a1 1 0 0 1 1-1h3a1 1 0 1 1 0 2h-3a1 1 0 0 1-1-1Zm-2 2a1 1 0 0 1 1 1v3a1 1 0 1 1-2 0v-3a1 1 0 0 1 1-1Z", fill: "currentColor" }) })));
});
IconUnlink2.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconUnlink2 = (IconUnlink2);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconFileInput.js



/**
 * Semantic vector graphics icon IconFileInput.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconFileInput size="large" color="green50" />
 */
const IconFileInput = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M3.879 1.879A3 3 0 0 1 6 1h8.5a1 1 0 0 1 .707.293l5.5 5.5A1 1 0 0 1 21 7.5V20a3 3 0 0 1-3 3H4a1 1 0 1 1 0-2h14a1 1 0 0 0 1-1V9h-5a1 1 0 0 1-1-1V3H6a1 1 0 0 0-1 1v4a1 1 0 0 1-2 0V4a3 3 0 0 1 .879-2.121ZM15 3.914V7h3.086L15 3.914Zm-6.707 7.379a1 1 0 0 1 1.414 0l3 3a1 1 0 0 1 0 1.414l-3 3a1 1 0 0 1-1.414-1.414L9.586 16H2a1 1 0 1 1 0-2h7.586l-1.293-1.293a1 1 0 0 1 0-1.414Z", fill: "currentColor" }) })));
});
IconFileInput.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconFileInput = (IconFileInput);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconTrendingUp.js



/**
 * Semantic vector graphics icon IconTrendingUp.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconTrendingUp size="large" color="green50" />
 */
const IconTrendingUp = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M17 7a1 1 0 1 1 0-2h6a1 1 0 0 1 1 1v6a1 1 0 1 1-2 0V8.414l-7.793 7.793a1 1 0 0 1-1.414 0L8.5 11.914l-6.793 6.793a1 1 0 0 1-1.414-1.414l7.5-7.5a1 1 0 0 1 1.414 0l4.293 4.293L20.586 7H17Z", fill: "currentColor" }) })));
});
IconTrendingUp.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconTrendingUp = (IconTrendingUp);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconTrendingDown.js



/**
 * Semantic vector graphics icon IconTrendingDown.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconTrendingDown size="large" color="green50" />
 */
const IconTrendingDown = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M1.707 5.293A1 1 0 0 0 .293 6.707l7.5 7.5a1 1 0 0 0 1.414 0L13.5 9.914 20.586 17H17a1 1 0 1 0 0 2h6.003a.996.996 0 0 0 .996-.952L24 18v-6a1 1 0 1 0-2 0v3.586l-7.793-7.793a1 1 0 0 0-1.414 0L8.5 12.086 1.707 5.293Z", fill: "currentColor" }) })));
});
IconTrendingDown.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconTrendingDown = (IconTrendingDown);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconMinimize2.js



/**
 * Semantic vector graphics icon IconMinimize2.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconMinimize2 size="large" color="green50" />
 */
const IconMinimize2 = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M8 2a1 1 0 0 1 1 1v3a3 3 0 0 1-3 3H3a1 1 0 0 1 0-2h3a1 1 0 0 0 1-1V3a1 1 0 0 1 1-1Zm8 0a1 1 0 0 1 1 1v3a1 1 0 0 0 1 1h3a1 1 0 1 1 0 2h-3a3 3 0 0 1-3-3V3a1 1 0 0 1 1-1ZM2 16a1 1 0 0 1 1-1h3a3 3 0 0 1 3 3v3a1 1 0 1 1-2 0v-3a1 1 0 0 0-1-1H3a1 1 0 0 1-1-1Zm16 1a1 1 0 0 0-1 1v3a1 1 0 1 1-2 0v-3a3 3 0 0 1 3-3h3a1 1 0 1 1 0 2h-3Z", fill: "currentColor" }) })));
});
IconMinimize2.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconMinimize2 = (IconMinimize2);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconMaximize2.js



/**
 * Semantic vector graphics icon IconMaximize2.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconMaximize2 size="large" color="green50" />
 */
const IconMaximize2 = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M2.879 2.879A3 3 0 0 1 5 2h3a1 1 0 0 1 0 2H5a1 1 0 0 0-1 1v3a1 1 0 0 1-2 0V5a3 3 0 0 1 .879-2.121ZM15 3a1 1 0 0 1 1-1h3a3 3 0 0 1 3 3v3a1 1 0 1 1-2 0V5a1 1 0 0 0-1-1h-3a1 1 0 0 1-1-1ZM3 15a1 1 0 0 1 1 1v3a1 1 0 0 0 1 1h3a1 1 0 1 1 0 2H5a3 3 0 0 1-3-3v-3a1 1 0 0 1 1-1Zm18 0a1 1 0 0 1 1 1v3a3 3 0 0 1-3 3h-3a1 1 0 1 1 0-2h3a1 1 0 0 0 1-1v-3a1 1 0 0 1 1-1Z", fill: "currentColor" }) })));
});
IconMaximize2.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconMaximize2 = (IconMaximize2);

// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconSortFilled.js
var IconSortFilled = __webpack_require__(7060);
// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconFilledCircle.js
var IconFilledCircle = __webpack_require__(2062);
;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconEmpty.js



/**
 * Semantic vector graphics icon IconEmpty.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconEmpty size="large" color="green50" />
 */
const IconEmpty = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M7.153 1.293A1 1 0 0 1 7.86 1h8.28a1 1 0 0 1 .707.293l5.86 5.86A1 1 0 0 1 23 7.86v8.28a1 1 0 0 1-.293.707l-5.86 5.86a1 1 0 0 1-.707.293H7.86a1 1 0 0 1-.707-.293l-5.86-5.86A1 1 0 0 1 1 16.14V7.86a1 1 0 0 1 .293-.707l5.86-5.86ZM8.274 3 3 8.274v7.452L8.274 21h7.452L21 15.726V8.274L15.726 3H8.274Z", fill: "currentColor" }) })));
});
IconEmpty.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconEmpty = (IconEmpty);

// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconX.js
var IconX = __webpack_require__(845);
;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconExclamation.js



/**
 * Semantic vector graphics icon IconExclamation.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconExclamation size="large" color="green50" />
 */
const IconExclamation = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M7.153 1.293A1 1 0 0 1 7.86 1h8.28a1 1 0 0 1 .707.293l5.86 5.86A1 1 0 0 1 23 7.86v8.28a1 1 0 0 1-.293.707l-5.86 5.86a1 1 0 0 1-.707.293H7.86a1 1 0 0 1-.707-.293l-5.86-5.86A1 1 0 0 1 1 16.14V7.86a1 1 0 0 1 .293-.707l5.86-5.86ZM8.274 3 3 8.274v7.452L8.274 21h7.452L21 15.726V8.274L15.726 3H8.274ZM12 7a1 1 0 0 1 1 1v4a1 1 0 1 1-2 0V8a1 1 0 0 1 1-1Zm0 8a1 1 0 1 0 0 2h.01a1 1 0 1 0 0-2H12Z", fill: "currentColor" }) })));
});
IconExclamation.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconExclamation = (IconExclamation);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconBan.js



/**
 * Semantic vector graphics icon IconBan.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconBan size="large" color="green50" />
 */
const IconBan = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M6.382 4.968a9 9 0 0 1 12.65 12.65L6.382 4.968ZM4.968 6.382a9 9 0 0 0 12.65 12.65L4.967 6.382ZM12 1C5.925 1 1 5.925 1 12s4.925 11 11 11 11-4.925 11-11S18.075 1 12 1Z", fill: "currentColor" }) })));
});
IconBan.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconBan = (IconBan);

// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconCheck.js
var IconCheck = __webpack_require__(6137);
;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconPlus.js



/**
 * Semantic vector graphics icon IconPlus.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconPlus size="large" color="green50" />
 */
const IconPlus = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M13 5a1 1 0 1 0-2 0v6H5a1 1 0 1 0 0 2h6v6a1 1 0 1 0 2 0v-6h6a1 1 0 1 0 0-2h-6V5Z", fill: "currentColor" }) })));
});
IconPlus.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconPlus = (IconPlus);

// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconMinus.js
var IconMinus = __webpack_require__(6470);
;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconEmptyTriangle.js



/**
 * Semantic vector graphics icon IconEmptyTriangle.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconEmptyTriangle size="large" color="green50" />
 */
const IconEmptyTriangle = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M10.528 2.283a3 3 0 0 1 4.037 1.058l.003.005 8.47 14.14.008.014a2.998 2.998 0 0 1-2.565 4.5H3.519a2.999 2.999 0 0 1-2.565-4.5l.008-.014 8.47-14.14.858.514-.855-.519a3 3 0 0 1 1.093-1.058Zm.618 2.094L2.683 18.506A1 1 0 0 0 3.536 20h16.928a1 1 0 0 0 .853-1.494L12.855 4.379l-.001-.002a1 1 0 0 0-1.708 0Z", fill: "currentColor" }) })));
});
IconEmptyTriangle.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconEmptyTriangle = (IconEmptyTriangle);

// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconExclamationTriangle.js
var IconExclamationTriangle = __webpack_require__(6699);
;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconEmptySquare.js



/**
 * Semantic vector graphics icon IconEmptySquare.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconEmptySquare size="large" color="green50" />
 */
const IconEmptySquare = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M5 4a1 1 0 0 0-1 1v14a1 1 0 0 0 1 1h14a1 1 0 0 0 1-1V5a1 1 0 0 0-1-1H5ZM2 5a3 3 0 0 1 3-3h14a3 3 0 0 1 3 3v14a3 3 0 0 1-3 3H5a3 3 0 0 1-3-3V5Z", fill: "currentColor" }) })));
});
IconEmptySquare.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconEmptySquare = (IconEmptySquare);

// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconCheckSquare.js
var IconCheckSquare = __webpack_require__(5584);
;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconXSquare.js



/**
 * Semantic vector graphics icon IconXSquare.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconXSquare size="large" color="green50" />
 */
const IconXSquare = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M5 4a1 1 0 0 0-1 1v14a1 1 0 0 0 1 1h14a1 1 0 0 0 1-1V5a1 1 0 0 0-1-1H5ZM2 5a3 3 0 0 1 3-3h14a3 3 0 0 1 3 3v14a3 3 0 0 1-3 3H5a3 3 0 0 1-3-3V5Zm6.293 3.293a1 1 0 0 1 1.414 0L12 10.586l2.293-2.293a1 1 0 1 1 1.414 1.414L13.414 12l2.293 2.293a1 1 0 0 1-1.414 1.414L12 13.414l-2.293 2.293a1 1 0 0 1-1.414-1.414L10.586 12 8.293 9.707a1 1 0 0 1 0-1.414Z", fill: "currentColor" }) })));
});
IconXSquare.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconXSquare = (IconXSquare);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconPlusSquare.js



/**
 * Semantic vector graphics icon IconPlusSquare.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconPlusSquare size="large" color="green50" />
 */
const IconPlusSquare = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M5 4a1 1 0 0 0-1 1v14a1 1 0 0 0 1 1h14a1 1 0 0 0 1-1V5a1 1 0 0 0-1-1H5ZM2 5a3 3 0 0 1 3-3h14a3 3 0 0 1 3 3v14a3 3 0 0 1-3 3H5a3 3 0 0 1-3-3V5Zm10 2a1 1 0 0 1 1 1v3h3a1 1 0 1 1 0 2h-3v3a1 1 0 1 1-2 0v-3H8a1 1 0 1 1 0-2h3V8a1 1 0 0 1 1-1Z", fill: "currentColor" }) })));
});
IconPlusSquare.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconPlusSquare = (IconPlusSquare);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconMinusSquare.js



/**
 * Semantic vector graphics icon IconMinusSquare.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconMinusSquare size="large" color="green50" />
 */
const IconMinusSquare = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M4 5a1 1 0 0 1 1-1h14a1 1 0 0 1 1 1v14a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1V5Zm1-3a3 3 0 0 0-3 3v14a3 3 0 0 0 3 3h14a3 3 0 0 0 3-3V5a3 3 0 0 0-3-3H5Zm3 9a1 1 0 1 0 0 2h8a1 1 0 1 0 0-2H8Z", fill: "currentColor" }) })));
});
IconMinusSquare.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconMinusSquare = (IconMinusSquare);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconEmptyCircle.js



/**
 * Semantic vector graphics icon IconEmptyCircle.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconEmptyCircle size="large" color="green50" />
 */
const IconEmptyCircle = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M12 3a9 9 0 1 0 0 18 9 9 0 0 0 0-18ZM1 12C1 5.925 5.925 1 12 1s11 4.925 11 11-4.925 11-11 11S1 18.075 1 12Z", fill: "currentColor" }) })));
});
IconEmptyCircle.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconEmptyCircle = (IconEmptyCircle);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconInfoCircle.js



/**
 * Semantic vector graphics icon IconInfoCircle.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconInfoCircle size="large" color="green50" />
 */
const IconInfoCircle = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M12 3a9 9 0 1 0 0 18 9 9 0 0 0 0-18ZM1 12C1 5.925 5.925 1 12 1s11 4.925 11 11-4.925 11-11 11S1 18.075 1 12Zm11-1a1 1 0 0 1 1 1v4a1 1 0 1 1-2 0v-4a1 1 0 0 1 1-1Zm0-4a1 1 0 1 0 0 2h.01a1 1 0 1 0 0-2H12Z", fill: "currentColor" }) })));
});
IconInfoCircle.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconInfoCircle = (IconInfoCircle);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconCheckCircle.js



/**
 * Semantic vector graphics icon IconCheckCircle.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconCheckCircle size="large" color="green50" />
 */
const IconCheckCircle = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M10.017 3.216a9 9 0 0 1 5.646.557 1 1 0 1 0 .814-1.826A11 11 0 1 0 23 12v-.921a1 1 0 1 0-2 0V12a9 9 0 1 1-10.983-8.784Zm12.69 1.49a1 1 0 0 0-1.415-1.413L12 12.595l-2.293-2.292a1 1 0 1 0-1.414 1.414l3 3a1 1 0 0 0 1.415 0l10-10.01Z", fill: "currentColor" }) })));
});
IconCheckCircle.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconCheckCircle = (IconCheckCircle);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconXCircle.js



/**
 * Semantic vector graphics icon IconXCircle.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconXCircle size="large" color="green50" />
 */
const IconXCircle = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M12 3a9 9 0 1 0 0 18 9 9 0 0 0 0-18ZM1 12C1 5.925 5.925 1 12 1s11 4.925 11 11-4.925 11-11 11S1 18.075 1 12Zm14.707-3.707a1 1 0 0 1 0 1.414L13.414 12l2.293 2.293a1 1 0 0 1-1.414 1.414L12 13.414l-2.293 2.293a1 1 0 0 1-1.414-1.414L10.586 12 8.293 9.707a1 1 0 0 1 1.414-1.414L12 10.586l2.293-2.293a1 1 0 0 1 1.414 0Z", fill: "currentColor" }) })));
});
IconXCircle.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconXCircle = (IconXCircle);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconPlusCircle.js



/**
 * Semantic vector graphics icon IconPlusCircle.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconPlusCircle size="large" color="green50" />
 */
const IconPlusCircle = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M12 3a9 9 0 1 0 0 18 9 9 0 0 0 0-18ZM1 12C1 5.925 5.925 1 12 1s11 4.925 11 11-4.925 11-11 11S1 18.075 1 12Zm11-5a1 1 0 0 1 1 1v3h3a1 1 0 1 1 0 2h-3v3a1 1 0 1 1-2 0v-3H8a1 1 0 1 1 0-2h3V8a1 1 0 0 1 1-1Z", fill: "currentColor" }) })));
});
IconPlusCircle.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconPlusCircle = (IconPlusCircle);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconMinusCircle.js



/**
 * Semantic vector graphics icon IconMinusCircle.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconMinusCircle size="large" color="green50" />
 */
const IconMinusCircle = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M3 12a9 9 0 1 1 18 0 9 9 0 0 1-18 0Zm9-11C5.925 1 1 5.925 1 12s4.925 11 11 11 11-4.925 11-11S18.075 1 12 1ZM8 11a1 1 0 1 0 0 2h8a1 1 0 1 0 0-2H8Z", fill: "currentColor" }) })));
});
IconMinusCircle.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconMinusCircle = (IconMinusCircle);

// EXTERNAL MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconQuestionCircle.js
var IconQuestionCircle = __webpack_require__(4019);
;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconExclamationCircle.js



/**
 * Semantic vector graphics icon IconExclamationCircle.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconExclamationCircle size="large" color="green50" />
 */
const IconExclamationCircle = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M12 3a9 9 0 1 0 0 18 9 9 0 0 0 0-18ZM1 12C1 5.925 5.925 1 12 1s11 4.925 11 11-4.925 11-11 11S1 18.075 1 12Zm11-5a1 1 0 0 1 1 1v4a1 1 0 1 1-2 0V8a1 1 0 0 1 1-1Zm0 8a1 1 0 1 0 0 2h.01a1 1 0 1 0 0-2H12Z", fill: "currentColor" }) })));
});
IconExclamationCircle.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconExclamationCircle = (IconExclamationCircle);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconTable.js



/**
 * Semantic vector graphics icon IconTable.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconTable size="large" color="green50" />
 */
const IconTable = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M5 22a3 3 0 0 1-3-3V5a3 3 0 0 1 3-3h14a3 3 0 0 1 3 3v14a3 3 0 0 1-3 3H5ZM4 5a1 1 0 0 1 1-1h6v4H4V5Zm7 5H4v4h7v-4Zm2 4v-4h7v4h-7Zm-2 2H4v3a1 1 0 0 0 1 1h6v-4Zm2 4v-4h7v3a1 1 0 0 1-1 1h-6Zm0-16h6a1 1 0 0 1 1 1v3h-7V4Z", fill: "currentColor" }) })));
});
IconTable.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconTable = (IconTable);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconFrame.js



/**
 * Semantic vector graphics icon IconFrame.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconFrame size="large" color="green50" />
 */
const IconFrame = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M6 1a1 1 0 0 1 1 1v3h10V2a1 1 0 1 1 2 0v3h3a1 1 0 1 1 0 2h-3v10h3a1 1 0 1 1 0 2h-3v3a1 1 0 1 1-2 0v-3H7v3a1 1 0 1 1-2 0v-3H2a1 1 0 1 1 0-2h3V7H2a1 1 0 0 1 0-2h3V2a1 1 0 0 1 1-1Zm11 16V7H7v10h10Z", fill: "currentColor" }) })));
});
IconFrame.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconFrame = (IconFrame);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconFocus.js



/**
 * Semantic vector graphics icon IconFocus.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconFocus size="large" color="green50" />
 */
const IconFocus = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsxs)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: [(0,jsx_runtime.jsx)("path", { d: "M5 4a1 1 0 0 0-1 1v2a1 1 0 0 1-2 0V5a3 3 0 0 1 3-3h2a1 1 0 0 1 0 2H5Z", fill: "currentColor" }), (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M8 12a4 4 0 1 1 8 0 4 4 0 0 1-8 0Zm4-2a2 2 0 1 0 0 4 2 2 0 0 0 0-4Z", fill: "currentColor" }), (0,jsx_runtime.jsx)("path", { d: "M17 2a1 1 0 1 0 0 2h2a1 1 0 0 1 1 1v2a1 1 0 1 0 2 0V5a3 3 0 0 0-3-3h-2ZM21 16a1 1 0 0 1 1 1v2a3 3 0 0 1-3 3h-2a1 1 0 1 1 0-2h2a1 1 0 0 0 1-1v-2a1 1 0 0 1 1-1ZM4 17a1 1 0 1 0-2 0v2a3 3 0 0 0 3 3h2a1 1 0 1 0 0-2H5a1 1 0 0 1-1-1v-2Z", fill: "currentColor" })] })));
});
IconFocus.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconFocus = (IconFocus);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconCurlyBraces.js



/**
 * Semantic vector graphics icon IconCurlyBraces.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconCurlyBraces size="large" color="green50" />
 */
const IconCurlyBraces = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { d: "M7 2a3 3 0 0 0-3 3v5a1 1 0 0 1-1 1 1 1 0 1 0 0 2 1 1 0 0 1 1 1v5c0 1.652 1.348 3 3 3h1a1 1 0 1 0 0-2H7c-.548 0-1-.452-1-1v-5a3 3 0 0 0-.764-2A3 3 0 0 0 6 10V5a1 1 0 0 1 1-1h1a1 1 0 0 0 0-2H7ZM16 2a1 1 0 1 0 0 2h1a1 1 0 0 1 1 1v5a3 3 0 0 0 .765 2.002A2.988 2.988 0 0 0 18 14v5a1 1 0 0 1-1 1h-1a1 1 0 1 0 0 2h1a3 3 0 0 0 3-3v-5c0-.548.452-1 1-1a1 1 0 1 0 0-2 1 1 0 0 1-1-1V5a3 3 0 0 0-3-3h-1Z", fill: "currentColor" }) })));
});
IconCurlyBraces.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconCurlyBraces = (IconCurlyBraces);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconNote.js



/**
 * Semantic vector graphics icon IconNote.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconNote size="large" color="green50" />
 */
const IconNote = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M5 2a3 3 0 0 0-3 3v14c0 1.652 1.348 3 3 3h14a3 3 0 0 0 3-3V8.5a1 1 0 0 0-.293-.707l-5.5-5.5A1 1 0 0 0 15.5 2H5Zm9 2H5a1 1 0 0 0-1 1v14c0 .548.452 1 1 1h14a1 1 0 0 0 1-1v-9h-5a1 1 0 0 1-1-1V4Zm5.086 4H16V4.914L19.086 8Z", fill: "currentColor" }) })));
});
IconNote.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconNote = (IconNote);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconBrandgoogle.js



/**
 * Semantic vector graphics icon IconBrandgoogle.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconBrandgoogle size="large" color="green50" />
 */
const IconBrandgoogle = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsxs)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: [(0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M23.52 12.273c0-.852-.076-1.669-.219-2.454H12v4.641h6.459a5.52 5.52 0 0 1-2.395 3.621v3.012h3.877c2.27-2.089 3.579-5.166 3.579-8.82Z", fill: "#4285F4" }), (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M12 24c3.24 0 5.956-1.075 7.941-2.907l-3.877-3.012c-1.075.72-2.45 1.147-4.064 1.147-3.125 0-5.77-2.112-6.715-4.948h-4.01v3.11A11.996 11.996 0 0 0 12 24Z", fill: "#34A853" }), (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M5.285 14.28A7.213 7.213 0 0 1 4.91 12c0-.79.136-1.56.376-2.28V6.61H1.276A11.995 11.995 0 0 0 0 12c0 1.936.464 3.77 1.276 5.39l4.01-3.11Z", fill: "#FBBC05" }), (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M12 4.773c1.761 0 3.344.606 4.587 1.794l3.442-3.44C17.951 1.188 15.235 0 12 0A11.996 11.996 0 0 0 1.277 6.61l4.01 3.11C6.228 6.884 8.874 4.773 12 4.773Z", fill: "#EA4335" })] })));
});
IconBrandgoogle.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconBrandgoogle = (IconBrandgoogle);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconBrandlinkedin.js



/**
 * Semantic vector graphics icon IconBrandlinkedin.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconBrandlinkedin size="large" color="green50" />
 */
const IconBrandlinkedin = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsxs)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: [(0,jsx_runtime.jsx)("path", { d: "M22.224 0H1.77C.794 0 0 .775 0 1.73v20.538C0 23.224.794 24 1.771 24h20.453c.979 0 1.776-.776 1.776-1.732V1.73C24 .775 23.203 0 22.224 0Z", fill: "#0077B5" }), (0,jsx_runtime.jsx)("path", { d: "M20.45 20.45h-3.557v-5.569c0-1.329-.024-3.037-1.85-3.037-1.852 0-2.135 1.447-2.135 2.941v5.666H9.35V8.998h3.414v1.564h.048c.475-.9 1.636-1.85 3.368-1.85 3.604 0 4.27 2.373 4.27 5.457v6.282ZM5.34 7.433a2.065 2.065 0 1 1 0-4.13 2.065 2.065 0 0 1 0 4.13ZM3.559 20.45h3.559V8.998h-3.56V20.45Z", fill: "#fff" })] })));
});
IconBrandlinkedin.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconBrandlinkedin = (IconBrandlinkedin);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconBrandtwitter.js



/**
 * Semantic vector graphics icon IconBrandtwitter.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconBrandtwitter size="large" color="green50" />
 */
const IconBrandtwitter = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsx)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: (0,jsx_runtime.jsx)("path", { d: "M21.557 7.891c0 6.509-4.953 14.012-14.009 14.012-2.782 0-5.368-.816-7.548-2.214a9.883 9.883 0 0 0 7.289-2.037 4.928 4.928 0 0 1-4.6-3.419 5.031 5.031 0 0 0 2.224-.085 4.929 4.929 0 0 1-3.95-4.83v-.061c.665.37 1.425.59 2.231.617a4.924 4.924 0 0 1-1.523-6.575A13.977 13.977 0 0 0 11.82 8.444a4.972 4.972 0 0 1-.127-1.123A4.921 4.921 0 0 1 16.617 2.4c1.417 0 2.696.596 3.595 1.553a9.916 9.916 0 0 0 3.126-1.194 4.942 4.942 0 0 1-2.165 2.723A9.849 9.849 0 0 0 24 4.707a9.944 9.944 0 0 1-2.457 2.548c.01.211.014.425.014.636Z", fill: "#1DA1F2" }) })));
});
IconBrandtwitter.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconBrandtwitter = (IconBrandtwitter);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/dist/components/Icon/icons/IconBrandslack.js



/**
 * Semantic vector graphics icon IconBrandslack.
 *
 * @see
 * {@link https://design-system.solventek.com/get-started/icons}
 *
 * @example
 * <IconBrandslack size="large" color="green50" />
 */
const IconBrandslack = (0,component/* componentWithRef */.w)((props, forwardRef) => {
    return ((0,jsx_runtime.jsxs)(Icon/* IconBase */.A0, Object.assign({ ref: forwardRef }, props, { children: [(0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M8.804 0A2.397 2.397 0 0 0 6.41 2.4a2.398 2.398 0 0 0 2.395 2.399h2.396V2.4A2.4 2.4 0 0 0 8.804 0c.001 0 .001 0 0 0Zm0 6.4H2.418A2.398 2.398 0 0 0 .022 8.8a2.398 2.398 0 0 0 2.395 2.4h6.387A2.398 2.398 0 0 0 11.2 8.8a2.398 2.398 0 0 0-2.396-2.4Z", fill: "#36C5F0" }), (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M23.975 8.8a2.398 2.398 0 0 0-2.396-2.4 2.398 2.398 0 0 0-2.396 2.4v2.4h2.396a2.398 2.398 0 0 0 2.396-2.4Zm-6.388 0V2.4A2.398 2.398 0 0 0 15.193 0a2.398 2.398 0 0 0-2.396 2.4v6.4a2.398 2.398 0 0 0 2.395 2.4 2.398 2.398 0 0 0 2.395-2.4Z", fill: "#2EB67D" }), (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M15.192 24a2.398 2.398 0 0 0 2.395-2.4 2.398 2.398 0 0 0-2.395-2.399h-2.396v2.4A2.4 2.4 0 0 0 15.192 24Zm0-6.401h6.387a2.398 2.398 0 0 0 2.396-2.4 2.398 2.398 0 0 0-2.395-2.4h-6.387a2.398 2.398 0 0 0-2.396 2.4 2.397 2.397 0 0 0 2.395 2.4Z", fill: "#ECB22E" }), (0,jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M.022 15.2a2.398 2.398 0 0 0 2.396 2.399 2.398 2.398 0 0 0 2.396-2.4v-2.4H2.418a2.398 2.398 0 0 0-2.396 2.4Zm6.388 0v6.4A2.398 2.398 0 0 0 8.804 24a2.398 2.398 0 0 0 2.396-2.4v-6.399a2.396 2.396 0 1 0-4.79-.002s0 .001 0 0Z", fill: "#E01E5A" })] })));
});
IconBrandslack.defaultProps = {
    size: 'medium',
    color: 'inherit'
};
/* harmony default export */ const icons_IconBrandslack = (IconBrandslack);

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/icons/index.js














































































































































































































































/***/ }),

/***/ 8460:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ApiTypes": () => (/* binding */ apiTypes),
/* harmony export */   "ArgContainer": () => (/* binding */ ArgContainer),
/* harmony export */   "BetaBadge": () => (/* binding */ BetaBadge),
/* harmony export */   "BrowserEditor": () => (/* binding */ BrowserEditor),
/* harmony export */   "Collapse": () => (/* binding */ Collapse),
/* harmony export */   "Comment": () => (/* binding */ Comment),
/* harmony export */   "Container": () => (/* binding */ Container),
/* harmony export */   "CopyToClipboard": () => (/* binding */ CopyToClipboard),
/* harmony export */   "Divider": () => (/* binding */ Divider),
/* harmony export */   "EditLocator": () => (/* binding */ EditLocator),
/* harmony export */   "ErrorMessage": () => (/* binding */ ErrorMessage),
/* harmony export */   "InlineEdit": () => (/* binding */ InlineEdit),
/* harmony export */   "Keyword": () => (/* binding */ Keyword),
/* harmony export */   "KeywordContainer": () => (/* binding */ KeywordContainer),
/* harmony export */   "KeywordList": () => (/* binding */ KeywordList),
/* harmony export */   "LocatorContext": () => (/* binding */ LocatorContext),
/* harmony export */   "LocatorDetails": () => (/* binding */ LocatorDetails),
/* harmony export */   "Match": () => (/* binding */ Match),
/* harmony export */   "MatchContainer": () => (/* binding */ MatchContainer),
/* harmony export */   "Matches": () => (/* binding */ Matches),
/* harmony export */   "MaybeError": () => (/* binding */ MaybeError),
/* harmony export */   "MaybeMatches": () => (/* binding */ MaybeMatches),
/* harmony export */   "MaybeOptions": () => (/* binding */ MaybeOptions),
/* harmony export */   "MaybeProgress": () => (/* binding */ MaybeProgress),
/* harmony export */   "PickElement": () => (/* binding */ PickElement),
/* harmony export */   "RecordButton": () => (/* binding */ RecordButton),
/* harmony export */   "RobotCodeScript": () => (/* binding */ RobotCodeScript),
/* harmony export */   "SaveLocator": () => (/* binding */ SaveLocator),
/* harmony export */   "SaveLocatorDialog": () => (/* binding */ SaveLocatorDialog),
/* harmony export */   "Screenshot": () => (/* binding */ Screenshot),
/* harmony export */   "SelectLocator": () => (/* binding */ SelectLocator),
/* harmony export */   "StartBrowser": () => (/* binding */ StartBrowser),
/* harmony export */   "WINDOWS_LOCATOR_VERSION": () => (/* binding */ WINDOWS_LOCATOR_VERSION),
/* harmony export */   "WebRecorderEditor": () => (/* binding */ WebRecorderEditor),
/* harmony export */   "WindowsEditor": () => (/* binding */ WindowsEditor),
/* harmony export */   "containsString": () => (/* binding */ containsString),
/* harmony export */   "copyToClipboard": () => (/* binding */ copyToClipboard),
/* harmony export */   "generateSelectorName": () => (/* binding */ generateSelectorName),
/* harmony export */   "getHTMLTagType": () => (/* binding */ getHTMLTagType),
/* harmony export */   "getValue": () => (/* binding */ getValue),
/* harmony export */   "hasProp": () => (/* binding */ hasProp),
/* harmony export */   "isBrowserLocator": () => (/* binding */ isBrowserLocator),
/* harmony export */   "isEmpty": () => (/* binding */ isEmpty),
/* harmony export */   "isImageLocator": () => (/* binding */ isImageLocator),
/* harmony export */   "isWindowsLocator": () => (/* binding */ isWindowsLocator),
/* harmony export */   "shortenString": () => (/* binding */ shortenString),
/* harmony export */   "toPascalCase": () => (/* binding */ toPascalCase),
/* harmony export */   "validateName": () => (/* binding */ validateName)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4191);
/* harmony import */ var _robocorp_ds__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3694);
/* harmony import */ var _robocorp_ds__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(1090);
/* harmony import */ var _robocorp_ds__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(5343);
/* harmony import */ var _robocorp_ds__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(7802);
/* harmony import */ var _robocorp_ds__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(5645);
/* harmony import */ var _robocorp_ds__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(6028);
/* harmony import */ var _robocorp_ds__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(2702);
/* harmony import */ var _robocorp_ds__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(2888);
/* harmony import */ var _robocorp_ds__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(1493);
/* harmony import */ var _robocorp_ds__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(3853);
/* harmony import */ var _robocorp_ds__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(8100);
/* harmony import */ var _robocorp_ds__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(3622);
/* harmony import */ var _robocorp_ds__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(3270);
/* harmony import */ var _robocorp_ds__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(6190);
/* harmony import */ var _robocorp_ds__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(4612);
/* harmony import */ var _robocorp_ds__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(4183);
/* harmony import */ var _robocorp_ds__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(6965);
/* harmony import */ var _robocorp_ds__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(9146);
/* harmony import */ var _robocorp_ds__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(6138);
/* harmony import */ var _robocorp_ds_icons__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(878);
/* harmony import */ var _robocorp_ds_icons__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(9339);
/* harmony import */ var _robocorp_ds_icons__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(6370);
/* harmony import */ var _robocorp_ds_icons__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(6632);
/* harmony import */ var _robocorp_ds_icons__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(8166);
/* harmony import */ var _robocorp_ds_icons__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(7760);
/* harmony import */ var _robocorp_ds_icons__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(6699);
/* harmony import */ var _robocorp_ds_icons__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(1364);
/* harmony import */ var _robocorp_ds_icons__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(6137);
/* harmony import */ var _robocorp_ds_icons__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(6108);
/* harmony import */ var _robocorp_ds_icons__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(845);
/* harmony import */ var _robocorp_ds_icons__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(5584);
/* harmony import */ var _robocorp_ds_icons__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(4222);
/* harmony import */ var _robocorp_ds_icons__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(3469);
/* harmony import */ var _robocorp_ds_icons__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(2554);
/* harmony import */ var _robocorp_ds_icons__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(7457);
/* harmony import */ var _robocorp_ds_icons__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(8404);
/* harmony import */ var _robocorp_ds_icons__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(3581);
/* harmony import */ var _robocorp_ds_icons__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(4103);
/* harmony import */ var _robocorp_ds_icons__WEBPACK_IMPORTED_MODULE_44__ = __webpack_require__(591);
/* harmony import */ var _robocorp_ds_icons__WEBPACK_IMPORTED_MODULE_46__ = __webpack_require__(1747);
/* harmony import */ var _robocorp_ds_icons__WEBPACK_IMPORTED_MODULE_50__ = __webpack_require__(1246);
/* harmony import */ var _robocorp_ds_icons_element__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(1360);
/* harmony import */ var _robocorp_ds_icons_element__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(9895);
/* harmony import */ var _robocorp_ds_icons_element__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(8566);
/* harmony import */ var _robocorp_ds_icons_element__WEBPACK_IMPORTED_MODULE_43__ = __webpack_require__(8958);
/* harmony import */ var _robocorp_ds_icons_element__WEBPACK_IMPORTED_MODULE_45__ = __webpack_require__(8939);
/* harmony import */ var _robocorp_ds_icons_element__WEBPACK_IMPORTED_MODULE_47__ = __webpack_require__(5550);
/* harmony import */ var _robocorp_ds_icons_element__WEBPACK_IMPORTED_MODULE_48__ = __webpack_require__(1542);
/* harmony import */ var _robocorp_ds_icons_element__WEBPACK_IMPORTED_MODULE_49__ = __webpack_require__(8788);






function _regeneratorRuntime() {
  _regeneratorRuntime = function () {
    return exports;
  };
  var exports = {},
    Op = Object.prototype,
    hasOwn = Op.hasOwnProperty,
    defineProperty = Object.defineProperty || function (obj, key, desc) {
      obj[key] = desc.value;
    },
    $Symbol = "function" == typeof Symbol ? Symbol : {},
    iteratorSymbol = $Symbol.iterator || "@@iterator",
    asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator",
    toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
  function define(obj, key, value) {
    return Object.defineProperty(obj, key, {
      value: value,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }), obj[key];
  }
  try {
    define({}, "");
  } catch (err) {
    define = function (obj, key, value) {
      return obj[key] = value;
    };
  }
  function wrap(innerFn, outerFn, self, tryLocsList) {
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator,
      generator = Object.create(protoGenerator.prototype),
      context = new Context(tryLocsList || []);
    return defineProperty(generator, "_invoke", {
      value: makeInvokeMethod(innerFn, self, context)
    }), generator;
  }
  function tryCatch(fn, obj, arg) {
    try {
      return {
        type: "normal",
        arg: fn.call(obj, arg)
      };
    } catch (err) {
      return {
        type: "throw",
        arg: err
      };
    }
  }
  exports.wrap = wrap;
  var ContinueSentinel = {};
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}
  var IteratorPrototype = {};
  define(IteratorPrototype, iteratorSymbol, function () {
    return this;
  });
  var getProto = Object.getPrototypeOf,
    NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function (method) {
      define(prototype, method, function (arg) {
        return this._invoke(method, arg);
      });
    });
  }
  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if ("throw" !== record.type) {
        var result = record.arg,
          value = result.value;
        return value && "object" == typeof value && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) {
          invoke("next", value, resolve, reject);
        }, function (err) {
          invoke("throw", err, resolve, reject);
        }) : PromiseImpl.resolve(value).then(function (unwrapped) {
          result.value = unwrapped, resolve(result);
        }, function (error) {
          return invoke("throw", error, resolve, reject);
        });
      }
      reject(record.arg);
    }
    var previousPromise;
    defineProperty(this, "_invoke", {
      value: function (method, arg) {
        function callInvokeWithMethodAndArg() {
          return new PromiseImpl(function (resolve, reject) {
            invoke(method, arg, resolve, reject);
          });
        }
        return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      }
    });
  }
  function makeInvokeMethod(innerFn, self, context) {
    var state = "suspendedStart";
    return function (method, arg) {
      if ("executing" === state) throw new Error("Generator is already running");
      if ("completed" === state) {
        if ("throw" === method) throw arg;
        return doneResult();
      }
      for (context.method = method, context.arg = arg;;) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }
        if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) {
          if ("suspendedStart" === state) throw state = "completed", context.arg;
          context.dispatchException(context.arg);
        } else "return" === context.method && context.abrupt("return", context.arg);
        state = "executing";
        var record = tryCatch(innerFn, self, context);
        if ("normal" === record.type) {
          if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue;
          return {
            value: record.arg,
            done: context.done
          };
        }
        "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
      }
    };
  }
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (undefined === method) {
      if (context.delegate = null, "throw" === context.method) {
        if (delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel;
        context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method");
      }
      return ContinueSentinel;
    }
    var record = tryCatch(method, delegate.iterator, context.arg);
    if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
    var info = record.arg;
    return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
  }
  function pushTryEntry(locs) {
    var entry = {
      tryLoc: locs[0]
    };
    1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
  }
  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal", delete record.arg, entry.completion = record;
  }
  function Context(tryLocsList) {
    this.tryEntries = [{
      tryLoc: "root"
    }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0);
  }
  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) return iteratorMethod.call(iterable);
      if ("function" == typeof iterable.next) return iterable;
      if (!isNaN(iterable.length)) {
        var i = -1,
          next = function next() {
            for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next;
            return next.value = undefined, next.done = !0, next;
          };
        return next.next = next;
      }
    }
    return {
      next: doneResult
    };
  }
  function doneResult() {
    return {
      value: undefined,
      done: !0
    };
  }
  return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", {
    value: GeneratorFunctionPrototype,
    configurable: !0
  }), defineProperty(GeneratorFunctionPrototype, "constructor", {
    value: GeneratorFunction,
    configurable: !0
  }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) {
    var ctor = "function" == typeof genFun && genFun.constructor;
    return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
  }, exports.mark = function (genFun) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
  }, exports.awrap = function (arg) {
    return {
      __await: arg
    };
  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
    return this;
  }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    void 0 === PromiseImpl && (PromiseImpl = Promise);
    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
    return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) {
      return result.done ? result.value : iter.next();
    });
  }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () {
    return this;
  }), define(Gp, "toString", function () {
    return "[object Generator]";
  }), exports.keys = function (val) {
    var object = Object(val),
      keys = [];
    for (var key in object) keys.push(key);
    return keys.reverse(), function next() {
      for (; keys.length;) {
        var key = keys.pop();
        if (key in object) return next.value = key, next.done = !1, next;
      }
      return next.done = !0, next;
    };
  }, exports.values = values, Context.prototype = {
    constructor: Context,
    reset: function (skipTempReset) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined);
    },
    stop: function () {
      this.done = !0;
      var rootRecord = this.tryEntries[0].completion;
      if ("throw" === rootRecord.type) throw rootRecord.arg;
      return this.rval;
    },
    dispatchException: function (exception) {
      if (this.done) throw exception;
      var context = this;
      function handle(loc, caught) {
        return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught;
      }
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i],
          record = entry.completion;
        if ("root" === entry.tryLoc) return handle("end");
        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc"),
            hasFinally = hasOwn.call(entry, "finallyLoc");
          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
          } else {
            if (!hasFinally) throw new Error("try statement without catch or finally");
            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
          }
        }
      }
    },
    abrupt: function (type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }
      finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
      var record = finallyEntry ? finallyEntry.completion : {};
      return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
    },
    complete: function (record, afterLoc) {
      if ("throw" === record.type) throw record.arg;
      return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
    },
    finish: function (finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
      }
    },
    catch: function (tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if ("throw" === record.type) {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }
      throw new Error("illegal catch attempt");
    },
    delegateYield: function (iterable, resultName, nextLoc) {
      return this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      }, "next" === this.method && (this.arg = undefined), ContinueSentinel;
    }
  }, exports;
}
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _asyncToGenerator(fn) {
  return function () {
    var self = this,
      args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);
      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(undefined);
    });
  };
}
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf(subClass, superClass);
}
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf(o, p);
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}
function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct.bind();
  } else {
    _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) _setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }
  return _construct.apply(null, arguments);
}
function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}
function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;
  _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !_isNativeFunction(Class)) return Class;
    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }
    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);
      _cache.set(Class, Wrapper);
    }
    function Wrapper() {
      return _construct(Class, arguments, _getPrototypeOf(this).constructor);
    }
    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class);
  };
  return _wrapNativeSuper(Class);
}
function _taggedTemplateLiteralLoose(strings, raw) {
  if (!raw) {
    raw = strings.slice(0);
  }
  strings.raw = raw;
  return strings;
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (it) return (it = it.call(o)).next.bind(it);
  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
    if (it) o = it;
    var i = 0;
    return function () {
      if (i >= o.length) return {
        done: true
      };
      return {
        done: false,
        value: o[i++]
      };
    };
  }
  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

var _templateObject;
var ContainerStyled = /*#__PURE__*/_robocorp_ds__WEBPACK_IMPORTED_MODULE_2__/* .styled.div */ .zo.div(_templateObject || (_templateObject = /*#__PURE__*/_taggedTemplateLiteralLoose(["\n  background: ", ";\n  padding: 12px;\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n"])), function (_ref) {
  var theme = _ref.theme;
  return theme.color('dark90');
});
/**
 * Locator window content container that updates the native window size based on it's own height
 */
var Container = function Container(_ref2) {
  var bridge = _ref2.bridge,
    children = _ref2.children;
  var container = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);
  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {
    var resizeObserver = new ResizeObserver(function (entries) {
      var height = 140;
      for (var _iterator = _createForOfIteratorHelperLoose(entries), _step; !(_step = _iterator()).done;) {
        var entry = _step.value;
        height = Math.min(
        // Content height + content padding 16px + titlebar 36px
        Math.ceil(entry.contentRect.height) + 22 + 36,
        // Limit amx size to screen height
        screen.height - 200);
      }
      bridge.windowSize(height);
    });
    if (container.current) {
      resizeObserver.observe(container.current);
    }
    bridge.windowSize(580);
    return function () {
      if (container.current) {
        resizeObserver.unobserve(container.current);
      }
    };
  }, []);
  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ContainerStyled, {
    ref: container,
    children: children
  });
};

/**
 * An enumeration.
 * @export
 * @enum {string}
 */
var BrowserStatus;
(function (BrowserStatus) {
  BrowserStatus["Stopped"] = "stopped";
  BrowserStatus["Started"] = "started";
  BrowserStatus["Running"] = "running";
})(BrowserStatus || (BrowserStatus = {}));
/**
 * An enumeration.
 * @export
 * @enum {string}
 */
var LocatorType;
(function (LocatorType) {
  LocatorType["Browser"] = "browser";
  LocatorType["Windows"] = "windows";
  LocatorType["Image"] = "image";
  LocatorType["WebRecorder"] = "web-recorder";
})(LocatorType || (LocatorType = {}));
/**
 * An enumeration.
 * @export
 * @enum {string}
 */
var DocType;
(function (DocType) {
  DocType["Library"] = "library";
  DocType["Keyword"] = "keyword";
  DocType["Argument"] = "argument";
  DocType["Variable"] = "variable";
  DocType["Locator"] = "locator";
  DocType["WorkItem"] = "work-item";
})(DocType || (DocType = {}));
/**
 * An enumeration.
 * @export
 * @enum {string}
 */
var ErrorCode;
(function (ErrorCode) {
  ErrorCode["Unknown"] = "unknown";
  ErrorCode["InternalError"] = "internal-error";
  ErrorCode["ValidationError"] = "validation-error";
  ErrorCode["TimedOutError"] = "timed-out-error";
  ErrorCode["NotAvailable"] = "not-available";
  ErrorCode["InvalidRequest"] = "invalid-request";
  ErrorCode["InvalidValue"] = "invalid-value";
})(ErrorCode || (ErrorCode = {}));

var apiTypes = {
  __proto__: null,
  get BrowserStatus () { return BrowserStatus; },
  get LocatorType () { return LocatorType; },
  get DocType () { return DocType; },
  get ErrorCode () { return ErrorCode; }
};

function hasProp(object, prop) {
  return Object.prototype.hasOwnProperty.call(object, prop);
}
function isEmpty(obj) {
  return Object.keys(obj).length === 0;
}
function containsString(lhs, rhs) {
  return lhs.toLowerCase().indexOf(rhs.toLowerCase()) >= 0;
}
function copyToClipboard(text) {
  var dummy = document.createElement('textarea');
  document.body.appendChild(dummy);
  try {
    dummy.value = text;
    dummy.select();
    document.execCommand('copy');
  } finally {
    document.body.removeChild(dummy);
  }
}
var toPascalCase = function toPascalCase(text) {
  return ("" + text).replace(new RegExp(/[-_]+/, 'g'), ' ').replace(new RegExp(/[^\w\s]/, 'g'), '').replace(new RegExp(/\s+(.)(\w+)/, 'g'), function (_$1, $2, $3) {
    return "" + ($2.toUpperCase() + $3.toLowerCase());
  }).replace(new RegExp(/\s/, 'g'), '').replace(new RegExp(/\w/), function (s) {
    return s.toUpperCase();
  });
};
function shortenString(text, length) {
  if (length === void 0) {
    length = 64;
  }
  if (text.length <= length) {
    return text;
  }
  var hidden = ' ... ';
  var sectionLength = Math.floor((length - hidden.length) / 2);
  if (sectionLength <= 0) {
    console.error('Invalid requested string length', length);
    return text;
  }
  var start = text.slice(0, sectionLength);
  var end = text.slice(-sectionLength);
  return start + hidden + end;
}
var generateSelectorName = function generateSelectorName(strategy, value, match, index) {
  var result;
  switch (strategy) {
    case 'name':
    case 'id':
    case 'class':
    case 'tag':
    case 'link':
      result = value;
      break;
    case 'css':
    case 'xpath':
    default:
      result = (match == null ? void 0 : match.name) || (index ? "Unknown" + index : 'Unknown');
      break;
  }
  result = toPascalCase(result);
  result = result.substring(0, 32);
  return result;
};
function validateName(text) {
  // TODO: Add more checks
  if (!text) {
    return "Name can't be empty";
  }
  if (/\s{2,}/.test(text)) {
    return 'Consecutive spaces in name not allowed';
  }
  return undefined;
}
var getHTMLTagType = function getHTMLTagType(input) {
  var tagName = input.match(/<([^\s>]+)(\s|>)+/);
  if (!tagName || tagName.length < 2) {
    return {
      name: 'element',
      Icon: _robocorp_ds_icons__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z
    };
  }
  switch (tagName[1]) {
    case 'img':
    case 'svg':
      return {
        name: 'image',
        Icon: _robocorp_ds_icons__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z
      };
    case 'h1':
    case 'h2':
    case 'h3':
    case 'h4':
    case 'h5':
    case 'h6':
      return {
        name: 'title',
        Icon: _robocorp_ds_icons__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z
      };
    case 'p':
      return {
        name: 'paragraph',
        Icon: _robocorp_ds_icons__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z
      };
    case 'a':
      return {
        name: 'link',
        Icon: _robocorp_ds_icons__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z
      };
    case 'button':
      return {
        name: 'button',
        Icon: _robocorp_ds_icons__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z
      };
    case 'input':
    case 'textarea':
      return {
        name: 'input',
        Icon: _robocorp_ds_icons__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z
      };
    default:
      return {
        name: 'element',
        Icon: _robocorp_ds_icons__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z
      };
  }
};
var getValue = function getValue(locator) {
  if (isBrowserLocator(locator)) {
    return locator.strategy + ":" + locator.value;
  } else if (isImageLocator(locator)) {
    return "image:" + locator.path;
  } else if (isWindowsLocator(locator)) {
    return locator.value;
  } else {
    return '';
  }
};
var isBrowserLocator = function isBrowserLocator(locator) {
  return locator.kind === LocatorType.Browser || "" + locator.type === LocatorType.Browser;
};
var isWindowsLocator = function isWindowsLocator(locator) {
  return locator.kind === LocatorType.Windows || "" + locator.type === LocatorType.Windows;
};
var isImageLocator = function isImageLocator(locator) {
  return locator.kind === LocatorType.Image || "" + locator.type === LocatorType.Image;
};

var MaybeOptions = function MaybeOptions(props) {
  var options = props.options;
  if (isEmpty(options)) {
    return null;
  }
  var optionElements = Object.keys(options).map(function (name) {
    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z, {
      onClick: function onClick() {
        props.onSelect(name);
      },
      children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .Z, {
        secondaryTop: name,
        type: "text",
        children: options[name]['value']
      })
    });
  });
  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_11__/* .Dialog */ .V, {
    title: "Select locator",
    open: true,
    onClose: function onClose() {
      props.onSelect();
    },
    children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_11__/* .Dialog.Content */ .V.Content, {
      children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_12__/* ["default"] */ .C, {
        divider: true,
        children: optionElements
      })
    })
  });
};
var MaybeProgress = function MaybeProgress(props) {
  return props.editorStatus === 'starting' || props.editorStatus === 'busy' ? (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z, {
    mb: 5,
    backgroundColor: "dark80",
    children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_14__/* ["default"] */ .Z, {})
  }) : null;
};
var MaybeError = function MaybeError(props) {
  return props.errorMessage ? (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z, {
    color: "red50",
    padding: "5px 0",
    children: props.errorMessage
  }) : null;
};
var MaybeMatches = function MaybeMatches(props) {
  if (props.matches === undefined) {
    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z, {
      p: 32,
      height: "100%",
      display: "flex",
      justifyContent: "center",
      alignItems: "center",
      children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_15__/* .Typography */ .Z, {
        fontSize: 16,
        color: "light40",
        children: props.errorText
      })
    });
  }
  var matchElements = props.matches.map(function (match, index) {
    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z, {
      onClick: function onClick() {
        return props.onSelect(index);
      },
      children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .Z, {
        secondary: shortenString(match.value),
        type: "text",
        children: match.name
      })
    });
  });
  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z, {
    margin: 16,
    children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_12__/* ["default"] */ .C, {
      dense: true,
      divider: true,
      children: matchElements
    })
  });
};

var ErrorMessage = function ErrorMessage(_ref) {
  var errorMessage = _ref.errorMessage;
  if (!errorMessage) {
    return null;
  }
  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z, {
    my: 4,
    p: 6,
    color: "red50",
    backgroundColor: "dark70",
    display: "flex",
    flexDirection: "row",
    alignItems: "center",
    borderRadius: 8,
    children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z, {
      mr: 8,
      pl: 6,
      children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds_icons__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z, {
        size: 24
      })
    }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(MaybeError, {
      errorMessage: errorMessage
    })]
  });
};

var _templateObject$1;
var Divider = /*#__PURE__*/(0,_robocorp_ds__WEBPACK_IMPORTED_MODULE_2__/* .styled */ .zo)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_17__/* ["default"] */ .Z)(_templateObject$1 || (_templateObject$1 = /*#__PURE__*/_taggedTemplateLiteralLoose(["\n  margin: 4px 0 16px;\n"])));

var LocatorContext = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)({
  locatorName: '',
  setLocatorName: function setLocatorName() {
    return null;
  },
  setLocator: function setLocator() {
    return null;
  }
});

var LocatorDetails = function LocatorDetails(_ref) {
  var setDisableSave = _ref.setDisableSave;
  var _useContext = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(LocatorContext),
    locator = _useContext.locator,
    setLocator = _useContext.setLocator,
    locatorName = _useContext.locatorName,
    setLocatorName = _useContext.setLocatorName;
  var onChange = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(function (value) {
    setLocatorName(value);
  }, []);
  var onCopy = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(function () {
    if (!locator) {
      return;
    }
    var text = isBrowserLocator(locator) ? locator.strategy + ":" + locator.value : locator.value;
    navigator.clipboard.writeText(text);
  }, [locator]);
  var onRemoveScreenshot = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(function () {
    setLocator(function (curr) {
      return curr ? _extends({}, curr, {
        screenshot: undefined
      }) : curr;
    });
  }, []);
  if (!locator) {
    return null;
  }
  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {
    children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z, {
      display: "flex",
      flex: "1",
      pb: 12,
      children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z, {
        flex: "1",
        mr: 8,
        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(InlineEdit, {
          prefix: "Locator ",
          value: locatorName,
          onChange: onChange,
          setDisableSave: setDisableSave
        })
      }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_18__/* .Dropdown */ .L, {
        width: 200,
        position: "bottom-end",
        icon: _robocorp_ds_icons__WEBPACK_IMPORTED_MODULE_19__/* ["default"] */ .Z,
        children: [locator.screenshot && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_18__/* .Dropdown.Item */ .L.Item, {
          label: "Remove Screenshot",
          onClick: onRemoveScreenshot
        }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_18__/* .Dropdown.Item */ .L.Item, {
          label: "Copy Selector as Text",
          onClick: onCopy
        })]
      })]
    }), locator.screenshot && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z, {
      children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Screenshot, {
        src: "data:image/jpeg;base64," + locator.screenshot
      })
    })]
  });
};

var _templateObject$2, _templateObject2, _templateObject3;
var Collapse = /*#__PURE__*/_robocorp_ds__WEBPACK_IMPORTED_MODULE_2__/* .styled.button */ .zo.button(_templateObject$2 || (_templateObject$2 = /*#__PURE__*/_taggedTemplateLiteralLoose(["\n  display: flex;\n  align-items: center;\n  background: none;\n  padding: 4px 0;\n  font-size: 12px;\n  font-weight: 500;\n\n  &:disabled {\n    cursor: default;\n  }\n"])));
var MatchContainer = /*#__PURE__*/(0,_robocorp_ds__WEBPACK_IMPORTED_MODULE_2__/* .styled */ .zo)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z)(_templateObject2 || (_templateObject2 = /*#__PURE__*/_taggedTemplateLiteralLoose(["\n  max-height: 160px;\n  background: ", ";\n  border: 1px solid ", ";\n\n  button {\n    color: ", ";\n  }\n"])), function (_ref) {
  var theme = _ref.theme;
  return theme.name === 'dark' ? theme.color('dark100') : 'white';
}, function (_ref2) {
  var theme = _ref2.theme;
  return theme.color('dark60');
}, function (_ref3) {
  var theme = _ref3.theme;
  return theme.color('dark0');
});
var Match = /*#__PURE__*/_robocorp_ds__WEBPACK_IMPORTED_MODULE_2__/* .styled.button */ .zo.button(_templateObject3 || (_templateObject3 = /*#__PURE__*/_taggedTemplateLiteralLoose(["\n  display: flex;\n  background: none;\n  font-size: 12px;\n  line-height: 13px;\n  width: 100%;\n  text-align: left;\n  margin-bottom: 12px;\n\n  &:last-of-type {\n    margin-bottom: 0px;\n  }\n\n  color: ", ";\n\n  strong {\n    display: block;\n    font-weight: 500;\n    margin-left: 6px;\n\n    color: ", ";\n\n    &::first-letter {\n      text-transform: uppercase;\n    }\n\n    span {\n      display: block;\n      font-size: 10px;\n      color: ", ";\n      white-space: nowrap;\n      width: 300px;\n      overflow: hidden;\n      text-overflow: ellipsis;\n    }\n  }\n"])), function (_ref4) {
  var theme = _ref4.theme;
  return theme.color('dark0');
}, function (_ref5) {
  var theme = _ref5.theme;
  return theme.color('dark0');
}, function (_ref6) {
  var theme = _ref6.theme;
  return theme.color('dark30');
});

var SaveLocator = function SaveLocator(_ref) {
  var bridge = _ref.bridge,
    matches = _ref.matches,
    disableSave = _ref.disableSave,
    afterSave = _ref.afterSave,
    onClose = _ref.onClose;
  var _useContext = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(LocatorContext),
    locator = _useContext.locator,
    locatorName = _useContext.locatorName,
    existingLocator = _useContext.existingLocator;
  var onCloseBridge = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(function () {
    if (onClose) {
      onClose();
    } else {
      bridge.stop();
    }
  }, [bridge, onClose]);
  var onSaveLocator = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(function () {
    var save = /*#__PURE__*/function () {
      var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!locator) {
                  _context.next = 9;
                  break;
                }
                if (!isWindowsLocator(locator)) {
                  _context.next = 6;
                  break;
                }
                _context.next = 4;
                return bridge.save(locatorName, locator, existingLocator);
              case 4:
                _context.next = 9;
                break;
              case 6:
                if (!isBrowserLocator(locator)) {
                  _context.next = 9;
                  break;
                }
                _context.next = 9;
                return bridge.save(locatorName, locator, existingLocator);
              case 9:
                if (afterSave) afterSave();
              case 10:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));
      return function save() {
        return _ref2.apply(this, arguments);
      };
    }();
    save().then(onCloseBridge);
  }, [locator, locatorName, afterSave]);
  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z, {
    pt: 6,
    children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z, {
      py: 12,
      display: "flex",
      alignItems: "center",
      justifyContent: "space-between",
      children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z, {
        color: "dark10",
        children: [matches === 1 && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z, {
          display: "flex",
          alignItems: "center",
          children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z, {
            backgroundColor: "dark70",
            p: 6,
            mr: 8,
            borderRadius: 4,
            display: "flex",
            children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds_icons__WEBPACK_IMPORTED_MODULE_20__/* ["default"] */ .Z, {
              color: "dark10",
              size: 20
            })
          }), "Matches 1 element"]
        }), matches > 1 && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z, {
          display: "flex",
          alignItems: "center",
          children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z, {
            backgroundColor: "yellow50",
            p: 6,
            mr: 8,
            borderRadius: 4,
            display: "flex",
            children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds_icons__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z, {
              color: "dark10",
              size: 20
            })
          }), "Matches multiple elements"]
        })]
      }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z, {
        display: "flex",
        children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_21__/* .Button */ .z, {
          onClick: onCloseBridge,
          variant: "secondary",
          children: "Cancel"
        }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z, {
          ml: 12,
          children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_21__/* .Button */ .z, {
            disabled: disableSave,
            onClick: onSaveLocator,
            children: "Save"
          })
        })]
      })]
    })
  });
};

var _templateObject$3;
// TODO: Move all of these as original component style variants to @robocorp/ds
var Title = /*#__PURE__*/_robocorp_ds__WEBPACK_IMPORTED_MODULE_2__/* .styled.div */ .zo.div(_templateObject$3 || (_templateObject$3 = /*#__PURE__*/_taggedTemplateLiteralLoose(["\n  min-width: 0px;\n\n  span {\n    display: block;\n    white-space: nowrap;\n    overflow: hidden;\n    text-overflow: ellipsis;\n  }\n"])));
var InlineEdit = function InlineEdit(_ref) {
  var value = _ref.value,
    onChange = _ref.onChange,
    setDisableSave = _ref.setDisableSave,
    prefix = _ref.prefix;
  var _useState = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true),
    edit = _useState[0],
    setEdit = _useState[1];
  var _useState2 = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(''),
    innerValue = _useState2[0],
    setInnerValue = _useState2[1];
  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {
    setInnerValue(value);
    setEdit(false);
  }, [value]);
  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {
    setDisableSave(edit);
  }, [edit]);
  var onEdit = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(function () {
    setEdit(true);
  }, []);
  var onInnerChange = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(function (e) {
    setInnerValue(e.target.value);
  }, []);
  var onSave = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(function () {
    onChange(innerValue);
    setEdit(false);
  }, [innerValue]);
  var onCancel = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(function () {
    setInnerValue(value);
    setEdit(false);
  }, [innerValue]);
  if (!edit) {
    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z, {
      display: "flex",
      alignItems: "center",
      height: 32,
      maxWidth: 265,
      children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Title, {
        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("span", {
          children: [prefix, " \u201C", value, "\u201D"]
        })
      }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_21__/* .Button */ .z, {
        variant: "ghost",
        color: "dark30",
        onClick: onEdit,
        icon: _robocorp_ds_icons__WEBPACK_IMPORTED_MODULE_22__/* ["default"] */ .Z
      })]
    });
  }
  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z, {
    display: "flex",
    alignItems: "center",
    height: 32,
    children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z, {
      children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_23__/* .Input */ .II, {
        value: innerValue,
        autoFocus: true,
        onChange: onInnerChange
      })
    }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z, {
      ml: 12,
      children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_21__/* .Button */ .z, {
        variant: "secondary",
        color: "dark30",
        onClick: onCancel,
        icon: _robocorp_ds_icons__WEBPACK_IMPORTED_MODULE_24__/* ["default"] */ .Z
      })
    }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z, {
      ml: 6,
      children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_21__/* .Button */ .z, {
        variant: "primary",
        onClick: onSave,
        icon: _robocorp_ds_icons__WEBPACK_IMPORTED_MODULE_20__/* ["default"] */ .Z
      })
    })]
  });
};

var _templateObject$4;
var Container$1 = /*#__PURE__*/_robocorp_ds__WEBPACK_IMPORTED_MODULE_2__/* .styled.div */ .zo.div(_templateObject$4 || (_templateObject$4 = /*#__PURE__*/_taggedTemplateLiteralLoose(["\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  width: 100%;\n  max-height: 200px;\n  background: ", ";\n  border: 1px solid ", ";\n  border-radius: 2px;\n  margin-bottom: 12px;\n  padding: 16px 0;\n  overflow: hidden;\n\n  img {\n    max-width: 90%;\n    object-fit: scale-down;\n  }\n"])), function (_ref) {
  var theme = _ref.theme;
  return theme.color('dark100');
}, function (_ref2) {
  var theme = _ref2.theme;
  return theme.color('dark50');
});
var Screenshot = function Screenshot(_ref3) {
  var src = _ref3.src;
  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Container$1, {
    children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("img", {
      src: src,
      alt: ""
    })
  });
};

var CopyToClipboard = function CopyToClipboard(_ref) {
  var value = _ref.value,
    text = _ref.text,
    _ref$disabled = _ref.disabled,
    disabled = _ref$disabled === void 0 ? false : _ref$disabled,
    _ref$variant = _ref.variant,
    variant = _ref$variant === void 0 ? 'secondary' : _ref$variant;
  var _useState = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false),
    clicked = _useState[0],
    setClicked = _useState[1];
  var _useState2 = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(text),
    clickText = _useState2[0],
    setClickText = _useState2[1];
  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {
    var timeout = setTimeout(function () {
      setClicked(false);
      setClickText(text);
    }, 2000);
    return function () {
      clearTimeout(timeout);
    };
  }, [clicked, setClicked]);
  var onClick = function onClick() {
    copyToClipboard(value != null ? value : '');
    setClicked(true);
    setClickText(text ? 'Copied' : undefined);
  };
  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_21__/* .Button */ .z, {
    variant: variant,
    disabled: disabled,
    icon: clicked ? _robocorp_ds_icons__WEBPACK_IMPORTED_MODULE_25__/* ["default"] */ .Z : _robocorp_ds_icons__WEBPACK_IMPORTED_MODULE_26__/* ["default"] */ .Z,
    onClick: onClick,
    children: clickText
  });
};

var RobotCodeScript = function RobotCodeScript(props) {
  if (props.editorStatus !== 'disabled' && props.editorStatus !== 'stopped' && props.codeLines.length !== 0) {
    var code = props.codeLines.map(function (line) {
      return line.trim();
    }).join('\n');
    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z, {
      maxHeight: 400,
      height: 400,
      children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_27__/* ["default"] */ .Z, {
        horizontal: true,
        variant: "custom",
        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_28__/* .Code */ .EK, {
          value: code,
          extensions: [(0,_robocorp_ds__WEBPACK_IMPORTED_MODULE_29__/* .robotFramework */ .q)()],
          lineNumbers: true
        })
      })
    });
  }
  return null;
};

var BetaBadge = function BetaBadge(_ref) {
  var tooltip = _ref.tooltip;
  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_30__/* ["default"] */ .Z, {
    text: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z, {
      fontSize: 10,
      color: "dark0",
      p: 8,
      children: tooltip
    }),
    placement: "left",
    variant: "navigation",
    children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_31__/* .Badge */ .C, {
      label: "",
      variant: "warning",
      highlight: true
    })
  });
};

var WINDOWS_LOCATOR_VERSION = 1.0;

var ErrorResponse = /*#__PURE__*/function (_Error) {
  _inheritsLoose(ErrorResponse, _Error);
  function ErrorResponse(error_code, message) {
    var _this;
    _this = _Error.call(this, message) || this;
    _this.error_code = void 0;
    _this.message = void 0;
    _this.name = 'ErrorResponse';
    _this.error_code = error_code;
    _this.message = message;
    return _this;
  }
  return ErrorResponse;
}( /*#__PURE__*/_wrapNativeSuper(Error));

var _templateObject$5, _templateObject2$1, _templateObject3$1;
var strategies = [{
  value: 'xpath',
  label: 'XPath'
}, {
  value: 'css',
  label: 'CSS'
}, {
  value: 'name',
  label: 'Name'
}, {
  value: 'id',
  label: 'ID'
}, {
  value: 'class',
  label: 'Class'
}, {
  value: 'tag',
  label: 'Tag'
}, {
  value: 'link',
  label: 'Link'
}];
var Container$2 = /*#__PURE__*/(0,_robocorp_ds__WEBPACK_IMPORTED_MODULE_2__/* .styled */ .zo)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z)(_templateObject$5 || (_templateObject$5 = /*#__PURE__*/_taggedTemplateLiteralLoose(["\n  display: flex;\n  position: relative;\n  width: 100%;\n\n  > label {\n    flex: 1;\n  }\n\n  > span {\n    pointer-events: none;\n    position: absolute;\n    z-index: 2;\n    top: 11px;\n    left: 58px;\n  }\n"])));
var Select = /*#__PURE__*/_robocorp_ds__WEBPACK_IMPORTED_MODULE_2__/* .styled.select */ .zo.select(_templateObject2$1 || (_templateObject2$1 = /*#__PURE__*/_taggedTemplateLiteralLoose(["\n  position: absolute;\n  top: 5px;\n  left: 5px;\n  cursor: pointer;\n  z-index: 2;\n  appearance: none;\n  font-size: 12px;\n  color: ", ";\n  background: ", ";\n  padding: 5px 0 5px 8px;\n  width: 72px;\n  font-family: 'Inter';\n  font-weight: 500;\n  border-radius: 2px;\n  border: 1px solid ", ";\n"])), function (_ref) {
  var theme = _ref.theme;
  return theme.color('dark20');
}, function (_ref2) {
  var theme = _ref2.theme;
  return theme.color('dark90');
}, function (_ref3) {
  var theme = _ref3.theme;
  return theme.color('dark50');
});
var Input = /*#__PURE__*/(0,_robocorp_ds__WEBPACK_IMPORTED_MODULE_2__/* .styled */ .zo)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_23__/* .Input */ .II)(_templateObject3$1 || (_templateObject3$1 = /*#__PURE__*/_taggedTemplateLiteralLoose(["\n  height: 36px;\n  padding-left: 85px;\n"])));
var EditLocator = function EditLocator() {
  var _useContext = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(LocatorContext),
    locator = _useContext.locator,
    setLocator = _useContext.setLocator;
  var onValueChange = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(function (e) {
    setLocator(function (curr) {
      return curr ? _extends({}, curr, {
        value: e.target.value
      }) : {
        strategy: 'xpath',
        value: e.target.value,
        type: DocType.Locator,
        kind: LocatorType.Browser
      };
    });
  }, []);
  var onStrategyChange = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(function (e) {
    var strategy = e.target.value;
    setLocator(function (curr) {
      return curr ? _extends({}, curr, {
        strategy: strategy
      }) : {
        strategy: strategy,
        value: '',
        type: DocType.Locator,
        kind: LocatorType.Browser
      };
    });
  }, []);
  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z, {
    pb: 12,
    display: "flex",
    justifyContent: "space-between",
    alignItems: "center",
    children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(Container$2, {
      children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Select, {
        onChange: onStrategyChange,
        children: strategies.map(function (_ref4) {
          var value = _ref4.value,
            label = _ref4.label;
          return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("option", {
            value: value,
            children: label
          }, value);
        })
      }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds_icons__WEBPACK_IMPORTED_MODULE_32__/* ["default"] */ .Z, {
        size: 16,
        color: "dark20"
      }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Input, {
        value: (locator == null ? void 0 : locator.value) || '',
        onChange: onValueChange,
        placeholder: "Type selector or pick element"
      })]
    })
  });
};

var Matches = function Matches(_ref) {
  var matches = _ref.matches,
    runCommand = _ref.runCommand;
  var _useState = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false),
    open = _useState[0],
    setOpen = _useState[1];
  var onToggle = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(function () {
    setOpen(function (curr) {
      return !curr;
    });
  }, []);
  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {
    if (matches.length === 0) {
      setOpen(false);
    }
  }, [matches]);
  var onFocus = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(function (index) {
    return function () {
      runCommand('focus', /*#__PURE__*/function () {
        var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(bridge) {
          return _regeneratorRuntime().wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  return _context.abrupt("return", bridge.focus(index));
                case 1:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }));
        return function (_x) {
          return _ref2.apply(this, arguments);
        };
      }());
    };
  }, []);
  var label = matches.length === 0 ? 'No matching elements' : "Matching elements (" + matches.length + ")";
  var Icon = open ? _robocorp_ds_icons__WEBPACK_IMPORTED_MODULE_32__/* ["default"] */ .Z : _robocorp_ds_icons__WEBPACK_IMPORTED_MODULE_33__/* ["default"] */ .Z;
  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z, {
    pb: 8,
    children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(Collapse, {
      onClick: onToggle,
      disabled: matches.length === 0,
      children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z, {
        mr: 4,
        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Icon, {
          size: 16,
          color: "dark20"
        })
      }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z, {
        color: "dark0",
        children: label
      })]
    }), open && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_27__/* ["default"] */ .Z, {
      vertical: true,
      variant: "custom",
      height: "100%",
      id: "matching-container",
      children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(MatchContainer, {
        p: 16,
        mt: 4,
        children: matches.map(function (match, index) {
          var _getHTMLTagType = getHTMLTagType(match.value),
            name = _getHTMLTagType.name,
            Icon = _getHTMLTagType.Icon;
          return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(Match, {
            onClick: onFocus(index),
            children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Icon, {
              size: 12,
              color: "dark20"
            }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("strong", {
              children: [name + " \u201C" + match.name + "\u201D", " ", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("span", {
                children: match.value
              })]
            })]
          }, index);
        })
      })
    })]
  });
};

var PickElement = function PickElement(_ref) {
  var disabled = _ref.disabled,
    runCommand = _ref.runCommand,
    setOptions = _ref.setOptions,
    editMode = _ref.editMode,
    setEditMode = _ref.setEditMode;
  var _useContext = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(LocatorContext),
    setLocator = _useContext.setLocator;
  var handlePick = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(function () {
    var pick = /*#__PURE__*/function () {
      var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var pickResult, items, target;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return runCommand('pick', function (bridge) {
                  return bridge.pick();
                });
              case 2:
                pickResult = _context.sent;
                if (pickResult) {
                  _context.next = 5;
                  break;
                }
                return _context.abrupt("return");
              case 5:
                items = Object.values(pickResult);
                setOptions(items);
                if (!(items.length === 0)) {
                  _context.next = 9;
                  break;
                }
                return _context.abrupt("return");
              case 9:
                target = {
                  strategy: items[0].strategy,
                  value: items[0].value,
                  type: DocType.Locator,
                  kind: LocatorType.Browser
                };
                setLocator(target);
              case 11:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));
      return function pick() {
        return _ref2.apply(this, arguments);
      };
    }();
    pick();
  }, []);
  var onChangeEditMode = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(function () {
    setEditMode(function (curr) {
      return !curr;
    });
  }, []);
  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z, {
    display: "flex",
    justifyContent: "space-between",
    alignItems: "center",
    width: "100%",
    children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_21__/* .Button */ .z, {
      icon: _robocorp_ds_icons__WEBPACK_IMPORTED_MODULE_34__/* ["default"] */ .Z,
      disabled: disabled,
      onClick: handlePick,
      children: "Pick Element"
    }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_35__/* .Switch */ .r, {
      checked: editMode,
      onChange: onChangeEditMode,
      label: "Edit Selector"
    })]
  });
};

var _templateObject$6, _templateObject2$2;
var Select$1 = /*#__PURE__*/(0,_robocorp_ds__WEBPACK_IMPORTED_MODULE_2__/* .styled */ .zo)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_36__/* .Select */ .P)(_templateObject$6 || (_templateObject$6 = /*#__PURE__*/_taggedTemplateLiteralLoose(["\n  flex: 1;\n  input {\n    border-left: none;\n    border-radius: 0 2px 2px 0;\n    &:hover,\n    &:focus {\n      border-color: ", ";\n    }\n  }\n"])), function (_ref) {
  var theme = _ref.theme;
  return theme.color('dark50');
});
var Strategy = /*#__PURE__*/_robocorp_ds__WEBPACK_IMPORTED_MODULE_2__/* .styled.div */ .zo.div(_templateObject2$2 || (_templateObject2$2 = /*#__PURE__*/_taggedTemplateLiteralLoose(["\n  display: flex;\n  align-items: center;\n  border: 1px solid ", ";\n  border-right: none;\n  height: 32px;\n  border-radius: 2px 0 0 2px;\n  padding-left: 8px;\n\n  background-color: ", ";\n\n  > span {\n    line-height: 20px;\n    border: 1px solid ", ";\n  }\n"])), function (_ref2) {
  var theme = _ref2.theme;
  return theme.color('dark50');
}, function (_ref3) {
  var theme = _ref3.theme;
  return theme.color('dark100');
}, function (_ref4) {
  var theme = _ref4.theme;
  return theme.color('dark60');
});
var SelectLocator = function SelectLocator(_ref5) {
  var options = _ref5.options;
  var _useContext = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(LocatorContext),
    locator = _useContext.locator,
    setLocator = _useContext.setLocator;
  var onOptionChange = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(function (value) {
    var target = options.find(function (item) {
      return item.value === value;
    });
    if (target) {
      setLocator(function (curr) {
        return curr ? _extends({}, curr, {
          value: target.value,
          strategy: target.strategy
        }) : curr;
      });
    }
  }, [options]);
  var selectOptions = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(function () {
    if (options.length === 0 && locator) {
      return [{
        value: locator.value,
        label: locator.value,
        optgroup: locator.strategy
      }];
    }
    return options.map(function (_ref6) {
      var strategy = _ref6.strategy,
        value = _ref6.value;
      return {
        value: value,
        label: value,
        optgroup: strategy
      };
    });
  }, [options, locator]);
  if (!locator) {
    return null;
  }
  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z, {
    pb: 12,
    display: "flex",
    justifyContent: "space-between",
    alignItems: "center",
    id: "select-locator",
    children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z, {
      display: "flex",
      flex: "1",
      id: "select-locator-container",
      children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Strategy, {
        id: "select-locator-container-strategy",
        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_31__/* .Badge */ .C, {
          label: isBrowserLocator(locator) ? locator.strategy : undefined,
          size: "small",
          variant: "secondary"
        })
      }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_27__/* ["default"] */ .Z, {
        vertical: true,
        variant: "custom",
        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Select$1, {
          id: "select-locator-container-select",
          items: selectOptions,
          value: locator.value,
          onChange: onOptionChange
        })
      })]
    })
  });
};

var StartBrowser = function StartBrowser(_ref) {
  var bridge = _ref.bridge,
    runCommand = _ref.runCommand;
  var _useState = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null),
    browsers = _useState[0],
    setBrowsers = _useState[1];
  var _useContext = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(LocatorContext),
    locator = _useContext.locator;
  var handleStart = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(function () {
    runCommand('starting', /*#__PURE__*/function () {
      var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(bridge) {
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                return _context.abrupt("return", bridge.start(locator == null ? void 0 : locator.source));
              case 1:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));
      return function (_x) {
        return _ref2.apply(this, arguments);
      };
    }());
  }, [locator]);
  var handleConnect = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(function (browser) {
    runCommand('starting', /*#__PURE__*/function () {
      var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(bridge) {
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                return _context2.abrupt("return", bridge.connect(browser));
              case 1:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      }));
      return function (_x2) {
        return _ref3.apply(this, arguments);
      };
    }());
  }, [locator]);
  var onBrowserSelect = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(function (item) {
    if (browsers) {
      var browser = browsers[parseInt(item, 10)];
      handleConnect(browser);
    }
  }, [browsers]);
  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {
    var getBrowsers = /*#__PURE__*/function () {
      var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
        var browsers;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return bridge.list();
              case 2:
                browsers = _context3.sent;
                if (browsers.length === 0) {
                  handleStart();
                } else if (browsers.length === 1) {
                  handleConnect(browsers[0]);
                } else {
                  setBrowsers(browsers);
                }
              case 4:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3);
      }));
      return function getBrowsers() {
        return _ref4.apply(this, arguments);
      };
    }();
    getBrowsers();
  }, []);
  if (!browsers) {
    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z, {
      px: 32,
      py: 18,
      children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_14__/* ["default"] */ .Z, {})
    });
  }
  var selectItems = browsers.map(function (browser, index) {
    return {
      value: index.toString(),
      label: browser.url || 'Empty'
    };
  });
  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z, {
    display: "flex",
    justifyContent: "space-between",
    alignItems: "center",
    children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_36__/* .Select */ .P, {
      items: selectItems,
      onChange: onBrowserSelect,
      placeholder: "Select available browser"
    }), "or", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_21__/* .Button */ .z, {
      onClick: handleStart,
      children: " Start new browser"
    })]
  });
};

var BrowserEditor = function BrowserEditor(_ref) {
  var bridge = _ref.bridge;
  var _useState = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]),
    matches = _useState[0],
    setMatches = _useState[1];
  var _useState2 = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]),
    options = _useState2[0],
    setOptions = _useState2[1];
  var _useState3 = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false),
    editMode = _useState3[0],
    setEditMode = _useState3[1];
  var _useState4 = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)('starting'),
    editorStatus = _useState4[0],
    setEditorStatus = _useState4[1];
  var prevEditorStatus = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)('starting');
  var _useState5 = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(),
    errorMessage = _useState5[0],
    setErrorMessage = _useState5[1];
  var _useState6 = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false),
    disableSave = _useState6[0],
    setDisableSave = _useState6[1];
  var _useContext = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(LocatorContext),
    locator = _useContext.locator,
    setLocator = _useContext.setLocator,
    setLocatorName = _useContext.setLocatorName,
    existingLocator = _useContext.existingLocator;
  var pollTimer = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();
  var validateDebounce = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(-1);
  var _useState7 = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null),
    setBrowsers = _useState7[1];
  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {
    autoStart();
  }, []);
  var validate = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
    var result;
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            if (!(!locator || locator.value.length === 0 || editorStatus !== 'idle' && editorStatus !== 'pick')) {
              _context2.next = 2;
              break;
            }
            return _context2.abrupt("return");
          case 2:
            _context2.next = 4;
            return runCommand('validate', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
              return _regeneratorRuntime().wrap(function _callee$(_context) {
                while (1) {
                  switch (_context.prev = _context.next) {
                    case 0:
                      return _context.abrupt("return", bridge.validate(locator.strategy, locator.value));
                    case 1:
                    case "end":
                      return _context.stop();
                  }
                }
              }, _callee);
            })));
          case 4:
            result = _context2.sent;
            setLocator(function (curr) {
              return curr ? _extends({}, curr, {
                screenshot: result == null ? void 0 : result.screenshot,
                source: result == null ? void 0 : result.source
              }) : curr;
            });
            setMatches((result == null ? void 0 : result.matches) || []);
            if (!existingLocator && result != null && result.matches && result.matches.length > 0) {
              setLocatorName(generateSelectorName(locator.strategy, locator.value, result.matches[0]));
            }
          case 8:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  })), [locator, editorStatus]);
  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {
    if (locator && !editMode) {
      setOptions([{
        strategy: locator.strategy,
        value: locator.value
      }]);
    }
  }, [editMode]);
  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {
    var immediate = validateDebounce.current < 0;
    clearTimeout(validateDebounce.current);
    validateDebounce.current = window.setTimeout(immediate ? function () {
      return null;
    } : validate, 500);
    if (immediate) {
      validate();
    }
  }, [locator == null ? void 0 : locator.value, locator == null ? void 0 : locator.strategy]);
  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {
    if (editorStatus === 'idle' && prevEditorStatus.current === 'starting') {
      validate();
    }
    prevEditorStatus.current = editorStatus;
  }, [editorStatus]);
  var updateStatus = /*#__PURE__*/function () {
    var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
      var isRunning, browsers;
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              clearTimeout(pollTimer.current);
              _context3.prev = 1;
              _context3.next = 4;
              return bridge.status();
            case 4:
              isRunning = _context3.sent;
              setEditorStatus(isRunning && isRunning !== 'stopped' ? 'idle' : 'stopped');
              if (!(!isRunning || isRunning === 'stopped')) {
                _context3.next = 11;
                break;
              }
              _context3.next = 9;
              return bridge.list();
            case 9:
              browsers = _context3.sent;
              setBrowsers(browsers);
            case 11:
              _context3.next = 16;
              break;
            case 13:
              _context3.prev = 13;
              _context3.t0 = _context3["catch"](1);
              // TODO: Show error or handled elsewhere?
              setEditorStatus('disabled');
            case 16:
              _context3.prev = 16;
              pollTimer.current = window.setTimeout(updateStatus, 1000);
              return _context3.finish(16);
            case 19:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3, null, [[1, 13, 16, 19]]);
    }));
    return function updateStatus() {
      return _ref4.apply(this, arguments);
    };
  }();
  var runCommand = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(function (status,
  // eslint-disable-next-line  @typescript-eslint/no-explicit-any
  callback) {
    var execute = /*#__PURE__*/function () {
      var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.prev = 0;
                setErrorMessage(undefined);
                setEditorStatus(status);
                _context4.next = 5;
                return callback(bridge);
              case 5:
                return _context4.abrupt("return", _context4.sent);
              case 8:
                _context4.prev = 8;
                _context4.t0 = _context4["catch"](0);
                if (_context4.t0 instanceof ErrorResponse) {
                  setErrorMessage(_context4.t0.message);
                } else if (_context4.t0 instanceof Error) {
                  setErrorMessage(_context4.t0.toString());
                }
                return _context4.abrupt("return", undefined);
              case 12:
                _context4.prev = 12;
                updateStatus();
                return _context4.finish(12);
              case 15:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, null, [[0, 8, 12, 15]]);
      }));
      return function execute() {
        return _ref5.apply(this, arguments);
      };
    }();
    return execute();
  }, []);
  var autoStart = /*#__PURE__*/function () {
    var _ref6 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {
      var isRunning, browsers;
      return _regeneratorRuntime().wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              _context5.prev = 0;
              _context5.next = 3;
              return bridge.status();
            case 3:
              isRunning = _context5.sent;
              if (!(isRunning && isRunning !== BrowserStatus.Stopped)) {
                _context5.next = 6;
                break;
              }
              return _context5.abrupt("return");
            case 6:
              _context5.next = 8;
              return bridge.list();
            case 8:
              browsers = _context5.sent;
              if (!(browsers.length === 0)) {
                _context5.next = 14;
                break;
              }
              _context5.next = 12;
              return handleStartBrowser();
            case 12:
              _context5.next = 17;
              break;
            case 14:
              if (!(browsers.length === 1)) {
                _context5.next = 17;
                break;
              }
              _context5.next = 17;
              return handleConnectBrowser(browsers[0]);
            case 17:
              setBrowsers(browsers);
            case 18:
              _context5.prev = 18;
              _context5.next = 21;
              return updateStatus();
            case 21:
              return _context5.finish(18);
            case 22:
            case "end":
              return _context5.stop();
          }
        }
      }, _callee5, null, [[0,, 18, 22]]);
    }));
    return function autoStart() {
      return _ref6.apply(this, arguments);
    };
  }();
  var handleStartBrowser = /*#__PURE__*/function () {
    var _ref7 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {
      return _regeneratorRuntime().wrap(function _callee7$(_context7) {
        while (1) {
          switch (_context7.prev = _context7.next) {
            case 0:
              _context7.next = 2;
              return runCommand('starting', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {
                return _regeneratorRuntime().wrap(function _callee6$(_context6) {
                  while (1) {
                    switch (_context6.prev = _context6.next) {
                      case 0:
                        return _context6.abrupt("return", bridge.start());
                      case 1:
                      case "end":
                        return _context6.stop();
                    }
                  }
                }, _callee6);
              })));
            case 2:
            case "end":
              return _context7.stop();
          }
        }
      }, _callee7);
    }));
    return function handleStartBrowser() {
      return _ref7.apply(this, arguments);
    };
  }();
  var handleConnectBrowser = /*#__PURE__*/function () {
    var _ref9 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(browser) {
      return _regeneratorRuntime().wrap(function _callee9$(_context9) {
        while (1) {
          switch (_context9.prev = _context9.next) {
            case 0:
              _context9.next = 2;
              return runCommand('starting', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {
                return _regeneratorRuntime().wrap(function _callee8$(_context8) {
                  while (1) {
                    switch (_context8.prev = _context8.next) {
                      case 0:
                        return _context8.abrupt("return", bridge.connect(browser));
                      case 1:
                      case "end":
                        return _context8.stop();
                    }
                  }
                }, _callee8);
              })));
            case 2:
            case "end":
              return _context9.stop();
          }
        }
      }, _callee9);
    }));
    return function handleConnectBrowser(_x) {
      return _ref9.apply(this, arguments);
    };
  }();
  if (editorStatus === 'starting') {
    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Container, {
      bridge: bridge,
      children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z, {
        p: 32,
        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_14__/* ["default"] */ .Z, {})
      })
    });
  }
  if (editorStatus === 'stopped' && errorMessage) {
    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Container, {
      bridge: bridge,
      children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ErrorMessage, {
        errorMessage: errorMessage
      })
    });
  }
  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(Container, {
    bridge: bridge,
    children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(PickElement, {
      disabled: editorStatus === 'pick',
      runCommand: runCommand,
      editMode: editMode,
      setEditMode: setEditMode,
      setOptions: setOptions
    }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Divider, {}), editMode && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {
      children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(EditLocator, {}), (locator == null ? void 0 : locator.value) && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Matches, {
        matches: matches,
        runCommand: runCommand
      }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Divider, {})]
    }), (locator == null ? void 0 : locator.value) && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {
      children: [!editMode && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {
        children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(SelectLocator, {
          options: options
        }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Divider, {})]
      }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(LocatorDetails, {
        setDisableSave: setDisableSave
      })]
    }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ErrorMessage, {
      errorMessage: errorMessage
    }), (locator == null ? void 0 : locator.value) && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(SaveLocator, {
      matches: matches.length,
      bridge: bridge,
      disableSave: disableSave || matches === undefined || (matches == null ? void 0 : matches.length) <= 0
    })]
  });
};

var Matches$1 = function Matches(_ref) {
  var matches = _ref.matches,
    runCommand = _ref.runCommand;
  var _useState = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false),
    open = _useState[0],
    setOpen = _useState[1];
  var onToggle = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(function () {
    setOpen(function (curr) {
      return !curr;
    });
  }, []);
  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {
    if (matches.length === 0) {
      setOpen(false);
    }
  }, [matches]);
  var onFocus = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(function (match) {
    return function () {
      runCommand('focus', /*#__PURE__*/function () {
        var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(bridge) {
          return _regeneratorRuntime().wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  return _context.abrupt("return", bridge.focus(match.window, match.value));
                case 1:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }));
        return function (_x) {
          return _ref2.apply(this, arguments);
        };
      }());
    };
  }, []);
  var label = matches.length === 0 ? 'No matching elements' : "Matching elements (" + matches.length + ")";
  var Icon = open ? _robocorp_ds_icons__WEBPACK_IMPORTED_MODULE_32__/* ["default"] */ .Z : _robocorp_ds_icons__WEBPACK_IMPORTED_MODULE_33__/* ["default"] */ .Z;
  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z, {
    pb: 8,
    children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(Collapse, {
      onClick: onToggle,
      disabled: matches.length === 0,
      children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z, {
        mr: 4,
        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Icon, {
          size: 16,
          color: "dark20"
        })
      }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z, {
        color: "dark0",
        children: label
      })]
    }), open && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_27__/* ["default"] */ .Z, {
      vertical: true,
      variant: "custom",
      height: "100%",
      id: "matching-container",
      children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(MatchContainer, {
        p: 16,
        mt: 4,
        children: matches.map(function (match, index) {
          return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(Match, {
            onClick: onFocus(match),
            children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Icon, {
              size: 12,
              color: "dark20"
            }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("strong", {
              children: ["\u201C" + match.name + "\u201D", " ", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("span", {
                children: match.value
              })]
            })]
          }, index);
        })
      })
    })]
  });
};

var _templateObject$7;
var Item = /*#__PURE__*/(0,_robocorp_ds__WEBPACK_IMPORTED_MODULE_2__/* .styled */ .zo)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_21__/* .ButtonBase */ .X)(_templateObject$7 || (_templateObject$7 = /*#__PURE__*/_taggedTemplateLiteralLoose(["\n  display: flex;\n  width: 100%;\n  padding: 0 ", ";\n  margin-bottom: ", ";\n  text-align: left;\n\n  strong {\n    display: flex;\n    align-items: center;\n    img,\n    div {\n      display: block;\n      width: 25px;\n      height: 25px;\n      margin-right: ", ";\n    }\n\n    span {\n      display: block;\n      white-space: nowrap;\n      width: 360px;\n      overflow: hidden;\n      text-overflow: ellipsis;\n    }\n  }\n"])), function (_ref) {
  var theme = _ref.theme;
  return theme.sizes.$16;
}, function (_ref2) {
  var theme = _ref2.theme;
  return theme.sizes.$8;
}, function (_ref3) {
  var theme = _ref3.theme;
  return theme.sizes.$8;
});
var Icon = function Icon(_ref4) {
  var icon = _ref4.icon;
  return icon ? (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("img", {
    src: "data:image/png;base64," + icon,
    width: 21,
    height: 21
  }) : (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", {});
};
var SelectWindow = function SelectWindow(_ref5) {
  var runCommand = _ref5.runCommand,
    bridge = _ref5.bridge,
    locator = _ref5.locator,
    locatorName = _ref5.locatorName,
    setActiveWindow = _ref5.setActiveWindow,
    latestWindowTitle = _ref5.latestWindowTitle;
  var _useState = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]),
    windows = _useState[0],
    setWindows = _useState[1];
  var _useState2 = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false),
    windowNotFound = _useState2[0],
    setWindowNotFound = _useState2[1];
  var pollInterval = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();
  var getWindows = /*#__PURE__*/function () {
    var _ref6 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
      var result;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return runCommand('starting', bridge.listWindows);
            case 2:
              result = _context.sent;
              if (result) {
                setWindows(result);
              }
            case 4:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return function getWindows() {
      return _ref6.apply(this, arguments);
    };
  }();
  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {
    pollInterval.current = window.setInterval(getWindows, 5000);
    return function () {
      clearInterval(pollInterval.current);
    };
  }, []);
  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {
    if (!locator || windows.length === 0) {
      if (!latestWindowTitle) {
        return;
      }
    }
    var match = windows.find(function (_ref7) {
      var _locator$window;
      var title = _ref7.title;
      return title === ((_locator$window = locator == null ? void 0 : locator.window) != null ? _locator$window : latestWindowTitle);
    });
    if (match) {
      setActiveWindow(match);
    } else {
      setWindowNotFound(true);
    }
  }, [locator, windows]);
  if (windows.length === 0) {
    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z, {
      p: 32,
      children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_14__/* ["default"] */ .Z, {})
    });
  }
  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z, {
    p: "$8",
    style: {
      overflow: 'hidden'
    },
    children: [windowNotFound && locator ? (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_15__/* .Typography */ .Z, {
      fontSize: "$13",
      py: "$12",
      lineHeight: 1.4,
      children: ["Could not find an open", ' ', (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_15__/* .Typography */ .Z, {
        as: "span",
        fontWeight: "semibold",
        children: ["\"", locator.window, "\""]
      }), ' ', "target window for the locator", ' ', (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_15__/* .Typography */ .Z, {
        as: "span",
        fontWeight: "semibold",
        children: ["\u201C", locatorName, "\u201D"]
      }), ". Open up the application or choose another window."]
    }) : (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_15__/* .Typography */ .Z, {
      fontWeight: "semibold",
      mb: "$8",
      children: "Select target window for the locator"
    }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_27__/* ["default"] */ .Z, {
      vertical: true,
      variant: "custom",
      height: 320,
      style: {
        margin: '16px'
      },
      indicators: true,
      children: windows.map(function (win) {
        if (win.title.length === 0) {
          return null;
        }
        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Item, {
          onClick: function onClick() {
            return setActiveWindow(win);
          },
          children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z, {
            display: "flex",
            children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z, {
              width: 21,
              mr: "$8",
              children: win.icon ? (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Icon, {
                icon: win.icon
              }) : (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds_icons__WEBPACK_IMPORTED_MODULE_37__/* ["default"] */ .Z, {
                size: 21
              })
            }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("strong", {
              children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("span", {
                children: win.title
              })
            })]
          })
        });
      })
    })]
  });
};

var _templateObject$8, _templateObject2$3;
var Select$2 = /*#__PURE__*/(0,_robocorp_ds__WEBPACK_IMPORTED_MODULE_2__/* .styled */ .zo)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_36__/* .Select */ .P)(_templateObject$8 || (_templateObject$8 = /*#__PURE__*/_taggedTemplateLiteralLoose(["\n  flex: 1;\n  input {\n    border-left: none;\n    border-radius: 0 2px 2px 0;\n    &:hover,\n    &:focus {\n      border-color: ", ";\n    }\n  }\n"])), function (_ref) {
  var theme = _ref.theme;
  return theme.color('dark50');
});
var Strategy$1 = /*#__PURE__*/_robocorp_ds__WEBPACK_IMPORTED_MODULE_2__/* .styled.div */ .zo.div(_templateObject2$3 || (_templateObject2$3 = /*#__PURE__*/_taggedTemplateLiteralLoose(["\n  display: flex;\n  align-items: center;\n  border: 1px solid ", ";\n  border-right: none;\n  height: 32px;\n  border-radius: 2px 0 0 2px;\n  padding-left: 8px;\n\n  background-color: ", ";\n\n  > span {\n    line-height: 20px;\n    border: 1px solid ", ";\n  }\n"])), function (_ref2) {
  var theme = _ref2.theme;
  return theme.color('dark50');
}, function (_ref3) {
  var theme = _ref3.theme;
  return theme.color('dark100');
}, function (_ref4) {
  var theme = _ref4.theme;
  return theme.color('dark60');
});
var SelectLocator$1 = function SelectLocator(_ref5) {
  var options = _ref5.options;
  var _useContext = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(LocatorContext),
    locator = _useContext.locator,
    setLocator = _useContext.setLocator;
  var onOptionChange = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(function (value) {
    var target = options.find(function (item) {
      return item.value === value;
    });
    if (target) {
      setLocator(function (curr) {
        return curr ? _extends({}, curr, {
          value: target.value
        }) : curr;
      });
    }
  }, [options]);
  var selectOptions = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(function () {
    if (options.length === 0 && locator) {
      return [{
        value: locator.value,
        label: locator.value
      }];
    }
    return options.map(function (_ref6) {
      var value = _ref6.value;
      return {
        value: value,
        label: value
      };
    });
  }, [options, locator]);
  if (!locator) {
    return null;
  }
  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z, {
    pb: 12,
    display: "flex",
    justifyContent: "space-between",
    alignItems: "center",
    id: "select-locator",
    children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z, {
      display: "flex",
      flex: "1",
      id: "select-locator-container",
      children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Strategy$1, {
        id: "select-locator-container-strategy",
        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_31__/* .Badge */ .C, {
          label: isBrowserLocator(locator) ? locator.strategy : undefined,
          size: "small",
          variant: "secondary"
        })
      }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Select$2, {
        id: "select-locator-container-select",
        items: selectOptions,
        value: locator.value,
        onChange: onOptionChange
      })]
    })
  });
};

var _templateObject$9;
var ApplicationTitle = /*#__PURE__*/(0,_robocorp_ds__WEBPACK_IMPORTED_MODULE_2__/* .styled */ .zo)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_15__/* .Typography */ .Z)(_templateObject$9 || (_templateObject$9 = /*#__PURE__*/_taggedTemplateLiteralLoose(["\n  max-width: 151px;\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n"])));
var WindowsEditor = function WindowsEditor(_ref) {
  var bridge = _ref.bridge;
  var _useContext = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(LocatorContext),
    locator = _useContext.locator,
    locatorName = _useContext.locatorName,
    setLocator = _useContext.setLocator,
    setLocatorName = _useContext.setLocatorName,
    existingLocator = _useContext.existingLocator;
  var _useState = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false),
    editMode = _useState[0],
    setEditMode = _useState[1];
  var _useState2 = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false),
    disableSave = _useState2[0],
    setDisableSave = _useState2[1];
  var _useState3 = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]),
    matches = _useState3[0],
    setMatches = _useState3[1];
  var _useState4 = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]),
    options = _useState4[0],
    setOptions = _useState4[1];
  var _useState5 = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null),
    activeWindow = _useState5[0],
    setActiveWindow = _useState5[1];
  var _useState6 = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(),
    errorMessage = _useState6[0],
    setErrorMessage = _useState6[1];
  var _useState7 = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)('idle'),
    editorStatus = _useState7[0],
    setEditorStatus = _useState7[1];
  var validateDebounce = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(-1);
  var validate = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(function () {
    var validate = /*#__PURE__*/function () {
      var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
        var result;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                setMatches([]);
                if (!(!locator || !activeWindow)) {
                  _context2.next = 3;
                  break;
                }
                return _context2.abrupt("return");
              case 3:
                _context2.next = 5;
                return runCommand('validate', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
                  return _regeneratorRuntime().wrap(function _callee$(_context) {
                    while (1) {
                      switch (_context.prev = _context.next) {
                        case 0:
                          _context.next = 2;
                          return bridge.validate(activeWindow.title, locator.value);
                        case 2:
                          return _context.abrupt("return", _context.sent);
                        case 3:
                        case "end":
                          return _context.stop();
                      }
                    }
                  }, _callee);
                })));
              case 5:
                result = _context2.sent;
                if ((result == null ? void 0 : result.matches.length) === 1) {
                  setLocator(function (curr) {
                    return curr ? _extends({}, curr, {
                      screenshot: result.matches[0].screenshot
                    }) : curr;
                  });
                  if (!existingLocator && result != null && result.matches && result.matches.length > 0) {
                    setLocatorName(activeWindow.title + " - " + toPascalCase(result.matches[0].value));
                  }
                }
                setMatches((result == null ? void 0 : result.matches) || []);
              case 8:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      }));
      return function validate() {
        return _ref2.apply(this, arguments);
      };
    }();
    validate();
  }, [activeWindow, locator]);
  var onChangeEditMode = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(function () {
    setEditMode(function (curr) {
      return !curr;
    });
  }, []);
  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {
    if ((matches == null ? void 0 : matches.length) === 0 && locator && !editMode) {
      setOptions([{
        value: locator.value
      }]);
    }
  }, [editMode]);
  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {
    var immediate = validateDebounce.current <= 0;
    clearTimeout(validateDebounce.current);
    validateDebounce.current = window.setTimeout(immediate ? function () {
      return null;
    } : validate, 500);
    if (immediate) {
      validate();
    }
  }, [activeWindow, locator == null ? void 0 : locator.value]);
  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {
    if (activeWindow !== null && bridge.latestWindow !== undefined) {
      bridge.latestWindow = activeWindow;
    }
  }, [activeWindow]);
  var runCommand = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(function (status, callback) {
    var execute = /*#__PURE__*/function () {
      var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.prev = 0;
                setErrorMessage(undefined);
                setEditorStatus(status);
                _context3.next = 5;
                return callback(bridge);
              case 5:
                return _context3.abrupt("return", _context3.sent);
              case 8:
                _context3.prev = 8;
                _context3.t0 = _context3["catch"](0);
                if (_context3.t0 instanceof ErrorResponse) {
                  setErrorMessage(_context3.t0.message);
                } else if (_context3.t0 instanceof Error) {
                  setErrorMessage(_context3.t0.toString());
                }
                return _context3.abrupt("return", undefined);
              case 12:
                _context3.prev = 12;
                setEditorStatus('idle');
                return _context3.finish(12);
              case 15:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, null, [[0, 8, 12, 15]]);
      }));
      return function execute() {
        return _ref4.apply(this, arguments);
      };
    }();
    return execute();
  }, []);
  var onValueChange = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(function (e) {
    setMatches([]);
    setLocator({
      type: DocType.Locator,
      kind: LocatorType.Windows,
      window: (activeWindow == null ? void 0 : activeWindow.title) || '',
      value: e.target.value,
      version: WINDOWS_LOCATOR_VERSION
    });
  }, []);
  var onResetLocator = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(function () {
    setLocator(undefined);
    setActiveWindow(null);
    if (bridge.latestWindow !== undefined) {
      bridge.latestWindow = null;
    }
  }, []);
  var handlePick = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(function () {
    var pick = /*#__PURE__*/function () {
      var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {
        var results, final_results;
        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                if (activeWindow) {
                  _context5.next = 2;
                  break;
                }
                return _context5.abrupt("return");
              case 2:
                _context5.next = 4;
                return runCommand('pick', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {
                  return _regeneratorRuntime().wrap(function _callee4$(_context4) {
                    while (1) {
                      switch (_context4.prev = _context4.next) {
                        case 0:
                          return _context4.abrupt("return", bridge.pick(activeWindow.title));
                        case 1:
                        case "end":
                          return _context4.stop();
                      }
                    }
                  }, _callee4);
                })));
              case 4:
                results = _context5.sent;
                setMatches([]);
                final_results = [];
                if (results && results.length > 0) {
                  final_results = [].concat(results);
                } else if (results && !(results instanceof Array)) {
                  final_results.push(results);
                }
                if (final_results && final_results.length > 0) {
                  setOptions(final_results.map(function (result) {
                    return {
                      value: result.value
                    };
                  }));
                  setLocator(final_results[0]);
                  setEditorStatus('validate');
                } else {
                  setLocator(undefined);
                  setErrorMessage('Could not find locator');
                }
              case 9:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5);
      }));
      return function pick() {
        return _ref5.apply(this, arguments);
      };
    }();
    pick();
  }, [activeWindow]);
  if (!activeWindow) {
    var _bridge$latestWindow;
    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Container, {
      bridge: bridge,
      children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(SelectWindow, {
        bridge: bridge,
        locator: locator,
        locatorName: locatorName,
        runCommand: runCommand,
        setActiveWindow: setActiveWindow,
        latestWindowTitle: (_bridge$latestWindow = bridge.latestWindow) == null ? void 0 : _bridge$latestWindow.title
      })
    });
  }
  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(Container, {
    bridge: bridge,
    children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z, {
      display: "flex",
      alignItems: "center",
      justifyContent: "space-between",
      pb: "$8",
      children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z, {
        display: "flex",
        mr: "$8",
        children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_21__/* .Button */ .z, {
          icon: _robocorp_ds_icons__WEBPACK_IMPORTED_MODULE_34__/* ["default"] */ .Z,
          disabled: editorStatus !== 'idle',
          onClick: handlePick,
          children: "Pick"
        }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z, {
          ml: "$8",
          children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_21__/* .Button */ .z, {
            variant: "secondary",
            disabled: editorStatus !== 'idle',
            onClick: onResetLocator,
            children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z, {
              width: 21,
              mr: "$8",
              children: activeWindow.icon ? (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Icon, {
                icon: activeWindow.icon
              }) : (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds_icons__WEBPACK_IMPORTED_MODULE_37__/* ["default"] */ .Z, {
                size: 21
              })
            }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ApplicationTitle, {
              fontSize: "$14",
              fontWeight: "normal",
              mb: "$2",
              children: "\"" + activeWindow.title + "\""
            })]
          })
        })]
      }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z, {
        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_35__/* .Switch */ .r, {
          disabled: !activeWindow,
          checked: editMode,
          onChange: onChangeEditMode,
          label: "Edit Selector"
        })
      })]
    }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Divider, {}), editMode && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {
      children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z, {
        pb: "$12",
        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_23__/* .Input */ .II, {
          value: locator == null ? void 0 : locator.value,
          onChange: onValueChange,
          placeholder: "Write selector here"
        })
      }), editorStatus !== 'validate' && (locator == null ? void 0 : locator.value) && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Matches$1, {
        matches: matches,
        runCommand: runCommand
      }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Divider, {})]
    }), (locator == null ? void 0 : locator.value) && matches.length > 0 && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {
      children: [!editMode && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {
        children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(SelectLocator$1, {
          options: options
        }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Divider, {})]
      }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(LocatorDetails, {
        setDisableSave: setDisableSave
      })]
    }), editorStatus === 'validate' && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z, {
      px: 32,
      pt: 18,
      pb: 30,
      children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_14__/* ["default"] */ .Z, {})
    }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ErrorMessage, {
      errorMessage: errorMessage
    }), (locator == null ? void 0 : locator.value) && matches.length > 0 && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(SaveLocator, {
      matches: matches.length,
      bridge: bridge,
      disableSave: disableSave
    })]
  });
};

var RecordButton = function RecordButton(props) {
  if (!props.currentlyRecording) {
    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_21__/* .Button */ .z, {
      icon: _robocorp_ds_icons__WEBPACK_IMPORTED_MODULE_38__/* ["default"] */ .Z,
      variant: "primary",
      onClick: props.startRecording,
      disabled: props.disable,
      children: props.hasEvents ? 'Record again' : 'Record'
    });
  } else {
    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_21__/* .Button */ .z, {
      onClick: props.stopRecording,
      loading: true,
      children: "Stop recording in Browser"
    });
  }
};

var SeleniumLibraryMap = {
  url: {
    keyword: 'Open Browser',
    icon: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds_icons_element__WEBPACK_IMPORTED_MODULE_39__/* ["default"] */ .Z, {
      size: "small"
    })
  },
  text: {
    keyword: 'Input Text',
    value: true,
    icon: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds_icons_element__WEBPACK_IMPORTED_MODULE_40__/* ["default"] */ .Z, {
      size: "small"
    })
  },
  file: {
    keyword: 'Choose File',
    value: true,
    _icon: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds_icons__WEBPACK_IMPORTED_MODULE_41__/* ["default"] */ .Z, {
      size: "small"
    }),
    get icon() {
      return this._icon;
    },
    set icon(value) {
      this._icon = value;
    }
  },
  button: {
    keyword: 'Click Button',
    icon: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds_icons_element__WEBPACK_IMPORTED_MODULE_42__/* ["default"] */ .Z, {
      size: "small"
    })
  },
  a: {
    keyword: 'Click Link',
    icon: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds_icons_element__WEBPACK_IMPORTED_MODULE_43__/* ["default"] */ .Z, {
      size: "small"
    })
  },
  select: {
    keyword: 'Select From List By Value',
    value: true,
    icon: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds_icons__WEBPACK_IMPORTED_MODULE_44__/* ["default"] */ .Z, {
      size: "small"
    })
  },
  // TODO: these might require special casses
  // radio:  { keyword: 'Select Radio Button', value: true },
  radio: {
    keyword: 'Click Element',
    value: true,
    icon: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds_icons_element__WEBPACK_IMPORTED_MODULE_45__/* ["default"] */ .Z, {
      size: "small"
    })
  },
  checkbox: {
    keyword: 'Click Element',
    value: true,
    icon: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds_icons_element__WEBPACK_IMPORTED_MODULE_45__/* ["default"] */ .Z, {
      size: "small"
    })
  },
  submit: {
    keyword: 'Click Element',
    value: true,
    icon: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds_icons_element__WEBPACK_IMPORTED_MODULE_45__/* ["default"] */ .Z, {
      size: "small"
    })
  },
  image: {
    keyword: 'Click Element',
    value: true,
    icon: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds_icons_element__WEBPACK_IMPORTED_MODULE_45__/* ["default"] */ .Z, {
      size: "small"
    })
  },
  range: {
    keyword: 'Click Element',
    value: true,
    icon: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds_icons_element__WEBPACK_IMPORTED_MODULE_45__/* ["default"] */ .Z, {
      size: "small"
    })
  },
  reset: {
    keyword: 'Click Element',
    value: true,
    icon: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds_icons_element__WEBPACK_IMPORTED_MODULE_45__/* ["default"] */ .Z, {
      size: "small"
    })
  },
  demo: {
    keyword: 'Sleep    ${SLEEP}',
    icon: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds_icons__WEBPACK_IMPORTED_MODULE_46__/* ["default"] */ .Z, {
      size: "small"
    })
  },
  verify: {
    keyword: 'Wait Until Page Contains Element',
    icon: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds_icons_element__WEBPACK_IMPORTED_MODULE_47__/* ["default"] */ .Z, {
      size: "small"
    })
  },
  "default": {
    keyword: 'Click Element',
    icon: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds_icons_element__WEBPACK_IMPORTED_MODULE_45__/* ["default"] */ .Z, {
      size: "small"
    })
  },
  comment: {
    keyword: '#',
    value: true,
    icon: null
  }
};
var RecordedOperationMapping = SeleniumLibraryMap;
var isSelectorALocator = function isSelectorALocator(selector, locators) {
  for (var _i2 = 0, _Object$entries2 = Object.entries(locators ? locators : {}); _i2 < _Object$entries2.length; _i2++) {
    var _locatorValue, _locatorValue2;
    var _Object$entries2$_i = _Object$entries2[_i2],
      key = _Object$entries2$_i[0],
      value = _Object$entries2$_i[1];
    var locatorValue = value;
    if (((_locatorValue = locatorValue) == null ? void 0 : _locatorValue.value) === (selector == null ? void 0 : selector.value) && ((_locatorValue2 = locatorValue) == null ? void 0 : _locatorValue2.strategy) === (selector == null ? void 0 : selector.strategy)) {
      return {
        key: key,
        value: value
      };
    }
  }
  return undefined;
};
var getKeywordAsLocator = function getKeywordAsLocator(selectors, locators) {
  var foundSelector = selectors == null ? void 0 : selectors.find(function (selector) {
    return isSelectorALocator(selector, locators) !== undefined;
  });
  return foundSelector ? isSelectorALocator(foundSelector, locators) : undefined;
};
var buildSelectorCode = function buildSelectorCode(selector) {
  return selector != null && selector.strategy ? (selector == null ? void 0 : selector.strategy) + ":" + (selector == null ? void 0 : selector.value) : "" + (selector == null ? void 0 : selector.value);
};
var buildBrowserLocator = function buildBrowserLocator(selector, meta) {
  return {
    type: DocType.Locator,
    kind: LocatorType.Browser,
    strategy: selector != null && selector.strategy ? selector == null ? void 0 : selector.strategy : '',
    value: selector != null && selector.value ? selector == null ? void 0 : selector.value : '',
    screenshot: meta == null ? void 0 : meta.screenshot,
    source: meta == null ? void 0 : meta.screenshot
  };
};
var buildCodeLineText = function buildCodeLineText(code, forceSelector) {
  var line = [];
  line.push(code.keyword);
  var selector = forceSelector ? forceSelector : code.selectors[0] ? buildSelectorCode(code.selectors[0]) : '';
  line.push(selector);
  return line.concat(code.args).join(' '.repeat(4));
};
var buildRecordedCodeLine = function buildRecordedCodeLine(code, forceSelector) {
  var selector = forceSelector ? forceSelector : code.selectors[0] ? buildSelectorCode(code.selectors[0]) : '';
  return {
    keyword: code.keyword,
    locator: selector,
    modifier: code.args[0] ? code.args[0] : undefined
  };
};
var buildCodeLineTextFromEvent = function buildCodeLineTextFromEvent(ev, locators) {
  var node = ev.node;
  var keywordAsLocator = getKeywordAsLocator(node == null ? void 0 : node.selectors, locators);
  var selector = keywordAsLocator && keywordAsLocator.key ? "alias:" + keywordAsLocator.key : undefined;
  return buildCodeLineText(node, selector);
};
var buildRecordedCodeLineFromEventAsLocator = function buildRecordedCodeLineFromEventAsLocator(ev, recOps, index) {
  var _node$selectors$;
  var node = ev.node;
  if (node.selectors === undefined || node.selectors.length === 0 || node.selectors.length > 0 && ((_node$selectors$ = node.selectors[0]) == null ? void 0 : _node$selectors$.strategy) === undefined) {
    return undefined;
  }
  var opMeta = recOps.meta && recOps.meta.length > 0 ? recOps.meta[0].matches[0] : undefined;
  var generatedLocator = generateSelectorName(node.selectors[0].strategy, node.selectors[0].value, opMeta, index);
  var selector = "alias:" + generatedLocator;
  return buildRecordedCodeLine(node, selector);
};
var saveFirstSelectorsAsLocators = function saveFirstSelectorsAsLocators(ops, bridge) {
  ops.forEach( /*#__PURE__*/function () {
    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(op) {
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return bridge.save(generateSelectorName(op.selectors[0].strategy, op.selectors[0].value, op.meta[0].matches[0]), {
                kind: LocatorType.Browser,
                type: DocType.Locator,
                value: op.selectors[0].value,
                strategy: op.selectors[0].strategy,
                screenshot: op.meta[0].screenshot
              });
            case 2:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return function (_x) {
      return _ref.apply(this, arguments);
    };
  }());
};
var isNodeComponent = function isNodeComponent(node) {
  return node ? !Object.prototype.hasOwnProperty.call(node, 'keyword') : false;
};

var _templateObject$a, _templateObject2$4, _templateObject3$2, _templateObject4;
var KeywordContainer = /*#__PURE__*/_robocorp_ds__WEBPACK_IMPORTED_MODULE_2__/* .styled.div */ .zo.div(_templateObject$a || (_templateObject$a = /*#__PURE__*/_taggedTemplateLiteralLoose(["\n  position: relative;\n  display: flex;\n  flex: 1;\n  align-items: center;\n  justify-content: space-between;\n  height: 36px;\n  border-radius: 4px;\n  padding-left: 12px;\n  padding-right: 12px;\n  min-width: 'none';\n  gap: 8px;\n\n  color: ", ";\n\n  border: 1px solid transparent;\n  border-left: none;\n  background: ", ";\n  white-space: nowrap;\n\n  overflow: hidden;\n  text-overflow: ellipsis;\n\n  &:before {\n    display: ", ";\n    content: '';\n    position: absolute;\n    left: 0px;\n    top: -1px;\n    width: 12px;\n    height: calc(100% + 2px);\n    border-radius: 4px 0 0 4px;\n    background: ", ";\n  }\n\n  &:after {\n    content: '';\n    position: absolute;\n    left: 0px;\n    top: -1px;\n    height: calc(100% + 2px);\n    width: calc(100% + 2px);\n    pointer-events: none;\n    border-radius: 4px;\n    border: 1px solid transparent;\n    z-index: 3;\n  }\n\n  > div > span {\n    max-height: 16px;\n  }\n"])), function (_ref) {
  var theme = _ref.theme,
    color = _ref.color;
  return color ? theme.color(color)({
    theme: theme
  }) : theme.color('dark0');
}, function (_ref2) {
  var theme = _ref2.theme;
  return theme.color('dark80', 'light100')({
    theme: theme
  });
}, function (_ref3) {
  var simple = _ref3.simple;
  return simple ? 'none' : 'block';
}, function (_ref4) {
  var theme = _ref4.theme;
  return theme.color('yellow50')({
    theme: theme
  });
});
var ArgContainer = /*#__PURE__*/_robocorp_ds__WEBPACK_IMPORTED_MODULE_2__/* .styled.div */ .zo.div(_templateObject2$4 || (_templateObject2$4 = /*#__PURE__*/_taggedTemplateLiteralLoose(["\n  position: relative;\n  display: flex;\n  flex: ", ";\n  align-items: center;\n  justify-content: space-between;\n  height: 28px;\n  border-radius: 4px;\n  padding-left: ", ";\n  padding-right: 8px;\n  min-width: 'none';\n\n  border-left: none;\n  background: ", ";\n  white-space: nowrap;\n  font-size: 12px;\n  color: ", ";\n\n  overflow: hidden;\n  text-overflow: ellipsis;\n\n  &:before {\n    content: '';\n    position: absolute;\n    left: 0px;\n    top: -1px;\n    width: 8px;\n    height: calc(100% + 2px);\n    border-radius: 4px 0 0 4px;\n    background: ", ";\n  }\n\n  &:after {\n    content: '';\n    position: absolute;\n    left: 0px;\n    top: -1px;\n    height: calc(100% + 2px);\n    width: calc(100% + 2px);\n    pointer-events: none;\n    border-radius: 4px;\n    border: 1px solid transparent;\n    z-index: 3;\n  }\n\n  > div > span {\n    max-height: 16px;\n  }\n"])), function (_ref5) {
  var grow = _ref5.grow;
  return grow ? grow : 1;
}, function (_ref6) {
  var simple = _ref6.simple;
  return simple ? '8px' : '12px';
}, function (_ref7) {
  var fill = _ref7.fill,
    theme = _ref7.theme;
  return fill ? theme.colors.green70 : theme.color('dark100', 'light80')({
    theme: theme
  });
}, function (_ref8) {
  var theme = _ref8.theme,
    fill = _ref8.fill;
  return fill ? theme.color('green10') : theme.color('dark0');
}, function (_ref9) {
  var theme = _ref9.theme,
    simple = _ref9.simple;
  return simple ? 'transparent' : theme.color('green50')({
    theme: theme
  });
});
var ListContainer = /*#__PURE__*/_robocorp_ds__WEBPACK_IMPORTED_MODULE_2__/* .styled.div */ .zo.div(_templateObject3$2 || (_templateObject3$2 = /*#__PURE__*/_taggedTemplateLiteralLoose(["\n  display: flex;\n  flex-direction: column;\n  gap: 4px;\n  padding: 16px;\n  width: 100%;\n  height: 'fit-content';\n  min-height: 400px;\n  border-radius: 8px;\n  background: ", ";\n"])), function (_ref10) {
  var theme = _ref10.theme;
  return theme.color('dark100', 'light80')({
    theme: theme
  });
});
var SaveClick = /*#__PURE__*/_robocorp_ds__WEBPACK_IMPORTED_MODULE_2__/* .styled.div */ .zo.div(_templateObject4 || (_templateObject4 = /*#__PURE__*/_taggedTemplateLiteralLoose(["\n  position: absolute;\n  right: 0px;\n  padding: 4px;\n  padding-top: 7px;\n  background: ", ";\n  z-index: 999;\n"])), function (_ref11) {
  var theme = _ref11.theme;
  return theme.color('dark100', 'light80')({
    theme: theme
  });
});
var Keyword = function Keyword(_ref12) {
  var _getFirstSelectorValu, _getFirstSelectorValu2, _getFirstSelectorValu3;
  var keyword = _ref12.keyword,
    icon = _ref12.icon,
    operation = _ref12.operation,
    savedLocators = _ref12.savedLocators,
    onDelete = _ref12.onDelete,
    onSave = _ref12.onSave;
  var getFirstSelectorValue = function getFirstSelectorValue() {
    return operation != null && operation.selectors && (operation == null ? void 0 : operation.selectors.length) !== 0 ? operation.selectors[0] : undefined;
  };
  var keywordAsLocator = getKeywordAsLocator(operation == null ? void 0 : operation.selectors, savedLocators);
  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z, {
    height: 36,
    children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(KeywordContainer, {
      simple: false,
      children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_30__/* ["default"] */ .Z, {
        text: keyword,
        placement: "top-start",
        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z, {
          color: "dark30",
          pl: 12,
          children: icon
        })
      }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(ArgContainer, {
        simple: keywordAsLocator === undefined,
        grow: 2,
        children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z, {
          display: "flex",
          alignItems: "center",
          children: [keywordAsLocator !== undefined ? (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z, {
            px: 4,
            children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds_icons_element__WEBPACK_IMPORTED_MODULE_48__/* ["default"] */ .Z, {
              color: "dark30",
              size: "small"
            })
          }) : (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_31__/* .Badge */ .C, {
            label: (_getFirstSelectorValu = getFirstSelectorValue()) == null ? void 0 : _getFirstSelectorValu.strategy.toUpperCase(),
            size: "medium",
            variant: "primary",
            highlight: true
          }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_30__/* ["default"] */ .Z, {
            text: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z, {
              style: {
                wordBreak: 'break-all'
              },
              width: 100,
              children: keywordAsLocator !== undefined ? keywordAsLocator.key : (_getFirstSelectorValu2 = getFirstSelectorValue()) == null ? void 0 : _getFirstSelectorValu2.value
            }),
            placement: "top-start",
            children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z, {
              pl: 2,
              style: {
                overflow: 'hidden',
                textOverflow: 'ellipsis'
              },
              children: keywordAsLocator !== undefined ? keywordAsLocator.key : (_getFirstSelectorValu3 = getFirstSelectorValue()) == null ? void 0 : _getFirstSelectorValu3.value
            })
          })]
        }), keywordAsLocator === undefined ? (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(SaveClick, {
          children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_30__/* ["default"] */ .Z, {
            text: "Save Locator",
            children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds_icons_element__WEBPACK_IMPORTED_MODULE_49__/* ["default"] */ .Z, {
              onClick: function onClick() {
                return onSave && operation ? onSave(operation) : null;
              },
              color: "dark30",
              size: "small",
              style: {
                cursor: 'pointer'
              }
            })
          })
        }) : null]
      }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ArgContainer, {
        simple: true,
        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_30__/* ["default"] */ .Z, {
          text: operation != null && operation.value ? (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z, {
            style: {
              wordBreak: 'break-all'
            },
            width: 100,
            children: "" + operation.value
          }) : undefined,
          placement: "top-start",
          children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z, {
            pl: 4,
            style: {
              overflow: 'hidden',
              textOverflow: 'ellipsis'
            },
            children: operation != null && operation.value ? "" + operation.value : ''
          })
        })
      }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_30__/* ["default"] */ .Z, {
        text: "Delete Line",
        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds_icons__WEBPACK_IMPORTED_MODULE_50__/* ["default"] */ .Z, {
          onClick: onDelete,
          color: "dark30",
          size: "small",
          style: {
            cursor: 'pointer'
          }
        })
      })]
    })
  });
};
var Comment = function Comment(_ref13) {
  var keyword = _ref13.keyword;
  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z, {
    height: 36,
    children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(KeywordContainer, {
      simple: true,
      color: "dark30",
      children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z, {
        fontSize: 12,
        style: {
          overflow: 'hidden',
          textOverflow: 'ellipsis',
          fontStyle: 'italic'
        },
        children: "# " + keyword
      })
    })
  });
};
var KeywordList = function KeywordList(_ref14) {
  var children = _ref14.children;
  var listEnd = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);
  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {
    if (listEnd) {
      var _listEnd$current;
      (_listEnd$current = listEnd.current) == null ? void 0 : _listEnd$current.scrollIntoView({
        behavior: 'smooth'
      });
    }
  }, [children == null ? void 0 : children.length]);
  return children ? (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z, {
    maxHeight: 400,
    height: 400,
    children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_27__/* ["default"] */ .Z, {
      variant: "custom",
      children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ListContainer, {
        children: children
      }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", {
        style: {
          "float": 'left',
          clear: 'both'
        },
        ref: function ref(el) {
          return listEnd ? listEnd.current = el : null;
        }
      })]
    })
  }) : null;
};

var maxLength = 5000;
var _generateCodeLine = function _generateCodeLine(operation) {
  var type = RecordedOperationMapping[operation.type] || RecordedOperationMapping["default"];
  var codeLine = {
    keyword: type.keyword,
    selectors: operation.selectors,
    args: []
  };
  if (operation.type === 'url') {
    codeLine.args.push('${BROWSER}');
  }
  if (operation.value) {
    if ('value' in type && type.value) {
      type.value ? codeLine.args.push("" + operation.value) : '';
    }
  }
  return codeLine;
};
var _generateCodeEvents = function _generateCodeEvents(operations, maxNumber) {
  var events = [];
  operations.forEach(function (operation, index) {
    if (index >= maxNumber) {
      return;
    }
    var codeLine = _generateCodeLine(operation);
    codeLine && events.push({
      id: index,
      node: codeLine
    });
  });
  return events;
};
var _generateVisualEvent = function _generateVisualEvent(operation, locators, onDelete, onSave) {
  var type = RecordedOperationMapping[operation.type] || RecordedOperationMapping["default"];
  if (operation.type === 'comment') {
    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Comment, {
      keyword: _generateCodeLine(operation).args.join(' ')
    });
  }
  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Keyword, {
    keyword: type == null ? void 0 : type.keyword,
    icon: type == null ? void 0 : type.icon,
    operation: operation,
    savedLocators: locators,
    onDelete: onDelete,
    onSave: onSave
  });
};
var _generateVisualEvents = function _generateVisualEvents(operations, maxNumber, locators, onDelete, onSave) {
  var events = [];
  operations.forEach(function (operation, index) {
    if (index >= maxNumber) {
      return;
    }
    events.push({
      id: index,
      node: _generateVisualEvent(operation, locators, function () {
        onDelete ? onDelete(index) : null;
      }, onSave)
    });
  });
  return events;
};
var translateRecordedOperationsToCode = function translateRecordedOperationsToCode(operations /* , length: number, demo: boolean, verify: boolean */) {
  return _generateCodeEvents(operations, maxLength);
};
var translateRecordedOperationsToVisualCode = function translateRecordedOperationsToVisualCode(operations /* , length: number, demo: boolean, verify: boolean */, locators, onDelete, onSave) {
  return _generateVisualEvents(operations, maxLength, locators, onDelete, onSave);
};

var SaveLocatorDialog = function SaveLocatorDialog(props) {
  var _props$operation, _props$operation2;
  var _useContext = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(LocatorContext),
    locator = _useContext.locator,
    locatorName = _useContext.locatorName;
  var _useState = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(),
    matches = _useState[0],
    setMatches = _useState[1];
  var _useState2 = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false),
    disableSave = _useState2[0],
    _setDisableSave = _useState2[1];
  var getMatches = function getMatches(locator, operation) {
    var _operation$selectors;
    var foundIndex = operation == null ? void 0 : (_operation$selectors = operation.selectors) == null ? void 0 : _operation$selectors.findIndex(function (selector) {
      return locator.strategy === selector.strategy && locator.value === selector.value;
    });
    return operation && foundIndex !== undefined && foundIndex !== -1 && operation.meta ? operation == null ? void 0 : operation.meta[foundIndex].matches : undefined;
  };
  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {
    if (locator) {
      setMatches(getMatches(locator, props.operation));
    }
  }, []);
  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {
    if (locator) {
      setMatches(getMatches(locator, props.operation));
    }
    _setDisableSave(locatorName === undefined || locatorName === '' || locator === undefined);
  }, [locator, props.operation]);
  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_11__/* .Dialog */ .V, {
    open: props.open,
    onClose: props.onClose,
    title: "Save Locator",
    children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_11__/* .Dialog.Content */ .V.Content, {
      children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z, {
        display: "flex",
        flexDirection: "column",
        children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z, {
          mb: 8,
          children: (_props$operation = props.operation) != null && _props$operation.selectors ? (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(SelectLocator, {
            options: (_props$operation2 = props.operation) == null ? void 0 : _props$operation2.selectors
          }) : null
        }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z, {
          children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(LocatorDetails, {
            setDisableSave: function setDisableSave(disableSave) {
              _setDisableSave(disableSave);
            }
          })
        }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z, {
          children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(SaveLocator, {
            bridge: props.bridge,
            matches: matches ? matches.length : 0,
            disableSave: disableSave,
            afterSave: props.afterSave,
            onClose: props.onClose
          })
        })]
      })
    })
  });
};

var WebRecorderEditor = function WebRecorderEditor(_ref) {
  var bridge = _ref.bridge,
    _ref$mode = _ref.mode,
    mode = _ref$mode === void 0 ? 'stand-alone' : _ref$mode,
    onSave = _ref.onSave;
  // checkLocatorsTimer - timeout polling for locators update
  var checkLocatorsTimer = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();
  // checkStatusTimer - timeout polling for editor status update
  var checkStatusTimer = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();
  // codeEvents - array of strings that represents generated code
  var _useState = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]),
    codeEvents = _useState[0],
    setCodeEvents = _useState[1];
  // visualCodeEvents - array of the ReactNodes to display in FE
  var _useState2 = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]),
    visualCodeEvents = _useState2[0],
    setVisualCodeEvents = _useState2[1];
  var operationEvents = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)([]);
  // keywordIndexToDelete - operational value used in callback so that we remove the exact element
  var _useState3 = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(),
    keywordIndexToDelete = _useState3[0],
    setKeywordIndexToDelete = _useState3[1];
  // showAsCode - switch display to the generated code & not keywords view
  var _useState4 = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false),
    showAsCode = _useState4[0],
    setShowAsCode = _useState4[1];
  // currentlyRecording - boolean that indicates if we are currently in the recording process
  var currentlyRecording = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);
  // editorStatus - status value that represents the async functionality
  var _useState5 = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)('starting'),
    editorStatus = _useState5[0],
    setEditorStatus = _useState5[1];
  // errorMessage - string that contains the error OR undefined
  var _useState6 = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(),
    errorMessage = _useState6[0],
    setErrorMessage = _useState6[1];
  // browsers - current opened browser array
  var _useState7 = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]),
    browsers = _useState7[0],
    setBrowsers = _useState7[1];
  var _useState8 = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false),
    saving = _useState8[0],
    setSaving = _useState8[1];
  // locator context
  var _useContext = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(LocatorContext),
    setLocator = _useContext.setLocator,
    setLocatorName = _useContext.setLocatorName;
  // savedLocators - locators from locators.json file
  var _useState9 = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({}),
    savedLocators = _useState9[0],
    setSavedLocators = _useState9[1];
  var _useState10 = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(),
    activeOperation = _useState10[0],
    setActiveOperation = _useState10[1];
  var _useState11 = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false),
    openSaveSelectorDialog = _useState11[0],
    setOpenSaveSelectorDialog = _useState11[1];
  // connect/start browser on start
  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {
    var updateLocs = /*#__PURE__*/function () {
      var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return updateLocators();
              case 2:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));
      return function updateLocs() {
        return _ref2.apply(this, arguments);
      };
    }();
    handleStart();
    updateLocs();
  }, []);
  // effect to delete keywords & code lines one by one
  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {
    if (keywordIndexToDelete !== undefined) {
      var newCodeEvents = [].concat(codeEvents);
      var newVisualCodeEvents = [].concat(visualCodeEvents ? visualCodeEvents : []);
      var newOperations = [].concat(operationEvents.current);
      // determine index to delete at based on the KeyEvent id
      var indexToDelete = newVisualCodeEvents.findIndex(function (ev) {
        return ev.id === keywordIndexToDelete;
      });
      // deleting elements from arrays
      newCodeEvents.splice(indexToDelete, 1);
      newVisualCodeEvents == null ? void 0 : newVisualCodeEvents.splice(indexToDelete, 1);
      newOperations.splice(indexToDelete, 1);
      // updating elements
      setCodeEvents(newCodeEvents);
      setVisualCodeEvents(newVisualCodeEvents);
      operationEvents.current = newOperations;
      // resetting index to delete
      setKeywordIndexToDelete(undefined);
    }
  }, [keywordIndexToDelete]);
  // effect to translate the active operation to a workable locator
  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {
    var _activeOperation$meta;
    var firstSelector = activeOperation && activeOperation.selectors.length > 0 ? activeOperation.selectors[0] : undefined;
    var firstMeta = activeOperation && ((_activeOperation$meta = activeOperation.meta) == null ? void 0 : _activeOperation$meta.length) > 0 ? activeOperation.meta[0] : undefined;
    var generatedName = generateSelectorName(firstSelector != null && firstSelector.strategy ? firstSelector == null ? void 0 : firstSelector.strategy : '', firstSelector != null && firstSelector.value ? firstSelector == null ? void 0 : firstSelector.value : '', firstMeta != null && firstMeta.matches && firstMeta.matches.length > 0 ? firstMeta.matches[0] : {
      name: '',
      value: ''
    });
    setLocator(buildBrowserLocator(firstSelector, firstMeta));
    setLocatorName(generatedName);
  }, [activeOperation]);
  // handleStart - handle browser operation - start & connect
  var handleStart = /*#__PURE__*/function () {
    var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
      var isRunning, _browsers;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              _context2.prev = 0;
              _context2.next = 3;
              return bridge.status();
            case 3:
              isRunning = _context2.sent;
              if (!(isRunning && isRunning !== 'stopped')) {
                _context2.next = 6;
                break;
              }
              return _context2.abrupt("return");
            case 6:
              _context2.next = 8;
              return bridge.list();
            case 8:
              _browsers = _context2.sent;
              if (!(_browsers.length === 0)) {
                _context2.next = 14;
                break;
              }
              _context2.next = 12;
              return handleStartBrowser();
            case 12:
              _context2.next = 17;
              break;
            case 14:
              if (!(_browsers.length === 1)) {
                _context2.next = 17;
                break;
              }
              _context2.next = 17;
              return handleConnectBrowser(_browsers[0]);
            case 17:
              setBrowsers(_browsers);
            case 18:
              _context2.prev = 18;
              _context2.next = 21;
              return updateStatus();
            case 21:
              return _context2.finish(18);
            case 22:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, null, [[0,, 18, 22]]);
    }));
    return function handleStart() {
      return _ref3.apply(this, arguments);
    };
  }();
  // updateStatus - update the editor status based on the browser state
  var updateStatus = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
    var isRunning, _browsers2;
    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            clearTimeout(checkStatusTimer.current);
            _context3.prev = 1;
            if (!currentlyRecording.current) {
              _context3.next = 6;
              break;
            }
            setEditorStatus('busy');
            checkStatusTimer.current = window.setTimeout(updateStatus, 1000);
            return _context3.abrupt("return");
          case 6:
            _context3.next = 8;
            return bridge.status();
          case 8:
            isRunning = _context3.sent;
            setEditorStatus(isRunning && isRunning !== 'stopped' ? 'idle' : 'stopped');
            if (!(!isRunning || isRunning === 'stopped')) {
              _context3.next = 15;
              break;
            }
            _context3.next = 13;
            return bridge.list();
          case 13:
            _browsers2 = _context3.sent;
            setBrowsers(_browsers2);
          case 15:
            _context3.next = 21;
            break;
          case 17:
            _context3.prev = 17;
            _context3.t0 = _context3["catch"](1);
            // TODO: Show error or handled elsewhere?
            setEditorStatus('disabled');
            setErrorMessage("Browser not connected: " + _context3.t0);
          case 21:
            _context3.prev = 21;
            checkStatusTimer.current = window.setTimeout(updateStatus, 1000);
            return _context3.finish(21);
          case 24:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3, null, [[1, 17, 21, 24]]);
  })), [currentlyRecording]);
  // updateLocators - refresh the saved locators
  var updateLocators = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {
    var result;
    return _regeneratorRuntime().wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            clearTimeout(checkLocatorsTimer.current);
            _context4.prev = 1;
            _context4.next = 4;
            return bridge.getLocators();
          case 4:
            result = _context4.sent;
            setSavedLocators(result);
            setVisualCodeEvents(translateRecordedOperationsToVisualCode(operationEvents.current, result, setKeywordIndexToDelete, function (operation) {
              setActiveOperation(operation);
              setOpenSaveSelectorDialog(true);
            }));
            _context4.next = 12;
            break;
          case 9:
            _context4.prev = 9;
            _context4.t0 = _context4["catch"](1);
            setErrorMessage("Failed to read locators: " + _context4.t0);
          case 12:
            _context4.prev = 12;
            checkLocatorsTimer.current = window.setTimeout(updateLocators, 5000);
            return _context4.finish(12);
          case 15:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4, null, [[1, 9, 12, 15]]);
  })), [bridge, operationEvents.current]);
  // runCommand - wrapper for executing the callback & changing the status
  var runCommand = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(function (status,
  // eslint-disable-next-line  @typescript-eslint/no-explicit-any
  callback) {
    var execute = /*#__PURE__*/function () {
      var _ref6 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {
        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                _context5.prev = 0;
                setErrorMessage(undefined);
                setEditorStatus(status);
                _context5.next = 5;
                return callback(bridge);
              case 5:
                return _context5.abrupt("return", _context5.sent);
              case 8:
                _context5.prev = 8;
                _context5.t0 = _context5["catch"](0);
                if (_context5.t0 instanceof ErrorResponse) {
                  setErrorMessage(_context5.t0.message);
                } else if (_context5.t0 instanceof Error) {
                  setErrorMessage(_context5.t0.toString());
                }
                return _context5.abrupt("return", undefined);
              case 12:
                _context5.prev = 12;
                _context5.next = 15;
                return updateStatus();
              case 15:
                return _context5.finish(12);
              case 16:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, null, [[0, 8, 12, 16]]);
      }));
      return function execute() {
        return _ref6.apply(this, arguments);
      };
    }();
    return execute();
  }, []);
  // startRecording - start the recording and translate the recorded events
  var startRecording = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {
    var result, tempCodeEvents, tempVisualCodeEvents;
    return _regeneratorRuntime().wrap(function _callee6$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            // start the recording
            currentlyRecording.current = true;
            // ensure browser
            if (!(browsers.length === 0)) {
              _context6.next = 4;
              break;
            }
            _context6.next = 4;
            return handleStart();
          case 4:
            if (currentlyRecording.current) {
              _context6.next = 7;
              break;
            }
            return _context6.abrupt("break", 15);
          case 7:
            _context6.next = 9;
            return runCommand('busy', bridge.record);
          case 9:
            result = _context6.sent;
            if (!(result === undefined || result === null || (result == null ? void 0 : result.trigger) === 'stop')) {
              _context6.next = 12;
              break;
            }
            return _context6.abrupt("break", 15);
          case 12:
            // save the events in different formats
            if (result) {
              tempCodeEvents = codeEvents;
              tempCodeEvents.push.apply(tempCodeEvents, translateRecordedOperationsToCode([result]));
              setCodeEvents(tempCodeEvents);
              tempVisualCodeEvents = visualCodeEvents;
              tempVisualCodeEvents.push.apply(tempVisualCodeEvents, translateRecordedOperationsToVisualCode([result], savedLocators, setKeywordIndexToDelete, function (operation) {
                setActiveOperation(operation);
                setOpenSaveSelectorDialog(true);
              }));
              setVisualCodeEvents(tempVisualCodeEvents);
              operationEvents.current.push(result);
            }
            _context6.next = 4;
            break;
          case 15:
            // change the recording status
            currentlyRecording.current = false;
          case 16:
          case "end":
            return _context6.stop();
        }
      }
    }, _callee6);
  })), [codeEvents, visualCodeEvents, savedLocators, browsers, operationEvents.current, currentlyRecording.current]);
  // stopRecording - stop the recording in progress
  var stopRecording = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {
    return _regeneratorRuntime().wrap(function _callee7$(_context7) {
      while (1) {
        switch (_context7.prev = _context7.next) {
          case 0:
            currentlyRecording.current = false;
            _context7.next = 3;
            return runCommand('stopped', bridge.stopRecording);
          case 3:
          case "end":
            return _context7.stop();
        }
      }
    }, _callee7);
  })), []);
  // browser handlers
  var handleStartBrowser = /*#__PURE__*/function () {
    var _ref9 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9() {
      return _regeneratorRuntime().wrap(function _callee9$(_context9) {
        while (1) {
          switch (_context9.prev = _context9.next) {
            case 0:
              _context9.next = 2;
              return runCommand('starting', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {
                return _regeneratorRuntime().wrap(function _callee8$(_context8) {
                  while (1) {
                    switch (_context8.prev = _context8.next) {
                      case 0:
                        return _context8.abrupt("return", bridge.start());
                      case 1:
                      case "end":
                        return _context8.stop();
                    }
                  }
                }, _callee8);
              })));
            case 2:
            case "end":
              return _context9.stop();
          }
        }
      }, _callee9);
    }));
    return function handleStartBrowser() {
      return _ref9.apply(this, arguments);
    };
  }();
  var handleConnectBrowser = /*#__PURE__*/function () {
    var _ref11 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11(browser) {
      return _regeneratorRuntime().wrap(function _callee11$(_context11) {
        while (1) {
          switch (_context11.prev = _context11.next) {
            case 0:
              _context11.next = 2;
              return runCommand('starting', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10() {
                return _regeneratorRuntime().wrap(function _callee10$(_context10) {
                  while (1) {
                    switch (_context10.prev = _context10.next) {
                      case 0:
                        return _context10.abrupt("return", bridge.connect(browser));
                      case 1:
                      case "end":
                        return _context10.stop();
                    }
                  }
                }, _callee10);
              })));
            case 2:
            case "end":
              return _context11.stop();
          }
        }
      }, _callee11);
    }));
    return function handleConnectBrowser(_x) {
      return _ref11.apply(this, arguments);
    };
  }();
  var handleClose = /*#__PURE__*/function () {
    var _ref13 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee13() {
      return _regeneratorRuntime().wrap(function _callee13$(_context13) {
        while (1) {
          switch (_context13.prev = _context13.next) {
            case 0:
              currentlyRecording.current = false;
              clearTimeout(checkLocatorsTimer.current);
              _context13.next = 4;
              return runCommand('stopped', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12() {
                return _regeneratorRuntime().wrap(function _callee12$(_context12) {
                  while (1) {
                    switch (_context12.prev = _context12.next) {
                      case 0:
                        return _context12.abrupt("return", bridge.stop());
                      case 1:
                      case "end":
                        return _context12.stop();
                    }
                  }
                }, _callee12);
              })));
            case 4:
            case "end":
              return _context13.stop();
          }
        }
      }, _callee13);
    }));
    return function handleClose() {
      return _ref13.apply(this, arguments);
    };
  }();
  var disableAll = editorStatus === 'starting' || editorStatus === 'busy';
  if (editorStatus === 'starting') {
    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Container, {
      bridge: bridge,
      children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z, {
        p: 32,
        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_14__/* ["default"] */ .Z, {})
      })
    });
  }
  if (editorStatus === 'stopped' && errorMessage) {
    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Container, {
      bridge: bridge,
      children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ErrorMessage, {
        errorMessage: errorMessage
      })
    });
  }
  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {
    children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Container, {
      bridge: bridge,
      children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z, {
        display: "flex",
        flexDirection: "column",
        justifyContent: "center",
        alignItems: "center",
        width: "100%",
        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z, {
          display: "flex",
          flexDirection: "column",
          width: "100%",
          height: "100%",
          children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z, {
            flex: "none",
            children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z, {
              padding: 8,
              children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z, {
                display: "flex",
                flexDirection: "row",
                alignItems: "center",
                justifyContent: "space-between",
                style: {
                  pointerEvents: disableAll ? 'none' : 'auto',
                  opacity: disableAll ? 0.4 : 1
                },
                children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(RecordButton, {
                  hasEvents: codeEvents.length !== 0,
                  currentlyRecording: currentlyRecording.current,
                  startRecording: startRecording,
                  stopRecording: stopRecording,
                  disable: disableAll
                }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(BetaBadge, {
                  tooltip: "Recorder might produce incorrect locators or code. Please make sure results are as intended."
                })]
              }), errorMessage ? (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ErrorMessage, {
                errorMessage: errorMessage
              }) : null]
            })
          }), codeEvents && codeEvents.length !== 0 ? (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {
            children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_17__/* ["default"] */ .Z, {}), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z, {
              display: "flex",
              flexDirection: "row",
              alignItems: "center",
              justifyContent: "space-between",
              p: 8,
              style: {
                pointerEvents: disableAll ? 'none' : 'auto',
                opacity: disableAll ? 0.4 : 1
              },
              children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z, {
                children: "Recorded Keywords (" + (visualCodeEvents == null ? void 0 : visualCodeEvents.length) + ")"
              }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z, {
                display: "flex",
                style: {
                  gap: '8px'
                },
                children: [mode !== 'solventek-rpa' ? (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_30__/* ["default"] */ .Z, {
                  text: "Save All Locators",
                  children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_21__/* .Button */ .z, {
                    icon: _robocorp_ds_icons_element__WEBPACK_IMPORTED_MODULE_49__/* ["default"] */ .Z,
                    onClick: function onClick() {
                      saveFirstSelectorsAsLocators(operationEvents.current, bridge);
                    },
                    variant: "secondary"
                  })
                }) : null, (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_30__/* ["default"] */ .Z, {
                  text: "Clear All",
                  children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_21__/* .Button */ .z, {
                    icon: _robocorp_ds_icons__WEBPACK_IMPORTED_MODULE_50__/* ["default"] */ .Z,
                    onClick: function onClick() {
                      setCodeEvents([]);
                      setVisualCodeEvents([]);
                      operationEvents.current = [];
                    },
                    variant: "secondary",
                    children: mode === 'solventek-rpa' ? 'Clear All' : null
                  })
                }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_30__/* ["default"] */ .Z, {
                  text: showAsCode ? 'Show Keywords' : 'Show Code',
                  placement: "top-end",
                  children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_21__/* .Button */ .z, {
                    icon: _robocorp_ds_icons__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z,
                    onClick: function onClick() {
                      return setShowAsCode(!showAsCode);
                    },
                    variant: showAsCode ? 'primary' : 'secondary'
                  })
                })]
              })]
            }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z, {
              flex: "auto",
              px: 8,
              height: "100%",
              minHeight: 400,
              style: {
                pointerEvents: disableAll ? 'none' : 'auto'
              },
              children: showAsCode ? (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(RobotCodeScript, {
                editorStatus: editorStatus,
                codeLines: codeEvents.map(function (ev) {
                  return buildCodeLineTextFromEvent(ev, savedLocators);
                }),
                onStartRecord: startRecording
              }) : (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(KeywordList, {
                children: visualCodeEvents == null ? void 0 : visualCodeEvents.map(function (ev) {
                  return isNodeComponent(ev.node) ? ev.node : null;
                })
              })
            }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z, {
              display: "flex",
              justifyContent: "space-between",
              p: 8,
              children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_30__/* ["default"] */ .Z, {
                text: "Copy Code",
                placement: "top-start",
                children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(CopyToClipboard, {
                  text: mode === 'solventek-rpa' ? undefined : 'Copy Code',
                  value: codeEvents.map(function (ev) {
                    return buildCodeLineTextFromEvent(ev, savedLocators);
                  }).join('\n'),
                  disabled: !codeEvents || codeEvents.length === 0 || disableAll,
                  variant: onSave === undefined ? 'primary' : 'secondary'
                })
              }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z, {
                display: "flex",
                flexDirection: "row",
                width: "100%",
                justifyContent: "flex-end",
                children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_21__/* .Button */ .z, {
                  variant: "secondary",
                  onClick: handleClose,
                  children: onSave === undefined ? 'Close' : 'Cancel'
                }), onSave !== undefined ? (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z, {
                  ml: 8,
                  children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_robocorp_ds__WEBPACK_IMPORTED_MODULE_21__/* .Button */ .z, {
                    variant: "primary",
                    onClick: function onClick() {
                      setSaving(true);
                      if (onSave) {
                        var codeLines = [];
                        codeEvents.forEach(function (element, index) {
                          var codeLine = buildRecordedCodeLineFromEventAsLocator(element, operationEvents.current[index], index);
                          if (codeLine) {
                            codeLines.push(codeLine);
                          }
                        });
                        onSave(codeLines, operationEvents.current);
                      }
                    },
                    disabled: !codeEvents || codeEvents.length === 0 || disableAll,
                    loading: saving,
                    children: "Save"
                  })
                }) : null]
              })]
            })]
          }) : null]
        })
      })
    }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(SaveLocatorDialog, {
      open: openSaveSelectorDialog,
      bridge: bridge,
      operation: activeOperation,
      onClose: function onClose() {
        setOpenSaveSelectorDialog(false);
        setActiveOperation(undefined);
      },
      afterSave: function () {
        var _afterSave = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee15() {
          return _regeneratorRuntime().wrap(function _callee15$(_context15) {
            while (1) {
              switch (_context15.prev = _context15.next) {
                case 0:
                  setTimeout( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee14() {
                    return _regeneratorRuntime().wrap(function _callee14$(_context14) {
                      while (1) {
                        switch (_context14.prev = _context14.next) {
                          case 0:
                            _context14.next = 2;
                            return updateLocators();
                          case 2:
                          case "end":
                            return _context14.stop();
                        }
                      }
                    }, _callee14);
                  })), 500);
                  setOpenSaveSelectorDialog(false);
                  setActiveOperation(undefined);
                case 3:
                case "end":
                  return _context15.stop();
              }
            }
          }, _callee15);
        }));
        function afterSave() {
          return _afterSave.apply(this, arguments);
        }
        return afterSave;
      }(),
      runCommand: runCommand
    })]
  });
};


//# sourceMappingURL=inspector.esm.js.map


/***/ }),

/***/ 1862:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;


__webpack_unused_export__ = true;
exports.Z = Line;
var _react = _interopRequireDefault(__webpack_require__(4191));
var _classnames = _interopRequireDefault(__webpack_require__(3497));
var _excluded = ["from", "to", "fill", "className", "innerRef"];
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }
function Line(_ref) {
  var _ref$from = _ref.from,
    from = _ref$from === void 0 ? {
      x: 0,
      y: 0
    } : _ref$from,
    _ref$to = _ref.to,
    to = _ref$to === void 0 ? {
      x: 1,
      y: 1
    } : _ref$to,
    _ref$fill = _ref.fill,
    fill = _ref$fill === void 0 ? 'transparent' : _ref$fill,
    className = _ref.className,
    innerRef = _ref.innerRef,
    restProps = _objectWithoutPropertiesLoose(_ref, _excluded);
  var isRectilinear = from.x === to.x || from.y === to.y;
  return /*#__PURE__*/_react.default.createElement("line", _extends({
    ref: innerRef,
    className: (0, _classnames.default)('visx-line', className),
    x1: from.x,
    y1: from.y,
    x2: to.x,
    y2: to.y,
    fill: fill,
    shapeRendering: isRectilinear ? 'crispEdges' : 'auto'
  }, restProps));
}

/***/ }),

/***/ 3612:
/***/ ((module) => {

"use strict";

module.exports = balanced;
function balanced(a, b, str) {
  if (a instanceof RegExp) a = maybeMatch(a, str);
  if (b instanceof RegExp) b = maybeMatch(b, str);

  var r = range(a, b, str);

  return r && {
    start: r[0],
    end: r[1],
    pre: str.slice(0, r[0]),
    body: str.slice(r[0] + a.length, r[1]),
    post: str.slice(r[1] + b.length)
  };
}

function maybeMatch(reg, str) {
  var m = str.match(reg);
  return m ? m[0] : null;
}

balanced.range = range;
function range(a, b, str) {
  var begs, beg, left, right, result;
  var ai = str.indexOf(a);
  var bi = str.indexOf(b, ai + 1);
  var i = ai;

  if (ai >= 0 && bi > 0) {
    if(a===b) {
      return [ai, bi];
    }
    begs = [];
    left = str.length;

    while (i >= 0 && !result) {
      if (i == ai) {
        begs.push(i);
        ai = str.indexOf(a, i + 1);
      } else if (begs.length == 1) {
        result = [ begs.pop(), bi ];
      } else {
        beg = begs.pop();
        if (beg < left) {
          left = beg;
          right = bi;
        }

        bi = str.indexOf(b, i + 1);
      }

      i = ai < bi && ai >= 0 ? ai : bi;
    }

    if (begs.length) {
      result = [ left, right ];
    }
  }

  return result;
}


/***/ }),

/***/ 3497:
/***/ ((module) => {

/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/
/* global define */

(function () {
	'use strict';

	var hasOwn = {}.hasOwnProperty;
	var nativeCodeString = '[native code]';

	function classNames() {
		var classes = [];

		for (var i = 0; i < arguments.length; i++) {
			var arg = arguments[i];
			if (!arg) continue;

			var argType = typeof arg;

			if (argType === 'string' || argType === 'number') {
				classes.push(arg);
			} else if (Array.isArray(arg)) {
				if (arg.length) {
					var inner = classNames.apply(null, arg);
					if (inner) {
						classes.push(inner);
					}
				}
			} else if (argType === 'object') {
				if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes('[native code]')) {
					classes.push(arg.toString());
					continue;
				}

				for (var key in arg) {
					if (hasOwn.call(arg, key) && arg[key]) {
						classes.push(key);
					}
				}
			}
		}

		return classes.join(' ');
	}

	if ( true && module.exports) {
		classNames.default = classNames;
		module.exports = classNames;
	} else if (typeof define === 'function' && typeof define.amd === 'object' && define.amd) {
		// register as 'classnames', consistent with npm package name
		define('classnames', [], function () {
			return classNames;
		});
	} else {
		window.classNames = classNames;
	}
}());


/***/ }),

/***/ 8268:
/***/ ((module) => {

"use strict";


/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
module.exports = function (cssWithMappingToString) {
  var list = [];

  // return the list of modules as css string
  list.toString = function toString() {
    return this.map(function (item) {
      var content = "";
      var needLayer = typeof item[5] !== "undefined";
      if (item[4]) {
        content += "@supports (".concat(item[4], ") {");
      }
      if (item[2]) {
        content += "@media ".concat(item[2], " {");
      }
      if (needLayer) {
        content += "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {");
      }
      content += cssWithMappingToString(item);
      if (needLayer) {
        content += "}";
      }
      if (item[2]) {
        content += "}";
      }
      if (item[4]) {
        content += "}";
      }
      return content;
    }).join("");
  };

  // import a list of modules into the list
  list.i = function i(modules, media, dedupe, supports, layer) {
    if (typeof modules === "string") {
      modules = [[null, modules, undefined]];
    }
    var alreadyImportedModules = {};
    if (dedupe) {
      for (var k = 0; k < this.length; k++) {
        var id = this[k][0];
        if (id != null) {
          alreadyImportedModules[id] = true;
        }
      }
    }
    for (var _k = 0; _k < modules.length; _k++) {
      var item = [].concat(modules[_k]);
      if (dedupe && alreadyImportedModules[item[0]]) {
        continue;
      }
      if (typeof layer !== "undefined") {
        if (typeof item[5] === "undefined") {
          item[5] = layer;
        } else {
          item[1] = "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {").concat(item[1], "}");
          item[5] = layer;
        }
      }
      if (media) {
        if (!item[2]) {
          item[2] = media;
        } else {
          item[1] = "@media ".concat(item[2], " {").concat(item[1], "}");
          item[2] = media;
        }
      }
      if (supports) {
        if (!item[4]) {
          item[4] = "".concat(supports);
        } else {
          item[1] = "@supports (".concat(item[4], ") {").concat(item[1], "}");
          item[4] = supports;
        }
      }
      list.push(item);
    }
  };
  return list;
};

/***/ }),

/***/ 8397:
/***/ ((module) => {

"use strict";


module.exports = function (item) {
  var content = item[1];
  var cssMapping = item[3];
  if (!cssMapping) {
    return content;
  }
  if (typeof btoa === "function") {
    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(cssMapping))));
    var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
    var sourceMapping = "/*# ".concat(data, " */");
    return [content].concat([sourceMapping]).join("\n");
  }
  return [content].join("\n");
};

/***/ }),

/***/ 4353:
/***/ ((module) => {

/**
 * Returns a function, that, as long as it continues to be invoked, will not
 * be triggered. The function will be called after it stops being called for
 * N milliseconds. If `immediate` is passed, trigger the function on the
 * leading edge, instead of the trailing. The function also has a property 'clear' 
 * that is a function which will clear the timer to prevent previously scheduled executions. 
 *
 * @source underscore.js
 * @see http://unscriptable.com/2009/03/20/debouncing-javascript-methods/
 * @param {Function} function to wrap
 * @param {Number} timeout in ms (`100`)
 * @param {Boolean} whether to execute at the beginning (`false`)
 * @api public
 */
function debounce(func, wait, immediate){
  var timeout, args, context, timestamp, result;
  if (null == wait) wait = 100;

  function later() {
    var last = Date.now() - timestamp;

    if (last < wait && last >= 0) {
      timeout = setTimeout(later, wait - last);
    } else {
      timeout = null;
      if (!immediate) {
        result = func.apply(context, args);
        context = args = null;
      }
    }
  };

  var debounced = function(){
    context = this;
    args = arguments;
    timestamp = Date.now();
    var callNow = immediate && !timeout;
    if (!timeout) timeout = setTimeout(later, wait);
    if (callNow) {
      result = func.apply(context, args);
      context = args = null;
    }

    return result;
  };

  debounced.clear = function() {
    if (timeout) {
      clearTimeout(timeout);
      timeout = null;
    }
  };
  
  debounced.flush = function() {
    if (timeout) {
      result = func.apply(context, args);
      context = args = null;
      
      clearTimeout(timeout);
      timeout = null;
    }
  };

  return debounced;
};

// Adds compatibility for ES modules
debounce.debounce = debounce;

module.exports = debounce;


/***/ }),

/***/ 7429:
/***/ ((module) => {

"use strict";


// do not edit .js files directly - edit src/index.jst



module.exports = function equal(a, b) {
  if (a === b) return true;

  if (a && b && typeof a == 'object' && typeof b == 'object') {
    if (a.constructor !== b.constructor) return false;

    var length, i, keys;
    if (Array.isArray(a)) {
      length = a.length;
      if (length != b.length) return false;
      for (i = length; i-- !== 0;)
        if (!equal(a[i], b[i])) return false;
      return true;
    }



    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();

    keys = Object.keys(a);
    length = keys.length;
    if (length !== Object.keys(b).length) return false;

    for (i = length; i-- !== 0;)
      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;

    for (i = length; i-- !== 0;) {
      var key = keys[i];

      if (!equal(a[key], b[key])) return false;
    }

    return true;
  }

  // true if both NaN, false otherwise
  return a!==a && b!==b;
};


/***/ }),

/***/ 6719:
/***/ (function() {

(function (global, factory) {
   true ? factory() :
  0;
}(this, (function () { 'use strict';

  /**
   * Applies the :focus-visible polyfill at the given scope.
   * A scope in this case is either the top-level Document or a Shadow Root.
   *
   * @param {(Document|ShadowRoot)} scope
   * @see https://github.com/WICG/focus-visible
   */
  function applyFocusVisiblePolyfill(scope) {
    var hadKeyboardEvent = true;
    var hadFocusVisibleRecently = false;
    var hadFocusVisibleRecentlyTimeout = null;

    var inputTypesAllowlist = {
      text: true,
      search: true,
      url: true,
      tel: true,
      email: true,
      password: true,
      number: true,
      date: true,
      month: true,
      week: true,
      time: true,
      datetime: true,
      'datetime-local': true
    };

    /**
     * Helper function for legacy browsers and iframes which sometimes focus
     * elements like document, body, and non-interactive SVG.
     * @param {Element} el
     */
    function isValidFocusTarget(el) {
      if (
        el &&
        el !== document &&
        el.nodeName !== 'HTML' &&
        el.nodeName !== 'BODY' &&
        'classList' in el &&
        'contains' in el.classList
      ) {
        return true;
      }
      return false;
    }

    /**
     * Computes whether the given element should automatically trigger the
     * `focus-visible` class being added, i.e. whether it should always match
     * `:focus-visible` when focused.
     * @param {Element} el
     * @return {boolean}
     */
    function focusTriggersKeyboardModality(el) {
      var type = el.type;
      var tagName = el.tagName;

      if (tagName === 'INPUT' && inputTypesAllowlist[type] && !el.readOnly) {
        return true;
      }

      if (tagName === 'TEXTAREA' && !el.readOnly) {
        return true;
      }

      if (el.isContentEditable) {
        return true;
      }

      return false;
    }

    /**
     * Add the `focus-visible` class to the given element if it was not added by
     * the author.
     * @param {Element} el
     */
    function addFocusVisibleClass(el) {
      if (el.classList.contains('focus-visible')) {
        return;
      }
      el.classList.add('focus-visible');
      el.setAttribute('data-focus-visible-added', '');
    }

    /**
     * Remove the `focus-visible` class from the given element if it was not
     * originally added by the author.
     * @param {Element} el
     */
    function removeFocusVisibleClass(el) {
      if (!el.hasAttribute('data-focus-visible-added')) {
        return;
      }
      el.classList.remove('focus-visible');
      el.removeAttribute('data-focus-visible-added');
    }

    /**
     * If the most recent user interaction was via the keyboard;
     * and the key press did not include a meta, alt/option, or control key;
     * then the modality is keyboard. Otherwise, the modality is not keyboard.
     * Apply `focus-visible` to any current active element and keep track
     * of our keyboard modality state with `hadKeyboardEvent`.
     * @param {KeyboardEvent} e
     */
    function onKeyDown(e) {
      if (e.metaKey || e.altKey || e.ctrlKey) {
        return;
      }

      if (isValidFocusTarget(scope.activeElement)) {
        addFocusVisibleClass(scope.activeElement);
      }

      hadKeyboardEvent = true;
    }

    /**
     * If at any point a user clicks with a pointing device, ensure that we change
     * the modality away from keyboard.
     * This avoids the situation where a user presses a key on an already focused
     * element, and then clicks on a different element, focusing it with a
     * pointing device, while we still think we're in keyboard modality.
     * @param {Event} e
     */
    function onPointerDown(e) {
      hadKeyboardEvent = false;
    }

    /**
     * On `focus`, add the `focus-visible` class to the target if:
     * - the target received focus as a result of keyboard navigation, or
     * - the event target is an element that will likely require interaction
     *   via the keyboard (e.g. a text box)
     * @param {Event} e
     */
    function onFocus(e) {
      // Prevent IE from focusing the document or HTML element.
      if (!isValidFocusTarget(e.target)) {
        return;
      }

      if (hadKeyboardEvent || focusTriggersKeyboardModality(e.target)) {
        addFocusVisibleClass(e.target);
      }
    }

    /**
     * On `blur`, remove the `focus-visible` class from the target.
     * @param {Event} e
     */
    function onBlur(e) {
      if (!isValidFocusTarget(e.target)) {
        return;
      }

      if (
        e.target.classList.contains('focus-visible') ||
        e.target.hasAttribute('data-focus-visible-added')
      ) {
        // To detect a tab/window switch, we look for a blur event followed
        // rapidly by a visibility change.
        // If we don't see a visibility change within 100ms, it's probably a
        // regular focus change.
        hadFocusVisibleRecently = true;
        window.clearTimeout(hadFocusVisibleRecentlyTimeout);
        hadFocusVisibleRecentlyTimeout = window.setTimeout(function() {
          hadFocusVisibleRecently = false;
        }, 100);
        removeFocusVisibleClass(e.target);
      }
    }

    /**
     * If the user changes tabs, keep track of whether or not the previously
     * focused element had .focus-visible.
     * @param {Event} e
     */
    function onVisibilityChange(e) {
      if (document.visibilityState === 'hidden') {
        // If the tab becomes active again, the browser will handle calling focus
        // on the element (Safari actually calls it twice).
        // If this tab change caused a blur on an element with focus-visible,
        // re-apply the class when the user switches back to the tab.
        if (hadFocusVisibleRecently) {
          hadKeyboardEvent = true;
        }
        addInitialPointerMoveListeners();
      }
    }

    /**
     * Add a group of listeners to detect usage of any pointing devices.
     * These listeners will be added when the polyfill first loads, and anytime
     * the window is blurred, so that they are active when the window regains
     * focus.
     */
    function addInitialPointerMoveListeners() {
      document.addEventListener('mousemove', onInitialPointerMove);
      document.addEventListener('mousedown', onInitialPointerMove);
      document.addEventListener('mouseup', onInitialPointerMove);
      document.addEventListener('pointermove', onInitialPointerMove);
      document.addEventListener('pointerdown', onInitialPointerMove);
      document.addEventListener('pointerup', onInitialPointerMove);
      document.addEventListener('touchmove', onInitialPointerMove);
      document.addEventListener('touchstart', onInitialPointerMove);
      document.addEventListener('touchend', onInitialPointerMove);
    }

    function removeInitialPointerMoveListeners() {
      document.removeEventListener('mousemove', onInitialPointerMove);
      document.removeEventListener('mousedown', onInitialPointerMove);
      document.removeEventListener('mouseup', onInitialPointerMove);
      document.removeEventListener('pointermove', onInitialPointerMove);
      document.removeEventListener('pointerdown', onInitialPointerMove);
      document.removeEventListener('pointerup', onInitialPointerMove);
      document.removeEventListener('touchmove', onInitialPointerMove);
      document.removeEventListener('touchstart', onInitialPointerMove);
      document.removeEventListener('touchend', onInitialPointerMove);
    }

    /**
     * When the polfyill first loads, assume the user is in keyboard modality.
     * If any event is received from a pointing device (e.g. mouse, pointer,
     * touch), turn off keyboard modality.
     * This accounts for situations where focus enters the page from the URL bar.
     * @param {Event} e
     */
    function onInitialPointerMove(e) {
      // Work around a Safari quirk that fires a mousemove on <html> whenever the
      // window blurs, even if you're tabbing out of the page. \_()_/
      if (e.target.nodeName && e.target.nodeName.toLowerCase() === 'html') {
        return;
      }

      hadKeyboardEvent = false;
      removeInitialPointerMoveListeners();
    }

    // For some kinds of state, we are interested in changes at the global scope
    // only. For example, global pointer input, global key presses and global
    // visibility change should affect the state at every scope:
    document.addEventListener('keydown', onKeyDown, true);
    document.addEventListener('mousedown', onPointerDown, true);
    document.addEventListener('pointerdown', onPointerDown, true);
    document.addEventListener('touchstart', onPointerDown, true);
    document.addEventListener('visibilitychange', onVisibilityChange, true);

    addInitialPointerMoveListeners();

    // For focus and blur, we specifically care about state changes in the local
    // scope. This is because focus / blur events that originate from within a
    // shadow root are not re-dispatched from the host element if it was already
    // the active element in its own scope:
    scope.addEventListener('focus', onFocus, true);
    scope.addEventListener('blur', onBlur, true);

    // We detect that a node is a ShadowRoot by ensuring that it is a
    // DocumentFragment and also has a host property. This check covers native
    // implementation and polyfill implementation transparently. If we only cared
    // about the native implementation, we could just check if the scope was
    // an instance of a ShadowRoot.
    if (scope.nodeType === Node.DOCUMENT_FRAGMENT_NODE && scope.host) {
      // Since a ShadowRoot is a special kind of DocumentFragment, it does not
      // have a root element to add a class to. So, we add this attribute to the
      // host element instead:
      scope.host.setAttribute('data-js-focus-visible', '');
    } else if (scope.nodeType === Node.DOCUMENT_NODE) {
      document.documentElement.classList.add('js-focus-visible');
      document.documentElement.setAttribute('data-js-focus-visible', '');
    }
  }

  // It is important to wrap all references to global window and document in
  // these checks to support server-side rendering use cases
  // @see https://github.com/WICG/focus-visible/issues/199
  if (typeof window !== 'undefined' && typeof document !== 'undefined') {
    // Make the polyfill helper globally available. This can be used as a signal
    // to interested libraries that wish to coordinate with the polyfill for e.g.,
    // applying the polyfill to a shadow root:
    window.applyFocusVisiblePolyfill = applyFocusVisiblePolyfill;

    // Notify interested libraries of the polyfill's presence, in case the
    // polyfill was loaded lazily:
    var event;

    try {
      event = new CustomEvent('focus-visible-polyfill-ready');
    } catch (error) {
      // IE11 does not support using CustomEvent as a constructor directly:
      event = document.createEvent('CustomEvent');
      event.initCustomEvent('focus-visible-polyfill-ready', false, false, {});
    }

    window.dispatchEvent(event);
  }

  if (typeof document !== 'undefined') {
    // Apply the polyfill to the global document, so that no JavaScript
    // coordination is required to use the polyfill in the top-level document:
    applyFocusVisiblePolyfill(document);
  }

})));


/***/ }),

/***/ 9721:
/***/ ((module) => {

/* eslint-env browser */
module.exports = typeof self == 'object' ? self.FormData : window.FormData;


/***/ }),

/***/ 6044:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var reactIs = __webpack_require__(1847);

/**
 * Copyright 2015, Yahoo! Inc.
 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
 */
var REACT_STATICS = {
  childContextTypes: true,
  contextType: true,
  contextTypes: true,
  defaultProps: true,
  displayName: true,
  getDefaultProps: true,
  getDerivedStateFromError: true,
  getDerivedStateFromProps: true,
  mixins: true,
  propTypes: true,
  type: true
};
var KNOWN_STATICS = {
  name: true,
  length: true,
  prototype: true,
  caller: true,
  callee: true,
  arguments: true,
  arity: true
};
var FORWARD_REF_STATICS = {
  '$$typeof': true,
  render: true,
  defaultProps: true,
  displayName: true,
  propTypes: true
};
var MEMO_STATICS = {
  '$$typeof': true,
  compare: true,
  defaultProps: true,
  displayName: true,
  propTypes: true,
  type: true
};
var TYPE_STATICS = {};
TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;

function getStatics(component) {
  // React v16.11 and below
  if (reactIs.isMemo(component)) {
    return MEMO_STATICS;
  } // React v16.12 and above


  return TYPE_STATICS[component['$$typeof']] || REACT_STATICS;
}

var defineProperty = Object.defineProperty;
var getOwnPropertyNames = Object.getOwnPropertyNames;
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var getPrototypeOf = Object.getPrototypeOf;
var objectPrototype = Object.prototype;
function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
  if (typeof sourceComponent !== 'string') {
    // don't hoist over string (html) components
    if (objectPrototype) {
      var inheritedComponent = getPrototypeOf(sourceComponent);

      if (inheritedComponent && inheritedComponent !== objectPrototype) {
        hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
      }
    }

    var keys = getOwnPropertyNames(sourceComponent);

    if (getOwnPropertySymbols) {
      keys = keys.concat(getOwnPropertySymbols(sourceComponent));
    }

    var targetStatics = getStatics(targetComponent);
    var sourceStatics = getStatics(sourceComponent);

    for (var i = 0; i < keys.length; ++i) {
      var key = keys[i];

      if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
        var descriptor = getOwnPropertyDescriptor(sourceComponent, key);

        try {
          // Avoid failures from read-only properties
          defineProperty(targetComponent, key, descriptor);
        } catch (e) {}
      }
    }
  }

  return targetComponent;
}

module.exports = hoistNonReactStatics;


/***/ }),

/***/ 4200:
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var b="function"===typeof Symbol&&Symbol.for,c=b?Symbol.for("react.element"):60103,d=b?Symbol.for("react.portal"):60106,e=b?Symbol.for("react.fragment"):60107,f=b?Symbol.for("react.strict_mode"):60108,g=b?Symbol.for("react.profiler"):60114,h=b?Symbol.for("react.provider"):60109,k=b?Symbol.for("react.context"):60110,l=b?Symbol.for("react.async_mode"):60111,m=b?Symbol.for("react.concurrent_mode"):60111,n=b?Symbol.for("react.forward_ref"):60112,p=b?Symbol.for("react.suspense"):60113,q=b?
Symbol.for("react.suspense_list"):60120,r=b?Symbol.for("react.memo"):60115,t=b?Symbol.for("react.lazy"):60116,v=b?Symbol.for("react.block"):60121,w=b?Symbol.for("react.fundamental"):60117,x=b?Symbol.for("react.responder"):60118,y=b?Symbol.for("react.scope"):60119;
function z(a){if("object"===typeof a&&null!==a){var u=a.$$typeof;switch(u){case c:switch(a=a.type,a){case l:case m:case e:case g:case f:case p:return a;default:switch(a=a&&a.$$typeof,a){case k:case n:case t:case r:case h:return a;default:return u}}case d:return u}}}function A(a){return z(a)===m}exports.AsyncMode=l;exports.ConcurrentMode=m;exports.ContextConsumer=k;exports.ContextProvider=h;exports.Element=c;exports.ForwardRef=n;exports.Fragment=e;exports.Lazy=t;exports.Memo=r;exports.Portal=d;
exports.Profiler=g;exports.StrictMode=f;exports.Suspense=p;exports.isAsyncMode=function(a){return A(a)||z(a)===l};exports.isConcurrentMode=A;exports.isContextConsumer=function(a){return z(a)===k};exports.isContextProvider=function(a){return z(a)===h};exports.isElement=function(a){return"object"===typeof a&&null!==a&&a.$$typeof===c};exports.isForwardRef=function(a){return z(a)===n};exports.isFragment=function(a){return z(a)===e};exports.isLazy=function(a){return z(a)===t};
exports.isMemo=function(a){return z(a)===r};exports.isPortal=function(a){return z(a)===d};exports.isProfiler=function(a){return z(a)===g};exports.isStrictMode=function(a){return z(a)===f};exports.isSuspense=function(a){return z(a)===p};
exports.isValidElementType=function(a){return"string"===typeof a||"function"===typeof a||a===e||a===m||a===g||a===f||a===p||a===q||"object"===typeof a&&null!==a&&(a.$$typeof===t||a.$$typeof===r||a.$$typeof===h||a.$$typeof===k||a.$$typeof===n||a.$$typeof===w||a.$$typeof===x||a.$$typeof===y||a.$$typeof===v)};exports.typeOf=z;


/***/ }),

/***/ 1847:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


if (true) {
  module.exports = __webpack_require__(4200);
} else {}


/***/ }),

/***/ 1139:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var hashClear = __webpack_require__(6227),
    hashDelete = __webpack_require__(2553),
    hashGet = __webpack_require__(6449),
    hashHas = __webpack_require__(6104),
    hashSet = __webpack_require__(9185);

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

module.exports = Hash;


/***/ }),

/***/ 2175:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var listCacheClear = __webpack_require__(3077),
    listCacheDelete = __webpack_require__(6274),
    listCacheGet = __webpack_require__(2657),
    listCacheHas = __webpack_require__(1633),
    listCacheSet = __webpack_require__(7510);

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

module.exports = ListCache;


/***/ }),

/***/ 5571:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getNative = __webpack_require__(5891),
    root = __webpack_require__(1243);

/* Built-in method references that are verified to be native. */
var Map = getNative(root, 'Map');

module.exports = Map;


/***/ }),

/***/ 1933:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var mapCacheClear = __webpack_require__(5303),
    mapCacheDelete = __webpack_require__(7135),
    mapCacheGet = __webpack_require__(3042),
    mapCacheHas = __webpack_require__(7571),
    mapCacheSet = __webpack_require__(507);

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

module.exports = MapCache;


/***/ }),

/***/ 7323:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var root = __webpack_require__(1243);

/** Built-in value references. */
var Symbol = root.Symbol;

module.exports = Symbol;


/***/ }),

/***/ 1135:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var eq = __webpack_require__(5585);

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

module.exports = assocIndexOf;


/***/ }),

/***/ 8085:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Symbol = __webpack_require__(7323),
    getRawTag = __webpack_require__(465),
    objectToString = __webpack_require__(7659);

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

module.exports = baseGetTag;


/***/ }),

/***/ 5490:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isFunction = __webpack_require__(5734),
    isMasked = __webpack_require__(780),
    isObject = __webpack_require__(7121),
    toSource = __webpack_require__(8219);

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

module.exports = baseIsNative;


/***/ }),

/***/ 8689:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var root = __webpack_require__(1243);

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

module.exports = coreJsData;


/***/ }),

/***/ 8615:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof __webpack_require__.g == 'object' && __webpack_require__.g && __webpack_require__.g.Object === Object && __webpack_require__.g;

module.exports = freeGlobal;


/***/ }),

/***/ 9741:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isKeyable = __webpack_require__(7301);

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

module.exports = getMapData;


/***/ }),

/***/ 5891:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsNative = __webpack_require__(5490),
    getValue = __webpack_require__(4613);

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

module.exports = getNative;


/***/ }),

/***/ 465:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Symbol = __webpack_require__(7323);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

module.exports = getRawTag;


/***/ }),

/***/ 4613:
/***/ ((module) => {

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

module.exports = getValue;


/***/ }),

/***/ 6227:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var nativeCreate = __webpack_require__(4047);

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

module.exports = hashClear;


/***/ }),

/***/ 2553:
/***/ ((module) => {

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = hashDelete;


/***/ }),

/***/ 6449:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var nativeCreate = __webpack_require__(4047);

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

module.exports = hashGet;


/***/ }),

/***/ 6104:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var nativeCreate = __webpack_require__(4047);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
}

module.exports = hashHas;


/***/ }),

/***/ 9185:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var nativeCreate = __webpack_require__(4047);

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

module.exports = hashSet;


/***/ }),

/***/ 7301:
/***/ ((module) => {

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

module.exports = isKeyable;


/***/ }),

/***/ 780:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var coreJsData = __webpack_require__(8689);

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

module.exports = isMasked;


/***/ }),

/***/ 3077:
/***/ ((module) => {

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

module.exports = listCacheClear;


/***/ }),

/***/ 6274:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assocIndexOf = __webpack_require__(1135);

/** Used for built-in method references. */
var arrayProto = Array.prototype;

/** Built-in value references. */
var splice = arrayProto.splice;

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}

module.exports = listCacheDelete;


/***/ }),

/***/ 2657:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assocIndexOf = __webpack_require__(1135);

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

module.exports = listCacheGet;


/***/ }),

/***/ 1633:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assocIndexOf = __webpack_require__(1135);

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

module.exports = listCacheHas;


/***/ }),

/***/ 7510:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assocIndexOf = __webpack_require__(1135);

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

module.exports = listCacheSet;


/***/ }),

/***/ 5303:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Hash = __webpack_require__(1139),
    ListCache = __webpack_require__(2175),
    Map = __webpack_require__(5571);

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

module.exports = mapCacheClear;


/***/ }),

/***/ 7135:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getMapData = __webpack_require__(9741);

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = mapCacheDelete;


/***/ }),

/***/ 3042:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getMapData = __webpack_require__(9741);

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

module.exports = mapCacheGet;


/***/ }),

/***/ 7571:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getMapData = __webpack_require__(9741);

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

module.exports = mapCacheHas;


/***/ }),

/***/ 507:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getMapData = __webpack_require__(9741);

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;

  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

module.exports = mapCacheSet;


/***/ }),

/***/ 4047:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getNative = __webpack_require__(5891);

/* Built-in method references that are verified to be native. */
var nativeCreate = getNative(Object, 'create');

module.exports = nativeCreate;


/***/ }),

/***/ 7659:
/***/ ((module) => {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

module.exports = objectToString;


/***/ }),

/***/ 1243:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var freeGlobal = __webpack_require__(8615);

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

module.exports = root;


/***/ }),

/***/ 8219:
/***/ ((module) => {

/** Used for built-in method references. */
var funcProto = Function.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

module.exports = toSource;


/***/ }),

/***/ 5585:
/***/ ((module) => {

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

module.exports = eq;


/***/ }),

/***/ 5734:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetTag = __webpack_require__(8085),
    isObject = __webpack_require__(7121);

/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

module.exports = isFunction;


/***/ }),

/***/ 7121:
/***/ ((module) => {

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

module.exports = isObject;


/***/ }),

/***/ 5210:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var MapCache = __webpack_require__(1933);

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize(func, resolver) {
  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache);
  return memoized;
}

// Expose `MapCache`.
memoize.Cache = MapCache;

module.exports = memoize;


/***/ }),

/***/ 7982:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Mexp=__webpack_require__(4443);
Mexp.prototype.formulaEval = function () {
	"use strict";
	var stack=[],pop1,pop2,pop3;
	var disp=[];
	var temp='';
	var arr=this.value;
	for(var i=0;i<arr.length;i++){
		if(arr[i].type===1||arr[i].type===3){
			disp.push({value:arr[i].type===3?arr[i].show:arr[i].value,type:1});
		}
		else if(arr[i].type===13){
			disp.push({value:arr[i].show,type:1});
		}
		else if(arr[i].type===0){
			disp[disp.length-1]={value:arr[i].show+(arr[i].show!="-"?"(":"")+disp[disp.length-1].value+(arr[i].show!="-"?")":""),type:0};
		}
		else if(arr[i].type===7){
			disp[disp.length-1]={value:(disp[disp.length-1].type!=1?"(":"")+disp[disp.length-1].value+(disp[disp.length-1].type!=1?")":"")+arr[i].show,type:7};
		}
		else if(arr[i].type===10){
			pop1=disp.pop();
			pop2=disp.pop();
			if(arr[i].show==='P'||arr[i].show==='C')disp.push({value:"<sup>"+pop2.value+"</sup>"+arr[i].show+"<sub>"+pop1.value+"</sub>",type:10});
			else disp.push({value:(pop2.type!=1?"(":"")+pop2.value+(pop2.type!=1?")":"")+"<sup>"+pop1.value+"</sup>",type:1});
		}
		else if(arr[i].type===2||arr[i].type===9){
			pop1=disp.pop();
			pop2=disp.pop();
			disp.push({value:(pop2.type!=1?"(":"")+pop2.value+(pop2.type!=1?")":"")+arr[i].show+(pop1.type!=1?"(":"")+pop1.value+(pop1.type!=1?")":""),type:arr[i].type});
		}
		else if(arr[i].type===12){
			pop1=disp.pop();
			pop2=disp.pop();
			pop3=disp.pop();
			disp.push({value:arr[i].show+"("+pop3.value+","+pop2.value+","+pop1.value+")",type:12});
		}
	}
	return disp[0].value;
};
module.exports=Mexp;

/***/ }),

/***/ 9763:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var Mexp = __webpack_require__(5991)
function inc(arr, val) {
	for (var i = 0; i < arr.length; i++) {
		arr[i] += val
	}
	return arr
}
var tokens = [
	{ token: 'sin', show: 'sin', type: 0, value: Mexp.math.sin },
	{ token: 'cos', show: 'cos', type: 0, value: Mexp.math.cos },
	{ token: 'tan', show: 'tan', type: 0, value: Mexp.math.tan },
	{ token: 'pi', show: '&pi;', type: 3, value: 'PI' },
	{ token: '(', show: '(', type: 4, value: '(' },
	{ token: ')', show: ')', type: 5, value: ')' },
	{ token: 'P', show: 'P', type: 10, value: Mexp.math.P },
	{ token: 'C', show: 'C', type: 10, value: Mexp.math.C },
	{ token: ' ', show: ' ', type: 14, value: ' '.anchor },
	{ token: 'asin', show: 'asin', type: 0, value: Mexp.math.asin },
	{ token: 'acos', show: 'acos', type: 0, value: Mexp.math.acos },
	{ token: 'atan', show: 'atan', type: 0, value: Mexp.math.atan },
	{ token: '7', show: '7', type: 1, value: '7' },
	{ token: '8', show: '8', type: 1, value: '8' },
	{ token: '9', show: '9', type: 1, value: '9' },
	{ token: 'int', show: 'Int', type: 0, value: Math.floor },
	{ token: 'cosh', show: 'cosh', type: 0, value: Mexp.math.cosh },
	{ token: 'acosh', show: 'acosh', type: 0, value: Mexp.math.acosh },
	{ token: 'ln', show: ' ln', type: 0, value: Math.log },
	{ token: '^', show: '^', type: 10, value: Math.pow },
	{ token: 'root', show: 'root', type: 0, value: Math.sqrt },
	{ token: '4', show: '4', type: 1, value: '4' },
	{ token: '5', show: '5', type: 1, value: '5' },
	{ token: '6', show: '6', type: 1, value: '6' },
	{ token: '/', show: '&divide;', type: 2, value: Mexp.math.div },
	{ token: '!', show: '!', type: 7, value: Mexp.math.fact },
	{ token: 'tanh', show: 'tanh', type: 0, value: Mexp.math.tanh },
	{ token: 'atanh', show: 'atanh', type: 0, value: Mexp.math.atanh },
	{ token: 'Mod', show: ' Mod ', type: 2, value: Mexp.math.mod },
	{ token: '1', show: '1', type: 1, value: '1' },
	{ token: '2', show: '2', type: 1, value: '2' },
	{ token: '3', show: '3', type: 1, value: '3' },
	{ token: '*', show: '&times;', type: 2, value: Mexp.math.mul },
	{ token: 'sinh', show: 'sinh', type: 0, value: Mexp.math.sinh },
	{ token: 'asinh', show: 'asinh', type: 0, value: Mexp.math.asinh },
	{ token: 'e', show: 'e', type: 3, value: 'E' },
	{ token: 'log', show: ' log', type: 0, value: Mexp.math.log },
	{ token: '0', show: '0', type: 1, value: '0' },
	{ token: '.', show: '.', type: 6, value: '.' },
	{ token: '+', show: '+', type: 9, value: Mexp.math.add },
	{ token: '-', show: '-', type: 9, value: Mexp.math.sub },
	{ token: ',', show: ',', type: 11, value: ',' },
	{ token: 'Sigma', show: '&Sigma;', type: 12, value: Mexp.math.sigma },
	{ token: 'n', show: 'n', type: 13, value: 'n' },
	{ token: 'Pi', show: '&Pi;', type: 12, value: Mexp.math.Pi },
	{ token: 'pow', show: 'pow', type: 8, value: Math.pow, numberOfArguments: 2 },
	{ token: '&', show: '&', type: 9, value: Mexp.math.and },
]
var preced = {
	0: 11,
	1: 0,
	2: 3,
	3: 0,
	4: 0,
	5: 0,
	6: 0,
	7: 11,
	8: 11,
	9: 1,
	10: 10,
	11: 0,
	12: 11,
	13: 0,
	14: -1,
	15: 11, // will be filtered after lexer
} // stores precedence by types
for (var i = 0; i < tokens.length; i++) {
	tokens[i].precedence = preced[tokens[i].type]
}
var type0 = {
	0: true,
	1: true,
	3: true,
	4: true,
	6: true,
	8: true,
	9: true,
	12: true,
	13: true,
	14: true,
	15: true,
} // type2:true,type4:true,type9:true,type11:true,type21:true,type22
var type1 = {
	0: true,
	1: true,
	2: true,
	3: true,
	4: true,
	5: true,
	6: true,
	7: true,
	8: true,
	9: true,
	10: true,
	11: true,
	12: true,
	13: true,
	15: true,
} // type3:true,type5:true,type7:true,type23
var type1Asterick = {
	0: true,
	3: true,
	4: true,
	8: true,
	12: true,
	13: true,
	15: true,
}
var empty = {}
var type3Asterick = {
	0: true,
	1: true,
	3: true,
	4: true,
	6: true,
	8: true,
	12: true,
	13: true,
	15: true,
} // type_5:true,type_7:true,type_23
var type6 = {
	1: true,
}
var newAr = [
	[],
	[
		'1',
		'2',
		'3',
		'7',
		'8',
		'9',
		'4',
		'5',
		'6',
		'+',
		'-',
		'*',
		'/',
		'(',
		')',
		'^',
		'!',
		'P',
		'C',
		'e',
		'0',
		'.',
		',',
		'n',
		' ',
		'&',
	],
	['pi', 'ln', 'Pi'],
	['sin', 'cos', 'tan', 'Del', 'int', 'Mod', 'log', 'pow'],
	['asin', 'acos', 'atan', 'cosh', 'root', 'tanh', 'sinh'],
	['acosh', 'atanh', 'asinh', 'Sigma'],
]

function match(str1, str2, i, x) {
	for (var f = 0; f < x; f++) {
		if (str1[i + f] !== str2[f]) {
			return false
		}
	}
	return true
}
Mexp.tokenTypes = {
	FUNCTION_WITH_ONE_ARG: 0,
	NUMBER: 1,
	BINARY_OPERATOR_HIGH_PRECENDENCE: 2,
	CONSTANT: 3,
	OPENING_PARENTHESIS: 4,
	CLOSING_PARENTHESIS: 5,
	DECIMAL: 6,
	POSTFIX_FUNCTION_WITH_ONE_ARG: 7,
	FUNCTION_WITH_N_ARGS: 8,
	BINARY_OPERATOR_LOW_PRECENDENCE: 9,
	BINARY_OPERATOR_PERMUTATION: 10,
	COMMA: 11,
	EVALUATED_FUNCTION: 12,
	EVALUATED_FUNCTION_PARAMETER: 13,
	SPACE: 14,
}
/**
  
  0 : function with syntax function_name(Maths_exp)
  1 : numbers
  2 : binary operators like * / Mod left associate and same precedence
  3 : Math constant values like e,pi,Cruncher ans
  4 : opening bracket
  5 : closing bracket
  6 : decimal
  7 : function with syntax (Math_exp)function_name
  8: function with syntax function_name(Math_exp1,Math_exp2)
  9 : binary operator like +,-
  10: binary operator like P C or ^
  11: ,
  12: function with , seperated three parameters and third parameter is a string that will be mexp string
  13: variable of Sigma function
 */
Mexp.addToken = function (newTokens) {
	for (var i = 0; i < newTokens.length; i++) {
		var x = newTokens[i].token.length
		var temp = -1
		if (newTokens[i].type === Mexp.tokenTypes.FUNCTION_WITH_N_ARGS && newTokens[i].numberOfArguments === undefined) {
			newTokens[i].numberOfArguments = 2
		}

		// newAr is a specially designed data structure index of 1d array = length of tokens
		newAr[x] = newAr[x] || []
		for (var y = 0; y < newAr[x].length; y++) {
			if (newTokens[i].token === newAr[x][y]) {
				temp = indexOfToken(newAr[x][y], tokens)
				break
			}
		}
		if (temp === -1) {
			tokens.push(newTokens[i])
			newTokens[i].precedence = preced[newTokens[i].type]
			if (newAr.length <= newTokens[i].token.length) {
				newAr[newTokens[i].token.length] = []
			}
			newAr[newTokens[i].token.length].push(newTokens[i].token)
		} else {
			// overwrite
			tokens[temp] = newTokens[i]
			newTokens[i].precedence = preced[newTokens[i].type]
		}
	}
}

function indexOfToken(key, tokens) {
	for (var search = 0; search < tokens.length; search++) {
		if (tokens[search].token === key) return search
	}
	return -1
}
function tokenize(string) {
	var nodes = []
	var length = string.length
	var key, x, y
	for (var i = 0; i < length; i++) {
		if (i < length - 1 && string[i] === ' ' && string[i + 1] === ' ') {
			continue
		}
		key = ''
		for (x = string.length - i > newAr.length - 2 ? newAr.length - 1 : string.length - i; x > 0; x--) {
			if (newAr[x] === undefined) continue
			for (y = 0; y < newAr[x].length; y++) {
				if (match(string, newAr[x][y], i, x)) {
					key = newAr[x][y]
					y = newAr[x].length
					x = 0
				}
			}
		}
		i += key.length - 1
		if (key === '') {
			throw new Mexp.Exception("Can't understand after " + string.slice(i))
		}
		nodes.push(tokens[indexOfToken(key, tokens)])
	}
	return nodes
}

var changeSignObj = {
	value: Mexp.math.changeSign,
	type: 0,
	pre: 21,
	show: '-',
}
var closingParObj = {
	value: ')',
	show: ')',
	type: 5,
	pre: 0,
}
var openingParObj = {
	value: '(',
	type: 4,
	pre: 0,
	show: '(',
}
Mexp.lex = function (inp, tokens) {
	'use strict'

	var str = [openingParObj]

	var ptc = [] // Parenthesis to close at the beginning is after one token
	var inpStr = inp
	var allowed = type0
	var bracToClose = 0
	var asterick = empty
	var prevKey = ''
	var i
	if (typeof tokens !== 'undefined') {
		Mexp.addToken(tokens)
	}
	var obj = {}
	var nodes = tokenize(inpStr)
	for (i = 0; i < nodes.length; i++) {
		var node = nodes[i]
		if (node.type === 14) {
			if (
				i > 0 &&
				i < nodes.length - 1 &&
				nodes[i + 1].type === 1 &&
				(nodes[i - 1].type === 1 || nodes[i - 1].type === 6)
			) {
				throw new Mexp.Exception('Unexpected Space')
			}
			continue
		}
		var cToken = node.token
		var cType = node.type
		var cEv = node.value
		var cPre = node.precedence
		var cShow = node.show
		var pre = str[str.length - 1]
		var j
		for (j = ptc.length; j--; ) {
			// loop over ptc
			if (ptc[j] === 0) {
				if ([0, 2, 3, 4, 5, 9, 11, 12, 13].indexOf(cType) !== -1) {
					if (allowed[cType] !== true) {
						throw new Mexp.Exception(cToken + ' is not allowed after ' + prevKey)
					}
					str.push(closingParObj)
					allowed = type1
					asterick = type3Asterick
					ptc.pop()
				}
			} else break
		}
		if (allowed[cType] !== true) {
			throw new Mexp.Exception(cToken + ' is not allowed after ' + prevKey)
		}
		if (asterick[cType] === true) {
			cType = 2
			cEv = Mexp.math.mul
			cShow = '&times;'
			cPre = 3
			i = i - 1
		}
		obj = {
			value: cEv,
			type: cType,
			pre: cPre,
			show: cShow,
			numberOfArguments: node.numberOfArguments,
		}
		if (cType === 0) {
			allowed = type0
			asterick = empty
			inc(ptc, 2)
			str.push(obj)
			if (nodes[i + 1].type !== 4) {
				str.push(openingParObj)
				ptc.push(2)
			}
			// bracToClose++
		} else if (cType === 1) {
			if (pre.type === 1) {
				pre.value += cEv
				inc(ptc, 1)
			} else {
				str.push(obj)
			}
			allowed = type1
			asterick = type1Asterick
		} else if (cType === 2) {
			allowed = type0
			asterick = empty
			inc(ptc, 2)
			str.push(obj)
		} else if (cType === 3) {
			// constant
			str.push(obj)
			allowed = type1
			asterick = type3Asterick
		} else if (cType === 4) {
			inc(ptc, 1)
			bracToClose++
			allowed = type0
			asterick = empty
			str.push(obj)
		} else if (cType === 5) {
			if (!bracToClose) {
				throw new Mexp.Exception('Closing parenthesis are more than opening one, wait What!!!')
			}
			bracToClose--
			allowed = type1
			asterick = type3Asterick
			str.push(obj)
			inc(ptc, 1)
		} else if (cType === 6) {
			if (pre.hasDec) {
				throw new Mexp.Exception('Two decimals are not allowed in one number')
			}
			if (pre.type !== 1) {
				pre = {
					value: 0,
					type: 1,
					pre: 0,
				} // pre needs to be changed as it will the last value now to be safe in later code
				str.push(pre)
				// inc(ptc, 1)
			}
			allowed = type6
			inc(ptc, 1)
			asterick = empty
			pre.value += cEv
			pre.hasDec = true
		} else if (cType === 7) {
			allowed = type1
			asterick = type3Asterick
			inc(ptc, 1)
			str.push(obj)
		}
		if (cType === 8) {
			allowed = type0
			asterick = empty
			inc(ptc, node.numberOfArguments + 2)
			str.push(obj)
			// str.push(openingParObj)
			if (nodes[i + 1].type !== 4) {
				str.push(openingParObj)
				ptc.push(node.numberOfArguments + 2)
			}
		} else if (cType === 9) {
			if (pre.type === 9) {
				if (pre.value === Mexp.math.add) {
					pre.value = cEv
					pre.show = cShow
					inc(ptc, 1)
				} else if (pre.value === Mexp.math.sub && cShow === '-') {
					pre.value = Mexp.math.add
					pre.show = '+'
					inc(ptc, 1)
				}
			} else if (pre.type !== 5 && pre.type !== 7 && pre.type !== 1 && pre.type !== 3 && pre.type !== 13) {
				// changesign only when negative is found
				if (cToken === '-') {
					// do nothing for + token
					// don't add with the above if statement as that will run the else statement of parent if on Ctoken +
					allowed = type0
					asterick = empty
					inc(ptc, 2).push(2)
					str.push(changeSignObj)
					str.push(openingParObj)
				}
			} else {
				str.push(obj)
				inc(ptc, 2)
			}
			allowed = type0
			asterick = empty
		} else if (cType === 10) {
			allowed = type0
			asterick = empty
			inc(ptc, 2)
			str.push(obj)
		} else if (cType === 11) {
			allowed = type0
			asterick = empty
			str.push(obj)
		} else if (cType === 12) {
			allowed = type0
			asterick = empty
			inc(ptc, 6)
			str.push(obj)
			if (nodes[i + 1].type !== 4) {
				str.push(openingParObj)
				ptc.push(6)
			}
		} else if (cType === 13) {
			allowed = type1
			asterick = type3Asterick
			str.push(obj)
		}

		inc(ptc, -1)
		prevKey = cToken
	}
	for (j = ptc.length; j--; ) {
		// loop over ptc
		str.push(closingParObj)
	}
	if (allowed[5] !== true) {
		throw new Mexp.Exception('complete the expression')
	}
	while (bracToClose--) {
		str.push(closingParObj)
	}

	str.push(closingParObj)
	//        console.log(str);
	return new Mexp(str)
}
module.exports = Mexp


/***/ }),

/***/ 5991:
/***/ ((module) => {

"use strict";

var Mexp = function (parsed) {
  this.value = parsed
}

Mexp.math = {
  isDegree: true, // mode of calculator
  acos: function (x) {
    return (Mexp.math.isDegree ? 180 / Math.PI * Math.acos(x) : Math.acos(x))
  },
  add: function (a, b) {
    return a + b
  },
  asin: function (x) {
    return (Mexp.math.isDegree ? 180 / Math.PI * Math.asin(x) : Math.asin(x))
  },
  atan: function (x) {
    return (Mexp.math.isDegree ? 180 / Math.PI * Math.atan(x) : Math.atan(x))
  },
  acosh: function (x) {
    return Math.log(x + Math.sqrt(x * x - 1))
  },
  asinh: function (x) {
    return Math.log(x + Math.sqrt(x * x + 1))
  },
  atanh: function (x) {
    return Math.log((1 + x) / (1 - x))
  },
  C: function (n, r) {
    var pro = 1
    var other = n - r
    var choice = r
    if (choice < other) {
      choice = other
      other = r
    }
    for (var i = choice + 1; i <= n; i++) {
      pro *= i
    }
    return pro / Mexp.math.fact(other)
  },
  changeSign: function (x) {
    return -x
  },
  cos: function (x) {
    if (Mexp.math.isDegree) x = Mexp.math.toRadian(x)
    return Math.cos(x)
  },
  cosh: function (x) {
    return (Math.pow(Math.E, x) + Math.pow(Math.E, -1 * x)) / 2
  },
  div: function (a, b) {
    return a / b
  },
  fact: function (n) {
    if (n % 1 !== 0) return 'NaN'
    var pro = 1
    for (var i = 2; i <= n; i++) {
      pro *= i
    }
    return pro
  },
  inverse: function (x) {
    return 1 / x
  },
  log: function (i) {
    return Math.log(i) / Math.log(10)
  },
  mod: function (a, b) {
    return a % b
  },
  mul: function (a, b) {
    return a * b
  },
  P: function (n, r) {
    var pro = 1
    for (var i = Math.floor(n) - Math.floor(r) + 1; i <= Math.floor(n); i++) {
      pro *= i
    }
    return pro
  },
  Pi: function (low, high, ex) {
    var pro = 1
    for (var i = low; i <= high; i++) {
      pro *= Number(ex.postfixEval({
        n: i
      }))
    }
    return pro
  },
  pow10x: function (e) {
    var x = 1
    while (e--) {
      x *= 10
    }
    return x
  },
  sigma: function (low, high, ex) {
    var sum = 0
    for (var i = low; i <= high; i++) {
      sum += Number(ex.postfixEval({
        n: i
      }))
    }
    return sum
  },
  sin: function (x) {
    if (Mexp.math.isDegree) x = Mexp.math.toRadian(x)
    return Math.sin(x)
  },
  sinh: function (x) {
    return (Math.pow(Math.E, x) - Math.pow(Math.E, -1 * x)) / 2
  },
  sub: function (a, b) {
    return a - b
  },
  tan: function (x) {
    if (Mexp.math.isDegree) x = Mexp.math.toRadian(x)
    return Math.tan(x)
  },
  tanh: function (x) {
    return Mexp.sinha(x) / Mexp.cosha(x)
  },
  toRadian: function (x) {
    return x * Math.PI / 180
  },
  and: function (a, b) {
    return a & b
  }
}
Mexp.Exception = function (message) {
  this.message = message
}
module.exports = Mexp


/***/ }),

/***/ 5881:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var Mexp = __webpack_require__(9763);

Mexp.prototype.toPostfix = function () {
	'use strict';
	var post = [], elem, popped, prep, pre, ele;
	var stack = [{ value: "(", type: 4, pre: 0 }];
	var arr = this.value;
	for (var i = 1; i < arr.length; i++) {
		if (arr[i].type === 1 || arr[i].type === 3 || arr[i].type === 13) {	//if token is number,constant,or n(which is also a special constant in our case)
			if (arr[i].type === 1)
				arr[i].value = Number(arr[i].value);
			post.push(arr[i]);
		}
		else if (arr[i].type === 4) {
			stack.push(arr[i]);
		}
		else if (arr[i].type === 5) {
			while ((popped = stack.pop()).type !== 4) {
				post.push(popped);
			}
		}
		else if (arr[i].type === 11) {
			while ((popped = stack.pop()).type !== 4) {
				post.push(popped);
			}
			stack.push(popped);
		}
		else {
			elem = arr[i];
			pre = elem.pre;
			ele = stack[stack.length - 1];
			prep = ele.pre;
			var flag = ele.value == 'Math.pow' && elem.value == 'Math.pow';
			if (pre > prep) stack.push(elem);
			else {
				while (prep >= pre && !flag || flag && pre < prep) {
					popped = stack.pop();
					ele = stack[stack.length - 1];
					post.push(popped);
					prep = ele.pre;
					flag = elem.value == 'Math.pow' && ele.value == 'Math.pow';
				}
				stack.push(elem);
			}
		}
	}
	return new Mexp(post);
};
module.exports = Mexp;

/***/ }),

/***/ 4443:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Mexp = __webpack_require__(5881)
Mexp.prototype.postfixEval = function (UserDefined) {
	'use strict'
	UserDefined = UserDefined || {}
	UserDefined.PI = Math.PI
	UserDefined.E = Math.E
	var stack = [],
		pop1,
		pop2,
		pop3
	var disp = []
	var temp = ''
	var arr = this.value
	var bool = typeof UserDefined.n !== 'undefined'
	for (var i = 0; i < arr.length; i++) {
		if (arr[i].type === 1) {
			stack.push({ value: arr[i].value, type: 1 })
		} else if (arr[i].type === 3) {
			stack.push({ value: UserDefined[arr[i].value], type: 1 })
		} else if (arr[i].type === 0) {
			if (typeof stack[stack.length - 1].type === 'undefined') {
				stack[stack.length - 1].value.push(arr[i])
			} else stack[stack.length - 1].value = arr[i].value(stack[stack.length - 1].value)
		} else if (arr[i].type === 7) {
			if (typeof stack[stack.length - 1].type === 'undefined') {
				stack[stack.length - 1].value.push(arr[i])
			} else stack[stack.length - 1].value = arr[i].value(stack[stack.length - 1].value)
		} else if (arr[i].type === 8) {
			var popped = []
			for (var x = 0; x < arr[i].numberOfArguments; x++) {
				popped.push(stack.pop().value)
			}
			stack.push({ type: 1, value: arr[i].value.apply(arr[i], popped.reverse()) })
		} else if (arr[i].type === 10) {
			pop1 = stack.pop()
			pop2 = stack.pop()
			if (typeof pop2.type === 'undefined') {
				pop2.value = pop2.concat(pop1)
				pop2.value.push(arr[i])
				stack.push(pop2)
			} else if (typeof pop1.type === 'undefined') {
				pop1.unshift(pop2)
				pop1.push(arr[i])
				stack.push(pop1)
			} else {
				stack.push({ type: 1, value: arr[i].value(pop2.value, pop1.value) })
			}
		} else if (arr[i].type === 2 || arr[i].type === 9) {
			pop1 = stack.pop()
			pop2 = stack.pop()
			if (typeof pop2.type === 'undefined') {
				pop2 = pop2.concat(pop1)
				pop2.push(arr[i])
				stack.push(pop2)
			} else if (typeof pop1.type === 'undefined') {
				pop1.unshift(pop2)
				pop1.push(arr[i])
				stack.push(pop1)
			} else {
				stack.push({ type: 1, value: arr[i].value(pop2.value, pop1.value) })
			}
		} else if (arr[i].type === 12) {
			pop1 = stack.pop()
			if (typeof pop1.type !== 'undefined') {
				pop1 = [pop1]
			}
			pop2 = stack.pop()
			pop3 = stack.pop()
			stack.push({ type: 1, value: arr[i].value(pop3.value, pop2.value, new Mexp(pop1)) })
		} else if (arr[i].type === 13) {
			if (bool) {
				stack.push({ value: UserDefined[arr[i].value], type: 3 })
			} else stack.push([arr[i]])
		}
	}
	if (stack.length > 1) {
		throw new Mexp.Exception('Uncaught Syntax error')
	}
	return stack[0].value > 1000000000000000 ? 'Infinity' : parseFloat(stack[0].value.toFixed(15))
}
Mexp.eval = function (str, tokens, obj) {
	if (typeof tokens === 'undefined') {
		return this.lex(str).toPostfix().postfixEval()
	} else if (typeof obj === 'undefined') {
		if (typeof tokens.length !== 'undefined') return this.lex(str, tokens).toPostfix().postfixEval()
		else return this.lex(str).toPostfix().postfixEval(tokens)
	} else return this.lex(str, tokens).toPostfix().postfixEval(obj)
}
module.exports = Mexp


/***/ }),

/***/ 6461:
/***/ ((module) => {

"use strict";
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/


/* eslint-disable no-unused-vars */
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};


/***/ }),

/***/ 1733:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactPropTypesSecret = __webpack_require__(2068);

function emptyFunction() {}
function emptyFunctionWithReset() {}
emptyFunctionWithReset.resetWarningCache = emptyFunction;

module.exports = function() {
  function shim(props, propName, componentName, location, propFullName, secret) {
    if (secret === ReactPropTypesSecret) {
      // It is still safe when called from React.
      return;
    }
    var err = new Error(
      'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
      'Use PropTypes.checkPropTypes() to call them. ' +
      'Read more at http://fb.me/use-check-prop-types'
    );
    err.name = 'Invariant Violation';
    throw err;
  };
  shim.isRequired = shim;
  function getShim() {
    return shim;
  };
  // Important!
  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.
  var ReactPropTypes = {
    array: shim,
    bigint: shim,
    bool: shim,
    func: shim,
    number: shim,
    object: shim,
    string: shim,
    symbol: shim,

    any: shim,
    arrayOf: getShim,
    element: shim,
    elementType: shim,
    instanceOf: getShim,
    node: shim,
    objectOf: getShim,
    oneOf: getShim,
    oneOfType: getShim,
    shape: getShim,
    exact: getShim,

    checkPropTypes: emptyFunctionWithReset,
    resetWarningCache: emptyFunction
  };

  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};


/***/ }),

/***/ 9724:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

if (false) { var throwOnDirectAccess, ReactIs; } else {
  // By explicitly using `prop-types` you are opting into new production behavior.
  // http://fb.me/prop-types-in-prod
  module.exports = __webpack_require__(1733)();
}


/***/ }),

/***/ 2068:
/***/ ((module) => {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;


/***/ }),

/***/ 1223:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/
var aa=__webpack_require__(4191),ca=__webpack_require__(7630);function p(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}var da=new Set,ea={};function fa(a,b){ha(a,b);ha(a+"Capture",b)}
function ha(a,b){ea[a]=b;for(a=0;a<b.length;a++)da.add(b[a])}
var ia=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),ja=Object.prototype.hasOwnProperty,ka=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,la=
{},ma={};function oa(a){if(ja.call(ma,a))return!0;if(ja.call(la,a))return!1;if(ka.test(a))return ma[a]=!0;la[a]=!0;return!1}function pa(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case "function":case "symbol":return!0;case "boolean":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return"data-"!==a&&"aria-"!==a;default:return!1}}
function qa(a,b,c,d){if(null===b||"undefined"===typeof b||pa(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function v(a,b,c,d,e,f,g){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f;this.removeEmptyString=g}var z={};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){z[a]=new v(a,0,!1,a,null,!1,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];z[b]=new v(b,1,!1,a[1],null,!1,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){z[a]=new v(a,2,!1,a.toLowerCase(),null,!1,!1)});
["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){z[a]=new v(a,2,!1,a,null,!1,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){z[a]=new v(a,3,!1,a.toLowerCase(),null,!1,!1)});
["checked","multiple","muted","selected"].forEach(function(a){z[a]=new v(a,3,!0,a,null,!1,!1)});["capture","download"].forEach(function(a){z[a]=new v(a,4,!1,a,null,!1,!1)});["cols","rows","size","span"].forEach(function(a){z[a]=new v(a,6,!1,a,null,!1,!1)});["rowSpan","start"].forEach(function(a){z[a]=new v(a,5,!1,a.toLowerCase(),null,!1,!1)});var ra=/[\-:]([a-z])/g;function sa(a){return a[1].toUpperCase()}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=a.replace(ra,
sa);z[b]=new v(b,1,!1,a,null,!1,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(ra,sa);z[b]=new v(b,1,!1,a,"http://www.w3.org/1999/xlink",!1,!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(ra,sa);z[b]=new v(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1,!1)});["tabIndex","crossOrigin"].forEach(function(a){z[a]=new v(a,1,!1,a.toLowerCase(),null,!1,!1)});
z.xlinkHref=new v("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1);["src","href","action","formAction"].forEach(function(a){z[a]=new v(a,1,!1,a.toLowerCase(),null,!0,!0)});
function ta(a,b,c,d){var e=z.hasOwnProperty(b)?z[b]:null;if(null!==e?0!==e.type:d||!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1])qa(b,c,e,d)&&(c=null),d||null===e?oa(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c)))}
var ua=aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,va=Symbol.for("react.element"),wa=Symbol.for("react.portal"),ya=Symbol.for("react.fragment"),za=Symbol.for("react.strict_mode"),Aa=Symbol.for("react.profiler"),Ba=Symbol.for("react.provider"),Ca=Symbol.for("react.context"),Da=Symbol.for("react.forward_ref"),Ea=Symbol.for("react.suspense"),Fa=Symbol.for("react.suspense_list"),Ga=Symbol.for("react.memo"),Ha=Symbol.for("react.lazy");Symbol.for("react.scope");Symbol.for("react.debug_trace_mode");
var Ia=Symbol.for("react.offscreen");Symbol.for("react.legacy_hidden");Symbol.for("react.cache");Symbol.for("react.tracing_marker");var Ja=Symbol.iterator;function Ka(a){if(null===a||"object"!==typeof a)return null;a=Ja&&a[Ja]||a["@@iterator"];return"function"===typeof a?a:null}var A=Object.assign,La;function Ma(a){if(void 0===La)try{throw Error();}catch(c){var b=c.stack.trim().match(/\n( *(at )?)/);La=b&&b[1]||""}return"\n"+La+a}var Na=!1;
function Oa(a,b){if(!a||Na)return"";Na=!0;var c=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{if(b)if(b=function(){throw Error();},Object.defineProperty(b.prototype,"props",{set:function(){throw Error();}}),"object"===typeof Reflect&&Reflect.construct){try{Reflect.construct(b,[])}catch(l){var d=l}Reflect.construct(a,[],b)}else{try{b.call()}catch(l){d=l}a.call(b.prototype)}else{try{throw Error();}catch(l){d=l}a()}}catch(l){if(l&&d&&"string"===typeof l.stack){for(var e=l.stack.split("\n"),
f=d.stack.split("\n"),g=e.length-1,h=f.length-1;1<=g&&0<=h&&e[g]!==f[h];)h--;for(;1<=g&&0<=h;g--,h--)if(e[g]!==f[h]){if(1!==g||1!==h){do if(g--,h--,0>h||e[g]!==f[h]){var k="\n"+e[g].replace(" at new "," at ");a.displayName&&k.includes("<anonymous>")&&(k=k.replace("<anonymous>",a.displayName));return k}while(1<=g&&0<=h)}break}}}finally{Na=!1,Error.prepareStackTrace=c}return(a=a?a.displayName||a.name:"")?Ma(a):""}
function Pa(a){switch(a.tag){case 5:return Ma(a.type);case 16:return Ma("Lazy");case 13:return Ma("Suspense");case 19:return Ma("SuspenseList");case 0:case 2:case 15:return a=Oa(a.type,!1),a;case 11:return a=Oa(a.type.render,!1),a;case 1:return a=Oa(a.type,!0),a;default:return""}}
function Qa(a){if(null==a)return null;if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case ya:return"Fragment";case wa:return"Portal";case Aa:return"Profiler";case za:return"StrictMode";case Ea:return"Suspense";case Fa:return"SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case Ca:return(a.displayName||"Context")+".Consumer";case Ba:return(a._context.displayName||"Context")+".Provider";case Da:var b=a.render;a=a.displayName;a||(a=b.displayName||
b.name||"",a=""!==a?"ForwardRef("+a+")":"ForwardRef");return a;case Ga:return b=a.displayName||null,null!==b?b:Qa(a.type)||"Memo";case Ha:b=a._payload;a=a._init;try{return Qa(a(b))}catch(c){}}return null}
function Ra(a){var b=a.type;switch(a.tag){case 24:return"Cache";case 9:return(b.displayName||"Context")+".Consumer";case 10:return(b._context.displayName||"Context")+".Provider";case 18:return"DehydratedFragment";case 11:return a=b.render,a=a.displayName||a.name||"",b.displayName||(""!==a?"ForwardRef("+a+")":"ForwardRef");case 7:return"Fragment";case 5:return b;case 4:return"Portal";case 3:return"Root";case 6:return"Text";case 16:return Qa(b);case 8:return b===za?"StrictMode":"Mode";case 22:return"Offscreen";
case 12:return"Profiler";case 21:return"Scope";case 13:return"Suspense";case 19:return"SuspenseList";case 25:return"TracingMarker";case 1:case 0:case 17:case 2:case 14:case 15:if("function"===typeof b)return b.displayName||b.name||null;if("string"===typeof b)return b}return null}function Sa(a){switch(typeof a){case "boolean":case "number":case "string":case "undefined":return a;case "object":return a;default:return""}}
function Ta(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}
function Ua(a){var b=Ta(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a)}});Object.defineProperty(a,b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=
null;delete a[b]}}}}function Va(a){a._valueTracker||(a._valueTracker=Ua(a))}function Wa(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=Ta(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Xa(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}
function Ya(a,b){var c=b.checked;return A({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=c?c:a._wrapperState.initialChecked})}function Za(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=Sa(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}function ab(a,b){b=b.checked;null!=b&&ta(a,"checked",b,!1)}
function bb(a,b){ab(a,b);var c=Sa(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c}else a.value!==""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?cb(a,b.type,c):b.hasOwnProperty("defaultValue")&&cb(a,b.type,Sa(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}
function db(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=b);a.defaultValue=b}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c)}
function cb(a,b,c){if("number"!==b||Xa(a.ownerDocument)!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c)}var eb=Array.isArray;
function fb(a,b,c,d){a=a.options;if(b){b={};for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+Sa(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}
function gb(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(p(91));return A({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}function hb(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(p(92));if(eb(c)){if(1<c.length)throw Error(p(93));c=c[0]}b=c}null==b&&(b="");c=b}a._wrapperState={initialValue:Sa(c)}}
function ib(a,b){var c=Sa(b.value),d=Sa(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d)}function jb(a){var b=a.textContent;b===a._wrapperState.initialValue&&""!==b&&null!==b&&(a.value=b)}function kb(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}
function lb(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?kb(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}
var mb,nb=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if("http://www.w3.org/2000/svg"!==a.namespaceURI||"innerHTML"in a)a.innerHTML=b;else{mb=mb||document.createElement("div");mb.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=mb.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}});
function ob(a,b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b}
var pb={animationIterationCount:!0,aspectRatio:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,
zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},qb=["Webkit","ms","Moz","O"];Object.keys(pb).forEach(function(a){qb.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);pb[b]=pb[a]})});function rb(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||pb.hasOwnProperty(a)&&pb[a]?(""+b).trim():b+"px"}
function sb(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=rb(c,b[c],d);"float"===c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}var tb=A({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0});
function ub(a,b){if(b){if(tb[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(p(137,a));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(p(60));if("object"!==typeof b.dangerouslySetInnerHTML||!("__html"in b.dangerouslySetInnerHTML))throw Error(p(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(p(62));}}
function vb(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;default:return!0}}var wb=null;function xb(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:a}var yb=null,zb=null,Ab=null;
function Bb(a){if(a=Cb(a)){if("function"!==typeof yb)throw Error(p(280));var b=a.stateNode;b&&(b=Db(b),yb(a.stateNode,a.type,b))}}function Eb(a){zb?Ab?Ab.push(a):Ab=[a]:zb=a}function Fb(){if(zb){var a=zb,b=Ab;Ab=zb=null;Bb(a);if(b)for(a=0;a<b.length;a++)Bb(b[a])}}function Gb(a,b){return a(b)}function Hb(){}var Ib=!1;function Jb(a,b,c){if(Ib)return a(b,c);Ib=!0;try{return Gb(a,b,c)}finally{if(Ib=!1,null!==zb||null!==Ab)Hb(),Fb()}}
function Kb(a,b){var c=a.stateNode;if(null===c)return null;var d=Db(c);if(null===d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&"function"!==
typeof c)throw Error(p(231,b,typeof c));return c}var Lb=!1;if(ia)try{var Mb={};Object.defineProperty(Mb,"passive",{get:function(){Lb=!0}});window.addEventListener("test",Mb,Mb);window.removeEventListener("test",Mb,Mb)}catch(a){Lb=!1}function Nb(a,b,c,d,e,f,g,h,k){var l=Array.prototype.slice.call(arguments,3);try{b.apply(c,l)}catch(m){this.onError(m)}}var Ob=!1,Pb=null,Qb=!1,Rb=null,Sb={onError:function(a){Ob=!0;Pb=a}};function Tb(a,b,c,d,e,f,g,h,k){Ob=!1;Pb=null;Nb.apply(Sb,arguments)}
function Ub(a,b,c,d,e,f,g,h,k){Tb.apply(this,arguments);if(Ob){if(Ob){var l=Pb;Ob=!1;Pb=null}else throw Error(p(198));Qb||(Qb=!0,Rb=l)}}function Vb(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.flags&4098)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function Wb(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function Xb(a){if(Vb(a)!==a)throw Error(p(188));}
function Yb(a){var b=a.alternate;if(!b){b=Vb(a);if(null===b)throw Error(p(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return Xb(e),a;if(f===d)return Xb(e),b;f=f.sibling}throw Error(p(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=f.child;h;){if(h===
c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(p(189));}}if(c.alternate!==d)throw Error(p(190));}if(3!==c.tag)throw Error(p(188));return c.stateNode.current===c?a:b}function Zb(a){a=Yb(a);return null!==a?$b(a):null}function $b(a){if(5===a.tag||6===a.tag)return a;for(a=a.child;null!==a;){var b=$b(a);if(null!==b)return b;a=a.sibling}return null}
var ac=ca.unstable_scheduleCallback,bc=ca.unstable_cancelCallback,cc=ca.unstable_shouldYield,dc=ca.unstable_requestPaint,B=ca.unstable_now,ec=ca.unstable_getCurrentPriorityLevel,fc=ca.unstable_ImmediatePriority,gc=ca.unstable_UserBlockingPriority,hc=ca.unstable_NormalPriority,ic=ca.unstable_LowPriority,jc=ca.unstable_IdlePriority,kc=null,lc=null;function mc(a){if(lc&&"function"===typeof lc.onCommitFiberRoot)try{lc.onCommitFiberRoot(kc,a,void 0,128===(a.current.flags&128))}catch(b){}}
var oc=Math.clz32?Math.clz32:nc,pc=Math.log,qc=Math.LN2;function nc(a){a>>>=0;return 0===a?32:31-(pc(a)/qc|0)|0}var rc=64,sc=4194304;
function tc(a){switch(a&-a){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return a&4194240;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return a&130023424;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 1073741824;
default:return a}}function uc(a,b){var c=a.pendingLanes;if(0===c)return 0;var d=0,e=a.suspendedLanes,f=a.pingedLanes,g=c&268435455;if(0!==g){var h=g&~e;0!==h?d=tc(h):(f&=g,0!==f&&(d=tc(f)))}else g=c&~e,0!==g?d=tc(g):0!==f&&(d=tc(f));if(0===d)return 0;if(0!==b&&b!==d&&0===(b&e)&&(e=d&-d,f=b&-b,e>=f||16===e&&0!==(f&4194240)))return b;0!==(d&4)&&(d|=c&16);b=a.entangledLanes;if(0!==b)for(a=a.entanglements,b&=d;0<b;)c=31-oc(b),e=1<<c,d|=a[c],b&=~e;return d}
function vc(a,b){switch(a){case 1:case 2:case 4:return b+250;case 8:case 16:case 32:case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return b+5E3;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return-1;case 134217728:case 268435456:case 536870912:case 1073741824:return-1;default:return-1}}
function wc(a,b){for(var c=a.suspendedLanes,d=a.pingedLanes,e=a.expirationTimes,f=a.pendingLanes;0<f;){var g=31-oc(f),h=1<<g,k=e[g];if(-1===k){if(0===(h&c)||0!==(h&d))e[g]=vc(h,b)}else k<=b&&(a.expiredLanes|=h);f&=~h}}function xc(a){a=a.pendingLanes&-1073741825;return 0!==a?a:a&1073741824?1073741824:0}function yc(){var a=rc;rc<<=1;0===(rc&4194240)&&(rc=64);return a}function zc(a){for(var b=[],c=0;31>c;c++)b.push(a);return b}
function Ac(a,b,c){a.pendingLanes|=b;536870912!==b&&(a.suspendedLanes=0,a.pingedLanes=0);a=a.eventTimes;b=31-oc(b);a[b]=c}function Bc(a,b){var c=a.pendingLanes&~b;a.pendingLanes=b;a.suspendedLanes=0;a.pingedLanes=0;a.expiredLanes&=b;a.mutableReadLanes&=b;a.entangledLanes&=b;b=a.entanglements;var d=a.eventTimes;for(a=a.expirationTimes;0<c;){var e=31-oc(c),f=1<<e;b[e]=0;d[e]=-1;a[e]=-1;c&=~f}}
function Cc(a,b){var c=a.entangledLanes|=b;for(a=a.entanglements;c;){var d=31-oc(c),e=1<<d;e&b|a[d]&b&&(a[d]|=b);c&=~e}}var C=0;function Dc(a){a&=-a;return 1<a?4<a?0!==(a&268435455)?16:536870912:4:1}var Ec,Fc,Gc,Hc,Ic,Jc=!1,Kc=[],Lc=null,Mc=null,Nc=null,Oc=new Map,Pc=new Map,Qc=[],Rc="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
function Sc(a,b){switch(a){case "focusin":case "focusout":Lc=null;break;case "dragenter":case "dragleave":Mc=null;break;case "mouseover":case "mouseout":Nc=null;break;case "pointerover":case "pointerout":Oc.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":Pc.delete(b.pointerId)}}
function Tc(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a={blockedOn:b,domEventName:c,eventSystemFlags:d,nativeEvent:f,targetContainers:[e]},null!==b&&(b=Cb(b),null!==b&&Fc(b)),a;a.eventSystemFlags|=d;b=a.targetContainers;null!==e&&-1===b.indexOf(e)&&b.push(e);return a}
function Uc(a,b,c,d,e){switch(b){case "focusin":return Lc=Tc(Lc,a,b,c,d,e),!0;case "dragenter":return Mc=Tc(Mc,a,b,c,d,e),!0;case "mouseover":return Nc=Tc(Nc,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;Oc.set(f,Tc(Oc.get(f)||null,a,b,c,d,e));return!0;case "gotpointercapture":return f=e.pointerId,Pc.set(f,Tc(Pc.get(f)||null,a,b,c,d,e)),!0}return!1}
function Vc(a){var b=Wc(a.target);if(null!==b){var c=Vb(b);if(null!==c)if(b=c.tag,13===b){if(b=Wb(c),null!==b){a.blockedOn=b;Ic(a.priority,function(){Gc(c)});return}}else if(3===b&&c.stateNode.current.memoizedState.isDehydrated){a.blockedOn=3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}
function Xc(a){if(null!==a.blockedOn)return!1;for(var b=a.targetContainers;0<b.length;){var c=Yc(a.domEventName,a.eventSystemFlags,b[0],a.nativeEvent);if(null===c){c=a.nativeEvent;var d=new c.constructor(c.type,c);wb=d;c.target.dispatchEvent(d);wb=null}else return b=Cb(c),null!==b&&Fc(b),a.blockedOn=c,!1;b.shift()}return!0}function Zc(a,b,c){Xc(a)&&c.delete(b)}function $c(){Jc=!1;null!==Lc&&Xc(Lc)&&(Lc=null);null!==Mc&&Xc(Mc)&&(Mc=null);null!==Nc&&Xc(Nc)&&(Nc=null);Oc.forEach(Zc);Pc.forEach(Zc)}
function ad(a,b){a.blockedOn===b&&(a.blockedOn=null,Jc||(Jc=!0,ca.unstable_scheduleCallback(ca.unstable_NormalPriority,$c)))}
function bd(a){function b(b){return ad(b,a)}if(0<Kc.length){ad(Kc[0],a);for(var c=1;c<Kc.length;c++){var d=Kc[c];d.blockedOn===a&&(d.blockedOn=null)}}null!==Lc&&ad(Lc,a);null!==Mc&&ad(Mc,a);null!==Nc&&ad(Nc,a);Oc.forEach(b);Pc.forEach(b);for(c=0;c<Qc.length;c++)d=Qc[c],d.blockedOn===a&&(d.blockedOn=null);for(;0<Qc.length&&(c=Qc[0],null===c.blockedOn);)Vc(c),null===c.blockedOn&&Qc.shift()}var cd=ua.ReactCurrentBatchConfig,dd=!0;
function ed(a,b,c,d){var e=C,f=cd.transition;cd.transition=null;try{C=1,fd(a,b,c,d)}finally{C=e,cd.transition=f}}function gd(a,b,c,d){var e=C,f=cd.transition;cd.transition=null;try{C=4,fd(a,b,c,d)}finally{C=e,cd.transition=f}}
function fd(a,b,c,d){if(dd){var e=Yc(a,b,c,d);if(null===e)hd(a,b,d,id,c),Sc(a,d);else if(Uc(e,a,b,c,d))d.stopPropagation();else if(Sc(a,d),b&4&&-1<Rc.indexOf(a)){for(;null!==e;){var f=Cb(e);null!==f&&Ec(f);f=Yc(a,b,c,d);null===f&&hd(a,b,d,id,c);if(f===e)break;e=f}null!==e&&d.stopPropagation()}else hd(a,b,d,null,c)}}var id=null;
function Yc(a,b,c,d){id=null;a=xb(d);a=Wc(a);if(null!==a)if(b=Vb(a),null===b)a=null;else if(c=b.tag,13===c){a=Wb(b);if(null!==a)return a;a=null}else if(3===c){if(b.stateNode.current.memoizedState.isDehydrated)return 3===b.tag?b.stateNode.containerInfo:null;a=null}else b!==a&&(a=null);id=a;return null}
function jd(a){switch(a){case "cancel":case "click":case "close":case "contextmenu":case "copy":case "cut":case "auxclick":case "dblclick":case "dragend":case "dragstart":case "drop":case "focusin":case "focusout":case "input":case "invalid":case "keydown":case "keypress":case "keyup":case "mousedown":case "mouseup":case "paste":case "pause":case "play":case "pointercancel":case "pointerdown":case "pointerup":case "ratechange":case "reset":case "resize":case "seeked":case "submit":case "touchcancel":case "touchend":case "touchstart":case "volumechange":case "change":case "selectionchange":case "textInput":case "compositionstart":case "compositionend":case "compositionupdate":case "beforeblur":case "afterblur":case "beforeinput":case "blur":case "fullscreenchange":case "focus":case "hashchange":case "popstate":case "select":case "selectstart":return 1;case "drag":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "mousemove":case "mouseout":case "mouseover":case "pointermove":case "pointerout":case "pointerover":case "scroll":case "toggle":case "touchmove":case "wheel":case "mouseenter":case "mouseleave":case "pointerenter":case "pointerleave":return 4;
case "message":switch(ec()){case fc:return 1;case gc:return 4;case hc:case ic:return 16;case jc:return 536870912;default:return 16}default:return 16}}var kd=null,ld=null,md=null;function nd(){if(md)return md;var a,b=ld,c=b.length,d,e="value"in kd?kd.value:kd.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return md=e.slice(a,1<d?1-d:void 0)}
function od(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function pd(){return!0}function qd(){return!1}
function rd(a){function b(b,d,e,f,g){this._reactName=b;this._targetInst=e;this.type=d;this.nativeEvent=f;this.target=g;this.currentTarget=null;for(var c in a)a.hasOwnProperty(c)&&(b=a[c],this[c]=b?b(f):f[c]);this.isDefaultPrevented=(null!=f.defaultPrevented?f.defaultPrevented:!1===f.returnValue)?pd:qd;this.isPropagationStopped=qd;return this}A(b.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&
(a.returnValue=!1),this.isDefaultPrevented=pd)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=pd)},persist:function(){},isPersistent:pd});return b}
var sd={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(a){return a.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},td=rd(sd),ud=A({},sd,{view:0,detail:0}),vd=rd(ud),wd,xd,yd,Ad=A({},ud,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:zd,button:0,buttons:0,relatedTarget:function(a){return void 0===a.relatedTarget?a.fromElement===a.srcElement?a.toElement:a.fromElement:a.relatedTarget},movementX:function(a){if("movementX"in
a)return a.movementX;a!==yd&&(yd&&"mousemove"===a.type?(wd=a.screenX-yd.screenX,xd=a.screenY-yd.screenY):xd=wd=0,yd=a);return wd},movementY:function(a){return"movementY"in a?a.movementY:xd}}),Bd=rd(Ad),Cd=A({},Ad,{dataTransfer:0}),Dd=rd(Cd),Ed=A({},ud,{relatedTarget:0}),Fd=rd(Ed),Gd=A({},sd,{animationName:0,elapsedTime:0,pseudoElement:0}),Hd=rd(Gd),Id=A({},sd,{clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),Jd=rd(Id),Kd=A({},sd,{data:0}),Ld=rd(Kd),Md={Esc:"Escape",
Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},Nd={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",
119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},Od={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function Pd(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Od[a])?!!b[a]:!1}function zd(){return Pd}
var Qd=A({},ud,{key:function(a){if(a.key){var b=Md[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=od(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?Nd[a.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:zd,charCode:function(a){return"keypress"===a.type?od(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===
a.type?od(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),Rd=rd(Qd),Sd=A({},Ad,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0}),Td=rd(Sd),Ud=A({},ud,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:zd}),Vd=rd(Ud),Wd=A({},sd,{propertyName:0,elapsedTime:0,pseudoElement:0}),Xd=rd(Wd),Yd=A({},Ad,{deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},
deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?-a.wheelDelta:0},deltaZ:0,deltaMode:0}),Zd=rd(Yd),$d=[9,13,27,32],ae=ia&&"CompositionEvent"in window,be=null;ia&&"documentMode"in document&&(be=document.documentMode);var ce=ia&&"TextEvent"in window&&!be,de=ia&&(!ae||be&&8<be&&11>=be),ee=String.fromCharCode(32),fe=!1;
function ge(a,b){switch(a){case "keyup":return-1!==$d.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "focusout":return!0;default:return!1}}function he(a){a=a.detail;return"object"===typeof a&&"data"in a?a.data:null}var ie=!1;function je(a,b){switch(a){case "compositionend":return he(b);case "keypress":if(32!==b.which)return null;fe=!0;return ee;case "textInput":return a=b.data,a===ee&&fe?null:a;default:return null}}
function ke(a,b){if(ie)return"compositionend"===a||!ae&&ge(a,b)?(a=nd(),md=ld=kd=null,ie=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;case "compositionend":return de&&"ko"!==b.locale?null:b.data;default:return null}}
var le={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function me(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!le[a.type]:"textarea"===b?!0:!1}function ne(a,b,c,d){Eb(d);b=oe(b,"onChange");0<b.length&&(c=new td("onChange","change",null,c,d),a.push({event:c,listeners:b}))}var pe=null,qe=null;function re(a){se(a,0)}function te(a){var b=ue(a);if(Wa(b))return a}
function ve(a,b){if("change"===a)return b}var we=!1;if(ia){var xe;if(ia){var ye="oninput"in document;if(!ye){var ze=document.createElement("div");ze.setAttribute("oninput","return;");ye="function"===typeof ze.oninput}xe=ye}else xe=!1;we=xe&&(!document.documentMode||9<document.documentMode)}function Ae(){pe&&(pe.detachEvent("onpropertychange",Be),qe=pe=null)}function Be(a){if("value"===a.propertyName&&te(qe)){var b=[];ne(b,qe,a,xb(a));Jb(re,b)}}
function Ce(a,b,c){"focusin"===a?(Ae(),pe=b,qe=c,pe.attachEvent("onpropertychange",Be)):"focusout"===a&&Ae()}function De(a){if("selectionchange"===a||"keyup"===a||"keydown"===a)return te(qe)}function Ee(a,b){if("click"===a)return te(b)}function Fe(a,b){if("input"===a||"change"===a)return te(b)}function Ge(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}var He="function"===typeof Object.is?Object.is:Ge;
function Ie(a,b){if(He(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++){var e=c[d];if(!ja.call(b,e)||!He(a[e],b[e]))return!1}return!0}function Je(a){for(;a&&a.firstChild;)a=a.firstChild;return a}
function Ke(a,b){var c=Je(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=Je(c)}}function Le(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?Le(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}
function Me(){for(var a=window,b=Xa();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=Xa(a.document)}return b}function Ne(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}
function Oe(a){var b=Me(),c=a.focusedElem,d=a.selectionRange;if(b!==c&&c&&c.ownerDocument&&Le(c.ownerDocument.documentElement,c)){if(null!==d&&Ne(c))if(b=d.start,a=d.end,void 0===a&&(a=b),"selectionStart"in c)c.selectionStart=b,c.selectionEnd=Math.min(a,c.value.length);else if(a=(b=c.ownerDocument||document)&&b.defaultView||window,a.getSelection){a=a.getSelection();var e=c.textContent.length,f=Math.min(d.start,e);d=void 0===d.end?f:Math.min(d.end,e);!a.extend&&f>d&&(e=d,d=f,f=e);e=Ke(c,f);var g=Ke(c,
d);e&&g&&(1!==a.rangeCount||a.anchorNode!==e.node||a.anchorOffset!==e.offset||a.focusNode!==g.node||a.focusOffset!==g.offset)&&(b=b.createRange(),b.setStart(e.node,e.offset),a.removeAllRanges(),f>d?(a.addRange(b),a.extend(g.node,g.offset)):(b.setEnd(g.node,g.offset),a.addRange(b)))}b=[];for(a=c;a=a.parentNode;)1===a.nodeType&&b.push({element:a,left:a.scrollLeft,top:a.scrollTop});"function"===typeof c.focus&&c.focus();for(c=0;c<b.length;c++)a=b[c],a.element.scrollLeft=a.left,a.element.scrollTop=a.top}}
var Pe=ia&&"documentMode"in document&&11>=document.documentMode,Qe=null,Re=null,Se=null,Te=!1;
function Ue(a,b,c){var d=c.window===c?c.document:9===c.nodeType?c:c.ownerDocument;Te||null==Qe||Qe!==Xa(d)||(d=Qe,"selectionStart"in d&&Ne(d)?d={start:d.selectionStart,end:d.selectionEnd}:(d=(d.ownerDocument&&d.ownerDocument.defaultView||window).getSelection(),d={anchorNode:d.anchorNode,anchorOffset:d.anchorOffset,focusNode:d.focusNode,focusOffset:d.focusOffset}),Se&&Ie(Se,d)||(Se=d,d=oe(Re,"onSelect"),0<d.length&&(b=new td("onSelect","select",null,b,c),a.push({event:b,listeners:d}),b.target=Qe)))}
function Ve(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}var We={animationend:Ve("Animation","AnimationEnd"),animationiteration:Ve("Animation","AnimationIteration"),animationstart:Ve("Animation","AnimationStart"),transitionend:Ve("Transition","TransitionEnd")},Xe={},Ye={};
ia&&(Ye=document.createElement("div").style,"AnimationEvent"in window||(delete We.animationend.animation,delete We.animationiteration.animation,delete We.animationstart.animation),"TransitionEvent"in window||delete We.transitionend.transition);function Ze(a){if(Xe[a])return Xe[a];if(!We[a])return a;var b=We[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Ye)return Xe[a]=b[c];return a}var $e=Ze("animationend"),af=Ze("animationiteration"),bf=Ze("animationstart"),cf=Ze("transitionend"),df=new Map,ef="abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
function ff(a,b){df.set(a,b);fa(b,[a])}for(var gf=0;gf<ef.length;gf++){var hf=ef[gf],jf=hf.toLowerCase(),kf=hf[0].toUpperCase()+hf.slice(1);ff(jf,"on"+kf)}ff($e,"onAnimationEnd");ff(af,"onAnimationIteration");ff(bf,"onAnimationStart");ff("dblclick","onDoubleClick");ff("focusin","onFocus");ff("focusout","onBlur");ff(cf,"onTransitionEnd");ha("onMouseEnter",["mouseout","mouseover"]);ha("onMouseLeave",["mouseout","mouseover"]);ha("onPointerEnter",["pointerout","pointerover"]);
ha("onPointerLeave",["pointerout","pointerover"]);fa("onChange","change click focusin focusout input keydown keyup selectionchange".split(" "));fa("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));fa("onBeforeInput",["compositionend","keypress","textInput","paste"]);fa("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" "));fa("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" "));
fa("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var lf="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),mf=new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));
function nf(a,b,c){var d=a.type||"unknown-event";a.currentTarget=c;Ub(d,b,void 0,a);a.currentTarget=null}
function se(a,b){b=0!==(b&4);for(var c=0;c<a.length;c++){var d=a[c],e=d.event;d=d.listeners;a:{var f=void 0;if(b)for(var g=d.length-1;0<=g;g--){var h=d[g],k=h.instance,l=h.currentTarget;h=h.listener;if(k!==f&&e.isPropagationStopped())break a;nf(e,h,l);f=k}else for(g=0;g<d.length;g++){h=d[g];k=h.instance;l=h.currentTarget;h=h.listener;if(k!==f&&e.isPropagationStopped())break a;nf(e,h,l);f=k}}}if(Qb)throw a=Rb,Qb=!1,Rb=null,a;}
function D(a,b){var c=b[of];void 0===c&&(c=b[of]=new Set);var d=a+"__bubble";c.has(d)||(pf(b,a,2,!1),c.add(d))}function qf(a,b,c){var d=0;b&&(d|=4);pf(c,a,d,b)}var rf="_reactListening"+Math.random().toString(36).slice(2);function sf(a){if(!a[rf]){a[rf]=!0;da.forEach(function(b){"selectionchange"!==b&&(mf.has(b)||qf(b,!1,a),qf(b,!0,a))});var b=9===a.nodeType?a:a.ownerDocument;null===b||b[rf]||(b[rf]=!0,qf("selectionchange",!1,b))}}
function pf(a,b,c,d){switch(jd(b)){case 1:var e=ed;break;case 4:e=gd;break;default:e=fd}c=e.bind(null,b,c,a);e=void 0;!Lb||"touchstart"!==b&&"touchmove"!==b&&"wheel"!==b||(e=!0);d?void 0!==e?a.addEventListener(b,c,{capture:!0,passive:e}):a.addEventListener(b,c,!0):void 0!==e?a.addEventListener(b,c,{passive:e}):a.addEventListener(b,c,!1)}
function hd(a,b,c,d,e){var f=d;if(0===(b&1)&&0===(b&2)&&null!==d)a:for(;;){if(null===d)return;var g=d.tag;if(3===g||4===g){var h=d.stateNode.containerInfo;if(h===e||8===h.nodeType&&h.parentNode===e)break;if(4===g)for(g=d.return;null!==g;){var k=g.tag;if(3===k||4===k)if(k=g.stateNode.containerInfo,k===e||8===k.nodeType&&k.parentNode===e)return;g=g.return}for(;null!==h;){g=Wc(h);if(null===g)return;k=g.tag;if(5===k||6===k){d=f=g;continue a}h=h.parentNode}}d=d.return}Jb(function(){var d=f,e=xb(c),g=[];
a:{var h=df.get(a);if(void 0!==h){var k=td,n=a;switch(a){case "keypress":if(0===od(c))break a;case "keydown":case "keyup":k=Rd;break;case "focusin":n="focus";k=Fd;break;case "focusout":n="blur";k=Fd;break;case "beforeblur":case "afterblur":k=Fd;break;case "click":if(2===c.button)break a;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":k=Bd;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":k=
Dd;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":k=Vd;break;case $e:case af:case bf:k=Hd;break;case cf:k=Xd;break;case "scroll":k=vd;break;case "wheel":k=Zd;break;case "copy":case "cut":case "paste":k=Jd;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":k=Td}var t=0!==(b&4),J=!t&&"scroll"===a,x=t?null!==h?h+"Capture":null:h;t=[];for(var w=d,u;null!==
w;){u=w;var F=u.stateNode;5===u.tag&&null!==F&&(u=F,null!==x&&(F=Kb(w,x),null!=F&&t.push(tf(w,F,u))));if(J)break;w=w.return}0<t.length&&(h=new k(h,n,null,c,e),g.push({event:h,listeners:t}))}}if(0===(b&7)){a:{h="mouseover"===a||"pointerover"===a;k="mouseout"===a||"pointerout"===a;if(h&&c!==wb&&(n=c.relatedTarget||c.fromElement)&&(Wc(n)||n[uf]))break a;if(k||h){h=e.window===e?e:(h=e.ownerDocument)?h.defaultView||h.parentWindow:window;if(k){if(n=c.relatedTarget||c.toElement,k=d,n=n?Wc(n):null,null!==
n&&(J=Vb(n),n!==J||5!==n.tag&&6!==n.tag))n=null}else k=null,n=d;if(k!==n){t=Bd;F="onMouseLeave";x="onMouseEnter";w="mouse";if("pointerout"===a||"pointerover"===a)t=Td,F="onPointerLeave",x="onPointerEnter",w="pointer";J=null==k?h:ue(k);u=null==n?h:ue(n);h=new t(F,w+"leave",k,c,e);h.target=J;h.relatedTarget=u;F=null;Wc(e)===d&&(t=new t(x,w+"enter",n,c,e),t.target=u,t.relatedTarget=J,F=t);J=F;if(k&&n)b:{t=k;x=n;w=0;for(u=t;u;u=vf(u))w++;u=0;for(F=x;F;F=vf(F))u++;for(;0<w-u;)t=vf(t),w--;for(;0<u-w;)x=
vf(x),u--;for(;w--;){if(t===x||null!==x&&t===x.alternate)break b;t=vf(t);x=vf(x)}t=null}else t=null;null!==k&&wf(g,h,k,t,!1);null!==n&&null!==J&&wf(g,J,n,t,!0)}}}a:{h=d?ue(d):window;k=h.nodeName&&h.nodeName.toLowerCase();if("select"===k||"input"===k&&"file"===h.type)var na=ve;else if(me(h))if(we)na=Fe;else{na=De;var xa=Ce}else(k=h.nodeName)&&"input"===k.toLowerCase()&&("checkbox"===h.type||"radio"===h.type)&&(na=Ee);if(na&&(na=na(a,d))){ne(g,na,c,e);break a}xa&&xa(a,h,d);"focusout"===a&&(xa=h._wrapperState)&&
xa.controlled&&"number"===h.type&&cb(h,"number",h.value)}xa=d?ue(d):window;switch(a){case "focusin":if(me(xa)||"true"===xa.contentEditable)Qe=xa,Re=d,Se=null;break;case "focusout":Se=Re=Qe=null;break;case "mousedown":Te=!0;break;case "contextmenu":case "mouseup":case "dragend":Te=!1;Ue(g,c,e);break;case "selectionchange":if(Pe)break;case "keydown":case "keyup":Ue(g,c,e)}var $a;if(ae)b:{switch(a){case "compositionstart":var ba="onCompositionStart";break b;case "compositionend":ba="onCompositionEnd";
break b;case "compositionupdate":ba="onCompositionUpdate";break b}ba=void 0}else ie?ge(a,c)&&(ba="onCompositionEnd"):"keydown"===a&&229===c.keyCode&&(ba="onCompositionStart");ba&&(de&&"ko"!==c.locale&&(ie||"onCompositionStart"!==ba?"onCompositionEnd"===ba&&ie&&($a=nd()):(kd=e,ld="value"in kd?kd.value:kd.textContent,ie=!0)),xa=oe(d,ba),0<xa.length&&(ba=new Ld(ba,a,null,c,e),g.push({event:ba,listeners:xa}),$a?ba.data=$a:($a=he(c),null!==$a&&(ba.data=$a))));if($a=ce?je(a,c):ke(a,c))d=oe(d,"onBeforeInput"),
0<d.length&&(e=new Ld("onBeforeInput","beforeinput",null,c,e),g.push({event:e,listeners:d}),e.data=$a)}se(g,b)})}function tf(a,b,c){return{instance:a,listener:b,currentTarget:c}}function oe(a,b){for(var c=b+"Capture",d=[];null!==a;){var e=a,f=e.stateNode;5===e.tag&&null!==f&&(e=f,f=Kb(a,c),null!=f&&d.unshift(tf(a,f,e)),f=Kb(a,b),null!=f&&d.push(tf(a,f,e)));a=a.return}return d}function vf(a){if(null===a)return null;do a=a.return;while(a&&5!==a.tag);return a?a:null}
function wf(a,b,c,d,e){for(var f=b._reactName,g=[];null!==c&&c!==d;){var h=c,k=h.alternate,l=h.stateNode;if(null!==k&&k===d)break;5===h.tag&&null!==l&&(h=l,e?(k=Kb(c,f),null!=k&&g.unshift(tf(c,k,h))):e||(k=Kb(c,f),null!=k&&g.push(tf(c,k,h))));c=c.return}0!==g.length&&a.push({event:b,listeners:g})}var xf=/\r\n?/g,yf=/\u0000|\uFFFD/g;function zf(a){return("string"===typeof a?a:""+a).replace(xf,"\n").replace(yf,"")}function Af(a,b,c){b=zf(b);if(zf(a)!==b&&c)throw Error(p(425));}function Bf(){}
var Cf=null,Df=null;function Ef(a,b){return"textarea"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}
var Ff="function"===typeof setTimeout?setTimeout:void 0,Gf="function"===typeof clearTimeout?clearTimeout:void 0,Hf="function"===typeof Promise?Promise:void 0,Jf="function"===typeof queueMicrotask?queueMicrotask:"undefined"!==typeof Hf?function(a){return Hf.resolve(null).then(a).catch(If)}:Ff;function If(a){setTimeout(function(){throw a;})}
function Kf(a,b){var c=b,d=0;do{var e=c.nextSibling;a.removeChild(c);if(e&&8===e.nodeType)if(c=e.data,"/$"===c){if(0===d){a.removeChild(e);bd(b);return}d--}else"$"!==c&&"$?"!==c&&"$!"!==c||d++;c=e}while(c);bd(b)}function Lf(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break;if(8===b){b=a.data;if("$"===b||"$!"===b||"$?"===b)break;if("/$"===b)return null}}return a}
function Mf(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if("$"===c||"$!"===c||"$?"===c){if(0===b)return a;b--}else"/$"===c&&b++}a=a.previousSibling}return null}var Nf=Math.random().toString(36).slice(2),Of="__reactFiber$"+Nf,Pf="__reactProps$"+Nf,uf="__reactContainer$"+Nf,of="__reactEvents$"+Nf,Qf="__reactListeners$"+Nf,Rf="__reactHandles$"+Nf;
function Wc(a){var b=a[Of];if(b)return b;for(var c=a.parentNode;c;){if(b=c[uf]||c[Of]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=Mf(a);null!==a;){if(c=a[Of])return c;a=Mf(a)}return b}a=c;c=a.parentNode}return null}function Cb(a){a=a[Of]||a[uf];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function ue(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(p(33));}function Db(a){return a[Pf]||null}var Sf=[],Tf=-1;function Uf(a){return{current:a}}
function E(a){0>Tf||(a.current=Sf[Tf],Sf[Tf]=null,Tf--)}function G(a,b){Tf++;Sf[Tf]=a.current;a.current=b}var Vf={},H=Uf(Vf),Wf=Uf(!1),Xf=Vf;function Yf(a,b){var c=a.type.contextTypes;if(!c)return Vf;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}
function Zf(a){a=a.childContextTypes;return null!==a&&void 0!==a}function $f(){E(Wf);E(H)}function ag(a,b,c){if(H.current!==Vf)throw Error(p(168));G(H,b);G(Wf,c)}function bg(a,b,c){var d=a.stateNode;b=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in b))throw Error(p(108,Ra(a)||"Unknown",e));return A({},c,d)}
function cg(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Vf;Xf=H.current;G(H,a);G(Wf,Wf.current);return!0}function dg(a,b,c){var d=a.stateNode;if(!d)throw Error(p(169));c?(a=bg(a,b,Xf),d.__reactInternalMemoizedMergedChildContext=a,E(Wf),E(H),G(H,a)):E(Wf);G(Wf,c)}var eg=null,fg=!1,gg=!1;function hg(a){null===eg?eg=[a]:eg.push(a)}function ig(a){fg=!0;hg(a)}
function jg(){if(!gg&&null!==eg){gg=!0;var a=0,b=C;try{var c=eg;for(C=1;a<c.length;a++){var d=c[a];do d=d(!0);while(null!==d)}eg=null;fg=!1}catch(e){throw null!==eg&&(eg=eg.slice(a+1)),ac(fc,jg),e;}finally{C=b,gg=!1}}return null}var kg=[],lg=0,mg=null,ng=0,og=[],pg=0,qg=null,rg=1,sg="";function tg(a,b){kg[lg++]=ng;kg[lg++]=mg;mg=a;ng=b}
function ug(a,b,c){og[pg++]=rg;og[pg++]=sg;og[pg++]=qg;qg=a;var d=rg;a=sg;var e=32-oc(d)-1;d&=~(1<<e);c+=1;var f=32-oc(b)+e;if(30<f){var g=e-e%5;f=(d&(1<<g)-1).toString(32);d>>=g;e-=g;rg=1<<32-oc(b)+e|c<<e|d;sg=f+a}else rg=1<<f|c<<e|d,sg=a}function vg(a){null!==a.return&&(tg(a,1),ug(a,1,0))}function wg(a){for(;a===mg;)mg=kg[--lg],kg[lg]=null,ng=kg[--lg],kg[lg]=null;for(;a===qg;)qg=og[--pg],og[pg]=null,sg=og[--pg],og[pg]=null,rg=og[--pg],og[pg]=null}var xg=null,yg=null,I=!1,zg=null;
function Ag(a,b){var c=Bg(5,null,null,0);c.elementType="DELETED";c.stateNode=b;c.return=a;b=a.deletions;null===b?(a.deletions=[c],a.flags|=16):b.push(c)}
function Cg(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,xg=a,yg=Lf(b.firstChild),!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?null:b,null!==b?(a.stateNode=b,xg=a,yg=null,!0):!1;case 13:return b=8!==b.nodeType?null:b,null!==b?(c=null!==qg?{id:rg,overflow:sg}:null,a.memoizedState={dehydrated:b,treeContext:c,retryLane:1073741824},c=Bg(18,null,null,0),c.stateNode=b,c.return=a,a.child=c,xg=a,yg=
null,!0):!1;default:return!1}}function Dg(a){return 0!==(a.mode&1)&&0===(a.flags&128)}function Eg(a){if(I){var b=yg;if(b){var c=b;if(!Cg(a,b)){if(Dg(a))throw Error(p(418));b=Lf(c.nextSibling);var d=xg;b&&Cg(a,b)?Ag(d,c):(a.flags=a.flags&-4097|2,I=!1,xg=a)}}else{if(Dg(a))throw Error(p(418));a.flags=a.flags&-4097|2;I=!1;xg=a}}}function Fg(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;xg=a}
function Gg(a){if(a!==xg)return!1;if(!I)return Fg(a),I=!0,!1;var b;(b=3!==a.tag)&&!(b=5!==a.tag)&&(b=a.type,b="head"!==b&&"body"!==b&&!Ef(a.type,a.memoizedProps));if(b&&(b=yg)){if(Dg(a))throw Hg(),Error(p(418));for(;b;)Ag(a,b),b=Lf(b.nextSibling)}Fg(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(p(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if("/$"===c){if(0===b){yg=Lf(a.nextSibling);break a}b--}else"$"!==c&&"$!"!==c&&"$?"!==c||b++}a=a.nextSibling}yg=
null}}else yg=xg?Lf(a.stateNode.nextSibling):null;return!0}function Hg(){for(var a=yg;a;)a=Lf(a.nextSibling)}function Ig(){yg=xg=null;I=!1}function Jg(a){null===zg?zg=[a]:zg.push(a)}var Kg=ua.ReactCurrentBatchConfig;function Lg(a,b){if(a&&a.defaultProps){b=A({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c]);return b}return b}var Mg=Uf(null),Ng=null,Og=null,Pg=null;function Qg(){Pg=Og=Ng=null}function Rg(a){var b=Mg.current;E(Mg);a._currentValue=b}
function Sg(a,b,c){for(;null!==a;){var d=a.alternate;(a.childLanes&b)!==b?(a.childLanes|=b,null!==d&&(d.childLanes|=b)):null!==d&&(d.childLanes&b)!==b&&(d.childLanes|=b);if(a===c)break;a=a.return}}function Tg(a,b){Ng=a;Pg=Og=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(0!==(a.lanes&b)&&(Ug=!0),a.firstContext=null)}
function Vg(a){var b=a._currentValue;if(Pg!==a)if(a={context:a,memoizedValue:b,next:null},null===Og){if(null===Ng)throw Error(p(308));Og=a;Ng.dependencies={lanes:0,firstContext:a}}else Og=Og.next=a;return b}var Wg=null;function Xg(a){null===Wg?Wg=[a]:Wg.push(a)}function Yg(a,b,c,d){var e=b.interleaved;null===e?(c.next=c,Xg(b)):(c.next=e.next,e.next=c);b.interleaved=c;return Zg(a,d)}
function Zg(a,b){a.lanes|=b;var c=a.alternate;null!==c&&(c.lanes|=b);c=a;for(a=a.return;null!==a;)a.childLanes|=b,c=a.alternate,null!==c&&(c.childLanes|=b),c=a,a=a.return;return 3===c.tag?c.stateNode:null}var $g=!1;function ah(a){a.updateQueue={baseState:a.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,interleaved:null,lanes:0},effects:null}}
function bh(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,firstBaseUpdate:a.firstBaseUpdate,lastBaseUpdate:a.lastBaseUpdate,shared:a.shared,effects:a.effects})}function ch(a,b){return{eventTime:a,lane:b,tag:0,payload:null,callback:null,next:null}}
function dh(a,b,c){var d=a.updateQueue;if(null===d)return null;d=d.shared;if(0!==(K&2)){var e=d.pending;null===e?b.next=b:(b.next=e.next,e.next=b);d.pending=b;return Zg(a,c)}e=d.interleaved;null===e?(b.next=b,Xg(d)):(b.next=e.next,e.next=b);d.interleaved=b;return Zg(a,c)}function eh(a,b,c){b=b.updateQueue;if(null!==b&&(b=b.shared,0!==(c&4194240))){var d=b.lanes;d&=a.pendingLanes;c|=d;b.lanes=c;Cc(a,c)}}
function fh(a,b){var c=a.updateQueue,d=a.alternate;if(null!==d&&(d=d.updateQueue,c===d)){var e=null,f=null;c=c.firstBaseUpdate;if(null!==c){do{var g={eventTime:c.eventTime,lane:c.lane,tag:c.tag,payload:c.payload,callback:c.callback,next:null};null===f?e=f=g:f=f.next=g;c=c.next}while(null!==c);null===f?e=f=b:f=f.next=b}else e=f=b;c={baseState:d.baseState,firstBaseUpdate:e,lastBaseUpdate:f,shared:d.shared,effects:d.effects};a.updateQueue=c;return}a=c.lastBaseUpdate;null===a?c.firstBaseUpdate=b:a.next=
b;c.lastBaseUpdate=b}
function gh(a,b,c,d){var e=a.updateQueue;$g=!1;var f=e.firstBaseUpdate,g=e.lastBaseUpdate,h=e.shared.pending;if(null!==h){e.shared.pending=null;var k=h,l=k.next;k.next=null;null===g?f=l:g.next=l;g=k;var m=a.alternate;null!==m&&(m=m.updateQueue,h=m.lastBaseUpdate,h!==g&&(null===h?m.firstBaseUpdate=l:h.next=l,m.lastBaseUpdate=k))}if(null!==f){var q=e.baseState;g=0;m=l=k=null;h=f;do{var r=h.lane,y=h.eventTime;if((d&r)===r){null!==m&&(m=m.next={eventTime:y,lane:0,tag:h.tag,payload:h.payload,callback:h.callback,
next:null});a:{var n=a,t=h;r=b;y=c;switch(t.tag){case 1:n=t.payload;if("function"===typeof n){q=n.call(y,q,r);break a}q=n;break a;case 3:n.flags=n.flags&-65537|128;case 0:n=t.payload;r="function"===typeof n?n.call(y,q,r):n;if(null===r||void 0===r)break a;q=A({},q,r);break a;case 2:$g=!0}}null!==h.callback&&0!==h.lane&&(a.flags|=64,r=e.effects,null===r?e.effects=[h]:r.push(h))}else y={eventTime:y,lane:r,tag:h.tag,payload:h.payload,callback:h.callback,next:null},null===m?(l=m=y,k=q):m=m.next=y,g|=r;
h=h.next;if(null===h)if(h=e.shared.pending,null===h)break;else r=h,h=r.next,r.next=null,e.lastBaseUpdate=r,e.shared.pending=null}while(1);null===m&&(k=q);e.baseState=k;e.firstBaseUpdate=l;e.lastBaseUpdate=m;b=e.shared.interleaved;if(null!==b){e=b;do g|=e.lane,e=e.next;while(e!==b)}else null===f&&(e.shared.lanes=0);hh|=g;a.lanes=g;a.memoizedState=q}}
function ih(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=c;if("function"!==typeof e)throw Error(p(191,e));e.call(d)}}}var jh=(new aa.Component).refs;function kh(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:A({},b,c);a.memoizedState=c;0===a.lanes&&(a.updateQueue.baseState=c)}
var nh={isMounted:function(a){return(a=a._reactInternals)?Vb(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternals;var d=L(),e=lh(a),f=ch(d,e);f.payload=b;void 0!==c&&null!==c&&(f.callback=c);b=dh(a,f,e);null!==b&&(mh(b,a,e,d),eh(b,a,e))},enqueueReplaceState:function(a,b,c){a=a._reactInternals;var d=L(),e=lh(a),f=ch(d,e);f.tag=1;f.payload=b;void 0!==c&&null!==c&&(f.callback=c);b=dh(a,f,e);null!==b&&(mh(b,a,e,d),eh(b,a,e))},enqueueForceUpdate:function(a,b){a=a._reactInternals;var c=L(),d=
lh(a),e=ch(c,d);e.tag=2;void 0!==b&&null!==b&&(e.callback=b);b=dh(a,e,d);null!==b&&(mh(b,a,d,c),eh(b,a,d))}};function oh(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,f,g):b.prototype&&b.prototype.isPureReactComponent?!Ie(c,d)||!Ie(e,f):!0}
function ph(a,b,c){var d=!1,e=Vf;var f=b.contextType;"object"===typeof f&&null!==f?f=Vg(f):(e=Zf(b)?Xf:H.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?Yf(a,e):Vf);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=nh;a.stateNode=b;b._reactInternals=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}
function qh(a,b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&nh.enqueueReplaceState(b,b.state,null)}
function rh(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=jh;ah(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=Vg(f):(f=Zf(b)?Xf:H.current,e.context=Yf(a,f));e.state=a.memoizedState;f=b.getDerivedStateFromProps;"function"===typeof f&&(kh(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||(b=e.state,
"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&nh.enqueueReplaceState(e,e.state,null),gh(a,c,e,d),e.state=a.memoizedState);"function"===typeof e.componentDidMount&&(a.flags|=4194308)}
function sh(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(p(309));var d=c.stateNode}if(!d)throw Error(p(147,a));var e=d,f=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===f)return b.ref;b=function(a){var b=e.refs;b===jh&&(b=e.refs={});null===a?delete b[f]:b[f]=a};b._stringRef=f;return b}if("string"!==typeof a)throw Error(p(284));if(!c._owner)throw Error(p(290,a));}return a}
function th(a,b){a=Object.prototype.toString.call(b);throw Error(p(31,"[object Object]"===a?"object with keys {"+Object.keys(b).join(", ")+"}":a));}function uh(a){var b=a._init;return b(a._payload)}
function vh(a){function b(b,c){if(a){var d=b.deletions;null===d?(b.deletions=[c],b.flags|=16):d.push(c)}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,b),b=b.sibling;return a}function e(a,b){a=wh(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return b.flags|=1048576,c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.flags|=2,c):d;b.flags|=2;return c}function g(b){a&&
null===b.alternate&&(b.flags|=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=xh(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function k(a,b,c,d){var f=c.type;if(f===ya)return m(a,b,c.props.children,d,c.key);if(null!==b&&(b.elementType===f||"object"===typeof f&&null!==f&&f.$$typeof===Ha&&uh(f)===b.type))return d=e(b,c.props),d.ref=sh(a,b,c),d.return=a,d;d=yh(c.type,c.key,c.props,null,a.mode,d);d.ref=sh(a,b,c);d.return=a;return d}function l(a,b,c,d){if(null===b||4!==b.tag||
b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=zh(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function m(a,b,c,d,f){if(null===b||7!==b.tag)return b=Ah(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function q(a,b,c){if("string"===typeof b&&""!==b||"number"===typeof b)return b=xh(""+b,a.mode,c),b.return=a,b;if("object"===typeof b&&null!==b){switch(b.$$typeof){case va:return c=yh(b.type,b.key,b.props,null,a.mode,c),
c.ref=sh(a,null,b),c.return=a,c;case wa:return b=zh(b,a.mode,c),b.return=a,b;case Ha:var d=b._init;return q(a,d(b._payload),c)}if(eb(b)||Ka(b))return b=Ah(b,a.mode,c,null),b.return=a,b;th(a,b)}return null}function r(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c&&""!==c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case va:return c.key===e?k(a,b,c,d):null;case wa:return c.key===e?l(a,b,c,d):null;case Ha:return e=c._init,r(a,
b,e(c._payload),d)}if(eb(c)||Ka(c))return null!==e?null:m(a,b,c,d,null);th(a,c)}return null}function y(a,b,c,d,e){if("string"===typeof d&&""!==d||"number"===typeof d)return a=a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case va:return a=a.get(null===d.key?c:d.key)||null,k(b,a,d,e);case wa:return a=a.get(null===d.key?c:d.key)||null,l(b,a,d,e);case Ha:var f=d._init;return y(a,b,c,f(d._payload),e)}if(eb(d)||Ka(d))return a=a.get(c)||null,m(b,a,d,e,null);th(b,d)}return null}
function n(e,g,h,k){for(var l=null,m=null,u=g,w=g=0,x=null;null!==u&&w<h.length;w++){u.index>w?(x=u,u=null):x=u.sibling;var n=r(e,u,h[w],k);if(null===n){null===u&&(u=x);break}a&&u&&null===n.alternate&&b(e,u);g=f(n,g,w);null===m?l=n:m.sibling=n;m=n;u=x}if(w===h.length)return c(e,u),I&&tg(e,w),l;if(null===u){for(;w<h.length;w++)u=q(e,h[w],k),null!==u&&(g=f(u,g,w),null===m?l=u:m.sibling=u,m=u);I&&tg(e,w);return l}for(u=d(e,u);w<h.length;w++)x=y(u,e,w,h[w],k),null!==x&&(a&&null!==x.alternate&&u.delete(null===
x.key?w:x.key),g=f(x,g,w),null===m?l=x:m.sibling=x,m=x);a&&u.forEach(function(a){return b(e,a)});I&&tg(e,w);return l}function t(e,g,h,k){var l=Ka(h);if("function"!==typeof l)throw Error(p(150));h=l.call(h);if(null==h)throw Error(p(151));for(var u=l=null,m=g,w=g=0,x=null,n=h.next();null!==m&&!n.done;w++,n=h.next()){m.index>w?(x=m,m=null):x=m.sibling;var t=r(e,m,n.value,k);if(null===t){null===m&&(m=x);break}a&&m&&null===t.alternate&&b(e,m);g=f(t,g,w);null===u?l=t:u.sibling=t;u=t;m=x}if(n.done)return c(e,
m),I&&tg(e,w),l;if(null===m){for(;!n.done;w++,n=h.next())n=q(e,n.value,k),null!==n&&(g=f(n,g,w),null===u?l=n:u.sibling=n,u=n);I&&tg(e,w);return l}for(m=d(e,m);!n.done;w++,n=h.next())n=y(m,e,w,n.value,k),null!==n&&(a&&null!==n.alternate&&m.delete(null===n.key?w:n.key),g=f(n,g,w),null===u?l=n:u.sibling=n,u=n);a&&m.forEach(function(a){return b(e,a)});I&&tg(e,w);return l}function J(a,d,f,h){"object"===typeof f&&null!==f&&f.type===ya&&null===f.key&&(f=f.props.children);if("object"===typeof f&&null!==f){switch(f.$$typeof){case va:a:{for(var k=
f.key,l=d;null!==l;){if(l.key===k){k=f.type;if(k===ya){if(7===l.tag){c(a,l.sibling);d=e(l,f.props.children);d.return=a;a=d;break a}}else if(l.elementType===k||"object"===typeof k&&null!==k&&k.$$typeof===Ha&&uh(k)===l.type){c(a,l.sibling);d=e(l,f.props);d.ref=sh(a,l,f);d.return=a;a=d;break a}c(a,l);break}else b(a,l);l=l.sibling}f.type===ya?(d=Ah(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=yh(f.type,f.key,f.props,null,a.mode,h),h.ref=sh(a,d,f),h.return=a,a=h)}return g(a);case wa:a:{for(l=f.key;null!==
d;){if(d.key===l)if(4===d.tag&&d.stateNode.containerInfo===f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=zh(f,a.mode,h);d.return=a;a=d}return g(a);case Ha:return l=f._init,J(a,d,l(f._payload),h)}if(eb(f))return n(a,d,f,h);if(Ka(f))return t(a,d,f,h);th(a,f)}return"string"===typeof f&&""!==f||"number"===typeof f?(f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):
(c(a,d),d=xh(f,a.mode,h),d.return=a,a=d),g(a)):c(a,d)}return J}var Bh=vh(!0),Ch=vh(!1),Dh={},Eh=Uf(Dh),Fh=Uf(Dh),Gh=Uf(Dh);function Hh(a){if(a===Dh)throw Error(p(174));return a}function Ih(a,b){G(Gh,b);G(Fh,a);G(Eh,Dh);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:lb(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=lb(b,a)}E(Eh);G(Eh,b)}function Jh(){E(Eh);E(Fh);E(Gh)}
function Kh(a){Hh(Gh.current);var b=Hh(Eh.current);var c=lb(b,a.type);b!==c&&(G(Fh,a),G(Eh,c))}function Lh(a){Fh.current===a&&(E(Eh),E(Fh))}var M=Uf(0);
function Mh(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||"$?"===c.data||"$!"===c.data))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.flags&128))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}var Nh=[];
function Oh(){for(var a=0;a<Nh.length;a++)Nh[a]._workInProgressVersionPrimary=null;Nh.length=0}var Ph=ua.ReactCurrentDispatcher,Qh=ua.ReactCurrentBatchConfig,Rh=0,N=null,O=null,P=null,Sh=!1,Th=!1,Uh=0,Vh=0;function Q(){throw Error(p(321));}function Wh(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!He(a[c],b[c]))return!1;return!0}
function Xh(a,b,c,d,e,f){Rh=f;N=b;b.memoizedState=null;b.updateQueue=null;b.lanes=0;Ph.current=null===a||null===a.memoizedState?Yh:Zh;a=c(d,e);if(Th){f=0;do{Th=!1;Uh=0;if(25<=f)throw Error(p(301));f+=1;P=O=null;b.updateQueue=null;Ph.current=$h;a=c(d,e)}while(Th)}Ph.current=ai;b=null!==O&&null!==O.next;Rh=0;P=O=N=null;Sh=!1;if(b)throw Error(p(300));return a}function bi(){var a=0!==Uh;Uh=0;return a}
function ci(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===P?N.memoizedState=P=a:P=P.next=a;return P}function di(){if(null===O){var a=N.alternate;a=null!==a?a.memoizedState:null}else a=O.next;var b=null===P?N.memoizedState:P.next;if(null!==b)P=b,O=a;else{if(null===a)throw Error(p(310));O=a;a={memoizedState:O.memoizedState,baseState:O.baseState,baseQueue:O.baseQueue,queue:O.queue,next:null};null===P?N.memoizedState=P=a:P=P.next=a}return P}
function ei(a,b){return"function"===typeof b?b(a):b}
function fi(a){var b=di(),c=b.queue;if(null===c)throw Error(p(311));c.lastRenderedReducer=a;var d=O,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){f=e.next;d=d.baseState;var h=g=null,k=null,l=f;do{var m=l.lane;if((Rh&m)===m)null!==k&&(k=k.next={lane:0,action:l.action,hasEagerState:l.hasEagerState,eagerState:l.eagerState,next:null}),d=l.hasEagerState?l.eagerState:a(d,l.action);else{var q={lane:m,action:l.action,hasEagerState:l.hasEagerState,
eagerState:l.eagerState,next:null};null===k?(h=k=q,g=d):k=k.next=q;N.lanes|=m;hh|=m}l=l.next}while(null!==l&&l!==f);null===k?g=d:k.next=h;He(d,b.memoizedState)||(Ug=!0);b.memoizedState=d;b.baseState=g;b.baseQueue=k;c.lastRenderedState=d}a=c.interleaved;if(null!==a){e=a;do f=e.lane,N.lanes|=f,hh|=f,e=e.next;while(e!==a)}else null===e&&(c.lanes=0);return[b.memoizedState,c.dispatch]}
function gi(a){var b=di(),c=b.queue;if(null===c)throw Error(p(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);He(f,b.memoizedState)||(Ug=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}function hi(){}
function ii(a,b){var c=N,d=di(),e=b(),f=!He(d.memoizedState,e);f&&(d.memoizedState=e,Ug=!0);d=d.queue;ji(ki.bind(null,c,d,a),[a]);if(d.getSnapshot!==b||f||null!==P&&P.memoizedState.tag&1){c.flags|=2048;li(9,mi.bind(null,c,d,e,b),void 0,null);if(null===R)throw Error(p(349));0!==(Rh&30)||ni(c,b,e)}return e}function ni(a,b,c){a.flags|=16384;a={getSnapshot:b,value:c};b=N.updateQueue;null===b?(b={lastEffect:null,stores:null},N.updateQueue=b,b.stores=[a]):(c=b.stores,null===c?b.stores=[a]:c.push(a))}
function mi(a,b,c,d){b.value=c;b.getSnapshot=d;oi(b)&&pi(a)}function ki(a,b,c){return c(function(){oi(b)&&pi(a)})}function oi(a){var b=a.getSnapshot;a=a.value;try{var c=b();return!He(a,c)}catch(d){return!0}}function pi(a){var b=Zg(a,1);null!==b&&mh(b,a,1,-1)}
function qi(a){var b=ci();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:ei,lastRenderedState:a};b.queue=a;a=a.dispatch=ri.bind(null,N,a);return[b.memoizedState,a]}
function li(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=N.updateQueue;null===b?(b={lastEffect:null,stores:null},N.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function si(){return di().memoizedState}function ti(a,b,c,d){var e=ci();N.flags|=a;e.memoizedState=li(1|b,c,void 0,void 0===d?null:d)}
function ui(a,b,c,d){var e=di();d=void 0===d?null:d;var f=void 0;if(null!==O){var g=O.memoizedState;f=g.destroy;if(null!==d&&Wh(d,g.deps)){e.memoizedState=li(b,c,f,d);return}}N.flags|=a;e.memoizedState=li(1|b,c,f,d)}function vi(a,b){return ti(8390656,8,a,b)}function ji(a,b){return ui(2048,8,a,b)}function wi(a,b){return ui(4,2,a,b)}function xi(a,b){return ui(4,4,a,b)}
function yi(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function zi(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ui(4,4,yi.bind(null,b,a),c)}function Ai(){}function Bi(a,b){var c=di();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&Wh(b,d[1]))return d[0];c.memoizedState=[a,b];return a}
function Ci(a,b){var c=di();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&Wh(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function Di(a,b,c){if(0===(Rh&21))return a.baseState&&(a.baseState=!1,Ug=!0),a.memoizedState=c;He(c,b)||(c=yc(),N.lanes|=c,hh|=c,a.baseState=!0);return b}function Ei(a,b){var c=C;C=0!==c&&4>c?c:4;a(!0);var d=Qh.transition;Qh.transition={};try{a(!1),b()}finally{C=c,Qh.transition=d}}function Fi(){return di().memoizedState}
function Gi(a,b,c){var d=lh(a);c={lane:d,action:c,hasEagerState:!1,eagerState:null,next:null};if(Hi(a))Ii(b,c);else if(c=Yg(a,b,c,d),null!==c){var e=L();mh(c,a,d,e);Ji(c,b,d)}}
function ri(a,b,c){var d=lh(a),e={lane:d,action:c,hasEagerState:!1,eagerState:null,next:null};if(Hi(a))Ii(b,e);else{var f=a.alternate;if(0===a.lanes&&(null===f||0===f.lanes)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,h=f(g,c);e.hasEagerState=!0;e.eagerState=h;if(He(h,g)){var k=b.interleaved;null===k?(e.next=e,Xg(b)):(e.next=k.next,k.next=e);b.interleaved=e;return}}catch(l){}finally{}c=Yg(a,b,e,d);null!==c&&(e=L(),mh(c,a,d,e),Ji(c,b,d))}}
function Hi(a){var b=a.alternate;return a===N||null!==b&&b===N}function Ii(a,b){Th=Sh=!0;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}function Ji(a,b,c){if(0!==(c&4194240)){var d=b.lanes;d&=a.pendingLanes;c|=d;b.lanes=c;Cc(a,c)}}
var ai={readContext:Vg,useCallback:Q,useContext:Q,useEffect:Q,useImperativeHandle:Q,useInsertionEffect:Q,useLayoutEffect:Q,useMemo:Q,useReducer:Q,useRef:Q,useState:Q,useDebugValue:Q,useDeferredValue:Q,useTransition:Q,useMutableSource:Q,useSyncExternalStore:Q,useId:Q,unstable_isNewReconciler:!1},Yh={readContext:Vg,useCallback:function(a,b){ci().memoizedState=[a,void 0===b?null:b];return a},useContext:Vg,useEffect:vi,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ti(4194308,
4,yi.bind(null,b,a),c)},useLayoutEffect:function(a,b){return ti(4194308,4,a,b)},useInsertionEffect:function(a,b){return ti(4,2,a,b)},useMemo:function(a,b){var c=ci();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=ci();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};d.queue=a;a=a.dispatch=Gi.bind(null,N,a);return[d.memoizedState,a]},useRef:function(a){var b=
ci();a={current:a};return b.memoizedState=a},useState:qi,useDebugValue:Ai,useDeferredValue:function(a){return ci().memoizedState=a},useTransition:function(){var a=qi(!1),b=a[0];a=Ei.bind(null,a[1]);ci().memoizedState=a;return[b,a]},useMutableSource:function(){},useSyncExternalStore:function(a,b,c){var d=N,e=ci();if(I){if(void 0===c)throw Error(p(407));c=c()}else{c=b();if(null===R)throw Error(p(349));0!==(Rh&30)||ni(d,b,c)}e.memoizedState=c;var f={value:c,getSnapshot:b};e.queue=f;vi(ki.bind(null,d,
f,a),[a]);d.flags|=2048;li(9,mi.bind(null,d,f,c,b),void 0,null);return c},useId:function(){var a=ci(),b=R.identifierPrefix;if(I){var c=sg;var d=rg;c=(d&~(1<<32-oc(d)-1)).toString(32)+c;b=":"+b+"R"+c;c=Uh++;0<c&&(b+="H"+c.toString(32));b+=":"}else c=Vh++,b=":"+b+"r"+c.toString(32)+":";return a.memoizedState=b},unstable_isNewReconciler:!1},Zh={readContext:Vg,useCallback:Bi,useContext:Vg,useEffect:ji,useImperativeHandle:zi,useInsertionEffect:wi,useLayoutEffect:xi,useMemo:Ci,useReducer:fi,useRef:si,useState:function(){return fi(ei)},
useDebugValue:Ai,useDeferredValue:function(a){var b=di();return Di(b,O.memoizedState,a)},useTransition:function(){var a=fi(ei)[0],b=di().memoizedState;return[a,b]},useMutableSource:hi,useSyncExternalStore:ii,useId:Fi,unstable_isNewReconciler:!1},$h={readContext:Vg,useCallback:Bi,useContext:Vg,useEffect:ji,useImperativeHandle:zi,useInsertionEffect:wi,useLayoutEffect:xi,useMemo:Ci,useReducer:gi,useRef:si,useState:function(){return gi(ei)},useDebugValue:Ai,useDeferredValue:function(a){var b=di();return null===
O?b.memoizedState=a:Di(b,O.memoizedState,a)},useTransition:function(){var a=gi(ei)[0],b=di().memoizedState;return[a,b]},useMutableSource:hi,useSyncExternalStore:ii,useId:Fi,unstable_isNewReconciler:!1};function Ki(a,b){try{var c="",d=b;do c+=Pa(d),d=d.return;while(d);var e=c}catch(f){e="\nError generating stack: "+f.message+"\n"+f.stack}return{value:a,source:b,stack:e,digest:null}}function Li(a,b,c){return{value:a,source:null,stack:null!=c?c:null,digest:null!=b?b:null}}
function Mi(a,b){try{console.error(b.value)}catch(c){setTimeout(function(){throw c;})}}var Ni="function"===typeof WeakMap?WeakMap:Map;function Oi(a,b,c){c=ch(-1,c);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){Pi||(Pi=!0,Qi=d);Mi(a,b)};return c}
function Ri(a,b,c){c=ch(-1,c);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){return d(e)};c.callback=function(){Mi(a,b)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){Mi(a,b);"function"!==typeof d&&(null===Si?Si=new Set([this]):Si.add(this));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""})});return c}
function Ti(a,b,c){var d=a.pingCache;if(null===d){d=a.pingCache=new Ni;var e=new Set;d.set(b,e)}else e=d.get(b),void 0===e&&(e=new Set,d.set(b,e));e.has(c)||(e.add(c),a=Ui.bind(null,a,b,c),b.then(a,a))}function Vi(a){do{var b;if(b=13===a.tag)b=a.memoizedState,b=null!==b?null!==b.dehydrated?!0:!1:!0;if(b)return a;a=a.return}while(null!==a);return null}
function Wi(a,b,c,d,e){if(0===(a.mode&1))return a===b?a.flags|=65536:(a.flags|=128,c.flags|=131072,c.flags&=-52805,1===c.tag&&(null===c.alternate?c.tag=17:(b=ch(-1,1),b.tag=2,dh(c,b,1))),c.lanes|=1),a;a.flags|=65536;a.lanes=e;return a}var Xi=ua.ReactCurrentOwner,Ug=!1;function Yi(a,b,c,d){b.child=null===a?Ch(b,null,c,d):Bh(b,a.child,c,d)}
function Zi(a,b,c,d,e){c=c.render;var f=b.ref;Tg(b,e);d=Xh(a,b,c,d,f,e);c=bi();if(null!==a&&!Ug)return b.updateQueue=a.updateQueue,b.flags&=-2053,a.lanes&=~e,$i(a,b,e);I&&c&&vg(b);b.flags|=1;Yi(a,b,d,e);return b.child}
function aj(a,b,c,d,e){if(null===a){var f=c.type;if("function"===typeof f&&!bj(f)&&void 0===f.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=f,cj(a,b,f,d,e);a=yh(c.type,null,d,b,b.mode,e);a.ref=b.ref;a.return=b;return b.child=a}f=a.child;if(0===(a.lanes&e)){var g=f.memoizedProps;c=c.compare;c=null!==c?c:Ie;if(c(g,d)&&a.ref===b.ref)return $i(a,b,e)}b.flags|=1;a=wh(f,d);a.ref=b.ref;a.return=b;return b.child=a}
function cj(a,b,c,d,e){if(null!==a){var f=a.memoizedProps;if(Ie(f,d)&&a.ref===b.ref)if(Ug=!1,b.pendingProps=d=f,0!==(a.lanes&e))0!==(a.flags&131072)&&(Ug=!0);else return b.lanes=a.lanes,$i(a,b,e)}return dj(a,b,c,d,e)}
function ej(a,b,c){var d=b.pendingProps,e=d.children,f=null!==a?a.memoizedState:null;if("hidden"===d.mode)if(0===(b.mode&1))b.memoizedState={baseLanes:0,cachePool:null,transitions:null},G(fj,gj),gj|=c;else{if(0===(c&1073741824))return a=null!==f?f.baseLanes|c:c,b.lanes=b.childLanes=1073741824,b.memoizedState={baseLanes:a,cachePool:null,transitions:null},b.updateQueue=null,G(fj,gj),gj|=a,null;b.memoizedState={baseLanes:0,cachePool:null,transitions:null};d=null!==f?f.baseLanes:c;G(fj,gj);gj|=d}else null!==
f?(d=f.baseLanes|c,b.memoizedState=null):d=c,G(fj,gj),gj|=d;Yi(a,b,e,c);return b.child}function hj(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.flags|=512,b.flags|=2097152}function dj(a,b,c,d,e){var f=Zf(c)?Xf:H.current;f=Yf(b,f);Tg(b,e);c=Xh(a,b,c,d,f,e);d=bi();if(null!==a&&!Ug)return b.updateQueue=a.updateQueue,b.flags&=-2053,a.lanes&=~e,$i(a,b,e);I&&d&&vg(b);b.flags|=1;Yi(a,b,c,e);return b.child}
function ij(a,b,c,d,e){if(Zf(c)){var f=!0;cg(b)}else f=!1;Tg(b,e);if(null===b.stateNode)jj(a,b),ph(b,c,d),rh(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var k=g.context,l=c.contextType;"object"===typeof l&&null!==l?l=Vg(l):(l=Zf(c)?Xf:H.current,l=Yf(b,l));var m=c.getDerivedStateFromProps,q="function"===typeof m||"function"===typeof g.getSnapshotBeforeUpdate;q||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||
(h!==d||k!==l)&&qh(b,g,d,l);$g=!1;var r=b.memoizedState;g.state=r;gh(b,d,g,e);k=b.memoizedState;h!==d||r!==k||Wf.current||$g?("function"===typeof m&&(kh(b,c,m,d),k=b.memoizedState),(h=$g||oh(b,c,h,d,r,k,l))?(q||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===typeof g.componentDidMount&&(b.flags|=4194308)):
("function"===typeof g.componentDidMount&&(b.flags|=4194308),b.memoizedProps=d,b.memoizedState=k),g.props=d,g.state=k,g.context=l,d=h):("function"===typeof g.componentDidMount&&(b.flags|=4194308),d=!1)}else{g=b.stateNode;bh(a,b);h=b.memoizedProps;l=b.type===b.elementType?h:Lg(b.type,h);g.props=l;q=b.pendingProps;r=g.context;k=c.contextType;"object"===typeof k&&null!==k?k=Vg(k):(k=Zf(c)?Xf:H.current,k=Yf(b,k));var y=c.getDerivedStateFromProps;(m="function"===typeof y||"function"===typeof g.getSnapshotBeforeUpdate)||
"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==q||r!==k)&&qh(b,g,d,k);$g=!1;r=b.memoizedState;g.state=r;gh(b,d,g,e);var n=b.memoizedState;h!==q||r!==n||Wf.current||$g?("function"===typeof y&&(kh(b,c,y,d),n=b.memoizedState),(l=$g||oh(b,c,l,d,r,n,k)||!1)?(m||"function"!==typeof g.UNSAFE_componentWillUpdate&&"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,n,k),"function"===typeof g.UNSAFE_componentWillUpdate&&
g.UNSAFE_componentWillUpdate(d,n,k)),"function"===typeof g.componentDidUpdate&&(b.flags|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.flags|=1024)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&r===a.memoizedState||(b.flags|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&r===a.memoizedState||(b.flags|=1024),b.memoizedProps=d,b.memoizedState=n),g.props=d,g.state=n,g.context=k,d=l):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&r===
a.memoizedState||(b.flags|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&r===a.memoizedState||(b.flags|=1024),d=!1)}return kj(a,b,c,d,f,e)}
function kj(a,b,c,d,e,f){hj(a,b);var g=0!==(b.flags&128);if(!d&&!g)return e&&dg(b,c,!1),$i(a,b,f);d=b.stateNode;Xi.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?null:d.render();b.flags|=1;null!==a&&g?(b.child=Bh(b,a.child,null,f),b.child=Bh(b,null,h,f)):Yi(a,b,h,f);b.memoizedState=d.state;e&&dg(b,c,!0);return b.child}function lj(a){var b=a.stateNode;b.pendingContext?ag(a,b.pendingContext,b.pendingContext!==b.context):b.context&&ag(a,b.context,!1);Ih(a,b.containerInfo)}
function mj(a,b,c,d,e){Ig();Jg(e);b.flags|=256;Yi(a,b,c,d);return b.child}var nj={dehydrated:null,treeContext:null,retryLane:0};function oj(a){return{baseLanes:a,cachePool:null,transitions:null}}
function pj(a,b,c){var d=b.pendingProps,e=M.current,f=!1,g=0!==(b.flags&128),h;(h=g)||(h=null!==a&&null===a.memoizedState?!1:0!==(e&2));if(h)f=!0,b.flags&=-129;else if(null===a||null!==a.memoizedState)e|=1;G(M,e&1);if(null===a){Eg(b);a=b.memoizedState;if(null!==a&&(a=a.dehydrated,null!==a))return 0===(b.mode&1)?b.lanes=1:"$!"===a.data?b.lanes=8:b.lanes=1073741824,null;g=d.children;a=d.fallback;return f?(d=b.mode,f=b.child,g={mode:"hidden",children:g},0===(d&1)&&null!==f?(f.childLanes=0,f.pendingProps=
g):f=qj(g,d,0,null),a=Ah(a,d,c,null),f.return=b,a.return=b,f.sibling=a,b.child=f,b.child.memoizedState=oj(c),b.memoizedState=nj,a):rj(b,g)}e=a.memoizedState;if(null!==e&&(h=e.dehydrated,null!==h))return sj(a,b,g,d,h,e,c);if(f){f=d.fallback;g=b.mode;e=a.child;h=e.sibling;var k={mode:"hidden",children:d.children};0===(g&1)&&b.child!==e?(d=b.child,d.childLanes=0,d.pendingProps=k,b.deletions=null):(d=wh(e,k),d.subtreeFlags=e.subtreeFlags&14680064);null!==h?f=wh(h,f):(f=Ah(f,g,c,null),f.flags|=2);f.return=
b;d.return=b;d.sibling=f;b.child=d;d=f;f=b.child;g=a.child.memoizedState;g=null===g?oj(c):{baseLanes:g.baseLanes|c,cachePool:null,transitions:g.transitions};f.memoizedState=g;f.childLanes=a.childLanes&~c;b.memoizedState=nj;return d}f=a.child;a=f.sibling;d=wh(f,{mode:"visible",children:d.children});0===(b.mode&1)&&(d.lanes=c);d.return=b;d.sibling=null;null!==a&&(c=b.deletions,null===c?(b.deletions=[a],b.flags|=16):c.push(a));b.child=d;b.memoizedState=null;return d}
function rj(a,b){b=qj({mode:"visible",children:b},a.mode,0,null);b.return=a;return a.child=b}function tj(a,b,c,d){null!==d&&Jg(d);Bh(b,a.child,null,c);a=rj(b,b.pendingProps.children);a.flags|=2;b.memoizedState=null;return a}
function sj(a,b,c,d,e,f,g){if(c){if(b.flags&256)return b.flags&=-257,d=Li(Error(p(422))),tj(a,b,g,d);if(null!==b.memoizedState)return b.child=a.child,b.flags|=128,null;f=d.fallback;e=b.mode;d=qj({mode:"visible",children:d.children},e,0,null);f=Ah(f,e,g,null);f.flags|=2;d.return=b;f.return=b;d.sibling=f;b.child=d;0!==(b.mode&1)&&Bh(b,a.child,null,g);b.child.memoizedState=oj(g);b.memoizedState=nj;return f}if(0===(b.mode&1))return tj(a,b,g,null);if("$!"===e.data){d=e.nextSibling&&e.nextSibling.dataset;
if(d)var h=d.dgst;d=h;f=Error(p(419));d=Li(f,d,void 0);return tj(a,b,g,d)}h=0!==(g&a.childLanes);if(Ug||h){d=R;if(null!==d){switch(g&-g){case 4:e=2;break;case 16:e=8;break;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:e=32;break;case 536870912:e=268435456;break;default:e=0}e=0!==(e&(d.suspendedLanes|g))?0:e;
0!==e&&e!==f.retryLane&&(f.retryLane=e,Zg(a,e),mh(d,a,e,-1))}uj();d=Li(Error(p(421)));return tj(a,b,g,d)}if("$?"===e.data)return b.flags|=128,b.child=a.child,b=vj.bind(null,a),e._reactRetry=b,null;a=f.treeContext;yg=Lf(e.nextSibling);xg=b;I=!0;zg=null;null!==a&&(og[pg++]=rg,og[pg++]=sg,og[pg++]=qg,rg=a.id,sg=a.overflow,qg=b);b=rj(b,d.children);b.flags|=4096;return b}function wj(a,b,c){a.lanes|=b;var d=a.alternate;null!==d&&(d.lanes|=b);Sg(a.return,b,c)}
function xj(a,b,c,d,e){var f=a.memoizedState;null===f?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailMode:e}:(f.isBackwards=b,f.rendering=null,f.renderingStartTime=0,f.last=d,f.tail=c,f.tailMode=e)}
function yj(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;Yi(a,b,d.children,c);d=M.current;if(0!==(d&2))d=d&1|2,b.flags|=128;else{if(null!==a&&0!==(a.flags&128))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&wj(a,c,b);else if(19===a.tag)wj(a,c,b);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}G(M,d);if(0===(b.mode&1))b.memoizedState=
null;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===Mh(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);xj(b,!1,e,c,f);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===Mh(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}xj(b,!0,c,null,f);break;case "together":xj(b,!1,null,null,void 0);break;default:b.memoizedState=null}return b.child}
function jj(a,b){0===(b.mode&1)&&null!==a&&(a.alternate=null,b.alternate=null,b.flags|=2)}function $i(a,b,c){null!==a&&(b.dependencies=a.dependencies);hh|=b.lanes;if(0===(c&b.childLanes))return null;if(null!==a&&b.child!==a.child)throw Error(p(153));if(null!==b.child){a=b.child;c=wh(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=wh(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}
function zj(a,b,c){switch(b.tag){case 3:lj(b);Ig();break;case 5:Kh(b);break;case 1:Zf(b.type)&&cg(b);break;case 4:Ih(b,b.stateNode.containerInfo);break;case 10:var d=b.type._context,e=b.memoizedProps.value;G(Mg,d._currentValue);d._currentValue=e;break;case 13:d=b.memoizedState;if(null!==d){if(null!==d.dehydrated)return G(M,M.current&1),b.flags|=128,null;if(0!==(c&b.child.childLanes))return pj(a,b,c);G(M,M.current&1);a=$i(a,b,c);return null!==a?a.sibling:null}G(M,M.current&1);break;case 19:d=0!==(c&
b.childLanes);if(0!==(a.flags&128)){if(d)return yj(a,b,c);b.flags|=128}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null,e.lastEffect=null);G(M,M.current);if(d)break;else return null;case 22:case 23:return b.lanes=0,ej(a,b,c)}return $i(a,b,c)}var Aj,Bj,Cj,Dj;
Aj=function(a,b){for(var c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};Bj=function(){};
Cj=function(a,b,c,d){var e=a.memoizedProps;if(e!==d){a=b.stateNode;Hh(Eh.current);var f=null;switch(c){case "input":e=Ya(a,e);d=Ya(a,d);f=[];break;case "select":e=A({},e,{value:void 0});d=A({},d,{value:void 0});f=[];break;case "textarea":e=gb(a,e);d=gb(a,d);f=[];break;default:"function"!==typeof e.onClick&&"function"===typeof d.onClick&&(a.onclick=Bf)}ub(c,d);var g;c=null;for(l in e)if(!d.hasOwnProperty(l)&&e.hasOwnProperty(l)&&null!=e[l])if("style"===l){var h=e[l];for(g in h)h.hasOwnProperty(g)&&
(c||(c={}),c[g]="")}else"dangerouslySetInnerHTML"!==l&&"children"!==l&&"suppressContentEditableWarning"!==l&&"suppressHydrationWarning"!==l&&"autoFocus"!==l&&(ea.hasOwnProperty(l)?f||(f=[]):(f=f||[]).push(l,null));for(l in d){var k=d[l];h=null!=e?e[l]:void 0;if(d.hasOwnProperty(l)&&k!==h&&(null!=k||null!=h))if("style"===l)if(h){for(g in h)!h.hasOwnProperty(g)||k&&k.hasOwnProperty(g)||(c||(c={}),c[g]="");for(g in k)k.hasOwnProperty(g)&&h[g]!==k[g]&&(c||(c={}),c[g]=k[g])}else c||(f||(f=[]),f.push(l,
c)),c=k;else"dangerouslySetInnerHTML"===l?(k=k?k.__html:void 0,h=h?h.__html:void 0,null!=k&&h!==k&&(f=f||[]).push(l,k)):"children"===l?"string"!==typeof k&&"number"!==typeof k||(f=f||[]).push(l,""+k):"suppressContentEditableWarning"!==l&&"suppressHydrationWarning"!==l&&(ea.hasOwnProperty(l)?(null!=k&&"onScroll"===l&&D("scroll",a),f||h===k||(f=[])):(f=f||[]).push(l,k))}c&&(f=f||[]).push("style",c);var l=f;if(b.updateQueue=l)b.flags|=4}};Dj=function(a,b,c,d){c!==d&&(b.flags|=4)};
function Ej(a,b){if(!I)switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}
function S(a){var b=null!==a.alternate&&a.alternate.child===a.child,c=0,d=0;if(b)for(var e=a.child;null!==e;)c|=e.lanes|e.childLanes,d|=e.subtreeFlags&14680064,d|=e.flags&14680064,e.return=a,e=e.sibling;else for(e=a.child;null!==e;)c|=e.lanes|e.childLanes,d|=e.subtreeFlags,d|=e.flags,e.return=a,e=e.sibling;a.subtreeFlags|=d;a.childLanes=c;return b}
function Fj(a,b,c){var d=b.pendingProps;wg(b);switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return S(b),null;case 1:return Zf(b.type)&&$f(),S(b),null;case 3:d=b.stateNode;Jh();E(Wf);E(H);Oh();d.pendingContext&&(d.context=d.pendingContext,d.pendingContext=null);if(null===a||null===a.child)Gg(b)?b.flags|=4:null===a||a.memoizedState.isDehydrated&&0===(b.flags&256)||(b.flags|=1024,null!==zg&&(Gj(zg),zg=null));Bj(a,b);S(b);return null;case 5:Lh(b);var e=Hh(Gh.current);
c=b.type;if(null!==a&&null!=b.stateNode)Cj(a,b,c,d,e),a.ref!==b.ref&&(b.flags|=512,b.flags|=2097152);else{if(!d){if(null===b.stateNode)throw Error(p(166));S(b);return null}a=Hh(Eh.current);if(Gg(b)){d=b.stateNode;c=b.type;var f=b.memoizedProps;d[Of]=b;d[Pf]=f;a=0!==(b.mode&1);switch(c){case "dialog":D("cancel",d);D("close",d);break;case "iframe":case "object":case "embed":D("load",d);break;case "video":case "audio":for(e=0;e<lf.length;e++)D(lf[e],d);break;case "source":D("error",d);break;case "img":case "image":case "link":D("error",
d);D("load",d);break;case "details":D("toggle",d);break;case "input":Za(d,f);D("invalid",d);break;case "select":d._wrapperState={wasMultiple:!!f.multiple};D("invalid",d);break;case "textarea":hb(d,f),D("invalid",d)}ub(c,f);e=null;for(var g in f)if(f.hasOwnProperty(g)){var h=f[g];"children"===g?"string"===typeof h?d.textContent!==h&&(!0!==f.suppressHydrationWarning&&Af(d.textContent,h,a),e=["children",h]):"number"===typeof h&&d.textContent!==""+h&&(!0!==f.suppressHydrationWarning&&Af(d.textContent,
h,a),e=["children",""+h]):ea.hasOwnProperty(g)&&null!=h&&"onScroll"===g&&D("scroll",d)}switch(c){case "input":Va(d);db(d,f,!0);break;case "textarea":Va(d);jb(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&(d.onclick=Bf)}d=e;b.updateQueue=d;null!==d&&(b.flags|=4)}else{g=9===e.nodeType?e:e.ownerDocument;"http://www.w3.org/1999/xhtml"===a&&(a=kb(c));"http://www.w3.org/1999/xhtml"===a?"script"===c?(a=g.createElement("div"),a.innerHTML="<script>\x3c/script>",a=a.removeChild(a.firstChild)):
"string"===typeof d.is?a=g.createElement(c,{is:d.is}):(a=g.createElement(c),"select"===c&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,c);a[Of]=b;a[Pf]=d;Aj(a,b,!1,!1);b.stateNode=a;a:{g=vb(c,d);switch(c){case "dialog":D("cancel",a);D("close",a);e=d;break;case "iframe":case "object":case "embed":D("load",a);e=d;break;case "video":case "audio":for(e=0;e<lf.length;e++)D(lf[e],a);e=d;break;case "source":D("error",a);e=d;break;case "img":case "image":case "link":D("error",
a);D("load",a);e=d;break;case "details":D("toggle",a);e=d;break;case "input":Za(a,d);e=Ya(a,d);D("invalid",a);break;case "option":e=d;break;case "select":a._wrapperState={wasMultiple:!!d.multiple};e=A({},d,{value:void 0});D("invalid",a);break;case "textarea":hb(a,d);e=gb(a,d);D("invalid",a);break;default:e=d}ub(c,e);h=e;for(f in h)if(h.hasOwnProperty(f)){var k=h[f];"style"===f?sb(a,k):"dangerouslySetInnerHTML"===f?(k=k?k.__html:void 0,null!=k&&nb(a,k)):"children"===f?"string"===typeof k?("textarea"!==
c||""!==k)&&ob(a,k):"number"===typeof k&&ob(a,""+k):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(ea.hasOwnProperty(f)?null!=k&&"onScroll"===f&&D("scroll",a):null!=k&&ta(a,f,k,g))}switch(c){case "input":Va(a);db(a,d,!1);break;case "textarea":Va(a);jb(a);break;case "option":null!=d.value&&a.setAttribute("value",""+Sa(d.value));break;case "select":a.multiple=!!d.multiple;f=d.value;null!=f?fb(a,!!d.multiple,f,!1):null!=d.defaultValue&&fb(a,!!d.multiple,d.defaultValue,
!0);break;default:"function"===typeof e.onClick&&(a.onclick=Bf)}switch(c){case "button":case "input":case "select":case "textarea":d=!!d.autoFocus;break a;case "img":d=!0;break a;default:d=!1}}d&&(b.flags|=4)}null!==b.ref&&(b.flags|=512,b.flags|=2097152)}S(b);return null;case 6:if(a&&null!=b.stateNode)Dj(a,b,a.memoizedProps,d);else{if("string"!==typeof d&&null===b.stateNode)throw Error(p(166));c=Hh(Gh.current);Hh(Eh.current);if(Gg(b)){d=b.stateNode;c=b.memoizedProps;d[Of]=b;if(f=d.nodeValue!==c)if(a=
xg,null!==a)switch(a.tag){case 3:Af(d.nodeValue,c,0!==(a.mode&1));break;case 5:!0!==a.memoizedProps.suppressHydrationWarning&&Af(d.nodeValue,c,0!==(a.mode&1))}f&&(b.flags|=4)}else d=(9===c.nodeType?c:c.ownerDocument).createTextNode(d),d[Of]=b,b.stateNode=d}S(b);return null;case 13:E(M);d=b.memoizedState;if(null===a||null!==a.memoizedState&&null!==a.memoizedState.dehydrated){if(I&&null!==yg&&0!==(b.mode&1)&&0===(b.flags&128))Hg(),Ig(),b.flags|=98560,f=!1;else if(f=Gg(b),null!==d&&null!==d.dehydrated){if(null===
a){if(!f)throw Error(p(318));f=b.memoizedState;f=null!==f?f.dehydrated:null;if(!f)throw Error(p(317));f[Of]=b}else Ig(),0===(b.flags&128)&&(b.memoizedState=null),b.flags|=4;S(b);f=!1}else null!==zg&&(Gj(zg),zg=null),f=!0;if(!f)return b.flags&65536?b:null}if(0!==(b.flags&128))return b.lanes=c,b;d=null!==d;d!==(null!==a&&null!==a.memoizedState)&&d&&(b.child.flags|=8192,0!==(b.mode&1)&&(null===a||0!==(M.current&1)?0===T&&(T=3):uj()));null!==b.updateQueue&&(b.flags|=4);S(b);return null;case 4:return Jh(),
Bj(a,b),null===a&&sf(b.stateNode.containerInfo),S(b),null;case 10:return Rg(b.type._context),S(b),null;case 17:return Zf(b.type)&&$f(),S(b),null;case 19:E(M);f=b.memoizedState;if(null===f)return S(b),null;d=0!==(b.flags&128);g=f.rendering;if(null===g)if(d)Ej(f,!1);else{if(0!==T||null!==a&&0!==(a.flags&128))for(a=b.child;null!==a;){g=Mh(a);if(null!==g){b.flags|=128;Ej(f,!1);d=g.updateQueue;null!==d&&(b.updateQueue=d,b.flags|=4);b.subtreeFlags=0;d=c;for(c=b.child;null!==c;)f=c,a=d,f.flags&=14680066,
g=f.alternate,null===g?(f.childLanes=0,f.lanes=a,f.child=null,f.subtreeFlags=0,f.memoizedProps=null,f.memoizedState=null,f.updateQueue=null,f.dependencies=null,f.stateNode=null):(f.childLanes=g.childLanes,f.lanes=g.lanes,f.child=g.child,f.subtreeFlags=0,f.deletions=null,f.memoizedProps=g.memoizedProps,f.memoizedState=g.memoizedState,f.updateQueue=g.updateQueue,f.type=g.type,a=g.dependencies,f.dependencies=null===a?null:{lanes:a.lanes,firstContext:a.firstContext}),c=c.sibling;G(M,M.current&1|2);return b.child}a=
a.sibling}null!==f.tail&&B()>Hj&&(b.flags|=128,d=!0,Ej(f,!1),b.lanes=4194304)}else{if(!d)if(a=Mh(g),null!==a){if(b.flags|=128,d=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.flags|=4),Ej(f,!0),null===f.tail&&"hidden"===f.tailMode&&!g.alternate&&!I)return S(b),null}else 2*B()-f.renderingStartTime>Hj&&1073741824!==c&&(b.flags|=128,d=!0,Ej(f,!1),b.lanes=4194304);f.isBackwards?(g.sibling=b.child,b.child=g):(c=f.last,null!==c?c.sibling=g:b.child=g,f.last=g)}if(null!==f.tail)return b=f.tail,f.rendering=
b,f.tail=b.sibling,f.renderingStartTime=B(),b.sibling=null,c=M.current,G(M,d?c&1|2:c&1),b;S(b);return null;case 22:case 23:return Ij(),d=null!==b.memoizedState,null!==a&&null!==a.memoizedState!==d&&(b.flags|=8192),d&&0!==(b.mode&1)?0!==(gj&1073741824)&&(S(b),b.subtreeFlags&6&&(b.flags|=8192)):S(b),null;case 24:return null;case 25:return null}throw Error(p(156,b.tag));}
function Jj(a,b){wg(b);switch(b.tag){case 1:return Zf(b.type)&&$f(),a=b.flags,a&65536?(b.flags=a&-65537|128,b):null;case 3:return Jh(),E(Wf),E(H),Oh(),a=b.flags,0!==(a&65536)&&0===(a&128)?(b.flags=a&-65537|128,b):null;case 5:return Lh(b),null;case 13:E(M);a=b.memoizedState;if(null!==a&&null!==a.dehydrated){if(null===b.alternate)throw Error(p(340));Ig()}a=b.flags;return a&65536?(b.flags=a&-65537|128,b):null;case 19:return E(M),null;case 4:return Jh(),null;case 10:return Rg(b.type._context),null;case 22:case 23:return Ij(),
null;case 24:return null;default:return null}}var Kj=!1,U=!1,Lj="function"===typeof WeakSet?WeakSet:Set,V=null;function Mj(a,b){var c=a.ref;if(null!==c)if("function"===typeof c)try{c(null)}catch(d){W(a,b,d)}else c.current=null}function Nj(a,b,c){try{c()}catch(d){W(a,b,d)}}var Oj=!1;
function Pj(a,b){Cf=dd;a=Me();if(Ne(a)){if("selectionStart"in a)var c={start:a.selectionStart,end:a.selectionEnd};else a:{c=(c=a.ownerDocument)&&c.defaultView||window;var d=c.getSelection&&c.getSelection();if(d&&0!==d.rangeCount){c=d.anchorNode;var e=d.anchorOffset,f=d.focusNode;d=d.focusOffset;try{c.nodeType,f.nodeType}catch(F){c=null;break a}var g=0,h=-1,k=-1,l=0,m=0,q=a,r=null;b:for(;;){for(var y;;){q!==c||0!==e&&3!==q.nodeType||(h=g+e);q!==f||0!==d&&3!==q.nodeType||(k=g+d);3===q.nodeType&&(g+=
q.nodeValue.length);if(null===(y=q.firstChild))break;r=q;q=y}for(;;){if(q===a)break b;r===c&&++l===e&&(h=g);r===f&&++m===d&&(k=g);if(null!==(y=q.nextSibling))break;q=r;r=q.parentNode}q=y}c=-1===h||-1===k?null:{start:h,end:k}}else c=null}c=c||{start:0,end:0}}else c=null;Df={focusedElem:a,selectionRange:c};dd=!1;for(V=b;null!==V;)if(b=V,a=b.child,0!==(b.subtreeFlags&1028)&&null!==a)a.return=b,V=a;else for(;null!==V;){b=V;try{var n=b.alternate;if(0!==(b.flags&1024))switch(b.tag){case 0:case 11:case 15:break;
case 1:if(null!==n){var t=n.memoizedProps,J=n.memoizedState,x=b.stateNode,w=x.getSnapshotBeforeUpdate(b.elementType===b.type?t:Lg(b.type,t),J);x.__reactInternalSnapshotBeforeUpdate=w}break;case 3:var u=b.stateNode.containerInfo;1===u.nodeType?u.textContent="":9===u.nodeType&&u.documentElement&&u.removeChild(u.documentElement);break;case 5:case 6:case 4:case 17:break;default:throw Error(p(163));}}catch(F){W(b,b.return,F)}a=b.sibling;if(null!==a){a.return=b.return;V=a;break}V=b.return}n=Oj;Oj=!1;return n}
function Qj(a,b,c){var d=b.updateQueue;d=null!==d?d.lastEffect:null;if(null!==d){var e=d=d.next;do{if((e.tag&a)===a){var f=e.destroy;e.destroy=void 0;void 0!==f&&Nj(b,c,f)}e=e.next}while(e!==d)}}function Rj(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d()}c=c.next}while(c!==b)}}function Sj(a){var b=a.ref;if(null!==b){var c=a.stateNode;switch(a.tag){case 5:a=c;break;default:a=c}"function"===typeof b?b(a):b.current=a}}
function Tj(a){var b=a.alternate;null!==b&&(a.alternate=null,Tj(b));a.child=null;a.deletions=null;a.sibling=null;5===a.tag&&(b=a.stateNode,null!==b&&(delete b[Of],delete b[Pf],delete b[of],delete b[Qf],delete b[Rf]));a.stateNode=null;a.return=null;a.dependencies=null;a.memoizedProps=null;a.memoizedState=null;a.pendingProps=null;a.stateNode=null;a.updateQueue=null}function Uj(a){return 5===a.tag||3===a.tag||4===a.tag}
function Vj(a){a:for(;;){for(;null===a.sibling;){if(null===a.return||Uj(a.return))return null;a=a.return}a.sibling.return=a.return;for(a=a.sibling;5!==a.tag&&6!==a.tag&&18!==a.tag;){if(a.flags&2)continue a;if(null===a.child||4===a.tag)continue a;else a.child.return=a,a=a.child}if(!(a.flags&2))return a.stateNode}}
function Wj(a,b,c){var d=a.tag;if(5===d||6===d)a=a.stateNode,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=Bf));else if(4!==d&&(a=a.child,null!==a))for(Wj(a,b,c),a=a.sibling;null!==a;)Wj(a,b,c),a=a.sibling}
function Xj(a,b,c){var d=a.tag;if(5===d||6===d)a=a.stateNode,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Xj(a,b,c),a=a.sibling;null!==a;)Xj(a,b,c),a=a.sibling}var X=null,Yj=!1;function Zj(a,b,c){for(c=c.child;null!==c;)ak(a,b,c),c=c.sibling}
function ak(a,b,c){if(lc&&"function"===typeof lc.onCommitFiberUnmount)try{lc.onCommitFiberUnmount(kc,c)}catch(h){}switch(c.tag){case 5:U||Mj(c,b);case 6:var d=X,e=Yj;X=null;Zj(a,b,c);X=d;Yj=e;null!==X&&(Yj?(a=X,c=c.stateNode,8===a.nodeType?a.parentNode.removeChild(c):a.removeChild(c)):X.removeChild(c.stateNode));break;case 18:null!==X&&(Yj?(a=X,c=c.stateNode,8===a.nodeType?Kf(a.parentNode,c):1===a.nodeType&&Kf(a,c),bd(a)):Kf(X,c.stateNode));break;case 4:d=X;e=Yj;X=c.stateNode.containerInfo;Yj=!0;
Zj(a,b,c);X=d;Yj=e;break;case 0:case 11:case 14:case 15:if(!U&&(d=c.updateQueue,null!==d&&(d=d.lastEffect,null!==d))){e=d=d.next;do{var f=e,g=f.destroy;f=f.tag;void 0!==g&&(0!==(f&2)?Nj(c,b,g):0!==(f&4)&&Nj(c,b,g));e=e.next}while(e!==d)}Zj(a,b,c);break;case 1:if(!U&&(Mj(c,b),d=c.stateNode,"function"===typeof d.componentWillUnmount))try{d.props=c.memoizedProps,d.state=c.memoizedState,d.componentWillUnmount()}catch(h){W(c,b,h)}Zj(a,b,c);break;case 21:Zj(a,b,c);break;case 22:c.mode&1?(U=(d=U)||null!==
c.memoizedState,Zj(a,b,c),U=d):Zj(a,b,c);break;default:Zj(a,b,c)}}function bk(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=new Lj);b.forEach(function(b){var d=ck.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}
function dk(a,b){var c=b.deletions;if(null!==c)for(var d=0;d<c.length;d++){var e=c[d];try{var f=a,g=b,h=g;a:for(;null!==h;){switch(h.tag){case 5:X=h.stateNode;Yj=!1;break a;case 3:X=h.stateNode.containerInfo;Yj=!0;break a;case 4:X=h.stateNode.containerInfo;Yj=!0;break a}h=h.return}if(null===X)throw Error(p(160));ak(f,g,e);X=null;Yj=!1;var k=e.alternate;null!==k&&(k.return=null);e.return=null}catch(l){W(e,b,l)}}if(b.subtreeFlags&12854)for(b=b.child;null!==b;)ek(b,a),b=b.sibling}
function ek(a,b){var c=a.alternate,d=a.flags;switch(a.tag){case 0:case 11:case 14:case 15:dk(b,a);fk(a);if(d&4){try{Qj(3,a,a.return),Rj(3,a)}catch(t){W(a,a.return,t)}try{Qj(5,a,a.return)}catch(t){W(a,a.return,t)}}break;case 1:dk(b,a);fk(a);d&512&&null!==c&&Mj(c,c.return);break;case 5:dk(b,a);fk(a);d&512&&null!==c&&Mj(c,c.return);if(a.flags&32){var e=a.stateNode;try{ob(e,"")}catch(t){W(a,a.return,t)}}if(d&4&&(e=a.stateNode,null!=e)){var f=a.memoizedProps,g=null!==c?c.memoizedProps:f,h=a.type,k=a.updateQueue;
a.updateQueue=null;if(null!==k)try{"input"===h&&"radio"===f.type&&null!=f.name&&ab(e,f);vb(h,g);var l=vb(h,f);for(g=0;g<k.length;g+=2){var m=k[g],q=k[g+1];"style"===m?sb(e,q):"dangerouslySetInnerHTML"===m?nb(e,q):"children"===m?ob(e,q):ta(e,m,q,l)}switch(h){case "input":bb(e,f);break;case "textarea":ib(e,f);break;case "select":var r=e._wrapperState.wasMultiple;e._wrapperState.wasMultiple=!!f.multiple;var y=f.value;null!=y?fb(e,!!f.multiple,y,!1):r!==!!f.multiple&&(null!=f.defaultValue?fb(e,!!f.multiple,
f.defaultValue,!0):fb(e,!!f.multiple,f.multiple?[]:"",!1))}e[Pf]=f}catch(t){W(a,a.return,t)}}break;case 6:dk(b,a);fk(a);if(d&4){if(null===a.stateNode)throw Error(p(162));e=a.stateNode;f=a.memoizedProps;try{e.nodeValue=f}catch(t){W(a,a.return,t)}}break;case 3:dk(b,a);fk(a);if(d&4&&null!==c&&c.memoizedState.isDehydrated)try{bd(b.containerInfo)}catch(t){W(a,a.return,t)}break;case 4:dk(b,a);fk(a);break;case 13:dk(b,a);fk(a);e=a.child;e.flags&8192&&(f=null!==e.memoizedState,e.stateNode.isHidden=f,!f||
null!==e.alternate&&null!==e.alternate.memoizedState||(gk=B()));d&4&&bk(a);break;case 22:m=null!==c&&null!==c.memoizedState;a.mode&1?(U=(l=U)||m,dk(b,a),U=l):dk(b,a);fk(a);if(d&8192){l=null!==a.memoizedState;if((a.stateNode.isHidden=l)&&!m&&0!==(a.mode&1))for(V=a,m=a.child;null!==m;){for(q=V=m;null!==V;){r=V;y=r.child;switch(r.tag){case 0:case 11:case 14:case 15:Qj(4,r,r.return);break;case 1:Mj(r,r.return);var n=r.stateNode;if("function"===typeof n.componentWillUnmount){d=r;c=r.return;try{b=d,n.props=
b.memoizedProps,n.state=b.memoizedState,n.componentWillUnmount()}catch(t){W(d,c,t)}}break;case 5:Mj(r,r.return);break;case 22:if(null!==r.memoizedState){hk(q);continue}}null!==y?(y.return=r,V=y):hk(q)}m=m.sibling}a:for(m=null,q=a;;){if(5===q.tag){if(null===m){m=q;try{e=q.stateNode,l?(f=e.style,"function"===typeof f.setProperty?f.setProperty("display","none","important"):f.display="none"):(h=q.stateNode,k=q.memoizedProps.style,g=void 0!==k&&null!==k&&k.hasOwnProperty("display")?k.display:null,h.style.display=
rb("display",g))}catch(t){W(a,a.return,t)}}}else if(6===q.tag){if(null===m)try{q.stateNode.nodeValue=l?"":q.memoizedProps}catch(t){W(a,a.return,t)}}else if((22!==q.tag&&23!==q.tag||null===q.memoizedState||q===a)&&null!==q.child){q.child.return=q;q=q.child;continue}if(q===a)break a;for(;null===q.sibling;){if(null===q.return||q.return===a)break a;m===q&&(m=null);q=q.return}m===q&&(m=null);q.sibling.return=q.return;q=q.sibling}}break;case 19:dk(b,a);fk(a);d&4&&bk(a);break;case 21:break;default:dk(b,
a),fk(a)}}function fk(a){var b=a.flags;if(b&2){try{a:{for(var c=a.return;null!==c;){if(Uj(c)){var d=c;break a}c=c.return}throw Error(p(160));}switch(d.tag){case 5:var e=d.stateNode;d.flags&32&&(ob(e,""),d.flags&=-33);var f=Vj(a);Xj(a,f,e);break;case 3:case 4:var g=d.stateNode.containerInfo,h=Vj(a);Wj(a,h,g);break;default:throw Error(p(161));}}catch(k){W(a,a.return,k)}a.flags&=-3}b&4096&&(a.flags&=-4097)}function ik(a,b,c){V=a;jk(a,b,c)}
function jk(a,b,c){for(var d=0!==(a.mode&1);null!==V;){var e=V,f=e.child;if(22===e.tag&&d){var g=null!==e.memoizedState||Kj;if(!g){var h=e.alternate,k=null!==h&&null!==h.memoizedState||U;h=Kj;var l=U;Kj=g;if((U=k)&&!l)for(V=e;null!==V;)g=V,k=g.child,22===g.tag&&null!==g.memoizedState?kk(e):null!==k?(k.return=g,V=k):kk(e);for(;null!==f;)V=f,jk(f,b,c),f=f.sibling;V=e;Kj=h;U=l}lk(a,b,c)}else 0!==(e.subtreeFlags&8772)&&null!==f?(f.return=e,V=f):lk(a,b,c)}}
function lk(a){for(;null!==V;){var b=V;if(0!==(b.flags&8772)){var c=b.alternate;try{if(0!==(b.flags&8772))switch(b.tag){case 0:case 11:case 15:U||Rj(5,b);break;case 1:var d=b.stateNode;if(b.flags&4&&!U)if(null===c)d.componentDidMount();else{var e=b.elementType===b.type?c.memoizedProps:Lg(b.type,c.memoizedProps);d.componentDidUpdate(e,c.memoizedState,d.__reactInternalSnapshotBeforeUpdate)}var f=b.updateQueue;null!==f&&ih(b,f,d);break;case 3:var g=b.updateQueue;if(null!==g){c=null;if(null!==b.child)switch(b.child.tag){case 5:c=
b.child.stateNode;break;case 1:c=b.child.stateNode}ih(b,g,c)}break;case 5:var h=b.stateNode;if(null===c&&b.flags&4){c=h;var k=b.memoizedProps;switch(b.type){case "button":case "input":case "select":case "textarea":k.autoFocus&&c.focus();break;case "img":k.src&&(c.src=k.src)}}break;case 6:break;case 4:break;case 12:break;case 13:if(null===b.memoizedState){var l=b.alternate;if(null!==l){var m=l.memoizedState;if(null!==m){var q=m.dehydrated;null!==q&&bd(q)}}}break;case 19:case 17:case 21:case 22:case 23:case 25:break;
default:throw Error(p(163));}U||b.flags&512&&Sj(b)}catch(r){W(b,b.return,r)}}if(b===a){V=null;break}c=b.sibling;if(null!==c){c.return=b.return;V=c;break}V=b.return}}function hk(a){for(;null!==V;){var b=V;if(b===a){V=null;break}var c=b.sibling;if(null!==c){c.return=b.return;V=c;break}V=b.return}}
function kk(a){for(;null!==V;){var b=V;try{switch(b.tag){case 0:case 11:case 15:var c=b.return;try{Rj(4,b)}catch(k){W(b,c,k)}break;case 1:var d=b.stateNode;if("function"===typeof d.componentDidMount){var e=b.return;try{d.componentDidMount()}catch(k){W(b,e,k)}}var f=b.return;try{Sj(b)}catch(k){W(b,f,k)}break;case 5:var g=b.return;try{Sj(b)}catch(k){W(b,g,k)}}}catch(k){W(b,b.return,k)}if(b===a){V=null;break}var h=b.sibling;if(null!==h){h.return=b.return;V=h;break}V=b.return}}
var mk=Math.ceil,nk=ua.ReactCurrentDispatcher,ok=ua.ReactCurrentOwner,pk=ua.ReactCurrentBatchConfig,K=0,R=null,Y=null,Z=0,gj=0,fj=Uf(0),T=0,qk=null,hh=0,rk=0,sk=0,tk=null,uk=null,gk=0,Hj=Infinity,vk=null,Pi=!1,Qi=null,Si=null,wk=!1,xk=null,yk=0,zk=0,Ak=null,Bk=-1,Ck=0;function L(){return 0!==(K&6)?B():-1!==Bk?Bk:Bk=B()}
function lh(a){if(0===(a.mode&1))return 1;if(0!==(K&2)&&0!==Z)return Z&-Z;if(null!==Kg.transition)return 0===Ck&&(Ck=yc()),Ck;a=C;if(0!==a)return a;a=window.event;a=void 0===a?16:jd(a.type);return a}function mh(a,b,c,d){if(50<zk)throw zk=0,Ak=null,Error(p(185));Ac(a,c,d);if(0===(K&2)||a!==R)a===R&&(0===(K&2)&&(rk|=c),4===T&&Dk(a,Z)),Ek(a,d),1===c&&0===K&&0===(b.mode&1)&&(Hj=B()+500,fg&&jg())}
function Ek(a,b){var c=a.callbackNode;wc(a,b);var d=uc(a,a===R?Z:0);if(0===d)null!==c&&bc(c),a.callbackNode=null,a.callbackPriority=0;else if(b=d&-d,a.callbackPriority!==b){null!=c&&bc(c);if(1===b)0===a.tag?ig(Fk.bind(null,a)):hg(Fk.bind(null,a)),Jf(function(){0===(K&6)&&jg()}),c=null;else{switch(Dc(d)){case 1:c=fc;break;case 4:c=gc;break;case 16:c=hc;break;case 536870912:c=jc;break;default:c=hc}c=Gk(c,Hk.bind(null,a))}a.callbackPriority=b;a.callbackNode=c}}
function Hk(a,b){Bk=-1;Ck=0;if(0!==(K&6))throw Error(p(327));var c=a.callbackNode;if(Ik()&&a.callbackNode!==c)return null;var d=uc(a,a===R?Z:0);if(0===d)return null;if(0!==(d&30)||0!==(d&a.expiredLanes)||b)b=Jk(a,d);else{b=d;var e=K;K|=2;var f=Kk();if(R!==a||Z!==b)vk=null,Hj=B()+500,Lk(a,b);do try{Mk();break}catch(h){Nk(a,h)}while(1);Qg();nk.current=f;K=e;null!==Y?b=0:(R=null,Z=0,b=T)}if(0!==b){2===b&&(e=xc(a),0!==e&&(d=e,b=Ok(a,e)));if(1===b)throw c=qk,Lk(a,0),Dk(a,d),Ek(a,B()),c;if(6===b)Dk(a,d);
else{e=a.current.alternate;if(0===(d&30)&&!Pk(e)&&(b=Jk(a,d),2===b&&(f=xc(a),0!==f&&(d=f,b=Ok(a,f))),1===b))throw c=qk,Lk(a,0),Dk(a,d),Ek(a,B()),c;a.finishedWork=e;a.finishedLanes=d;switch(b){case 0:case 1:throw Error(p(345));case 2:Qk(a,uk,vk);break;case 3:Dk(a,d);if((d&130023424)===d&&(b=gk+500-B(),10<b)){if(0!==uc(a,0))break;e=a.suspendedLanes;if((e&d)!==d){L();a.pingedLanes|=a.suspendedLanes&e;break}a.timeoutHandle=Ff(Qk.bind(null,a,uk,vk),b);break}Qk(a,uk,vk);break;case 4:Dk(a,d);if((d&4194240)===
d)break;b=a.eventTimes;for(e=-1;0<d;){var g=31-oc(d);f=1<<g;g=b[g];g>e&&(e=g);d&=~f}d=e;d=B()-d;d=(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*mk(d/1960))-d;if(10<d){a.timeoutHandle=Ff(Qk.bind(null,a,uk,vk),d);break}Qk(a,uk,vk);break;case 5:Qk(a,uk,vk);break;default:throw Error(p(329));}}}Ek(a,B());return a.callbackNode===c?Hk.bind(null,a):null}
function Ok(a,b){var c=tk;a.current.memoizedState.isDehydrated&&(Lk(a,b).flags|=256);a=Jk(a,b);2!==a&&(b=uk,uk=c,null!==b&&Gj(b));return a}function Gj(a){null===uk?uk=a:uk.push.apply(uk,a)}
function Pk(a){for(var b=a;;){if(b.flags&16384){var c=b.updateQueue;if(null!==c&&(c=c.stores,null!==c))for(var d=0;d<c.length;d++){var e=c[d],f=e.getSnapshot;e=e.value;try{if(!He(f(),e))return!1}catch(g){return!1}}}c=b.child;if(b.subtreeFlags&16384&&null!==c)c.return=b,b=c;else{if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return!0;b=b.return}b.sibling.return=b.return;b=b.sibling}}return!0}
function Dk(a,b){b&=~sk;b&=~rk;a.suspendedLanes|=b;a.pingedLanes&=~b;for(a=a.expirationTimes;0<b;){var c=31-oc(b),d=1<<c;a[c]=-1;b&=~d}}function Fk(a){if(0!==(K&6))throw Error(p(327));Ik();var b=uc(a,0);if(0===(b&1))return Ek(a,B()),null;var c=Jk(a,b);if(0!==a.tag&&2===c){var d=xc(a);0!==d&&(b=d,c=Ok(a,d))}if(1===c)throw c=qk,Lk(a,0),Dk(a,b),Ek(a,B()),c;if(6===c)throw Error(p(345));a.finishedWork=a.current.alternate;a.finishedLanes=b;Qk(a,uk,vk);Ek(a,B());return null}
function Rk(a,b){var c=K;K|=1;try{return a(b)}finally{K=c,0===K&&(Hj=B()+500,fg&&jg())}}function Sk(a){null!==xk&&0===xk.tag&&0===(K&6)&&Ik();var b=K;K|=1;var c=pk.transition,d=C;try{if(pk.transition=null,C=1,a)return a()}finally{C=d,pk.transition=c,K=b,0===(K&6)&&jg()}}function Ij(){gj=fj.current;E(fj)}
function Lk(a,b){a.finishedWork=null;a.finishedLanes=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,Gf(c));if(null!==Y)for(c=Y.return;null!==c;){var d=c;wg(d);switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&$f();break;case 3:Jh();E(Wf);E(H);Oh();break;case 5:Lh(d);break;case 4:Jh();break;case 13:E(M);break;case 19:E(M);break;case 10:Rg(d.type._context);break;case 22:case 23:Ij()}c=c.return}R=a;Y=a=wh(a.current,null);Z=gj=b;T=0;qk=null;sk=rk=hh=0;uk=tk=null;if(null!==Wg){for(b=
0;b<Wg.length;b++)if(c=Wg[b],d=c.interleaved,null!==d){c.interleaved=null;var e=d.next,f=c.pending;if(null!==f){var g=f.next;f.next=e;d.next=g}c.pending=d}Wg=null}return a}
function Nk(a,b){do{var c=Y;try{Qg();Ph.current=ai;if(Sh){for(var d=N.memoizedState;null!==d;){var e=d.queue;null!==e&&(e.pending=null);d=d.next}Sh=!1}Rh=0;P=O=N=null;Th=!1;Uh=0;ok.current=null;if(null===c||null===c.return){T=1;qk=b;Y=null;break}a:{var f=a,g=c.return,h=c,k=b;b=Z;h.flags|=32768;if(null!==k&&"object"===typeof k&&"function"===typeof k.then){var l=k,m=h,q=m.tag;if(0===(m.mode&1)&&(0===q||11===q||15===q)){var r=m.alternate;r?(m.updateQueue=r.updateQueue,m.memoizedState=r.memoizedState,
m.lanes=r.lanes):(m.updateQueue=null,m.memoizedState=null)}var y=Vi(g);if(null!==y){y.flags&=-257;Wi(y,g,h,f,b);y.mode&1&&Ti(f,l,b);b=y;k=l;var n=b.updateQueue;if(null===n){var t=new Set;t.add(k);b.updateQueue=t}else n.add(k);break a}else{if(0===(b&1)){Ti(f,l,b);uj();break a}k=Error(p(426))}}else if(I&&h.mode&1){var J=Vi(g);if(null!==J){0===(J.flags&65536)&&(J.flags|=256);Wi(J,g,h,f,b);Jg(Ki(k,h));break a}}f=k=Ki(k,h);4!==T&&(T=2);null===tk?tk=[f]:tk.push(f);f=g;do{switch(f.tag){case 3:f.flags|=65536;
b&=-b;f.lanes|=b;var x=Oi(f,k,b);fh(f,x);break a;case 1:h=k;var w=f.type,u=f.stateNode;if(0===(f.flags&128)&&("function"===typeof w.getDerivedStateFromError||null!==u&&"function"===typeof u.componentDidCatch&&(null===Si||!Si.has(u)))){f.flags|=65536;b&=-b;f.lanes|=b;var F=Ri(f,h,b);fh(f,F);break a}}f=f.return}while(null!==f)}Tk(c)}catch(na){b=na;Y===c&&null!==c&&(Y=c=c.return);continue}break}while(1)}function Kk(){var a=nk.current;nk.current=ai;return null===a?ai:a}
function uj(){if(0===T||3===T||2===T)T=4;null===R||0===(hh&268435455)&&0===(rk&268435455)||Dk(R,Z)}function Jk(a,b){var c=K;K|=2;var d=Kk();if(R!==a||Z!==b)vk=null,Lk(a,b);do try{Uk();break}catch(e){Nk(a,e)}while(1);Qg();K=c;nk.current=d;if(null!==Y)throw Error(p(261));R=null;Z=0;return T}function Uk(){for(;null!==Y;)Vk(Y)}function Mk(){for(;null!==Y&&!cc();)Vk(Y)}function Vk(a){var b=Wk(a.alternate,a,gj);a.memoizedProps=a.pendingProps;null===b?Tk(a):Y=b;ok.current=null}
function Tk(a){var b=a;do{var c=b.alternate;a=b.return;if(0===(b.flags&32768)){if(c=Fj(c,b,gj),null!==c){Y=c;return}}else{c=Jj(c,b);if(null!==c){c.flags&=32767;Y=c;return}if(null!==a)a.flags|=32768,a.subtreeFlags=0,a.deletions=null;else{T=6;Y=null;return}}b=b.sibling;if(null!==b){Y=b;return}Y=b=a}while(null!==b);0===T&&(T=5)}function Qk(a,b,c){var d=C,e=pk.transition;try{pk.transition=null,C=1,Xk(a,b,c,d)}finally{pk.transition=e,C=d}return null}
function Xk(a,b,c,d){do Ik();while(null!==xk);if(0!==(K&6))throw Error(p(327));c=a.finishedWork;var e=a.finishedLanes;if(null===c)return null;a.finishedWork=null;a.finishedLanes=0;if(c===a.current)throw Error(p(177));a.callbackNode=null;a.callbackPriority=0;var f=c.lanes|c.childLanes;Bc(a,f);a===R&&(Y=R=null,Z=0);0===(c.subtreeFlags&2064)&&0===(c.flags&2064)||wk||(wk=!0,Gk(hc,function(){Ik();return null}));f=0!==(c.flags&15990);if(0!==(c.subtreeFlags&15990)||f){f=pk.transition;pk.transition=null;
var g=C;C=1;var h=K;K|=4;ok.current=null;Pj(a,c);ek(c,a);Oe(Df);dd=!!Cf;Df=Cf=null;a.current=c;ik(c,a,e);dc();K=h;C=g;pk.transition=f}else a.current=c;wk&&(wk=!1,xk=a,yk=e);f=a.pendingLanes;0===f&&(Si=null);mc(c.stateNode,d);Ek(a,B());if(null!==b)for(d=a.onRecoverableError,c=0;c<b.length;c++)e=b[c],d(e.value,{componentStack:e.stack,digest:e.digest});if(Pi)throw Pi=!1,a=Qi,Qi=null,a;0!==(yk&1)&&0!==a.tag&&Ik();f=a.pendingLanes;0!==(f&1)?a===Ak?zk++:(zk=0,Ak=a):zk=0;jg();return null}
function Ik(){if(null!==xk){var a=Dc(yk),b=pk.transition,c=C;try{pk.transition=null;C=16>a?16:a;if(null===xk)var d=!1;else{a=xk;xk=null;yk=0;if(0!==(K&6))throw Error(p(331));var e=K;K|=4;for(V=a.current;null!==V;){var f=V,g=f.child;if(0!==(V.flags&16)){var h=f.deletions;if(null!==h){for(var k=0;k<h.length;k++){var l=h[k];for(V=l;null!==V;){var m=V;switch(m.tag){case 0:case 11:case 15:Qj(8,m,f)}var q=m.child;if(null!==q)q.return=m,V=q;else for(;null!==V;){m=V;var r=m.sibling,y=m.return;Tj(m);if(m===
l){V=null;break}if(null!==r){r.return=y;V=r;break}V=y}}}var n=f.alternate;if(null!==n){var t=n.child;if(null!==t){n.child=null;do{var J=t.sibling;t.sibling=null;t=J}while(null!==t)}}V=f}}if(0!==(f.subtreeFlags&2064)&&null!==g)g.return=f,V=g;else b:for(;null!==V;){f=V;if(0!==(f.flags&2048))switch(f.tag){case 0:case 11:case 15:Qj(9,f,f.return)}var x=f.sibling;if(null!==x){x.return=f.return;V=x;break b}V=f.return}}var w=a.current;for(V=w;null!==V;){g=V;var u=g.child;if(0!==(g.subtreeFlags&2064)&&null!==
u)u.return=g,V=u;else b:for(g=w;null!==V;){h=V;if(0!==(h.flags&2048))try{switch(h.tag){case 0:case 11:case 15:Rj(9,h)}}catch(na){W(h,h.return,na)}if(h===g){V=null;break b}var F=h.sibling;if(null!==F){F.return=h.return;V=F;break b}V=h.return}}K=e;jg();if(lc&&"function"===typeof lc.onPostCommitFiberRoot)try{lc.onPostCommitFiberRoot(kc,a)}catch(na){}d=!0}return d}finally{C=c,pk.transition=b}}return!1}function Yk(a,b,c){b=Ki(c,b);b=Oi(a,b,1);a=dh(a,b,1);b=L();null!==a&&(Ac(a,1,b),Ek(a,b))}
function W(a,b,c){if(3===a.tag)Yk(a,a,c);else for(;null!==b;){if(3===b.tag){Yk(b,a,c);break}else if(1===b.tag){var d=b.stateNode;if("function"===typeof b.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===Si||!Si.has(d))){a=Ki(c,a);a=Ri(b,a,1);b=dh(b,a,1);a=L();null!==b&&(Ac(b,1,a),Ek(b,a));break}}b=b.return}}
function Ui(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);b=L();a.pingedLanes|=a.suspendedLanes&c;R===a&&(Z&c)===c&&(4===T||3===T&&(Z&130023424)===Z&&500>B()-gk?Lk(a,0):sk|=c);Ek(a,b)}function Zk(a,b){0===b&&(0===(a.mode&1)?b=1:(b=sc,sc<<=1,0===(sc&130023424)&&(sc=4194304)));var c=L();a=Zg(a,b);null!==a&&(Ac(a,b,c),Ek(a,c))}function vj(a){var b=a.memoizedState,c=0;null!==b&&(c=b.retryLane);Zk(a,c)}
function ck(a,b){var c=0;switch(a.tag){case 13:var d=a.stateNode;var e=a.memoizedState;null!==e&&(c=e.retryLane);break;case 19:d=a.stateNode;break;default:throw Error(p(314));}null!==d&&d.delete(b);Zk(a,c)}var Wk;
Wk=function(a,b,c){if(null!==a)if(a.memoizedProps!==b.pendingProps||Wf.current)Ug=!0;else{if(0===(a.lanes&c)&&0===(b.flags&128))return Ug=!1,zj(a,b,c);Ug=0!==(a.flags&131072)?!0:!1}else Ug=!1,I&&0!==(b.flags&1048576)&&ug(b,ng,b.index);b.lanes=0;switch(b.tag){case 2:var d=b.type;jj(a,b);a=b.pendingProps;var e=Yf(b,H.current);Tg(b,c);e=Xh(null,b,d,a,e,c);var f=bi();b.flags|=1;"object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof?(b.tag=1,b.memoizedState=null,b.updateQueue=
null,Zf(d)?(f=!0,cg(b)):f=!1,b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null,ah(b),e.updater=nh,b.stateNode=e,e._reactInternals=b,rh(b,d,a,c),b=kj(null,b,d,!0,f,c)):(b.tag=0,I&&f&&vg(b),Yi(null,b,e,c),b=b.child);return b;case 16:d=b.elementType;a:{jj(a,b);a=b.pendingProps;e=d._init;d=e(d._payload);b.type=d;e=b.tag=$k(d);a=Lg(d,a);switch(e){case 0:b=dj(null,b,d,a,c);break a;case 1:b=ij(null,b,d,a,c);break a;case 11:b=Zi(null,b,d,a,c);break a;case 14:b=aj(null,b,d,Lg(d.type,a),c);break a}throw Error(p(306,
d,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:Lg(d,e),dj(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:Lg(d,e),ij(a,b,d,e,c);case 3:a:{lj(b);if(null===a)throw Error(p(387));d=b.pendingProps;f=b.memoizedState;e=f.element;bh(a,b);gh(b,d,null,c);var g=b.memoizedState;d=g.element;if(f.isDehydrated)if(f={element:d,isDehydrated:!1,cache:g.cache,pendingSuspenseBoundaries:g.pendingSuspenseBoundaries,transitions:g.transitions},b.updateQueue.baseState=
f,b.memoizedState=f,b.flags&256){e=Ki(Error(p(423)),b);b=mj(a,b,d,c,e);break a}else if(d!==e){e=Ki(Error(p(424)),b);b=mj(a,b,d,c,e);break a}else for(yg=Lf(b.stateNode.containerInfo.firstChild),xg=b,I=!0,zg=null,c=Ch(b,null,d,c),b.child=c;c;)c.flags=c.flags&-3|4096,c=c.sibling;else{Ig();if(d===e){b=$i(a,b,c);break a}Yi(a,b,d,c)}b=b.child}return b;case 5:return Kh(b),null===a&&Eg(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:null,g=e.children,Ef(d,e)?g=null:null!==f&&Ef(d,f)&&(b.flags|=32),
hj(a,b),Yi(a,b,g,c),b.child;case 6:return null===a&&Eg(b),null;case 13:return pj(a,b,c);case 4:return Ih(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=Bh(b,null,d,c):Yi(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:Lg(d,e),Zi(a,b,d,e,c);case 7:return Yi(a,b,b.pendingProps,c),b.child;case 8:return Yi(a,b,b.pendingProps.children,c),b.child;case 12:return Yi(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;f=b.memoizedProps;
g=e.value;G(Mg,d._currentValue);d._currentValue=g;if(null!==f)if(He(f.value,g)){if(f.children===e.children&&!Wf.current){b=$i(a,b,c);break a}}else for(f=b.child,null!==f&&(f.return=b);null!==f;){var h=f.dependencies;if(null!==h){g=f.child;for(var k=h.firstContext;null!==k;){if(k.context===d){if(1===f.tag){k=ch(-1,c&-c);k.tag=2;var l=f.updateQueue;if(null!==l){l=l.shared;var m=l.pending;null===m?k.next=k:(k.next=m.next,m.next=k);l.pending=k}}f.lanes|=c;k=f.alternate;null!==k&&(k.lanes|=c);Sg(f.return,
c,b);h.lanes|=c;break}k=k.next}}else if(10===f.tag)g=f.type===b.type?null:f.child;else if(18===f.tag){g=f.return;if(null===g)throw Error(p(341));g.lanes|=c;h=g.alternate;null!==h&&(h.lanes|=c);Sg(g,c,b);g=f.sibling}else g=f.child;if(null!==g)g.return=f;else for(g=f;null!==g;){if(g===b){g=null;break}f=g.sibling;if(null!==f){f.return=g.return;g=f;break}g=g.return}f=g}Yi(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,d=b.pendingProps.children,Tg(b,c),e=Vg(e),d=d(e),b.flags|=1,Yi(a,b,d,c),
b.child;case 14:return d=b.type,e=Lg(d,b.pendingProps),e=Lg(d.type,e),aj(a,b,d,e,c);case 15:return cj(a,b,b.type,b.pendingProps,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:Lg(d,e),jj(a,b),b.tag=1,Zf(d)?(a=!0,cg(b)):a=!1,Tg(b,c),ph(b,d,e),rh(b,d,e,c),kj(null,b,d,!0,a,c);case 19:return yj(a,b,c);case 22:return ej(a,b,c)}throw Error(p(156,b.tag));};function Gk(a,b){return ac(a,b)}
function al(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.subtreeFlags=this.flags=0;this.deletions=null;this.childLanes=this.lanes=0;this.alternate=null}function Bg(a,b,c,d){return new al(a,b,c,d)}function bj(a){a=a.prototype;return!(!a||!a.isReactComponent)}
function $k(a){if("function"===typeof a)return bj(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===Da)return 11;if(a===Ga)return 14}return 2}
function wh(a,b){var c=a.alternate;null===c?(c=Bg(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.type=a.type,c.flags=0,c.subtreeFlags=0,c.deletions=null);c.flags=a.flags&14680064;c.childLanes=a.childLanes;c.lanes=a.lanes;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{lanes:b.lanes,firstContext:b.firstContext};
c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}
function yh(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)bj(a)&&(g=1);else if("string"===typeof a)g=5;else a:switch(a){case ya:return Ah(c.children,e,f,b);case za:g=8;e|=8;break;case Aa:return a=Bg(12,c,b,e|2),a.elementType=Aa,a.lanes=f,a;case Ea:return a=Bg(13,c,b,e),a.elementType=Ea,a.lanes=f,a;case Fa:return a=Bg(19,c,b,e),a.elementType=Fa,a.lanes=f,a;case Ia:return qj(c,e,f,b);default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case Ba:g=10;break a;case Ca:g=9;break a;case Da:g=11;
break a;case Ga:g=14;break a;case Ha:g=16;d=null;break a}throw Error(p(130,null==a?a:typeof a,""));}b=Bg(g,c,b,e);b.elementType=a;b.type=d;b.lanes=f;return b}function Ah(a,b,c,d){a=Bg(7,a,d,b);a.lanes=c;return a}function qj(a,b,c,d){a=Bg(22,a,d,b);a.elementType=Ia;a.lanes=c;a.stateNode={isHidden:!1};return a}function xh(a,b,c){a=Bg(6,a,null,b);a.lanes=c;return a}
function zh(a,b,c){b=Bg(4,null!==a.children?a.children:[],a.key,b);b.lanes=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}
function bl(a,b,c,d,e){this.tag=b;this.containerInfo=a;this.finishedWork=this.pingCache=this.current=this.pendingChildren=null;this.timeoutHandle=-1;this.callbackNode=this.pendingContext=this.context=null;this.callbackPriority=0;this.eventTimes=zc(0);this.expirationTimes=zc(-1);this.entangledLanes=this.finishedLanes=this.mutableReadLanes=this.expiredLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0;this.entanglements=zc(0);this.identifierPrefix=d;this.onRecoverableError=e;this.mutableSourceEagerHydrationData=
null}function cl(a,b,c,d,e,f,g,h,k){a=new bl(a,b,c,h,k);1===b?(b=1,!0===f&&(b|=8)):b=0;f=Bg(3,null,null,b);a.current=f;f.stateNode=a;f.memoizedState={element:d,isDehydrated:c,cache:null,transitions:null,pendingSuspenseBoundaries:null};ah(f);return a}function dl(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:wa,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}
function el(a){if(!a)return Vf;a=a._reactInternals;a:{if(Vb(a)!==a||1!==a.tag)throw Error(p(170));var b=a;do{switch(b.tag){case 3:b=b.stateNode.context;break a;case 1:if(Zf(b.type)){b=b.stateNode.__reactInternalMemoizedMergedChildContext;break a}}b=b.return}while(null!==b);throw Error(p(171));}if(1===a.tag){var c=a.type;if(Zf(c))return bg(a,c,b)}return b}
function fl(a,b,c,d,e,f,g,h,k){a=cl(c,d,!0,a,e,f,g,h,k);a.context=el(null);c=a.current;d=L();e=lh(c);f=ch(d,e);f.callback=void 0!==b&&null!==b?b:null;dh(c,f,e);a.current.lanes=e;Ac(a,e,d);Ek(a,d);return a}function gl(a,b,c,d){var e=b.current,f=L(),g=lh(e);c=el(c);null===b.context?b.context=c:b.pendingContext=c;b=ch(f,g);b.payload={element:a};d=void 0===d?null:d;null!==d&&(b.callback=d);a=dh(e,b,g);null!==a&&(mh(a,e,g,f),eh(a,e,g));return g}
function hl(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function il(a,b){a=a.memoizedState;if(null!==a&&null!==a.dehydrated){var c=a.retryLane;a.retryLane=0!==c&&c<b?c:b}}function jl(a,b){il(a,b);(a=a.alternate)&&il(a,b)}function kl(){return null}var ll="function"===typeof reportError?reportError:function(a){console.error(a)};function ml(a){this._internalRoot=a}
nl.prototype.render=ml.prototype.render=function(a){var b=this._internalRoot;if(null===b)throw Error(p(409));gl(a,b,null,null)};nl.prototype.unmount=ml.prototype.unmount=function(){var a=this._internalRoot;if(null!==a){this._internalRoot=null;var b=a.containerInfo;Sk(function(){gl(null,a,null,null)});b[uf]=null}};function nl(a){this._internalRoot=a}
nl.prototype.unstable_scheduleHydration=function(a){if(a){var b=Hc();a={blockedOn:null,target:a,priority:b};for(var c=0;c<Qc.length&&0!==b&&b<Qc[c].priority;c++);Qc.splice(c,0,a);0===c&&Vc(a)}};function ol(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType)}function pl(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}function ql(){}
function rl(a,b,c,d,e){if(e){if("function"===typeof d){var f=d;d=function(){var a=hl(g);f.call(a)}}var g=fl(b,d,a,0,null,!1,!1,"",ql);a._reactRootContainer=g;a[uf]=g.current;sf(8===a.nodeType?a.parentNode:a);Sk();return g}for(;e=a.lastChild;)a.removeChild(e);if("function"===typeof d){var h=d;d=function(){var a=hl(k);h.call(a)}}var k=cl(a,0,!1,null,null,!1,!1,"",ql);a._reactRootContainer=k;a[uf]=k.current;sf(8===a.nodeType?a.parentNode:a);Sk(function(){gl(b,k,c,d)});return k}
function sl(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f;if("function"===typeof e){var h=e;e=function(){var a=hl(g);h.call(a)}}gl(b,g,a,e)}else g=rl(c,b,a,e,d);return hl(g)}Ec=function(a){switch(a.tag){case 3:var b=a.stateNode;if(b.current.memoizedState.isDehydrated){var c=tc(b.pendingLanes);0!==c&&(Cc(b,c|1),Ek(b,B()),0===(K&6)&&(Hj=B()+500,jg()))}break;case 13:Sk(function(){var b=Zg(a,1);if(null!==b){var c=L();mh(b,a,1,c)}}),jl(a,1)}};
Fc=function(a){if(13===a.tag){var b=Zg(a,134217728);if(null!==b){var c=L();mh(b,a,134217728,c)}jl(a,134217728)}};Gc=function(a){if(13===a.tag){var b=lh(a),c=Zg(a,b);if(null!==c){var d=L();mh(c,a,b,d)}jl(a,b)}};Hc=function(){return C};Ic=function(a,b){var c=C;try{return C=a,b()}finally{C=c}};
yb=function(a,b,c){switch(b){case "input":bb(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=Db(d);if(!e)throw Error(p(90));Wa(d);bb(d,e)}}}break;case "textarea":ib(a,c);break;case "select":b=c.value,null!=b&&fb(a,!!c.multiple,b,!1)}};Gb=Rk;Hb=Sk;
var tl={usingClientEntryPoint:!1,Events:[Cb,ue,Db,Eb,Fb,Rk]},ul={findFiberByHostInstance:Wc,bundleType:0,version:"18.2.0",rendererPackageName:"react-dom"};
var vl={bundleType:ul.bundleType,version:ul.version,rendererPackageName:ul.rendererPackageName,rendererConfig:ul.rendererConfig,overrideHookState:null,overrideHookStateDeletePath:null,overrideHookStateRenamePath:null,overrideProps:null,overridePropsDeletePath:null,overridePropsRenamePath:null,setErrorHandler:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:ua.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=Zb(a);return null===a?null:a.stateNode},findFiberByHostInstance:ul.findFiberByHostInstance||
kl,findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null,reconcilerVersion:"18.2.0-next-9e3b772b8-20220608"};if("undefined"!==typeof __REACT_DEVTOOLS_GLOBAL_HOOK__){var wl=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!wl.isDisabled&&wl.supportsFiber)try{kc=wl.inject(vl),lc=wl}catch(a){}}exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=tl;
exports.createPortal=function(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;if(!ol(b))throw Error(p(200));return dl(a,b,null,c)};exports.createRoot=function(a,b){if(!ol(a))throw Error(p(299));var c=!1,d="",e=ll;null!==b&&void 0!==b&&(!0===b.unstable_strictMode&&(c=!0),void 0!==b.identifierPrefix&&(d=b.identifierPrefix),void 0!==b.onRecoverableError&&(e=b.onRecoverableError));b=cl(a,1,!1,null,null,c,!1,d,e);a[uf]=b.current;sf(8===a.nodeType?a.parentNode:a);return new ml(b)};
exports.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternals;if(void 0===b){if("function"===typeof a.render)throw Error(p(188));a=Object.keys(a).join(",");throw Error(p(268,a));}a=Zb(b);a=null===a?null:a.stateNode;return a};exports.flushSync=function(a){return Sk(a)};exports.hydrate=function(a,b,c){if(!pl(b))throw Error(p(200));return sl(null,a,b,!0,c)};
exports.hydrateRoot=function(a,b,c){if(!ol(a))throw Error(p(405));var d=null!=c&&c.hydratedSources||null,e=!1,f="",g=ll;null!==c&&void 0!==c&&(!0===c.unstable_strictMode&&(e=!0),void 0!==c.identifierPrefix&&(f=c.identifierPrefix),void 0!==c.onRecoverableError&&(g=c.onRecoverableError));b=fl(b,null,a,1,null!=c?c:null,e,!1,f,g);a[uf]=b.current;sf(a);if(d)for(a=0;a<d.length;a++)c=d[a],e=c._getVersion,e=e(c._source),null==b.mutableSourceEagerHydrationData?b.mutableSourceEagerHydrationData=[c,e]:b.mutableSourceEagerHydrationData.push(c,
e);return new nl(b)};exports.render=function(a,b,c){if(!pl(b))throw Error(p(200));return sl(null,a,b,!1,c)};exports.unmountComponentAtNode=function(a){if(!pl(a))throw Error(p(40));return a._reactRootContainer?(Sk(function(){sl(null,null,a,!1,function(){a._reactRootContainer=null;a[uf]=null})}),!0):!1};exports.unstable_batchedUpdates=Rk;
exports.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!pl(c))throw Error(p(200));if(null==a||void 0===a._reactInternals)throw Error(p(38));return sl(a,b,c,!1,d)};exports.version="18.2.0-next-9e3b772b8-20220608";


/***/ }),

/***/ 2412:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var m = __webpack_require__(7668);
if (true) {
  exports.createRoot = m.createRoot;
  exports.hydrateRoot = m.hydrateRoot;
} else { var i; }


/***/ }),

/***/ 7668:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


function checkDCE() {
  /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
  if (
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' ||
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function'
  ) {
    return;
  }
  if (false) {}
  try {
    // Verify that the code above has been dead code eliminated (DCE'd).
    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
  } catch (err) {
    // DevTools shouldn't crash React, no matter what.
    // We should still report in case we break this code.
    console.error(err);
  }
}

if (true) {
  // DCE check should happen before ReactDOM bundle executes so that
  // DevTools can report bad minification during injection.
  checkDCE();
  module.exports = __webpack_require__(1223);
} else {}


/***/ }),

/***/ 7829:
/***/ ((__unused_webpack_module, exports) => {

"use strict";
var __webpack_unused_export__;
/**
 * @license React
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var b=Symbol.for("react.element"),c=Symbol.for("react.portal"),d=Symbol.for("react.fragment"),e=Symbol.for("react.strict_mode"),f=Symbol.for("react.profiler"),g=Symbol.for("react.provider"),h=Symbol.for("react.context"),k=Symbol.for("react.server_context"),l=Symbol.for("react.forward_ref"),m=Symbol.for("react.suspense"),n=Symbol.for("react.suspense_list"),p=Symbol.for("react.memo"),q=Symbol.for("react.lazy"),t=Symbol.for("react.offscreen"),u;u=Symbol.for("react.module.reference");
function v(a){if("object"===typeof a&&null!==a){var r=a.$$typeof;switch(r){case b:switch(a=a.type,a){case d:case f:case e:case m:case n:return a;default:switch(a=a&&a.$$typeof,a){case k:case h:case l:case q:case p:case g:return a;default:return r}}case c:return r}}}__webpack_unused_export__=h;__webpack_unused_export__=g;__webpack_unused_export__=b;__webpack_unused_export__=l;__webpack_unused_export__=d;__webpack_unused_export__=q;__webpack_unused_export__=p;__webpack_unused_export__=c;__webpack_unused_export__=f;__webpack_unused_export__=e;__webpack_unused_export__=m;
__webpack_unused_export__=n;__webpack_unused_export__=function(){return!1};__webpack_unused_export__=function(){return!1};__webpack_unused_export__=function(a){return v(a)===h};__webpack_unused_export__=function(a){return v(a)===g};__webpack_unused_export__=function(a){return"object"===typeof a&&null!==a&&a.$$typeof===b};__webpack_unused_export__=function(a){return v(a)===l};__webpack_unused_export__=function(a){return v(a)===d};__webpack_unused_export__=function(a){return v(a)===q};__webpack_unused_export__=function(a){return v(a)===p};
__webpack_unused_export__=function(a){return v(a)===c};__webpack_unused_export__=function(a){return v(a)===f};__webpack_unused_export__=function(a){return v(a)===e};__webpack_unused_export__=function(a){return v(a)===m};__webpack_unused_export__=function(a){return v(a)===n};
exports.isValidElementType=function(a){return"string"===typeof a||"function"===typeof a||a===d||a===f||a===e||a===m||a===n||a===t||"object"===typeof a&&null!==a&&(a.$$typeof===q||a.$$typeof===p||a.$$typeof===g||a.$$typeof===h||a.$$typeof===l||a.$$typeof===u||void 0!==a.getModuleId)?!0:!1};exports.typeOf=v;


/***/ }),

/***/ 5167:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


if (true) {
  module.exports = __webpack_require__(7829);
} else {}


/***/ }),

/***/ 384:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "AbortedDeferredError": () => (/* reexport */ AbortedDeferredError),
  "Await": () => (/* reexport */ Await),
  "BrowserRouter": () => (/* binding */ BrowserRouter),
  "Form": () => (/* binding */ Form),
  "HashRouter": () => (/* binding */ HashRouter),
  "Link": () => (/* binding */ Link),
  "MemoryRouter": () => (/* reexport */ MemoryRouter),
  "NavLink": () => (/* binding */ NavLink),
  "Navigate": () => (/* reexport */ Navigate),
  "NavigationType": () => (/* reexport */ Action),
  "Outlet": () => (/* reexport */ Outlet),
  "Route": () => (/* reexport */ Route),
  "Router": () => (/* reexport */ Router),
  "RouterProvider": () => (/* reexport */ RouterProvider),
  "Routes": () => (/* reexport */ Routes),
  "ScrollRestoration": () => (/* binding */ ScrollRestoration),
  "UNSAFE_DataRouterContext": () => (/* reexport */ DataRouterContext),
  "UNSAFE_DataRouterStateContext": () => (/* reexport */ DataRouterStateContext),
  "UNSAFE_DataStaticRouterContext": () => (/* reexport */ DataStaticRouterContext),
  "UNSAFE_LocationContext": () => (/* reexport */ LocationContext),
  "UNSAFE_NavigationContext": () => (/* reexport */ NavigationContext),
  "UNSAFE_RouteContext": () => (/* reexport */ RouteContext),
  "UNSAFE_enhanceManualRouteObjects": () => (/* reexport */ enhanceManualRouteObjects),
  "UNSAFE_useScrollRestoration": () => (/* binding */ useScrollRestoration),
  "createBrowserRouter": () => (/* binding */ createBrowserRouter),
  "createHashRouter": () => (/* binding */ createHashRouter),
  "createMemoryRouter": () => (/* reexport */ createMemoryRouter),
  "createPath": () => (/* reexport */ createPath),
  "createRoutesFromChildren": () => (/* reexport */ createRoutesFromChildren),
  "createRoutesFromElements": () => (/* reexport */ createRoutesFromChildren),
  "createSearchParams": () => (/* binding */ createSearchParams),
  "defer": () => (/* reexport */ defer),
  "generatePath": () => (/* reexport */ generatePath),
  "isRouteErrorResponse": () => (/* reexport */ isRouteErrorResponse),
  "json": () => (/* reexport */ json),
  "matchPath": () => (/* reexport */ matchPath),
  "matchRoutes": () => (/* reexport */ matchRoutes),
  "parsePath": () => (/* reexport */ parsePath),
  "redirect": () => (/* reexport */ redirect),
  "renderMatches": () => (/* reexport */ renderMatches),
  "resolvePath": () => (/* reexport */ resolvePath),
  "unstable_HistoryRouter": () => (/* binding */ HistoryRouter),
  "useActionData": () => (/* reexport */ useActionData),
  "useAsyncError": () => (/* reexport */ useAsyncError),
  "useAsyncValue": () => (/* reexport */ useAsyncValue),
  "useBeforeUnload": () => (/* binding */ useBeforeUnload),
  "useFetcher": () => (/* binding */ useFetcher),
  "useFetchers": () => (/* binding */ useFetchers),
  "useFormAction": () => (/* binding */ useFormAction),
  "useHref": () => (/* reexport */ useHref),
  "useInRouterContext": () => (/* reexport */ useInRouterContext),
  "useLinkClickHandler": () => (/* binding */ useLinkClickHandler),
  "useLoaderData": () => (/* reexport */ useLoaderData),
  "useLocation": () => (/* reexport */ useLocation),
  "useMatch": () => (/* reexport */ useMatch),
  "useMatches": () => (/* reexport */ useMatches),
  "useNavigate": () => (/* reexport */ useNavigate),
  "useNavigation": () => (/* reexport */ useNavigation),
  "useNavigationType": () => (/* reexport */ useNavigationType),
  "useOutlet": () => (/* reexport */ useOutlet),
  "useOutletContext": () => (/* reexport */ useOutletContext),
  "useParams": () => (/* reexport */ useParams),
  "useResolvedPath": () => (/* reexport */ useResolvedPath),
  "useRevalidator": () => (/* reexport */ useRevalidator),
  "useRouteError": () => (/* reexport */ useRouteError),
  "useRouteLoaderData": () => (/* reexport */ useRouteLoaderData),
  "useRoutes": () => (/* reexport */ useRoutes),
  "useSearchParams": () => (/* binding */ useSearchParams),
  "useSubmit": () => (/* binding */ useSubmit)
});

// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(4191);
var react_namespaceObject = /*#__PURE__*/__webpack_require__.t(react, 2);
;// CONCATENATED MODULE: ./node_modules/@remix-run/router/dist/router.js
/**
 * @remix-run/router v1.2.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends.apply(this, arguments);
}

////////////////////////////////////////////////////////////////////////////////
//#region Types and Constants
////////////////////////////////////////////////////////////////////////////////

/**
 * Actions represent the type of change to a location value.
 */
var Action;

(function (Action) {
  /**
   * A POP indicates a change to an arbitrary index in the history stack, such
   * as a back or forward navigation. It does not describe the direction of the
   * navigation, only that the current index changed.
   *
   * Note: This is the default action for newly created history objects.
   */
  Action["Pop"] = "POP";
  /**
   * A PUSH indicates a new entry being added to the history stack, such as when
   * a link is clicked and a new page loads. When this happens, all subsequent
   * entries in the stack are lost.
   */

  Action["Push"] = "PUSH";
  /**
   * A REPLACE indicates the entry at the current index in the history stack
   * being replaced by a new one.
   */

  Action["Replace"] = "REPLACE";
})(Action || (Action = {}));

const PopStateEventType = "popstate";
/**
 * Memory history stores the current location in memory. It is designed for use
 * in stateful non-browser environments like tests and React Native.
 */

function createMemoryHistory(options) {
  if (options === void 0) {
    options = {};
  }

  let {
    initialEntries = ["/"],
    initialIndex,
    v5Compat = false
  } = options;
  let entries; // Declare so we can access from createMemoryLocation

  entries = initialEntries.map((entry, index) => createMemoryLocation(entry, typeof entry === "string" ? null : entry.state, index === 0 ? "default" : undefined));
  let index = clampIndex(initialIndex == null ? entries.length - 1 : initialIndex);
  let action = Action.Pop;
  let listener = null;

  function clampIndex(n) {
    return Math.min(Math.max(n, 0), entries.length - 1);
  }

  function getCurrentLocation() {
    return entries[index];
  }

  function createMemoryLocation(to, state, key) {
    if (state === void 0) {
      state = null;
    }

    let location = createLocation(entries ? getCurrentLocation().pathname : "/", to, state, key);
    warning$1(location.pathname.charAt(0) === "/", "relative pathnames are not supported in memory history: " + JSON.stringify(to));
    return location;
  }

  let history = {
    get index() {
      return index;
    },

    get action() {
      return action;
    },

    get location() {
      return getCurrentLocation();
    },

    createHref(to) {
      return typeof to === "string" ? to : createPath(to);
    },

    encodeLocation(to) {
      let path = typeof to === "string" ? parsePath(to) : to;
      return {
        pathname: path.pathname || "",
        search: path.search || "",
        hash: path.hash || ""
      };
    },

    push(to, state) {
      action = Action.Push;
      let nextLocation = createMemoryLocation(to, state);
      index += 1;
      entries.splice(index, entries.length, nextLocation);

      if (v5Compat && listener) {
        listener({
          action,
          location: nextLocation
        });
      }
    },

    replace(to, state) {
      action = Action.Replace;
      let nextLocation = createMemoryLocation(to, state);
      entries[index] = nextLocation;

      if (v5Compat && listener) {
        listener({
          action,
          location: nextLocation
        });
      }
    },

    go(delta) {
      action = Action.Pop;
      index = clampIndex(index + delta);

      if (listener) {
        listener({
          action,
          location: getCurrentLocation()
        });
      }
    },

    listen(fn) {
      listener = fn;
      return () => {
        listener = null;
      };
    }

  };
  return history;
}
/**
 * Browser history stores the location in regular URLs. This is the standard for
 * most web apps, but it requires some configuration on the server to ensure you
 * serve the same app at multiple URLs.
 *
 * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createbrowserhistory
 */

function createBrowserHistory(options) {
  if (options === void 0) {
    options = {};
  }

  function createBrowserLocation(window, globalHistory) {
    let {
      pathname,
      search,
      hash
    } = window.location;
    return createLocation("", {
      pathname,
      search,
      hash
    }, // state defaults to `null` because `window.history.state` does
    globalHistory.state && globalHistory.state.usr || null, globalHistory.state && globalHistory.state.key || "default");
  }

  function createBrowserHref(window, to) {
    return typeof to === "string" ? to : createPath(to);
  }

  return getUrlBasedHistory(createBrowserLocation, createBrowserHref, null, options);
}
/**
 * Hash history stores the location in window.location.hash. This makes it ideal
 * for situations where you don't want to send the location to the server for
 * some reason, either because you do cannot configure it or the URL space is
 * reserved for something else.
 *
 * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createhashhistory
 */

function createHashHistory(options) {
  if (options === void 0) {
    options = {};
  }

  function createHashLocation(window, globalHistory) {
    let {
      pathname = "/",
      search = "",
      hash = ""
    } = parsePath(window.location.hash.substr(1));
    return createLocation("", {
      pathname,
      search,
      hash
    }, // state defaults to `null` because `window.history.state` does
    globalHistory.state && globalHistory.state.usr || null, globalHistory.state && globalHistory.state.key || "default");
  }

  function createHashHref(window, to) {
    let base = window.document.querySelector("base");
    let href = "";

    if (base && base.getAttribute("href")) {
      let url = window.location.href;
      let hashIndex = url.indexOf("#");
      href = hashIndex === -1 ? url : url.slice(0, hashIndex);
    }

    return href + "#" + (typeof to === "string" ? to : createPath(to));
  }

  function validateHashLocation(location, to) {
    warning$1(location.pathname.charAt(0) === "/", "relative pathnames are not supported in hash history.push(" + JSON.stringify(to) + ")");
  }

  return getUrlBasedHistory(createHashLocation, createHashHref, validateHashLocation, options);
}
function invariant(value, message) {
  if (value === false || value === null || typeof value === "undefined") {
    throw new Error(message);
  }
}

function warning$1(cond, message) {
  if (!cond) {
    // eslint-disable-next-line no-console
    if (typeof console !== "undefined") console.warn(message);

    try {
      // Welcome to debugging history!
      //
      // This error is thrown as a convenience so you can more easily
      // find the source for a warning that appears in the console by
      // enabling "pause on exceptions" in your JavaScript debugger.
      throw new Error(message); // eslint-disable-next-line no-empty
    } catch (e) {}
  }
}

function createKey() {
  return Math.random().toString(36).substr(2, 8);
}
/**
 * For browser-based histories, we combine the state and key into an object
 */


function getHistoryState(location) {
  return {
    usr: location.state,
    key: location.key
  };
}
/**
 * Creates a Location object with a unique key from the given Path
 */


function createLocation(current, to, state, key) {
  if (state === void 0) {
    state = null;
  }

  let location = _extends({
    pathname: typeof current === "string" ? current : current.pathname,
    search: "",
    hash: ""
  }, typeof to === "string" ? parsePath(to) : to, {
    state,
    // TODO: This could be cleaned up.  push/replace should probably just take
    // full Locations now and avoid the need to run through this flow at all
    // But that's a pretty big refactor to the current test suite so going to
    // keep as is for the time being and just let any incoming keys take precedence
    key: to && to.key || key || createKey()
  });

  return location;
}
/**
 * Creates a string URL path from the given pathname, search, and hash components.
 */

function createPath(_ref) {
  let {
    pathname = "/",
    search = "",
    hash = ""
  } = _ref;
  if (search && search !== "?") pathname += search.charAt(0) === "?" ? search : "?" + search;
  if (hash && hash !== "#") pathname += hash.charAt(0) === "#" ? hash : "#" + hash;
  return pathname;
}
/**
 * Parses a string URL path into its separate pathname, search, and hash components.
 */

function parsePath(path) {
  let parsedPath = {};

  if (path) {
    let hashIndex = path.indexOf("#");

    if (hashIndex >= 0) {
      parsedPath.hash = path.substr(hashIndex);
      path = path.substr(0, hashIndex);
    }

    let searchIndex = path.indexOf("?");

    if (searchIndex >= 0) {
      parsedPath.search = path.substr(searchIndex);
      path = path.substr(0, searchIndex);
    }

    if (path) {
      parsedPath.pathname = path;
    }
  }

  return parsedPath;
}
function createClientSideURL(location) {
  // window.location.origin is "null" (the literal string value) in Firefox
  // under certain conditions, notably when serving from a local HTML file
  // See https://bugzilla.mozilla.org/show_bug.cgi?id=878297
  let base = typeof window !== "undefined" && typeof window.location !== "undefined" && window.location.origin !== "null" ? window.location.origin : window.location.href;
  let href = typeof location === "string" ? location : createPath(location);
  invariant(base, "No window.location.(origin|href) available to create URL for href: " + href);
  return new URL(href, base);
}

function getUrlBasedHistory(getLocation, createHref, validateLocation, options) {
  if (options === void 0) {
    options = {};
  }

  let {
    window = document.defaultView,
    v5Compat = false
  } = options;
  let globalHistory = window.history;
  let action = Action.Pop;
  let listener = null;

  function handlePop() {
    action = Action.Pop;

    if (listener) {
      listener({
        action,
        location: history.location
      });
    }
  }

  function push(to, state) {
    action = Action.Push;
    let location = createLocation(history.location, to, state);
    if (validateLocation) validateLocation(location, to);
    let historyState = getHistoryState(location);
    let url = history.createHref(location); // try...catch because iOS limits us to 100 pushState calls :/

    try {
      globalHistory.pushState(historyState, "", url);
    } catch (error) {
      // They are going to lose state here, but there is no real
      // way to warn them about it since the page will refresh...
      window.location.assign(url);
    }

    if (v5Compat && listener) {
      listener({
        action,
        location: history.location
      });
    }
  }

  function replace(to, state) {
    action = Action.Replace;
    let location = createLocation(history.location, to, state);
    if (validateLocation) validateLocation(location, to);
    let historyState = getHistoryState(location);
    let url = history.createHref(location);
    globalHistory.replaceState(historyState, "", url);

    if (v5Compat && listener) {
      listener({
        action,
        location: history.location
      });
    }
  }

  let history = {
    get action() {
      return action;
    },

    get location() {
      return getLocation(window, globalHistory);
    },

    listen(fn) {
      if (listener) {
        throw new Error("A history only accepts one active listener");
      }

      window.addEventListener(PopStateEventType, handlePop);
      listener = fn;
      return () => {
        window.removeEventListener(PopStateEventType, handlePop);
        listener = null;
      };
    },

    createHref(to) {
      return createHref(window, to);
    },

    encodeLocation(to) {
      // Encode a Location the same way window.location would
      let url = createClientSideURL(typeof to === "string" ? to : createPath(to));
      return {
        pathname: url.pathname,
        search: url.search,
        hash: url.hash
      };
    },

    push,
    replace,

    go(n) {
      return globalHistory.go(n);
    }

  };
  return history;
} //#endregion

var ResultType;

(function (ResultType) {
  ResultType["data"] = "data";
  ResultType["deferred"] = "deferred";
  ResultType["redirect"] = "redirect";
  ResultType["error"] = "error";
})(ResultType || (ResultType = {}));

function isIndexRoute(route) {
  return route.index === true;
} // Walk the route tree generating unique IDs where necessary so we are working
// solely with AgnosticDataRouteObject's within the Router


function convertRoutesToDataRoutes(routes, parentPath, allIds) {
  if (parentPath === void 0) {
    parentPath = [];
  }

  if (allIds === void 0) {
    allIds = new Set();
  }

  return routes.map((route, index) => {
    let treePath = [...parentPath, index];
    let id = typeof route.id === "string" ? route.id : treePath.join("-");
    invariant(route.index !== true || !route.children, "Cannot specify children on an index route");
    invariant(!allIds.has(id), "Found a route id collision on id \"" + id + "\".  Route " + "id's must be globally unique within Data Router usages");
    allIds.add(id);

    if (isIndexRoute(route)) {
      let indexRoute = _extends({}, route, {
        id
      });

      return indexRoute;
    } else {
      let pathOrLayoutRoute = _extends({}, route, {
        id,
        children: route.children ? convertRoutesToDataRoutes(route.children, treePath, allIds) : undefined
      });

      return pathOrLayoutRoute;
    }
  });
}
/**
 * Matches the given routes to a location and returns the match data.
 *
 * @see https://reactrouter.com/utils/match-routes
 */

function matchRoutes(routes, locationArg, basename) {
  if (basename === void 0) {
    basename = "/";
  }

  let location = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
  let pathname = stripBasename(location.pathname || "/", basename);

  if (pathname == null) {
    return null;
  }

  let branches = flattenRoutes(routes);
  rankRouteBranches(branches);
  let matches = null;

  for (let i = 0; matches == null && i < branches.length; ++i) {
    matches = matchRouteBranch(branches[i], // Incoming pathnames are generally encoded from either window.location
    // or from router.navigate, but we want to match against the unencoded
    // paths in the route definitions.  Memory router locations won't be
    // encoded here but there also shouldn't be anything to decode so this
    // should be a safe operation.  This avoids needing matchRoutes to be
    // history-aware.
    safelyDecodeURI(pathname));
  }

  return matches;
}

function flattenRoutes(routes, branches, parentsMeta, parentPath) {
  if (branches === void 0) {
    branches = [];
  }

  if (parentsMeta === void 0) {
    parentsMeta = [];
  }

  if (parentPath === void 0) {
    parentPath = "";
  }

  let flattenRoute = (route, index, relativePath) => {
    let meta = {
      relativePath: relativePath === undefined ? route.path || "" : relativePath,
      caseSensitive: route.caseSensitive === true,
      childrenIndex: index,
      route
    };

    if (meta.relativePath.startsWith("/")) {
      invariant(meta.relativePath.startsWith(parentPath), "Absolute route path \"" + meta.relativePath + "\" nested under path " + ("\"" + parentPath + "\" is not valid. An absolute child route path ") + "must start with the combined path of all its parent routes.");
      meta.relativePath = meta.relativePath.slice(parentPath.length);
    }

    let path = joinPaths([parentPath, meta.relativePath]);
    let routesMeta = parentsMeta.concat(meta); // Add the children before adding this route to the array so we traverse the
    // route tree depth-first and child routes appear before their parents in
    // the "flattened" version.

    if (route.children && route.children.length > 0) {
      invariant( // Our types know better, but runtime JS may not!
      // @ts-expect-error
      route.index !== true, "Index routes must not have child routes. Please remove " + ("all child routes from route path \"" + path + "\"."));
      flattenRoutes(route.children, branches, routesMeta, path);
    } // Routes without a path shouldn't ever match by themselves unless they are
    // index routes, so don't add them to the list of possible branches.


    if (route.path == null && !route.index) {
      return;
    }

    branches.push({
      path,
      score: computeScore(path, route.index),
      routesMeta
    });
  };

  routes.forEach((route, index) => {
    var _route$path;

    // coarse-grain check for optional params
    if (route.path === "" || !((_route$path = route.path) != null && _route$path.includes("?"))) {
      flattenRoute(route, index);
    } else {
      for (let exploded of explodeOptionalSegments(route.path)) {
        flattenRoute(route, index, exploded);
      }
    }
  });
  return branches;
}
/**
 * Computes all combinations of optional path segments for a given path,
 * excluding combinations that are ambiguous and of lower priority.
 *
 * For example, `/one/:two?/three/:four?/:five?` explodes to:
 * - `/one/three`
 * - `/one/:two/three`
 * - `/one/three/:four`
 * - `/one/three/:five`
 * - `/one/:two/three/:four`
 * - `/one/:two/three/:five`
 * - `/one/three/:four/:five`
 * - `/one/:two/three/:four/:five`
 */


function explodeOptionalSegments(path) {
  let segments = path.split("/");
  if (segments.length === 0) return [];
  let [first, ...rest] = segments; // Optional path segments are denoted by a trailing `?`

  let isOptional = first.endsWith("?"); // Compute the corresponding required segment: `foo?` -> `foo`

  let required = first.replace(/\?$/, "");

  if (rest.length === 0) {
    // Intepret empty string as omitting an optional segment
    // `["one", "", "three"]` corresponds to omitting `:two` from `/one/:two?/three` -> `/one/three`
    return isOptional ? [required, ""] : [required];
  }

  let restExploded = explodeOptionalSegments(rest.join("/"));
  let result = []; // All child paths with the prefix.  Do this for all children before the
  // optional version for all children so we get consistent ordering where the
  // parent optional aspect is preferred as required.  Otherwise, we can get
  // child sections interspersed where deeper optional segments are higher than
  // parent optional segments, where for example, /:two would explodes _earlier_
  // then /:one.  By always including the parent as required _for all children_
  // first, we avoid this issue

  result.push(...restExploded.map(subpath => subpath === "" ? required : [required, subpath].join("/"))); // Then if this is an optional value, add all child versions without

  if (isOptional) {
    result.push(...restExploded);
  } // for absolute paths, ensure `/` instead of empty segment


  return result.map(exploded => path.startsWith("/") && exploded === "" ? "/" : exploded);
}

function rankRouteBranches(branches) {
  branches.sort((a, b) => a.score !== b.score ? b.score - a.score // Higher score first
  : compareIndexes(a.routesMeta.map(meta => meta.childrenIndex), b.routesMeta.map(meta => meta.childrenIndex)));
}

const paramRe = /^:\w+$/;
const dynamicSegmentValue = 3;
const indexRouteValue = 2;
const emptySegmentValue = 1;
const staticSegmentValue = 10;
const splatPenalty = -2;

const isSplat = s => s === "*";

function computeScore(path, index) {
  let segments = path.split("/");
  let initialScore = segments.length;

  if (segments.some(isSplat)) {
    initialScore += splatPenalty;
  }

  if (index) {
    initialScore += indexRouteValue;
  }

  return segments.filter(s => !isSplat(s)).reduce((score, segment) => score + (paramRe.test(segment) ? dynamicSegmentValue : segment === "" ? emptySegmentValue : staticSegmentValue), initialScore);
}

function compareIndexes(a, b) {
  let siblings = a.length === b.length && a.slice(0, -1).every((n, i) => n === b[i]);
  return siblings ? // If two routes are siblings, we should try to match the earlier sibling
  // first. This allows people to have fine-grained control over the matching
  // behavior by simply putting routes with identical paths in the order they
  // want them tried.
  a[a.length - 1] - b[b.length - 1] : // Otherwise, it doesn't really make sense to rank non-siblings by index,
  // so they sort equally.
  0;
}

function matchRouteBranch(branch, pathname) {
  let {
    routesMeta
  } = branch;
  let matchedParams = {};
  let matchedPathname = "/";
  let matches = [];

  for (let i = 0; i < routesMeta.length; ++i) {
    let meta = routesMeta[i];
    let end = i === routesMeta.length - 1;
    let remainingPathname = matchedPathname === "/" ? pathname : pathname.slice(matchedPathname.length) || "/";
    let match = matchPath({
      path: meta.relativePath,
      caseSensitive: meta.caseSensitive,
      end
    }, remainingPathname);
    if (!match) return null;
    Object.assign(matchedParams, match.params);
    let route = meta.route;
    matches.push({
      // TODO: Can this as be avoided?
      params: matchedParams,
      pathname: joinPaths([matchedPathname, match.pathname]),
      pathnameBase: normalizePathname(joinPaths([matchedPathname, match.pathnameBase])),
      route
    });

    if (match.pathnameBase !== "/") {
      matchedPathname = joinPaths([matchedPathname, match.pathnameBase]);
    }
  }

  return matches;
}
/**
 * Returns a path with params interpolated.
 *
 * @see https://reactrouter.com/utils/generate-path
 */


function generatePath(originalPath, params) {
  if (params === void 0) {
    params = {};
  }

  let path = originalPath;

  if (path.endsWith("*") && path !== "*" && !path.endsWith("/*")) {
    warning(false, "Route path \"" + path + "\" will be treated as if it were " + ("\"" + path.replace(/\*$/, "/*") + "\" because the `*` character must ") + "always follow a `/` in the pattern. To get rid of this warning, " + ("please change the route path to \"" + path.replace(/\*$/, "/*") + "\"."));
    path = path.replace(/\*$/, "/*");
  }

  return path.replace(/^:(\w+)/g, (_, key) => {
    invariant(params[key] != null, "Missing \":" + key + "\" param");
    return params[key];
  }).replace(/\/:(\w+)/g, (_, key) => {
    invariant(params[key] != null, "Missing \":" + key + "\" param");
    return "/" + params[key];
  }).replace(/(\/?)\*/, (_, prefix, __, str) => {
    const star = "*";

    if (params[star] == null) {
      // If no splat was provided, trim the trailing slash _unless_ it's
      // the entire path
      return str === "/*" ? "/" : "";
    } // Apply the splat


    return "" + prefix + params[star];
  });
}
/**
 * Performs pattern matching on a URL pathname and returns information about
 * the match.
 *
 * @see https://reactrouter.com/utils/match-path
 */

function matchPath(pattern, pathname) {
  if (typeof pattern === "string") {
    pattern = {
      path: pattern,
      caseSensitive: false,
      end: true
    };
  }

  let [matcher, paramNames] = compilePath(pattern.path, pattern.caseSensitive, pattern.end);
  let match = pathname.match(matcher);
  if (!match) return null;
  let matchedPathname = match[0];
  let pathnameBase = matchedPathname.replace(/(.)\/+$/, "$1");
  let captureGroups = match.slice(1);
  let params = paramNames.reduce((memo, paramName, index) => {
    // We need to compute the pathnameBase here using the raw splat value
    // instead of using params["*"] later because it will be decoded then
    if (paramName === "*") {
      let splatValue = captureGroups[index] || "";
      pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\/+$/, "$1");
    }

    memo[paramName] = safelyDecodeURIComponent(captureGroups[index] || "", paramName);
    return memo;
  }, {});
  return {
    params,
    pathname: matchedPathname,
    pathnameBase,
    pattern
  };
}

function compilePath(path, caseSensitive, end) {
  if (caseSensitive === void 0) {
    caseSensitive = false;
  }

  if (end === void 0) {
    end = true;
  }

  warning(path === "*" || !path.endsWith("*") || path.endsWith("/*"), "Route path \"" + path + "\" will be treated as if it were " + ("\"" + path.replace(/\*$/, "/*") + "\" because the `*` character must ") + "always follow a `/` in the pattern. To get rid of this warning, " + ("please change the route path to \"" + path.replace(/\*$/, "/*") + "\"."));
  let paramNames = [];
  let regexpSource = "^" + path.replace(/\/*\*?$/, "") // Ignore trailing / and /*, we'll handle it below
  .replace(/^\/*/, "/") // Make sure it has a leading /
  .replace(/[\\.*+^$?{}|()[\]]/g, "\\$&") // Escape special regex chars
  .replace(/\/:(\w+)/g, (_, paramName) => {
    paramNames.push(paramName);
    return "/([^\\/]+)";
  });

  if (path.endsWith("*")) {
    paramNames.push("*");
    regexpSource += path === "*" || path === "/*" ? "(.*)$" // Already matched the initial /, just match the rest
    : "(?:\\/(.+)|\\/*)$"; // Don't include the / in params["*"]
  } else if (end) {
    // When matching to the end, ignore trailing slashes
    regexpSource += "\\/*$";
  } else if (path !== "" && path !== "/") {
    // If our path is non-empty and contains anything beyond an initial slash,
    // then we have _some_ form of path in our regex so we should expect to
    // match only if we find the end of this path segment.  Look for an optional
    // non-captured trailing slash (to match a portion of the URL) or the end
    // of the path (if we've matched to the end).  We used to do this with a
    // word boundary but that gives false positives on routes like
    // /user-preferences since `-` counts as a word boundary.
    regexpSource += "(?:(?=\\/|$))";
  } else ;

  let matcher = new RegExp(regexpSource, caseSensitive ? undefined : "i");
  return [matcher, paramNames];
}

function safelyDecodeURI(value) {
  try {
    return decodeURI(value);
  } catch (error) {
    warning(false, "The URL path \"" + value + "\" could not be decoded because it is is a " + "malformed URL segment. This is probably due to a bad percent " + ("encoding (" + error + ")."));
    return value;
  }
}

function safelyDecodeURIComponent(value, paramName) {
  try {
    return decodeURIComponent(value);
  } catch (error) {
    warning(false, "The value for the URL param \"" + paramName + "\" will not be decoded because" + (" the string \"" + value + "\" is a malformed URL segment. This is probably") + (" due to a bad percent encoding (" + error + ")."));
    return value;
  }
}
/**
 * @private
 */


function stripBasename(pathname, basename) {
  if (basename === "/") return pathname;

  if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {
    return null;
  } // We want to leave trailing slash behavior in the user's control, so if they
  // specify a basename with a trailing slash, we should support it


  let startIndex = basename.endsWith("/") ? basename.length - 1 : basename.length;
  let nextChar = pathname.charAt(startIndex);

  if (nextChar && nextChar !== "/") {
    // pathname does not start with basename/
    return null;
  }

  return pathname.slice(startIndex) || "/";
}
/**
 * @private
 */

function warning(cond, message) {
  if (!cond) {
    // eslint-disable-next-line no-console
    if (typeof console !== "undefined") console.warn(message);

    try {
      // Welcome to debugging React Router!
      //
      // This error is thrown as a convenience so you can more easily
      // find the source for a warning that appears in the console by
      // enabling "pause on exceptions" in your JavaScript debugger.
      throw new Error(message); // eslint-disable-next-line no-empty
    } catch (e) {}
  }
}
/**
 * Returns a resolved path object relative to the given pathname.
 *
 * @see https://reactrouter.com/utils/resolve-path
 */

function resolvePath(to, fromPathname) {
  if (fromPathname === void 0) {
    fromPathname = "/";
  }

  let {
    pathname: toPathname,
    search = "",
    hash = ""
  } = typeof to === "string" ? parsePath(to) : to;
  let pathname = toPathname ? toPathname.startsWith("/") ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname;
  return {
    pathname,
    search: normalizeSearch(search),
    hash: normalizeHash(hash)
  };
}

function resolvePathname(relativePath, fromPathname) {
  let segments = fromPathname.replace(/\/+$/, "").split("/");
  let relativeSegments = relativePath.split("/");
  relativeSegments.forEach(segment => {
    if (segment === "..") {
      // Keep the root "" segment so the pathname starts at /
      if (segments.length > 1) segments.pop();
    } else if (segment !== ".") {
      segments.push(segment);
    }
  });
  return segments.length > 1 ? segments.join("/") : "/";
}

function getInvalidPathError(char, field, dest, path) {
  return "Cannot include a '" + char + "' character in a manually specified " + ("`to." + field + "` field [" + JSON.stringify(path) + "].  Please separate it out to the ") + ("`to." + dest + "` field. Alternatively you may provide the full path as ") + "a string in <Link to=\"...\"> and the router will parse it for you.";
}
/**
 * @private
 *
 * When processing relative navigation we want to ignore ancestor routes that
 * do not contribute to the path, such that index/pathless layout routes don't
 * interfere.
 *
 * For example, when moving a route element into an index route and/or a
 * pathless layout route, relative link behavior contained within should stay
 * the same.  Both of the following examples should link back to the root:
 *
 *   <Route path="/">
 *     <Route path="accounts" element={<Link to=".."}>
 *   </Route>
 *
 *   <Route path="/">
 *     <Route path="accounts">
 *       <Route element={<AccountsLayout />}>       // <-- Does not contribute
 *         <Route index element={<Link to=".."} />  // <-- Does not contribute
 *       </Route
 *     </Route>
 *   </Route>
 */


function getPathContributingMatches(matches) {
  return matches.filter((match, index) => index === 0 || match.route.path && match.route.path.length > 0);
}
/**
 * @private
 */

function resolveTo(toArg, routePathnames, locationPathname, isPathRelative) {
  if (isPathRelative === void 0) {
    isPathRelative = false;
  }

  let to;

  if (typeof toArg === "string") {
    to = parsePath(toArg);
  } else {
    to = _extends({}, toArg);
    invariant(!to.pathname || !to.pathname.includes("?"), getInvalidPathError("?", "pathname", "search", to));
    invariant(!to.pathname || !to.pathname.includes("#"), getInvalidPathError("#", "pathname", "hash", to));
    invariant(!to.search || !to.search.includes("#"), getInvalidPathError("#", "search", "hash", to));
  }

  let isEmptyPath = toArg === "" || to.pathname === "";
  let toPathname = isEmptyPath ? "/" : to.pathname;
  let from; // Routing is relative to the current pathname if explicitly requested.
  //
  // If a pathname is explicitly provided in `to`, it should be relative to the
  // route context. This is explained in `Note on `<Link to>` values` in our
  // migration guide from v5 as a means of disambiguation between `to` values
  // that begin with `/` and those that do not. However, this is problematic for
  // `to` values that do not provide a pathname. `to` can simply be a search or
  // hash string, in which case we should assume that the navigation is relative
  // to the current location's pathname and *not* the route pathname.

  if (isPathRelative || toPathname == null) {
    from = locationPathname;
  } else {
    let routePathnameIndex = routePathnames.length - 1;

    if (toPathname.startsWith("..")) {
      let toSegments = toPathname.split("/"); // Each leading .. segment means "go up one route" instead of "go up one
      // URL segment".  This is a key difference from how <a href> works and a
      // major reason we call this a "to" value instead of a "href".

      while (toSegments[0] === "..") {
        toSegments.shift();
        routePathnameIndex -= 1;
      }

      to.pathname = toSegments.join("/");
    } // If there are more ".." segments than parent routes, resolve relative to
    // the root / URL.


    from = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : "/";
  }

  let path = resolvePath(to, from); // Ensure the pathname has a trailing slash if the original "to" had one

  let hasExplicitTrailingSlash = toPathname && toPathname !== "/" && toPathname.endsWith("/"); // Or if this was a link to the current path which has a trailing slash

  let hasCurrentTrailingSlash = (isEmptyPath || toPathname === ".") && locationPathname.endsWith("/");

  if (!path.pathname.endsWith("/") && (hasExplicitTrailingSlash || hasCurrentTrailingSlash)) {
    path.pathname += "/";
  }

  return path;
}
/**
 * @private
 */

function getToPathname(to) {
  // Empty strings should be treated the same as / paths
  return to === "" || to.pathname === "" ? "/" : typeof to === "string" ? parsePath(to).pathname : to.pathname;
}
/**
 * @private
 */

const joinPaths = paths => paths.join("/").replace(/\/\/+/g, "/");
/**
 * @private
 */

const normalizePathname = pathname => pathname.replace(/\/+$/, "").replace(/^\/*/, "/");
/**
 * @private
 */

const normalizeSearch = search => !search || search === "?" ? "" : search.startsWith("?") ? search : "?" + search;
/**
 * @private
 */

const normalizeHash = hash => !hash || hash === "#" ? "" : hash.startsWith("#") ? hash : "#" + hash;
/**
 * This is a shortcut for creating `application/json` responses. Converts `data`
 * to JSON and sets the `Content-Type` header.
 */

const json = function json(data, init) {
  if (init === void 0) {
    init = {};
  }

  let responseInit = typeof init === "number" ? {
    status: init
  } : init;
  let headers = new Headers(responseInit.headers);

  if (!headers.has("Content-Type")) {
    headers.set("Content-Type", "application/json; charset=utf-8");
  }

  return new Response(JSON.stringify(data), _extends({}, responseInit, {
    headers
  }));
};
class AbortedDeferredError extends Error {}
class DeferredData {
  constructor(data) {
    this.pendingKeys = new Set();
    this.subscriber = undefined;
    invariant(data && typeof data === "object" && !Array.isArray(data), "defer() only accepts plain objects"); // Set up an AbortController + Promise we can race against to exit early
    // cancellation

    let reject;
    this.abortPromise = new Promise((_, r) => reject = r);
    this.controller = new AbortController();

    let onAbort = () => reject(new AbortedDeferredError("Deferred data aborted"));

    this.unlistenAbortSignal = () => this.controller.signal.removeEventListener("abort", onAbort);

    this.controller.signal.addEventListener("abort", onAbort);
    this.data = Object.entries(data).reduce((acc, _ref) => {
      let [key, value] = _ref;
      return Object.assign(acc, {
        [key]: this.trackPromise(key, value)
      });
    }, {});
  }

  trackPromise(key, value) {
    if (!(value instanceof Promise)) {
      return value;
    }

    this.pendingKeys.add(key); // We store a little wrapper promise that will be extended with
    // _data/_error props upon resolve/reject

    let promise = Promise.race([value, this.abortPromise]).then(data => this.onSettle(promise, key, null, data), error => this.onSettle(promise, key, error)); // Register rejection listeners to avoid uncaught promise rejections on
    // errors or aborted deferred values

    promise.catch(() => {});
    Object.defineProperty(promise, "_tracked", {
      get: () => true
    });
    return promise;
  }

  onSettle(promise, key, error, data) {
    if (this.controller.signal.aborted && error instanceof AbortedDeferredError) {
      this.unlistenAbortSignal();
      Object.defineProperty(promise, "_error", {
        get: () => error
      });
      return Promise.reject(error);
    }

    this.pendingKeys.delete(key);

    if (this.done) {
      // Nothing left to abort!
      this.unlistenAbortSignal();
    }

    const subscriber = this.subscriber;

    if (error) {
      Object.defineProperty(promise, "_error", {
        get: () => error
      });
      subscriber && subscriber(false);
      return Promise.reject(error);
    }

    Object.defineProperty(promise, "_data", {
      get: () => data
    });
    subscriber && subscriber(false);
    return data;
  }

  subscribe(fn) {
    this.subscriber = fn;
  }

  cancel() {
    this.controller.abort();
    this.pendingKeys.forEach((v, k) => this.pendingKeys.delete(k));
    let subscriber = this.subscriber;
    subscriber && subscriber(true);
  }

  async resolveData(signal) {
    let aborted = false;

    if (!this.done) {
      let onAbort = () => this.cancel();

      signal.addEventListener("abort", onAbort);
      aborted = await new Promise(resolve => {
        this.subscribe(aborted => {
          signal.removeEventListener("abort", onAbort);

          if (aborted || this.done) {
            resolve(aborted);
          }
        });
      });
    }

    return aborted;
  }

  get done() {
    return this.pendingKeys.size === 0;
  }

  get unwrappedData() {
    invariant(this.data !== null && this.done, "Can only unwrap data on initialized and settled deferreds");
    return Object.entries(this.data).reduce((acc, _ref2) => {
      let [key, value] = _ref2;
      return Object.assign(acc, {
        [key]: unwrapTrackedPromise(value)
      });
    }, {});
  }

}

function isTrackedPromise(value) {
  return value instanceof Promise && value._tracked === true;
}

function unwrapTrackedPromise(value) {
  if (!isTrackedPromise(value)) {
    return value;
  }

  if (value._error) {
    throw value._error;
  }

  return value._data;
}

function defer(data) {
  return new DeferredData(data);
}
/**
 * A redirect response. Sets the status code and the `Location` header.
 * Defaults to "302 Found".
 */

const redirect = function redirect(url, init) {
  if (init === void 0) {
    init = 302;
  }

  let responseInit = init;

  if (typeof responseInit === "number") {
    responseInit = {
      status: responseInit
    };
  } else if (typeof responseInit.status === "undefined") {
    responseInit.status = 302;
  }

  let headers = new Headers(responseInit.headers);
  headers.set("Location", url);
  return new Response(null, _extends({}, responseInit, {
    headers
  }));
};
/**
 * @private
 * Utility class we use to hold auto-unwrapped 4xx/5xx Response bodies
 */

class ErrorResponse {
  constructor(status, statusText, data, internal) {
    if (internal === void 0) {
      internal = false;
    }

    this.status = status;
    this.statusText = statusText || "";
    this.internal = internal;

    if (data instanceof Error) {
      this.data = data.toString();
      this.error = data;
    } else {
      this.data = data;
    }
  }

}
/**
 * Check if the given error is an ErrorResponse generated from a 4xx/5xx
 * Response throw from an action/loader
 */

function isRouteErrorResponse(e) {
  return e instanceof ErrorResponse;
}

const validMutationMethodsArr = ["post", "put", "patch", "delete"];
const validMutationMethods = new Set(validMutationMethodsArr);
const validRequestMethodsArr = ["get", ...validMutationMethodsArr];
const validRequestMethods = new Set(validRequestMethodsArr);
const redirectStatusCodes = new Set([301, 302, 303, 307, 308]);
const redirectPreserveMethodStatusCodes = new Set([307, 308]);
const IDLE_NAVIGATION = {
  state: "idle",
  location: undefined,
  formMethod: undefined,
  formAction: undefined,
  formEncType: undefined,
  formData: undefined
};
const IDLE_FETCHER = {
  state: "idle",
  data: undefined,
  formMethod: undefined,
  formAction: undefined,
  formEncType: undefined,
  formData: undefined
};
const isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
const isServer = !isBrowser; //#endregion
////////////////////////////////////////////////////////////////////////////////
//#region createRouter
////////////////////////////////////////////////////////////////////////////////

/**
 * Create a router and listen to history POP navigations
 */

function createRouter(init) {
  invariant(init.routes.length > 0, "You must provide a non-empty routes array to createRouter");
  let dataRoutes = convertRoutesToDataRoutes(init.routes); // Cleanup function for history

  let unlistenHistory = null; // Externally-provided functions to call on all state changes

  let subscribers = new Set(); // Externally-provided object to hold scroll restoration locations during routing

  let savedScrollPositions = null; // Externally-provided function to get scroll restoration keys

  let getScrollRestorationKey = null; // Externally-provided function to get current scroll position

  let getScrollPosition = null; // One-time flag to control the initial hydration scroll restoration.  Because
  // we don't get the saved positions from <ScrollRestoration /> until _after_
  // the initial render, we need to manually trigger a separate updateState to
  // send along the restoreScrollPosition
  // Set to true if we have `hydrationData` since we assume we were SSR'd and that
  // SSR did the initial scroll restoration.

  let initialScrollRestored = init.hydrationData != null;
  let initialMatches = matchRoutes(dataRoutes, init.history.location, init.basename);
  let initialErrors = null;

  if (initialMatches == null) {
    // If we do not match a user-provided-route, fall back to the root
    // to allow the error boundary to take over
    let error = getInternalRouterError(404, {
      pathname: init.history.location.pathname
    });
    let {
      matches,
      route
    } = getShortCircuitMatches(dataRoutes);
    initialMatches = matches;
    initialErrors = {
      [route.id]: error
    };
  }

  let initialized = !initialMatches.some(m => m.route.loader) || init.hydrationData != null;
  let router;
  let state = {
    historyAction: init.history.action,
    location: init.history.location,
    matches: initialMatches,
    initialized,
    navigation: IDLE_NAVIGATION,
    // Don't restore on initial updateState() if we were SSR'd
    restoreScrollPosition: init.hydrationData != null ? false : null,
    preventScrollReset: false,
    revalidation: "idle",
    loaderData: init.hydrationData && init.hydrationData.loaderData || {},
    actionData: init.hydrationData && init.hydrationData.actionData || null,
    errors: init.hydrationData && init.hydrationData.errors || initialErrors,
    fetchers: new Map()
  }; // -- Stateful internal variables to manage navigations --
  // Current navigation in progress (to be committed in completeNavigation)

  let pendingAction = Action.Pop; // Should the current navigation prevent the scroll reset if scroll cannot
  // be restored?

  let pendingPreventScrollReset = false; // AbortController for the active navigation

  let pendingNavigationController; // We use this to avoid touching history in completeNavigation if a
  // revalidation is entirely uninterrupted

  let isUninterruptedRevalidation = false; // Use this internal flag to force revalidation of all loaders:
  //  - submissions (completed or interrupted)
  //  - useRevalidate()
  //  - X-Remix-Revalidate (from redirect)

  let isRevalidationRequired = false; // Use this internal array to capture routes that require revalidation due
  // to a cancelled deferred on action submission

  let cancelledDeferredRoutes = []; // Use this internal array to capture fetcher loads that were cancelled by an
  // action navigation and require revalidation

  let cancelledFetcherLoads = []; // AbortControllers for any in-flight fetchers

  let fetchControllers = new Map(); // Track loads based on the order in which they started

  let incrementingLoadId = 0; // Track the outstanding pending navigation data load to be compared against
  // the globally incrementing load when a fetcher load lands after a completed
  // navigation

  let pendingNavigationLoadId = -1; // Fetchers that triggered data reloads as a result of their actions

  let fetchReloadIds = new Map(); // Fetchers that triggered redirect navigations from their actions

  let fetchRedirectIds = new Set(); // Most recent href/match for fetcher.load calls for fetchers

  let fetchLoadMatches = new Map(); // Store DeferredData instances for active route matches.  When a
  // route loader returns defer() we stick one in here.  Then, when a nested
  // promise resolves we update loaderData.  If a new navigation starts we
  // cancel active deferreds for eliminated routes.

  let activeDeferreds = new Map(); // Initialize the router, all side effects should be kicked off from here.
  // Implemented as a Fluent API for ease of:
  //   let router = createRouter(init).initialize();

  function initialize() {
    // If history informs us of a POP navigation, start the navigation but do not update
    // state.  We'll update our own state once the navigation completes
    unlistenHistory = init.history.listen(_ref => {
      let {
        action: historyAction,
        location
      } = _ref;
      return startNavigation(historyAction, location);
    }); // Kick off initial data load if needed.  Use Pop to avoid modifying history

    if (!state.initialized) {
      startNavigation(Action.Pop, state.location);
    }

    return router;
  } // Clean up a router and it's side effects


  function dispose() {
    if (unlistenHistory) {
      unlistenHistory();
    }

    subscribers.clear();
    pendingNavigationController && pendingNavigationController.abort();
    state.fetchers.forEach((_, key) => deleteFetcher(key));
  } // Subscribe to state updates for the router


  function subscribe(fn) {
    subscribers.add(fn);
    return () => subscribers.delete(fn);
  } // Update our state and notify the calling context of the change


  function updateState(newState) {
    state = _extends({}, state, newState);
    subscribers.forEach(subscriber => subscriber(state));
  } // Complete a navigation returning the state.navigation back to the IDLE_NAVIGATION
  // and setting state.[historyAction/location/matches] to the new route.
  // - Location is a required param
  // - Navigation will always be set to IDLE_NAVIGATION
  // - Can pass any other state in newState


  function completeNavigation(location, newState) {
    var _location$state;

    // Deduce if we're in a loading/actionReload state:
    // - We have committed actionData in the store
    // - The current navigation was a mutation submission
    // - We're past the submitting state and into the loading state
    // - The location being loaded is not the result of a redirect
    let isActionReload = state.actionData != null && state.navigation.formMethod != null && isMutationMethod(state.navigation.formMethod) && state.navigation.state === "loading" && ((_location$state = location.state) == null ? void 0 : _location$state._isRedirect) !== true;
    let actionData;

    if (newState.actionData) {
      if (Object.keys(newState.actionData).length > 0) {
        actionData = newState.actionData;
      } else {
        // Empty actionData -> clear prior actionData due to an action error
        actionData = null;
      }
    } else if (isActionReload) {
      // Keep the current data if we're wrapping up the action reload
      actionData = state.actionData;
    } else {
      // Clear actionData on any other completed navigations
      actionData = null;
    } // Always preserve any existing loaderData from re-used routes


    let loaderData = newState.loaderData ? mergeLoaderData(state.loaderData, newState.loaderData, newState.matches || [], newState.errors) : state.loaderData;
    updateState(_extends({}, newState, {
      actionData,
      loaderData,
      historyAction: pendingAction,
      location,
      initialized: true,
      navigation: IDLE_NAVIGATION,
      revalidation: "idle",
      // Don't restore on submission navigations
      restoreScrollPosition: state.navigation.formData ? false : getSavedScrollPosition(location, newState.matches || state.matches),
      preventScrollReset: pendingPreventScrollReset
    }));

    if (isUninterruptedRevalidation) ; else if (pendingAction === Action.Pop) ; else if (pendingAction === Action.Push) {
      init.history.push(location, location.state);
    } else if (pendingAction === Action.Replace) {
      init.history.replace(location, location.state);
    } // Reset stateful navigation vars


    pendingAction = Action.Pop;
    pendingPreventScrollReset = false;
    isUninterruptedRevalidation = false;
    isRevalidationRequired = false;
    cancelledDeferredRoutes = [];
    cancelledFetcherLoads = [];
  } // Trigger a navigation event, which can either be a numerical POP or a PUSH
  // replace with an optional submission


  async function navigate(to, opts) {
    if (typeof to === "number") {
      init.history.go(to);
      return;
    }

    let {
      path,
      submission,
      error
    } = normalizeNavigateOptions(to, opts);
    let location = createLocation(state.location, path, opts && opts.state); // When using navigate as a PUSH/REPLACE we aren't reading an already-encoded
    // URL from window.location, so we need to encode it here so the behavior
    // remains the same as POP and non-data-router usages.  new URL() does all
    // the same encoding we'd get from a history.pushState/window.location read
    // without having to touch history

    location = _extends({}, location, init.history.encodeLocation(location));
    let userReplace = opts && opts.replace != null ? opts.replace : undefined;
    let historyAction = Action.Push;

    if (userReplace === true) {
      historyAction = Action.Replace;
    } else if (userReplace === false) ; else if (submission != null && isMutationMethod(submission.formMethod) && submission.formAction === state.location.pathname + state.location.search) {
      // By default on submissions to the current location we REPLACE so that
      // users don't have to double-click the back button to get to the prior
      // location.  If the user redirects to a different location from the
      // action/loader this will be ignored and the redirect will be a PUSH
      historyAction = Action.Replace;
    }

    let preventScrollReset = opts && "preventScrollReset" in opts ? opts.preventScrollReset === true : undefined;
    return await startNavigation(historyAction, location, {
      submission,
      // Send through the formData serialization error if we have one so we can
      // render at the right error boundary after we match routes
      pendingError: error,
      preventScrollReset,
      replace: opts && opts.replace
    });
  } // Revalidate all current loaders.  If a navigation is in progress or if this
  // is interrupted by a navigation, allow this to "succeed" by calling all
  // loaders during the next loader round


  function revalidate() {
    interruptActiveLoads();
    updateState({
      revalidation: "loading"
    }); // If we're currently submitting an action, we don't need to start a new
    // navigation, we'll just let the follow up loader execution call all loaders

    if (state.navigation.state === "submitting") {
      return;
    } // If we're currently in an idle state, start a new navigation for the current
    // action/location and mark it as uninterrupted, which will skip the history
    // update in completeNavigation


    if (state.navigation.state === "idle") {
      startNavigation(state.historyAction, state.location, {
        startUninterruptedRevalidation: true
      });
      return;
    } // Otherwise, if we're currently in a loading state, just start a new
    // navigation to the navigation.location but do not trigger an uninterrupted
    // revalidation so that history correctly updates once the navigation completes


    startNavigation(pendingAction || state.historyAction, state.navigation.location, {
      overrideNavigation: state.navigation
    });
  } // Start a navigation to the given action/location.  Can optionally provide a
  // overrideNavigation which will override the normalLoad in the case of a redirect
  // navigation


  async function startNavigation(historyAction, location, opts) {
    // Abort any in-progress navigations and start a new one. Unset any ongoing
    // uninterrupted revalidations unless told otherwise, since we want this
    // new navigation to update history normally
    pendingNavigationController && pendingNavigationController.abort();
    pendingNavigationController = null;
    pendingAction = historyAction;
    isUninterruptedRevalidation = (opts && opts.startUninterruptedRevalidation) === true; // Save the current scroll position every time we start a new navigation,
    // and track whether we should reset scroll on completion

    saveScrollPosition(state.location, state.matches);
    pendingPreventScrollReset = (opts && opts.preventScrollReset) === true;
    let loadingNavigation = opts && opts.overrideNavigation;
    let matches = matchRoutes(dataRoutes, location, init.basename); // Short circuit with a 404 on the root error boundary if we match nothing

    if (!matches) {
      let error = getInternalRouterError(404, {
        pathname: location.pathname
      });
      let {
        matches: notFoundMatches,
        route
      } = getShortCircuitMatches(dataRoutes); // Cancel all pending deferred on 404s since we don't keep any routes

      cancelActiveDeferreds();
      completeNavigation(location, {
        matches: notFoundMatches,
        loaderData: {},
        errors: {
          [route.id]: error
        }
      });
      return;
    } // Short circuit if it's only a hash change


    if (isHashChangeOnly(state.location, location)) {
      completeNavigation(location, {
        matches
      });
      return;
    } // Create a controller/Request for this navigation


    pendingNavigationController = new AbortController();
    let request = createClientSideRequest(location, pendingNavigationController.signal, opts && opts.submission);
    let pendingActionData;
    let pendingError;

    if (opts && opts.pendingError) {
      // If we have a pendingError, it means the user attempted a GET submission
      // with binary FormData so assign here and skip to handleLoaders.  That
      // way we handle calling loaders above the boundary etc.  It's not really
      // different from an actionError in that sense.
      pendingError = {
        [findNearestBoundary(matches).route.id]: opts.pendingError
      };
    } else if (opts && opts.submission && isMutationMethod(opts.submission.formMethod)) {
      // Call action if we received an action submission
      let actionOutput = await handleAction(request, location, opts.submission, matches, {
        replace: opts.replace
      });

      if (actionOutput.shortCircuited) {
        return;
      }

      pendingActionData = actionOutput.pendingActionData;
      pendingError = actionOutput.pendingActionError;

      let navigation = _extends({
        state: "loading",
        location
      }, opts.submission);

      loadingNavigation = navigation; // Create a GET request for the loaders

      request = new Request(request.url, {
        signal: request.signal
      });
    } // Call loaders


    let {
      shortCircuited,
      loaderData,
      errors
    } = await handleLoaders(request, location, matches, loadingNavigation, opts && opts.submission, opts && opts.replace, pendingActionData, pendingError);

    if (shortCircuited) {
      return;
    } // Clean up now that the action/loaders have completed.  Don't clean up if
    // we short circuited because pendingNavigationController will have already
    // been assigned to a new controller for the next navigation


    pendingNavigationController = null;
    completeNavigation(location, _extends({
      matches
    }, pendingActionData ? {
      actionData: pendingActionData
    } : {}, {
      loaderData,
      errors
    }));
  } // Call the action matched by the leaf route for this navigation and handle
  // redirects/errors


  async function handleAction(request, location, submission, matches, opts) {
    interruptActiveLoads(); // Put us in a submitting state

    let navigation = _extends({
      state: "submitting",
      location
    }, submission);

    updateState({
      navigation
    }); // Call our action and get the result

    let result;
    let actionMatch = getTargetMatch(matches, location);

    if (!actionMatch.route.action) {
      result = {
        type: ResultType.error,
        error: getInternalRouterError(405, {
          method: request.method,
          pathname: location.pathname,
          routeId: actionMatch.route.id
        })
      };
    } else {
      result = await callLoaderOrAction("action", request, actionMatch, matches, router.basename);

      if (request.signal.aborted) {
        return {
          shortCircuited: true
        };
      }
    }

    if (isRedirectResult(result)) {
      let replace;

      if (opts && opts.replace != null) {
        replace = opts.replace;
      } else {
        // If the user didn't explicity indicate replace behavior, replace if
        // we redirected to the exact same location we're currently at to avoid
        // double back-buttons
        replace = result.location === state.location.pathname + state.location.search;
      }

      await startRedirectNavigation(state, result, {
        submission,
        replace
      });
      return {
        shortCircuited: true
      };
    }

    if (isErrorResult(result)) {
      // Store off the pending error - we use it to determine which loaders
      // to call and will commit it when we complete the navigation
      let boundaryMatch = findNearestBoundary(matches, actionMatch.route.id); // By default, all submissions are REPLACE navigations, but if the
      // action threw an error that'll be rendered in an errorElement, we fall
      // back to PUSH so that the user can use the back button to get back to
      // the pre-submission form location to try again

      if ((opts && opts.replace) !== true) {
        pendingAction = Action.Push;
      }

      return {
        // Send back an empty object we can use to clear out any prior actionData
        pendingActionData: {},
        pendingActionError: {
          [boundaryMatch.route.id]: result.error
        }
      };
    }

    if (isDeferredResult(result)) {
      throw new Error("defer() is not supported in actions");
    }

    return {
      pendingActionData: {
        [actionMatch.route.id]: result.data
      }
    };
  } // Call all applicable loaders for the given matches, handling redirects,
  // errors, etc.


  async function handleLoaders(request, location, matches, overrideNavigation, submission, replace, pendingActionData, pendingError) {
    // Figure out the right navigation we want to use for data loading
    let loadingNavigation = overrideNavigation;

    if (!loadingNavigation) {
      let navigation = _extends({
        state: "loading",
        location,
        formMethod: undefined,
        formAction: undefined,
        formEncType: undefined,
        formData: undefined
      }, submission);

      loadingNavigation = navigation;
    } // If this was a redirect from an action we don't have a "submission" but
    // we have it on the loading navigation so use that if available


    let activeSubmission = submission ? submission : loadingNavigation.formMethod && loadingNavigation.formAction && loadingNavigation.formData && loadingNavigation.formEncType ? {
      formMethod: loadingNavigation.formMethod,
      formAction: loadingNavigation.formAction,
      formData: loadingNavigation.formData,
      formEncType: loadingNavigation.formEncType
    } : undefined;
    let [matchesToLoad, revalidatingFetchers] = getMatchesToLoad(state, matches, activeSubmission, location, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, pendingActionData, pendingError, fetchLoadMatches); // Cancel pending deferreds for no-longer-matched routes or routes we're
    // about to reload.  Note that if this is an action reload we would have
    // already cancelled all pending deferreds so this would be a no-op

    cancelActiveDeferreds(routeId => !(matches && matches.some(m => m.route.id === routeId)) || matchesToLoad && matchesToLoad.some(m => m.route.id === routeId)); // Short circuit if we have no loaders to run

    if (matchesToLoad.length === 0 && revalidatingFetchers.length === 0) {
      completeNavigation(location, _extends({
        matches,
        loaderData: {},
        // Commit pending error if we're short circuiting
        errors: pendingError || null
      }, pendingActionData ? {
        actionData: pendingActionData
      } : {}));
      return {
        shortCircuited: true
      };
    } // If this is an uninterrupted revalidation, we remain in our current idle
    // state.  If not, we need to switch to our loading state and load data,
    // preserving any new action data or existing action data (in the case of
    // a revalidation interrupting an actionReload)


    if (!isUninterruptedRevalidation) {
      revalidatingFetchers.forEach(_ref2 => {
        let [key] = _ref2;
        let fetcher = state.fetchers.get(key);
        let revalidatingFetcher = {
          state: "loading",
          data: fetcher && fetcher.data,
          formMethod: undefined,
          formAction: undefined,
          formEncType: undefined,
          formData: undefined,
          " _hasFetcherDoneAnything ": true
        };
        state.fetchers.set(key, revalidatingFetcher);
      });
      let actionData = pendingActionData || state.actionData;
      updateState(_extends({
        navigation: loadingNavigation
      }, actionData ? Object.keys(actionData).length === 0 ? {
        actionData: null
      } : {
        actionData
      } : {}, revalidatingFetchers.length > 0 ? {
        fetchers: new Map(state.fetchers)
      } : {}));
    }

    pendingNavigationLoadId = ++incrementingLoadId;
    revalidatingFetchers.forEach(_ref3 => {
      let [key] = _ref3;
      return fetchControllers.set(key, pendingNavigationController);
    });
    let {
      results,
      loaderResults,
      fetcherResults
    } = await callLoadersAndMaybeResolveData(state.matches, matches, matchesToLoad, revalidatingFetchers, request);

    if (request.signal.aborted) {
      return {
        shortCircuited: true
      };
    } // Clean up _after_ loaders have completed.  Don't clean up if we short
    // circuited because fetchControllers would have been aborted and
    // reassigned to new controllers for the next navigation


    revalidatingFetchers.forEach(_ref4 => {
      let [key] = _ref4;
      return fetchControllers.delete(key);
    }); // If any loaders returned a redirect Response, start a new REPLACE navigation

    let redirect = findRedirect(results);

    if (redirect) {
      await startRedirectNavigation(state, redirect, {
        replace
      });
      return {
        shortCircuited: true
      };
    } // Process and commit output from loaders


    let {
      loaderData,
      errors
    } = processLoaderData(state, matches, matchesToLoad, loaderResults, pendingError, revalidatingFetchers, fetcherResults, activeDeferreds); // Wire up subscribers to update loaderData as promises settle

    activeDeferreds.forEach((deferredData, routeId) => {
      deferredData.subscribe(aborted => {
        // Note: No need to updateState here since the TrackedPromise on
        // loaderData is stable across resolve/reject
        // Remove this instance if we were aborted or if promises have settled
        if (aborted || deferredData.done) {
          activeDeferreds.delete(routeId);
        }
      });
    });
    markFetchRedirectsDone();
    let didAbortFetchLoads = abortStaleFetchLoads(pendingNavigationLoadId);
    return _extends({
      loaderData,
      errors
    }, didAbortFetchLoads || revalidatingFetchers.length > 0 ? {
      fetchers: new Map(state.fetchers)
    } : {});
  }

  function getFetcher(key) {
    return state.fetchers.get(key) || IDLE_FETCHER;
  } // Trigger a fetcher load/submit for the given fetcher key


  function fetch(key, routeId, href, opts) {
    if (isServer) {
      throw new Error("router.fetch() was called during the server render, but it shouldn't be. " + "You are likely calling a useFetcher() method in the body of your component. " + "Try moving it to a useEffect or a callback.");
    }

    if (fetchControllers.has(key)) abortFetcher(key);
    let matches = matchRoutes(dataRoutes, href, init.basename);

    if (!matches) {
      setFetcherError(key, routeId, getInternalRouterError(404, {
        pathname: href
      }));
      return;
    }

    let {
      path,
      submission
    } = normalizeNavigateOptions(href, opts, true);
    let match = getTargetMatch(matches, path);

    if (submission && isMutationMethod(submission.formMethod)) {
      handleFetcherAction(key, routeId, path, match, matches, submission);
      return;
    } // Store off the match so we can call it's shouldRevalidate on subsequent
    // revalidations


    fetchLoadMatches.set(key, [path, match, matches]);
    handleFetcherLoader(key, routeId, path, match, matches, submission);
  } // Call the action for the matched fetcher.submit(), and then handle redirects,
  // errors, and revalidation


  async function handleFetcherAction(key, routeId, path, match, requestMatches, submission) {
    interruptActiveLoads();
    fetchLoadMatches.delete(key);

    if (!match.route.action) {
      let error = getInternalRouterError(405, {
        method: submission.formMethod,
        pathname: path,
        routeId: routeId
      });
      setFetcherError(key, routeId, error);
      return;
    } // Put this fetcher into it's submitting state


    let existingFetcher = state.fetchers.get(key);

    let fetcher = _extends({
      state: "submitting"
    }, submission, {
      data: existingFetcher && existingFetcher.data,
      " _hasFetcherDoneAnything ": true
    });

    state.fetchers.set(key, fetcher);
    updateState({
      fetchers: new Map(state.fetchers)
    }); // Call the action for the fetcher

    let abortController = new AbortController();
    let fetchRequest = createClientSideRequest(path, abortController.signal, submission);
    fetchControllers.set(key, abortController);
    let actionResult = await callLoaderOrAction("action", fetchRequest, match, requestMatches, router.basename);

    if (fetchRequest.signal.aborted) {
      // We can delete this so long as we weren't aborted by ou our own fetcher
      // re-submit which would have put _new_ controller is in fetchControllers
      if (fetchControllers.get(key) === abortController) {
        fetchControllers.delete(key);
      }

      return;
    }

    if (isRedirectResult(actionResult)) {
      fetchControllers.delete(key);
      fetchRedirectIds.add(key);

      let loadingFetcher = _extends({
        state: "loading"
      }, submission, {
        data: undefined,
        " _hasFetcherDoneAnything ": true
      });

      state.fetchers.set(key, loadingFetcher);
      updateState({
        fetchers: new Map(state.fetchers)
      });
      return startRedirectNavigation(state, actionResult, {
        isFetchActionRedirect: true
      });
    } // Process any non-redirect errors thrown


    if (isErrorResult(actionResult)) {
      setFetcherError(key, routeId, actionResult.error);
      return;
    }

    if (isDeferredResult(actionResult)) {
      invariant(false, "defer() is not supported in actions");
    } // Start the data load for current matches, or the next location if we're
    // in the middle of a navigation


    let nextLocation = state.navigation.location || state.location;
    let revalidationRequest = createClientSideRequest(nextLocation, abortController.signal);
    let matches = state.navigation.state !== "idle" ? matchRoutes(dataRoutes, state.navigation.location, init.basename) : state.matches;
    invariant(matches, "Didn't find any matches after fetcher action");
    let loadId = ++incrementingLoadId;
    fetchReloadIds.set(key, loadId);

    let loadFetcher = _extends({
      state: "loading",
      data: actionResult.data
    }, submission, {
      " _hasFetcherDoneAnything ": true
    });

    state.fetchers.set(key, loadFetcher);
    let [matchesToLoad, revalidatingFetchers] = getMatchesToLoad(state, matches, submission, nextLocation, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, {
      [match.route.id]: actionResult.data
    }, undefined, // No need to send through errors since we short circuit above
    fetchLoadMatches); // Put all revalidating fetchers into the loading state, except for the
    // current fetcher which we want to keep in it's current loading state which
    // contains it's action submission info + action data

    revalidatingFetchers.filter(_ref5 => {
      let [staleKey] = _ref5;
      return staleKey !== key;
    }).forEach(_ref6 => {
      let [staleKey] = _ref6;
      let existingFetcher = state.fetchers.get(staleKey);
      let revalidatingFetcher = {
        state: "loading",
        data: existingFetcher && existingFetcher.data,
        formMethod: undefined,
        formAction: undefined,
        formEncType: undefined,
        formData: undefined,
        " _hasFetcherDoneAnything ": true
      };
      state.fetchers.set(staleKey, revalidatingFetcher);
      fetchControllers.set(staleKey, abortController);
    });
    updateState({
      fetchers: new Map(state.fetchers)
    });
    let {
      results,
      loaderResults,
      fetcherResults
    } = await callLoadersAndMaybeResolveData(state.matches, matches, matchesToLoad, revalidatingFetchers, revalidationRequest);

    if (abortController.signal.aborted) {
      return;
    }

    fetchReloadIds.delete(key);
    fetchControllers.delete(key);
    revalidatingFetchers.forEach(_ref7 => {
      let [staleKey] = _ref7;
      return fetchControllers.delete(staleKey);
    });
    let redirect = findRedirect(results);

    if (redirect) {
      return startRedirectNavigation(state, redirect);
    } // Process and commit output from loaders


    let {
      loaderData,
      errors
    } = processLoaderData(state, state.matches, matchesToLoad, loaderResults, undefined, revalidatingFetchers, fetcherResults, activeDeferreds);
    let doneFetcher = {
      state: "idle",
      data: actionResult.data,
      formMethod: undefined,
      formAction: undefined,
      formEncType: undefined,
      formData: undefined,
      " _hasFetcherDoneAnything ": true
    };
    state.fetchers.set(key, doneFetcher);
    let didAbortFetchLoads = abortStaleFetchLoads(loadId); // If we are currently in a navigation loading state and this fetcher is
    // more recent than the navigation, we want the newer data so abort the
    // navigation and complete it with the fetcher data

    if (state.navigation.state === "loading" && loadId > pendingNavigationLoadId) {
      invariant(pendingAction, "Expected pending action");
      pendingNavigationController && pendingNavigationController.abort();
      completeNavigation(state.navigation.location, {
        matches,
        loaderData,
        errors,
        fetchers: new Map(state.fetchers)
      });
    } else {
      // otherwise just update with the fetcher data, preserving any existing
      // loaderData for loaders that did not need to reload.  We have to
      // manually merge here since we aren't going through completeNavigation
      updateState(_extends({
        errors,
        loaderData: mergeLoaderData(state.loaderData, loaderData, matches, errors)
      }, didAbortFetchLoads ? {
        fetchers: new Map(state.fetchers)
      } : {}));
      isRevalidationRequired = false;
    }
  } // Call the matched loader for fetcher.load(), handling redirects, errors, etc.


  async function handleFetcherLoader(key, routeId, path, match, matches, submission) {
    let existingFetcher = state.fetchers.get(key); // Put this fetcher into it's loading state

    let loadingFetcher = _extends({
      state: "loading",
      formMethod: undefined,
      formAction: undefined,
      formEncType: undefined,
      formData: undefined
    }, submission, {
      data: existingFetcher && existingFetcher.data,
      " _hasFetcherDoneAnything ": true
    });

    state.fetchers.set(key, loadingFetcher);
    updateState({
      fetchers: new Map(state.fetchers)
    }); // Call the loader for this fetcher route match

    let abortController = new AbortController();
    let fetchRequest = createClientSideRequest(path, abortController.signal);
    fetchControllers.set(key, abortController);
    let result = await callLoaderOrAction("loader", fetchRequest, match, matches, router.basename); // Deferred isn't supported or fetcher loads, await everything and treat it
    // as a normal load.  resolveDeferredData will return undefined if this
    // fetcher gets aborted, so we just leave result untouched and short circuit
    // below if that happens

    if (isDeferredResult(result)) {
      result = (await resolveDeferredData(result, fetchRequest.signal, true)) || result;
    } // We can delete this so long as we weren't aborted by ou our own fetcher
    // re-load which would have put _new_ controller is in fetchControllers


    if (fetchControllers.get(key) === abortController) {
      fetchControllers.delete(key);
    }

    if (fetchRequest.signal.aborted) {
      return;
    } // If the loader threw a redirect Response, start a new REPLACE navigation


    if (isRedirectResult(result)) {
      await startRedirectNavigation(state, result);
      return;
    } // Process any non-redirect errors thrown


    if (isErrorResult(result)) {
      let boundaryMatch = findNearestBoundary(state.matches, routeId);
      state.fetchers.delete(key); // TODO: In remix, this would reset to IDLE_NAVIGATION if it was a catch -
      // do we need to behave any differently with our non-redirect errors?
      // What if it was a non-redirect Response?

      updateState({
        fetchers: new Map(state.fetchers),
        errors: {
          [boundaryMatch.route.id]: result.error
        }
      });
      return;
    }

    invariant(!isDeferredResult(result), "Unhandled fetcher deferred data"); // Put the fetcher back into an idle state

    let doneFetcher = {
      state: "idle",
      data: result.data,
      formMethod: undefined,
      formAction: undefined,
      formEncType: undefined,
      formData: undefined,
      " _hasFetcherDoneAnything ": true
    };
    state.fetchers.set(key, doneFetcher);
    updateState({
      fetchers: new Map(state.fetchers)
    });
  }
  /**
   * Utility function to handle redirects returned from an action or loader.
   * Normally, a redirect "replaces" the navigation that triggered it.  So, for
   * example:
   *
   *  - user is on /a
   *  - user clicks a link to /b
   *  - loader for /b redirects to /c
   *
   * In a non-JS app the browser would track the in-flight navigation to /b and
   * then replace it with /c when it encountered the redirect response.  In
   * the end it would only ever update the URL bar with /c.
   *
   * In client-side routing using pushState/replaceState, we aim to emulate
   * this behavior and we also do not update history until the end of the
   * navigation (including processed redirects).  This means that we never
   * actually touch history until we've processed redirects, so we just use
   * the history action from the original navigation (PUSH or REPLACE).
   */


  async function startRedirectNavigation(state, redirect, _temp) {
    var _window;

    let {
      submission,
      replace,
      isFetchActionRedirect
    } = _temp === void 0 ? {} : _temp;

    if (redirect.revalidate) {
      isRevalidationRequired = true;
    }

    let redirectLocation = createLocation(state.location, redirect.location, // TODO: This can be removed once we get rid of useTransition in Remix v2
    _extends({
      _isRedirect: true
    }, isFetchActionRedirect ? {
      _isFetchActionRedirect: true
    } : {}));
    invariant(redirectLocation, "Expected a location on the redirect navigation"); // Check if this an external redirect that goes to a new origin

    if (typeof ((_window = window) == null ? void 0 : _window.location) !== "undefined") {
      let newOrigin = createClientSideURL(redirect.location).origin;

      if (window.location.origin !== newOrigin) {
        if (replace) {
          window.location.replace(redirect.location);
        } else {
          window.location.assign(redirect.location);
        }

        return;
      }
    } // There's no need to abort on redirects, since we don't detect the
    // redirect until the action/loaders have settled


    pendingNavigationController = null;
    let redirectHistoryAction = replace === true ? Action.Replace : Action.Push; // Use the incoming submission if provided, fallback on the active one in
    // state.navigation

    let {
      formMethod,
      formAction,
      formEncType,
      formData
    } = state.navigation;

    if (!submission && formMethod && formAction && formData && formEncType) {
      submission = {
        formMethod,
        formAction,
        formEncType,
        formData
      };
    } // If this was a 307/308 submission we want to preserve the HTTP method and
    // re-submit the GET/POST/PUT/PATCH/DELETE as a submission navigation to the
    // redirected location


    if (redirectPreserveMethodStatusCodes.has(redirect.status) && submission && isMutationMethod(submission.formMethod)) {
      await startNavigation(redirectHistoryAction, redirectLocation, {
        submission: _extends({}, submission, {
          formAction: redirect.location
        })
      });
    } else {
      // Otherwise, we kick off a new loading navigation, preserving the
      // submission info for the duration of this navigation
      await startNavigation(redirectHistoryAction, redirectLocation, {
        overrideNavigation: {
          state: "loading",
          location: redirectLocation,
          formMethod: submission ? submission.formMethod : undefined,
          formAction: submission ? submission.formAction : undefined,
          formEncType: submission ? submission.formEncType : undefined,
          formData: submission ? submission.formData : undefined
        }
      });
    }
  }

  async function callLoadersAndMaybeResolveData(currentMatches, matches, matchesToLoad, fetchersToLoad, request) {
    // Call all navigation loaders and revalidating fetcher loaders in parallel,
    // then slice off the results into separate arrays so we can handle them
    // accordingly
    let results = await Promise.all([...matchesToLoad.map(match => callLoaderOrAction("loader", request, match, matches, router.basename)), ...fetchersToLoad.map(_ref8 => {
      let [, href, match, fetchMatches] = _ref8;
      return callLoaderOrAction("loader", createClientSideRequest(href, request.signal), match, fetchMatches, router.basename);
    })]);
    let loaderResults = results.slice(0, matchesToLoad.length);
    let fetcherResults = results.slice(matchesToLoad.length);
    await Promise.all([resolveDeferredResults(currentMatches, matchesToLoad, loaderResults, request.signal, false, state.loaderData), resolveDeferredResults(currentMatches, fetchersToLoad.map(_ref9 => {
      let [,, match] = _ref9;
      return match;
    }), fetcherResults, request.signal, true)]);
    return {
      results,
      loaderResults,
      fetcherResults
    };
  }

  function interruptActiveLoads() {
    // Every interruption triggers a revalidation
    isRevalidationRequired = true; // Cancel pending route-level deferreds and mark cancelled routes for
    // revalidation

    cancelledDeferredRoutes.push(...cancelActiveDeferreds()); // Abort in-flight fetcher loads

    fetchLoadMatches.forEach((_, key) => {
      if (fetchControllers.has(key)) {
        cancelledFetcherLoads.push(key);
        abortFetcher(key);
      }
    });
  }

  function setFetcherError(key, routeId, error) {
    let boundaryMatch = findNearestBoundary(state.matches, routeId);
    deleteFetcher(key);
    updateState({
      errors: {
        [boundaryMatch.route.id]: error
      },
      fetchers: new Map(state.fetchers)
    });
  }

  function deleteFetcher(key) {
    if (fetchControllers.has(key)) abortFetcher(key);
    fetchLoadMatches.delete(key);
    fetchReloadIds.delete(key);
    fetchRedirectIds.delete(key);
    state.fetchers.delete(key);
  }

  function abortFetcher(key) {
    let controller = fetchControllers.get(key);
    invariant(controller, "Expected fetch controller: " + key);
    controller.abort();
    fetchControllers.delete(key);
  }

  function markFetchersDone(keys) {
    for (let key of keys) {
      let fetcher = getFetcher(key);
      let doneFetcher = {
        state: "idle",
        data: fetcher.data,
        formMethod: undefined,
        formAction: undefined,
        formEncType: undefined,
        formData: undefined,
        " _hasFetcherDoneAnything ": true
      };
      state.fetchers.set(key, doneFetcher);
    }
  }

  function markFetchRedirectsDone() {
    let doneKeys = [];

    for (let key of fetchRedirectIds) {
      let fetcher = state.fetchers.get(key);
      invariant(fetcher, "Expected fetcher: " + key);

      if (fetcher.state === "loading") {
        fetchRedirectIds.delete(key);
        doneKeys.push(key);
      }
    }

    markFetchersDone(doneKeys);
  }

  function abortStaleFetchLoads(landedId) {
    let yeetedKeys = [];

    for (let [key, id] of fetchReloadIds) {
      if (id < landedId) {
        let fetcher = state.fetchers.get(key);
        invariant(fetcher, "Expected fetcher: " + key);

        if (fetcher.state === "loading") {
          abortFetcher(key);
          fetchReloadIds.delete(key);
          yeetedKeys.push(key);
        }
      }
    }

    markFetchersDone(yeetedKeys);
    return yeetedKeys.length > 0;
  }

  function cancelActiveDeferreds(predicate) {
    let cancelledRouteIds = [];
    activeDeferreds.forEach((dfd, routeId) => {
      if (!predicate || predicate(routeId)) {
        // Cancel the deferred - but do not remove from activeDeferreds here -
        // we rely on the subscribers to do that so our tests can assert proper
        // cleanup via _internalActiveDeferreds
        dfd.cancel();
        cancelledRouteIds.push(routeId);
        activeDeferreds.delete(routeId);
      }
    });
    return cancelledRouteIds;
  } // Opt in to capturing and reporting scroll positions during navigations,
  // used by the <ScrollRestoration> component


  function enableScrollRestoration(positions, getPosition, getKey) {
    savedScrollPositions = positions;
    getScrollPosition = getPosition;

    getScrollRestorationKey = getKey || (location => location.key); // Perform initial hydration scroll restoration, since we miss the boat on
    // the initial updateState() because we've not yet rendered <ScrollRestoration/>
    // and therefore have no savedScrollPositions available


    if (!initialScrollRestored && state.navigation === IDLE_NAVIGATION) {
      initialScrollRestored = true;
      let y = getSavedScrollPosition(state.location, state.matches);

      if (y != null) {
        updateState({
          restoreScrollPosition: y
        });
      }
    }

    return () => {
      savedScrollPositions = null;
      getScrollPosition = null;
      getScrollRestorationKey = null;
    };
  }

  function saveScrollPosition(location, matches) {
    if (savedScrollPositions && getScrollRestorationKey && getScrollPosition) {
      let userMatches = matches.map(m => createUseMatchesMatch(m, state.loaderData));
      let key = getScrollRestorationKey(location, userMatches) || location.key;
      savedScrollPositions[key] = getScrollPosition();
    }
  }

  function getSavedScrollPosition(location, matches) {
    if (savedScrollPositions && getScrollRestorationKey && getScrollPosition) {
      let userMatches = matches.map(m => createUseMatchesMatch(m, state.loaderData));
      let key = getScrollRestorationKey(location, userMatches) || location.key;
      let y = savedScrollPositions[key];

      if (typeof y === "number") {
        return y;
      }
    }

    return null;
  }

  router = {
    get basename() {
      return init.basename;
    },

    get state() {
      return state;
    },

    get routes() {
      return dataRoutes;
    },

    initialize,
    subscribe,
    enableScrollRestoration,
    navigate,
    fetch,
    revalidate,
    // Passthrough to history-aware createHref used by useHref so we get proper
    // hash-aware URLs in DOM paths
    createHref: to => init.history.createHref(to),
    encodeLocation: to => init.history.encodeLocation(to),
    getFetcher,
    deleteFetcher,
    dispose,
    _internalFetchControllers: fetchControllers,
    _internalActiveDeferreds: activeDeferreds
  };
  return router;
} //#endregion
////////////////////////////////////////////////////////////////////////////////
//#region createStaticHandler
////////////////////////////////////////////////////////////////////////////////

function createStaticHandler(routes, opts) {
  invariant(routes.length > 0, "You must provide a non-empty routes array to createStaticHandler");
  let dataRoutes = convertRoutesToDataRoutes(routes);
  let basename = (opts ? opts.basename : null) || "/";
  /**
   * The query() method is intended for document requests, in which we want to
   * call an optional action and potentially multiple loaders for all nested
   * routes.  It returns a StaticHandlerContext object, which is very similar
   * to the router state (location, loaderData, actionData, errors, etc.) and
   * also adds SSR-specific information such as the statusCode and headers
   * from action/loaders Responses.
   *
   * It _should_ never throw and should report all errors through the
   * returned context.errors object, properly associating errors to their error
   * boundary.  Additionally, it tracks _deepestRenderedBoundaryId which can be
   * used to emulate React error boundaries during SSr by performing a second
   * pass only down to the boundaryId.
   *
   * The one exception where we do not return a StaticHandlerContext is when a
   * redirect response is returned or thrown from any action/loader.  We
   * propagate that out and return the raw Response so the HTTP server can
   * return it directly.
   */

  async function query(request, _temp2) {
    let {
      requestContext
    } = _temp2 === void 0 ? {} : _temp2;
    let url = new URL(request.url);
    let method = request.method.toLowerCase();
    let location = createLocation("", createPath(url), null, "default");
    let matches = matchRoutes(dataRoutes, location, basename); // SSR supports HEAD requests while SPA doesn't

    if (!isValidMethod(method) && method !== "head") {
      let error = getInternalRouterError(405, {
        method
      });
      let {
        matches: methodNotAllowedMatches,
        route
      } = getShortCircuitMatches(dataRoutes);
      return {
        basename,
        location,
        matches: methodNotAllowedMatches,
        loaderData: {},
        actionData: null,
        errors: {
          [route.id]: error
        },
        statusCode: error.status,
        loaderHeaders: {},
        actionHeaders: {}
      };
    } else if (!matches) {
      let error = getInternalRouterError(404, {
        pathname: location.pathname
      });
      let {
        matches: notFoundMatches,
        route
      } = getShortCircuitMatches(dataRoutes);
      return {
        basename,
        location,
        matches: notFoundMatches,
        loaderData: {},
        actionData: null,
        errors: {
          [route.id]: error
        },
        statusCode: error.status,
        loaderHeaders: {},
        actionHeaders: {}
      };
    }

    let result = await queryImpl(request, location, matches, requestContext);

    if (isResponse(result)) {
      return result;
    } // When returning StaticHandlerContext, we patch back in the location here
    // since we need it for React Context.  But this helps keep our submit and
    // loadRouteData operating on a Request instead of a Location


    return _extends({
      location,
      basename
    }, result);
  }
  /**
   * The queryRoute() method is intended for targeted route requests, either
   * for fetch ?_data requests or resource route requests.  In this case, we
   * are only ever calling a single action or loader, and we are returning the
   * returned value directly.  In most cases, this will be a Response returned
   * from the action/loader, but it may be a primitive or other value as well -
   * and in such cases the calling context should handle that accordingly.
   *
   * We do respect the throw/return differentiation, so if an action/loader
   * throws, then this method will throw the value.  This is important so we
   * can do proper boundary identification in Remix where a thrown Response
   * must go to the Catch Boundary but a returned Response is happy-path.
   *
   * One thing to note is that any Router-initiated Errors that make sense
   * to associate with a status code will be thrown as an ErrorResponse
   * instance which include the raw Error, such that the calling context can
   * serialize the error as they see fit while including the proper response
   * code.  Examples here are 404 and 405 errors that occur prior to reaching
   * any user-defined loaders.
   */


  async function queryRoute(request, _temp3) {
    let {
      routeId,
      requestContext
    } = _temp3 === void 0 ? {} : _temp3;
    let url = new URL(request.url);
    let method = request.method.toLowerCase();
    let location = createLocation("", createPath(url), null, "default");
    let matches = matchRoutes(dataRoutes, location, basename); // SSR supports HEAD requests while SPA doesn't

    if (!isValidMethod(method) && method !== "head") {
      throw getInternalRouterError(405, {
        method
      });
    } else if (!matches) {
      throw getInternalRouterError(404, {
        pathname: location.pathname
      });
    }

    let match = routeId ? matches.find(m => m.route.id === routeId) : getTargetMatch(matches, location);

    if (routeId && !match) {
      throw getInternalRouterError(403, {
        pathname: location.pathname,
        routeId
      });
    } else if (!match) {
      // This should never hit I don't think?
      throw getInternalRouterError(404, {
        pathname: location.pathname
      });
    }

    let result = await queryImpl(request, location, matches, requestContext, match);

    if (isResponse(result)) {
      return result;
    }

    let error = result.errors ? Object.values(result.errors)[0] : undefined;

    if (error !== undefined) {
      // If we got back result.errors, that means the loader/action threw
      // _something_ that wasn't a Response, but it's not guaranteed/required
      // to be an `instanceof Error` either, so we have to use throw here to
      // preserve the "error" state outside of queryImpl.
      throw error;
    } // Pick off the right state value to return


    let routeData = [result.actionData, result.loaderData].find(v => v);
    return Object.values(routeData || {})[0];
  }

  async function queryImpl(request, location, matches, requestContext, routeMatch) {
    invariant(request.signal, "query()/queryRoute() requests must contain an AbortController signal");

    try {
      if (isMutationMethod(request.method.toLowerCase())) {
        let result = await submit(request, matches, routeMatch || getTargetMatch(matches, location), requestContext, routeMatch != null);
        return result;
      }

      let result = await loadRouteData(request, matches, requestContext, routeMatch);
      return isResponse(result) ? result : _extends({}, result, {
        actionData: null,
        actionHeaders: {}
      });
    } catch (e) {
      // If the user threw/returned a Response in callLoaderOrAction, we throw
      // it to bail out and then return or throw here based on whether the user
      // returned or threw
      if (isQueryRouteResponse(e)) {
        if (e.type === ResultType.error && !isRedirectResponse(e.response)) {
          throw e.response;
        }

        return e.response;
      } // Redirects are always returned since they don't propagate to catch
      // boundaries


      if (isRedirectResponse(e)) {
        return e;
      }

      throw e;
    }
  }

  async function submit(request, matches, actionMatch, requestContext, isRouteRequest) {
    let result;

    if (!actionMatch.route.action) {
      let error = getInternalRouterError(405, {
        method: request.method,
        pathname: new URL(request.url).pathname,
        routeId: actionMatch.route.id
      });

      if (isRouteRequest) {
        throw error;
      }

      result = {
        type: ResultType.error,
        error
      };
    } else {
      result = await callLoaderOrAction("action", request, actionMatch, matches, basename, true, isRouteRequest, requestContext);

      if (request.signal.aborted) {
        let method = isRouteRequest ? "queryRoute" : "query";
        throw new Error(method + "() call aborted");
      }
    }

    if (isRedirectResult(result)) {
      // Uhhhh - this should never happen, we should always throw these from
      // callLoaderOrAction, but the type narrowing here keeps TS happy and we
      // can get back on the "throw all redirect responses" train here should
      // this ever happen :/
      throw new Response(null, {
        status: result.status,
        headers: {
          Location: result.location
        }
      });
    }

    if (isDeferredResult(result)) {
      throw new Error("defer() is not supported in actions");
    }

    if (isRouteRequest) {
      // Note: This should only be non-Response values if we get here, since
      // isRouteRequest should throw any Response received in callLoaderOrAction
      if (isErrorResult(result)) {
        throw result.error;
      }

      return {
        matches: [actionMatch],
        loaderData: {},
        actionData: {
          [actionMatch.route.id]: result.data
        },
        errors: null,
        // Note: statusCode + headers are unused here since queryRoute will
        // return the raw Response or value
        statusCode: 200,
        loaderHeaders: {},
        actionHeaders: {}
      };
    }

    if (isErrorResult(result)) {
      // Store off the pending error - we use it to determine which loaders
      // to call and will commit it when we complete the navigation
      let boundaryMatch = findNearestBoundary(matches, actionMatch.route.id);
      let context = await loadRouteData(request, matches, requestContext, undefined, {
        [boundaryMatch.route.id]: result.error
      }); // action status codes take precedence over loader status codes

      return _extends({}, context, {
        statusCode: isRouteErrorResponse(result.error) ? result.error.status : 500,
        actionData: null,
        actionHeaders: _extends({}, result.headers ? {
          [actionMatch.route.id]: result.headers
        } : {})
      });
    } // Create a GET request for the loaders


    let loaderRequest = new Request(request.url, {
      headers: request.headers,
      redirect: request.redirect,
      signal: request.signal
    });
    let context = await loadRouteData(loaderRequest, matches, requestContext);
    return _extends({}, context, result.statusCode ? {
      statusCode: result.statusCode
    } : {}, {
      actionData: {
        [actionMatch.route.id]: result.data
      },
      actionHeaders: _extends({}, result.headers ? {
        [actionMatch.route.id]: result.headers
      } : {})
    });
  }

  async function loadRouteData(request, matches, requestContext, routeMatch, pendingActionError) {
    let isRouteRequest = routeMatch != null; // Short circuit if we have no loaders to run (queryRoute())

    if (isRouteRequest && !(routeMatch != null && routeMatch.route.loader)) {
      throw getInternalRouterError(400, {
        method: request.method,
        pathname: new URL(request.url).pathname,
        routeId: routeMatch == null ? void 0 : routeMatch.route.id
      });
    }

    let requestMatches = routeMatch ? [routeMatch] : getLoaderMatchesUntilBoundary(matches, Object.keys(pendingActionError || {})[0]);
    let matchesToLoad = requestMatches.filter(m => m.route.loader); // Short circuit if we have no loaders to run (query())

    if (matchesToLoad.length === 0) {
      return {
        matches,
        // Add a null for all matched routes for proper revalidation on the client
        loaderData: matches.reduce((acc, m) => Object.assign(acc, {
          [m.route.id]: null
        }), {}),
        errors: pendingActionError || null,
        statusCode: 200,
        loaderHeaders: {}
      };
    }

    let results = await Promise.all([...matchesToLoad.map(match => callLoaderOrAction("loader", request, match, matches, basename, true, isRouteRequest, requestContext))]);

    if (request.signal.aborted) {
      let method = isRouteRequest ? "queryRoute" : "query";
      throw new Error(method + "() call aborted");
    }

    let executedLoaders = new Set();
    results.forEach((result, i) => {
      executedLoaders.add(matchesToLoad[i].route.id); // Can't do anything with these without the Remix side of things, so just
      // cancel them for now

      if (isDeferredResult(result)) {
        result.deferredData.cancel();
      }
    }); // Process and commit output from loaders

    let context = processRouteLoaderData(matches, matchesToLoad, results, pendingActionError); // Add a null for any non-loader matches for proper revalidation on the client

    matches.forEach(match => {
      if (!executedLoaders.has(match.route.id)) {
        context.loaderData[match.route.id] = null;
      }
    });
    return _extends({}, context, {
      matches
    });
  }

  return {
    dataRoutes,
    query,
    queryRoute
  };
} //#endregion
////////////////////////////////////////////////////////////////////////////////
//#region Helpers
////////////////////////////////////////////////////////////////////////////////

/**
 * Given an existing StaticHandlerContext and an error thrown at render time,
 * provide an updated StaticHandlerContext suitable for a second SSR render
 */

function getStaticContextFromError(routes, context, error) {
  let newContext = _extends({}, context, {
    statusCode: 500,
    errors: {
      [context._deepestRenderedBoundaryId || routes[0].id]: error
    }
  });

  return newContext;
}

function isSubmissionNavigation(opts) {
  return opts != null && "formData" in opts;
} // Normalize navigation options by converting formMethod=GET formData objects to
// URLSearchParams so they behave identically to links with query params


function normalizeNavigateOptions(to, opts, isFetcher) {
  if (isFetcher === void 0) {
    isFetcher = false;
  }

  let path = typeof to === "string" ? to : createPath(to); // Return location verbatim on non-submission navigations

  if (!opts || !isSubmissionNavigation(opts)) {
    return {
      path
    };
  }

  if (opts.formMethod && !isValidMethod(opts.formMethod)) {
    return {
      path,
      error: getInternalRouterError(405, {
        method: opts.formMethod
      })
    };
  } // Create a Submission on non-GET navigations


  let submission;

  if (opts.formData) {
    submission = {
      formMethod: opts.formMethod || "get",
      formAction: stripHashFromPath(path),
      formEncType: opts && opts.formEncType || "application/x-www-form-urlencoded",
      formData: opts.formData
    };

    if (isMutationMethod(submission.formMethod)) {
      return {
        path,
        submission
      };
    }
  } // Flatten submission onto URLSearchParams for GET submissions


  let parsedPath = parsePath(path);

  try {
    let searchParams = convertFormDataToSearchParams(opts.formData); // Since fetcher GET submissions only run a single loader (as opposed to
    // navigation GET submissions which run all loaders), we need to preserve
    // any incoming ?index params

    if (isFetcher && parsedPath.search && hasNakedIndexQuery(parsedPath.search)) {
      searchParams.append("index", "");
    }

    parsedPath.search = "?" + searchParams;
  } catch (e) {
    return {
      path,
      error: getInternalRouterError(400)
    };
  }

  return {
    path: createPath(parsedPath),
    submission
  };
} // Filter out all routes below any caught error as they aren't going to
// render so we don't need to load them


function getLoaderMatchesUntilBoundary(matches, boundaryId) {
  let boundaryMatches = matches;

  if (boundaryId) {
    let index = matches.findIndex(m => m.route.id === boundaryId);

    if (index >= 0) {
      boundaryMatches = matches.slice(0, index);
    }
  }

  return boundaryMatches;
}

function getMatchesToLoad(state, matches, submission, location, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, pendingActionData, pendingError, fetchLoadMatches) {
  let actionResult = pendingError ? Object.values(pendingError)[0] : pendingActionData ? Object.values(pendingActionData)[0] : undefined; // Pick navigation matches that are net-new or qualify for revalidation

  let boundaryId = pendingError ? Object.keys(pendingError)[0] : undefined;
  let boundaryMatches = getLoaderMatchesUntilBoundary(matches, boundaryId);
  let navigationMatches = boundaryMatches.filter((match, index) => match.route.loader != null && (isNewLoader(state.loaderData, state.matches[index], match) || // If this route had a pending deferred cancelled it must be revalidated
  cancelledDeferredRoutes.some(id => id === match.route.id) || shouldRevalidateLoader(state.location, state.matches[index], submission, location, match, isRevalidationRequired, actionResult))); // Pick fetcher.loads that need to be revalidated

  let revalidatingFetchers = [];
  fetchLoadMatches && fetchLoadMatches.forEach((_ref10, key) => {
    let [href, match, fetchMatches] = _ref10;

    // This fetcher was cancelled from a prior action submission - force reload
    if (cancelledFetcherLoads.includes(key)) {
      revalidatingFetchers.push([key, href, match, fetchMatches]);
    } else if (isRevalidationRequired) {
      let shouldRevalidate = shouldRevalidateLoader(href, match, submission, href, match, isRevalidationRequired, actionResult);

      if (shouldRevalidate) {
        revalidatingFetchers.push([key, href, match, fetchMatches]);
      }
    }
  });
  return [navigationMatches, revalidatingFetchers];
}

function isNewLoader(currentLoaderData, currentMatch, match) {
  let isNew = // [a] -> [a, b]
  !currentMatch || // [a, b] -> [a, c]
  match.route.id !== currentMatch.route.id; // Handle the case that we don't have data for a re-used route, potentially
  // from a prior error or from a cancelled pending deferred

  let isMissingData = currentLoaderData[match.route.id] === undefined; // Always load if this is a net-new route or we don't yet have data

  return isNew || isMissingData;
}

function isNewRouteInstance(currentMatch, match) {
  let currentPath = currentMatch.route.path;
  return (// param change for this match, /users/123 -> /users/456
    currentMatch.pathname !== match.pathname || // splat param changed, which is not present in match.path
    // e.g. /files/images/avatar.jpg -> files/finances.xls
    currentPath && currentPath.endsWith("*") && currentMatch.params["*"] !== match.params["*"]
  );
}

function shouldRevalidateLoader(currentLocation, currentMatch, submission, location, match, isRevalidationRequired, actionResult) {
  let currentUrl = createClientSideURL(currentLocation);
  let currentParams = currentMatch.params;
  let nextUrl = createClientSideURL(location);
  let nextParams = match.params; // This is the default implementation as to when we revalidate.  If the route
  // provides it's own implementation, then we give them full control but
  // provide this value so they can leverage it if needed after they check
  // their own specific use cases
  // Note that fetchers always provide the same current/next locations so the
  // URL-based checks here don't apply to fetcher shouldRevalidate calls

  let defaultShouldRevalidate = isNewRouteInstance(currentMatch, match) || // Clicked the same link, resubmitted a GET form
  currentUrl.toString() === nextUrl.toString() || // Search params affect all loaders
  currentUrl.search !== nextUrl.search || // Forced revalidation due to submission, useRevalidate, or X-Remix-Revalidate
  isRevalidationRequired;

  if (match.route.shouldRevalidate) {
    let routeChoice = match.route.shouldRevalidate(_extends({
      currentUrl,
      currentParams,
      nextUrl,
      nextParams
    }, submission, {
      actionResult,
      defaultShouldRevalidate
    }));

    if (typeof routeChoice === "boolean") {
      return routeChoice;
    }
  }

  return defaultShouldRevalidate;
}

async function callLoaderOrAction(type, request, match, matches, basename, isStaticRequest, isRouteRequest, requestContext) {
  if (basename === void 0) {
    basename = "/";
  }

  if (isStaticRequest === void 0) {
    isStaticRequest = false;
  }

  if (isRouteRequest === void 0) {
    isRouteRequest = false;
  }

  let resultType;
  let result; // Setup a promise we can race against so that abort signals short circuit

  let reject;
  let abortPromise = new Promise((_, r) => reject = r);

  let onReject = () => reject();

  request.signal.addEventListener("abort", onReject);

  try {
    let handler = match.route[type];
    invariant(handler, "Could not find the " + type + " to run on the \"" + match.route.id + "\" route");
    result = await Promise.race([handler({
      request,
      params: match.params,
      context: requestContext
    }), abortPromise]);
    invariant(result !== undefined, "You defined " + (type === "action" ? "an action" : "a loader") + " for route " + ("\"" + match.route.id + "\" but didn't return anything from your `" + type + "` ") + "function. Please return a value or `null`.");
  } catch (e) {
    resultType = ResultType.error;
    result = e;
  } finally {
    request.signal.removeEventListener("abort", onReject);
  }

  if (isResponse(result)) {
    let status = result.status; // Process redirects

    if (redirectStatusCodes.has(status)) {
      let location = result.headers.get("Location");
      invariant(location, "Redirects returned/thrown from loaders/actions must have a Location header");
      let isAbsolute = /^[a-z+]+:\/\//i.test(location) || location.startsWith("//"); // Support relative routing in internal redirects

      if (!isAbsolute) {
        let activeMatches = matches.slice(0, matches.indexOf(match) + 1);
        let routePathnames = getPathContributingMatches(activeMatches).map(match => match.pathnameBase);
        let resolvedLocation = resolveTo(location, routePathnames, new URL(request.url).pathname);
        invariant(createPath(resolvedLocation), "Unable to resolve redirect location: " + location); // Prepend the basename to the redirect location if we have one

        if (basename) {
          let path = resolvedLocation.pathname;
          resolvedLocation.pathname = path === "/" ? basename : joinPaths([basename, path]);
        }

        location = createPath(resolvedLocation);
      } // Don't process redirects in the router during static requests requests.
      // Instead, throw the Response and let the server handle it with an HTTP
      // redirect.  We also update the Location header in place in this flow so
      // basename and relative routing is taken into account


      if (isStaticRequest) {
        result.headers.set("Location", location);
        throw result;
      }

      return {
        type: ResultType.redirect,
        status,
        location,
        revalidate: result.headers.get("X-Remix-Revalidate") !== null
      };
    } // For SSR single-route requests, we want to hand Responses back directly
    // without unwrapping.  We do this with the QueryRouteResponse wrapper
    // interface so we can know whether it was returned or thrown


    if (isRouteRequest) {
      // eslint-disable-next-line no-throw-literal
      throw {
        type: resultType || ResultType.data,
        response: result
      };
    }

    let data;
    let contentType = result.headers.get("Content-Type"); // Check between word boundaries instead of startsWith() due to the last
    // paragraph of https://httpwg.org/specs/rfc9110.html#field.content-type

    if (contentType && /\bapplication\/json\b/.test(contentType)) {
      data = await result.json();
    } else {
      data = await result.text();
    }

    if (resultType === ResultType.error) {
      return {
        type: resultType,
        error: new ErrorResponse(status, result.statusText, data),
        headers: result.headers
      };
    }

    return {
      type: ResultType.data,
      data,
      statusCode: result.status,
      headers: result.headers
    };
  }

  if (resultType === ResultType.error) {
    return {
      type: resultType,
      error: result
    };
  }

  if (result instanceof DeferredData) {
    return {
      type: ResultType.deferred,
      deferredData: result
    };
  }

  return {
    type: ResultType.data,
    data: result
  };
} // Utility method for creating the Request instances for loaders/actions during
// client-side navigations and fetches.  During SSR we will always have a
// Request instance from the static handler (query/queryRoute)


function createClientSideRequest(location, signal, submission) {
  let url = createClientSideURL(stripHashFromPath(location)).toString();
  let init = {
    signal
  };

  if (submission && isMutationMethod(submission.formMethod)) {
    let {
      formMethod,
      formEncType,
      formData
    } = submission;
    init.method = formMethod.toUpperCase();
    init.body = formEncType === "application/x-www-form-urlencoded" ? convertFormDataToSearchParams(formData) : formData;
  } // Content-Type is inferred (https://fetch.spec.whatwg.org/#dom-request)


  return new Request(url, init);
}

function convertFormDataToSearchParams(formData) {
  let searchParams = new URLSearchParams();

  for (let [key, value] of formData.entries()) {
    invariant(typeof value === "string", 'File inputs are not supported with encType "application/x-www-form-urlencoded", ' + 'please use "multipart/form-data" instead.');
    searchParams.append(key, value);
  }

  return searchParams;
}

function processRouteLoaderData(matches, matchesToLoad, results, pendingError, activeDeferreds) {
  // Fill in loaderData/errors from our loaders
  let loaderData = {};
  let errors = null;
  let statusCode;
  let foundError = false;
  let loaderHeaders = {}; // Process loader results into state.loaderData/state.errors

  results.forEach((result, index) => {
    let id = matchesToLoad[index].route.id;
    invariant(!isRedirectResult(result), "Cannot handle redirect results in processLoaderData");

    if (isErrorResult(result)) {
      // Look upwards from the matched route for the closest ancestor
      // error boundary, defaulting to the root match
      let boundaryMatch = findNearestBoundary(matches, id);
      let error = result.error; // If we have a pending action error, we report it at the highest-route
      // that throws a loader error, and then clear it out to indicate that
      // it was consumed

      if (pendingError) {
        error = Object.values(pendingError)[0];
        pendingError = undefined;
      }

      errors = errors || {}; // Prefer higher error values if lower errors bubble to the same boundary

      if (errors[boundaryMatch.route.id] == null) {
        errors[boundaryMatch.route.id] = error;
      } // Clear our any prior loaderData for the throwing route


      loaderData[id] = undefined; // Once we find our first (highest) error, we set the status code and
      // prevent deeper status codes from overriding

      if (!foundError) {
        foundError = true;
        statusCode = isRouteErrorResponse(result.error) ? result.error.status : 500;
      }

      if (result.headers) {
        loaderHeaders[id] = result.headers;
      }
    } else if (isDeferredResult(result)) {
      activeDeferreds && activeDeferreds.set(id, result.deferredData);
      loaderData[id] = result.deferredData.data; // TODO: Add statusCode/headers once we wire up streaming in Remix
    } else {
      loaderData[id] = result.data; // Error status codes always override success status codes, but if all
      // loaders are successful we take the deepest status code.

      if (result.statusCode != null && result.statusCode !== 200 && !foundError) {
        statusCode = result.statusCode;
      }

      if (result.headers) {
        loaderHeaders[id] = result.headers;
      }
    }
  }); // If we didn't consume the pending action error (i.e., all loaders
  // resolved), then consume it here.  Also clear out any loaderData for the
  // throwing route

  if (pendingError) {
    errors = pendingError;
    loaderData[Object.keys(pendingError)[0]] = undefined;
  }

  return {
    loaderData,
    errors,
    statusCode: statusCode || 200,
    loaderHeaders
  };
}

function processLoaderData(state, matches, matchesToLoad, results, pendingError, revalidatingFetchers, fetcherResults, activeDeferreds) {
  let {
    loaderData,
    errors
  } = processRouteLoaderData(matches, matchesToLoad, results, pendingError, activeDeferreds); // Process results from our revalidating fetchers

  for (let index = 0; index < revalidatingFetchers.length; index++) {
    let [key,, match] = revalidatingFetchers[index];
    invariant(fetcherResults !== undefined && fetcherResults[index] !== undefined, "Did not find corresponding fetcher result");
    let result = fetcherResults[index]; // Process fetcher non-redirect errors

    if (isErrorResult(result)) {
      let boundaryMatch = findNearestBoundary(state.matches, match.route.id);

      if (!(errors && errors[boundaryMatch.route.id])) {
        errors = _extends({}, errors, {
          [boundaryMatch.route.id]: result.error
        });
      }

      state.fetchers.delete(key);
    } else if (isRedirectResult(result)) {
      // Should never get here, redirects should get processed above, but we
      // keep this to type narrow to a success result in the else
      throw new Error("Unhandled fetcher revalidation redirect");
    } else if (isDeferredResult(result)) {
      // Should never get here, deferred data should be awaited for fetchers
      // in resolveDeferredResults
      throw new Error("Unhandled fetcher deferred data");
    } else {
      let doneFetcher = {
        state: "idle",
        data: result.data,
        formMethod: undefined,
        formAction: undefined,
        formEncType: undefined,
        formData: undefined,
        " _hasFetcherDoneAnything ": true
      };
      state.fetchers.set(key, doneFetcher);
    }
  }

  return {
    loaderData,
    errors
  };
}

function mergeLoaderData(loaderData, newLoaderData, matches, errors) {
  let mergedLoaderData = _extends({}, newLoaderData);

  for (let match of matches) {
    let id = match.route.id;

    if (newLoaderData.hasOwnProperty(id)) {
      if (newLoaderData[id] !== undefined) {
        mergedLoaderData[id] = newLoaderData[id];
      }
    } else if (loaderData[id] !== undefined) {
      mergedLoaderData[id] = loaderData[id];
    }

    if (errors && errors.hasOwnProperty(id)) {
      // Don't keep any loader data below the boundary
      break;
    }
  }

  return mergedLoaderData;
} // Find the nearest error boundary, looking upwards from the leaf route (or the
// route specified by routeId) for the closest ancestor error boundary,
// defaulting to the root match


function findNearestBoundary(matches, routeId) {
  let eligibleMatches = routeId ? matches.slice(0, matches.findIndex(m => m.route.id === routeId) + 1) : [...matches];
  return eligibleMatches.reverse().find(m => m.route.hasErrorBoundary === true) || matches[0];
}

function getShortCircuitMatches(routes) {
  // Prefer a root layout route if present, otherwise shim in a route object
  let route = routes.find(r => r.index || !r.path || r.path === "/") || {
    id: "__shim-error-route__"
  };
  return {
    matches: [{
      params: {},
      pathname: "",
      pathnameBase: "",
      route
    }],
    route
  };
}

function getInternalRouterError(status, _temp4) {
  let {
    pathname,
    routeId,
    method
  } = _temp4 === void 0 ? {} : _temp4;
  let statusText = "Unknown Server Error";
  let errorMessage = "Unknown @remix-run/router error";

  if (status === 400) {
    statusText = "Bad Request";

    if (method && pathname && routeId) {
      errorMessage = "You made a " + method + " request to \"" + pathname + "\" but " + ("did not provide a `loader` for route \"" + routeId + "\", ") + "so there is no way to handle the request.";
    } else {
      errorMessage = "Cannot submit binary form data using GET";
    }
  } else if (status === 403) {
    statusText = "Forbidden";
    errorMessage = "Route \"" + routeId + "\" does not match URL \"" + pathname + "\"";
  } else if (status === 404) {
    statusText = "Not Found";
    errorMessage = "No route matches URL \"" + pathname + "\"";
  } else if (status === 405) {
    statusText = "Method Not Allowed";

    if (method && pathname && routeId) {
      errorMessage = "You made a " + method.toUpperCase() + " request to \"" + pathname + "\" but " + ("did not provide an `action` for route \"" + routeId + "\", ") + "so there is no way to handle the request.";
    } else if (method) {
      errorMessage = "Invalid request method \"" + method.toUpperCase() + "\"";
    }
  }

  return new ErrorResponse(status || 500, statusText, new Error(errorMessage), true);
} // Find any returned redirect errors, starting from the lowest match


function findRedirect(results) {
  for (let i = results.length - 1; i >= 0; i--) {
    let result = results[i];

    if (isRedirectResult(result)) {
      return result;
    }
  }
}

function stripHashFromPath(path) {
  let parsedPath = typeof path === "string" ? parsePath(path) : path;
  return createPath(_extends({}, parsedPath, {
    hash: ""
  }));
}

function isHashChangeOnly(a, b) {
  return a.pathname === b.pathname && a.search === b.search && a.hash !== b.hash;
}

function isDeferredResult(result) {
  return result.type === ResultType.deferred;
}

function isErrorResult(result) {
  return result.type === ResultType.error;
}

function isRedirectResult(result) {
  return (result && result.type) === ResultType.redirect;
}

function isResponse(value) {
  return value != null && typeof value.status === "number" && typeof value.statusText === "string" && typeof value.headers === "object" && typeof value.body !== "undefined";
}

function isRedirectResponse(result) {
  if (!isResponse(result)) {
    return false;
  }

  let status = result.status;
  let location = result.headers.get("Location");
  return status >= 300 && status <= 399 && location != null;
}

function isQueryRouteResponse(obj) {
  return obj && isResponse(obj.response) && (obj.type === ResultType.data || ResultType.error);
}

function isValidMethod(method) {
  return validRequestMethods.has(method);
}

function isMutationMethod(method) {
  return validMutationMethods.has(method);
}

async function resolveDeferredResults(currentMatches, matchesToLoad, results, signal, isFetcher, currentLoaderData) {
  for (let index = 0; index < results.length; index++) {
    let result = results[index];
    let match = matchesToLoad[index];
    let currentMatch = currentMatches.find(m => m.route.id === match.route.id);
    let isRevalidatingLoader = currentMatch != null && !isNewRouteInstance(currentMatch, match) && (currentLoaderData && currentLoaderData[match.route.id]) !== undefined;

    if (isDeferredResult(result) && (isFetcher || isRevalidatingLoader)) {
      // Note: we do not have to touch activeDeferreds here since we race them
      // against the signal in resolveDeferredData and they'll get aborted
      // there if needed
      await resolveDeferredData(result, signal, isFetcher).then(result => {
        if (result) {
          results[index] = result || results[index];
        }
      });
    }
  }
}

async function resolveDeferredData(result, signal, unwrap) {
  if (unwrap === void 0) {
    unwrap = false;
  }

  let aborted = await result.deferredData.resolveData(signal);

  if (aborted) {
    return;
  }

  if (unwrap) {
    try {
      return {
        type: ResultType.data,
        data: result.deferredData.unwrappedData
      };
    } catch (e) {
      // Handle any TrackedPromise._error values encountered while unwrapping
      return {
        type: ResultType.error,
        error: e
      };
    }
  }

  return {
    type: ResultType.data,
    data: result.deferredData.data
  };
}

function hasNakedIndexQuery(search) {
  return new URLSearchParams(search).getAll("index").some(v => v === "");
} // Note: This should match the format exported by useMatches, so if you change
// this please also change that :)  Eventually we'll DRY this up


function createUseMatchesMatch(match, loaderData) {
  let {
    route,
    pathname,
    params
  } = match;
  return {
    id: route.id,
    pathname,
    params,
    data: loaderData[route.id],
    handle: route.handle
  };
}

function getTargetMatch(matches, location) {
  let search = typeof location === "string" ? parsePath(location).search : location.search;

  if (matches[matches.length - 1].route.index && hasNakedIndexQuery(search || "")) {
    // Return the leaf index route when index is present
    return matches[matches.length - 1];
  } // Otherwise grab the deepest "path contributing" match (ignoring index and
  // pathless layout routes)


  let pathMatches = getPathContributingMatches(matches);
  return pathMatches[pathMatches.length - 1];
} //#endregion


//# sourceMappingURL=router.js.map

;// CONCATENATED MODULE: ./node_modules/react-router/dist/index.js
/**
 * React Router v6.6.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */




function dist_extends() {
  dist_extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return dist_extends.apply(this, arguments);
}

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/**
 * inlined Object.is polyfill to avoid requiring consumers ship their own
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
 */

function isPolyfill(x, y) {
  return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y // eslint-disable-line no-self-compare
  ;
}

const is = typeof Object.is === "function" ? Object.is : isPolyfill; // Intentionally not using named imports because Rollup uses dynamic
// dispatch for CommonJS interop named imports.

const {
  useState,
  useEffect,
  useLayoutEffect,
  useDebugValue
} = react_namespaceObject;
let didWarnOld18Alpha = false;
let didWarnUncachedGetSnapshot = false; // Disclaimer: This shim breaks many of the rules of React, and only works
// because of a very particular set of implementation details and assumptions
// -- change any one of them and it will break. The most important assumption
// is that updates are always synchronous, because concurrent rendering is
// only available in versions of React that also have a built-in
// useSyncExternalStore API. And we only use this shim when the built-in API
// does not exist.
//
// Do not assume that the clever hacks used by this hook also work in general.
// The point of this shim is to replace the need for hacks by other libraries.

function useSyncExternalStore$2(subscribe, getSnapshot, // Note: The shim does not use getServerSnapshot, because pre-18 versions of
// React do not expose a way to check if we're hydrating. So users of the shim
// will need to track that themselves and return the correct value
// from `getSnapshot`.
getServerSnapshot) {
  if (false) {} // Read the current snapshot from the store on every render. Again, this
  // breaks the rules of React, and only works here because of specific
  // implementation details, most importantly that updates are
  // always synchronous.


  const value = getSnapshot();

  if (false) {} // Because updates are synchronous, we don't queue them. Instead we force a
  // re-render whenever the subscribed state changes by updating an some
  // arbitrary useState hook. Then, during render, we call getSnapshot to read
  // the current value.
  //
  // Because we don't actually use the state returned by the useState hook, we
  // can save a bit of memory by storing other stuff in that slot.
  //
  // To implement the early bailout, we need to track some things on a mutable
  // object. Usually, we would put that in a useRef hook, but we can stash it in
  // our useState hook instead.
  //
  // To force a re-render, we call forceUpdate({inst}). That works because the
  // new object always fails an equality check.


  const [{
    inst
  }, forceUpdate] = useState({
    inst: {
      value,
      getSnapshot
    }
  }); // Track the latest getSnapshot function with a ref. This needs to be updated
  // in the layout phase so we can access it during the tearing check that
  // happens on subscribe.

  useLayoutEffect(() => {
    inst.value = value;
    inst.getSnapshot = getSnapshot; // Whenever getSnapshot or subscribe changes, we need to check in the
    // commit phase if there was an interleaved mutation. In concurrent mode
    // this can happen all the time, but even in synchronous mode, an earlier
    // effect may have mutated the store.

    if (checkIfSnapshotChanged(inst)) {
      // Force a re-render.
      forceUpdate({
        inst
      });
    } // eslint-disable-next-line react-hooks/exhaustive-deps

  }, [subscribe, value, getSnapshot]);
  useEffect(() => {
    // Check for changes right before subscribing. Subsequent changes will be
    // detected in the subscription handler.
    if (checkIfSnapshotChanged(inst)) {
      // Force a re-render.
      forceUpdate({
        inst
      });
    }

    const handleStoreChange = () => {
      // TODO: Because there is no cross-renderer API for batching updates, it's
      // up to the consumer of this library to wrap their subscription event
      // with unstable_batchedUpdates. Should we try to detect when this isn't
      // the case and print a warning in development?
      // The store changed. Check if the snapshot changed since the last time we
      // read from the store.
      if (checkIfSnapshotChanged(inst)) {
        // Force a re-render.
        forceUpdate({
          inst
        });
      }
    }; // Subscribe to the store and return a clean-up function.


    return subscribe(handleStoreChange); // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [subscribe]);
  useDebugValue(value);
  return value;
}

function checkIfSnapshotChanged(inst) {
  const latestGetSnapshot = inst.getSnapshot;
  const prevValue = inst.value;

  try {
    const nextValue = latestGetSnapshot();
    return !is(prevValue, nextValue);
  } catch (error) {
    return true;
  }
}

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
 */
function useSyncExternalStore$1(subscribe, getSnapshot, getServerSnapshot) {
  // Note: The shim does not use getServerSnapshot, because pre-18 versions of
  // React do not expose a way to check if we're hydrating. So users of the shim
  // will need to track that themselves and return the correct value
  // from `getSnapshot`.
  return getSnapshot();
}

/**
 * Inlined into the react-router repo since use-sync-external-store does not
 * provide a UMD-compatible package, so we need this to be able to distribute
 * UMD react-router bundles
 */
const canUseDOM = !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
const isServerEnvironment = !canUseDOM;
const shim = isServerEnvironment ? useSyncExternalStore$1 : useSyncExternalStore$2;
const useSyncExternalStore =  true ? (module => module.useSyncExternalStore)(react_namespaceObject) : shim;

// Contexts for data routers
const DataStaticRouterContext = /*#__PURE__*/react.createContext(null);

if (false) {}

const DataRouterContext = /*#__PURE__*/react.createContext(null);

if (false) {}

const DataRouterStateContext = /*#__PURE__*/react.createContext(null);

if (false) {}

const AwaitContext = /*#__PURE__*/react.createContext(null);

if (false) {}

const NavigationContext = /*#__PURE__*/react.createContext(null);

if (false) {}

const LocationContext = /*#__PURE__*/react.createContext(null);

if (false) {}

const RouteContext = /*#__PURE__*/react.createContext({
  outlet: null,
  matches: []
});

if (false) {}

const RouteErrorContext = /*#__PURE__*/react.createContext(null);

if (false) {}

/**
 * Returns the full href for the given "to" value. This is useful for building
 * custom links that are also accessible and preserve right-click behavior.
 *
 * @see https://reactrouter.com/hooks/use-href
 */

function useHref(to, _temp) {
  let {
    relative
  } = _temp === void 0 ? {} : _temp;
  !useInRouterContext() ?  false ? 0 : invariant(false) : void 0;
  let {
    basename,
    navigator
  } = react.useContext(NavigationContext);
  let {
    hash,
    pathname,
    search
  } = useResolvedPath(to, {
    relative
  });
  let joinedPathname = pathname; // If we're operating within a basename, prepend it to the pathname prior
  // to creating the href.  If this is a root navigation, then just use the raw
  // basename which allows the basename to have full control over the presence
  // of a trailing slash on root links

  if (basename !== "/") {
    joinedPathname = pathname === "/" ? basename : joinPaths([basename, pathname]);
  }

  return navigator.createHref({
    pathname: joinedPathname,
    search,
    hash
  });
}
/**
 * Returns true if this component is a descendant of a <Router>.
 *
 * @see https://reactrouter.com/hooks/use-in-router-context
 */

function useInRouterContext() {
  return react.useContext(LocationContext) != null;
}
/**
 * Returns the current location object, which represents the current URL in web
 * browsers.
 *
 * Note: If you're using this it may mean you're doing some of your own
 * "routing" in your app, and we'd like to know what your use case is. We may
 * be able to provide something higher-level to better suit your needs.
 *
 * @see https://reactrouter.com/hooks/use-location
 */

function useLocation() {
  !useInRouterContext() ?  false ? 0 : invariant(false) : void 0;
  return react.useContext(LocationContext).location;
}
/**
 * Returns the current navigation action which describes how the router came to
 * the current location, either by a pop, push, or replace on the history stack.
 *
 * @see https://reactrouter.com/hooks/use-navigation-type
 */

function useNavigationType() {
  return react.useContext(LocationContext).navigationType;
}
/**
 * Returns a PathMatch object if the given pattern matches the current URL.
 * This is useful for components that need to know "active" state, e.g.
 * <NavLink>.
 *
 * @see https://reactrouter.com/hooks/use-match
 */

function useMatch(pattern) {
  !useInRouterContext() ?  false ? 0 : invariant(false) : void 0;
  let {
    pathname
  } = useLocation();
  return react.useMemo(() => matchPath(pattern, pathname), [pathname, pattern]);
}
/**
 * The interface for the navigate() function returned from useNavigate().
 */

/**
 * Returns an imperative method for changing the location. Used by <Link>s, but
 * may also be used by other elements to change the location.
 *
 * @see https://reactrouter.com/hooks/use-navigate
 */
function useNavigate() {
  !useInRouterContext() ?  false ? 0 : invariant(false) : void 0;
  let {
    basename,
    navigator
  } = react.useContext(NavigationContext);
  let {
    matches
  } = react.useContext(RouteContext);
  let {
    pathname: locationPathname
  } = useLocation();
  let routePathnamesJson = JSON.stringify(getPathContributingMatches(matches).map(match => match.pathnameBase));
  let activeRef = react.useRef(false);
  react.useEffect(() => {
    activeRef.current = true;
  });
  let navigate = react.useCallback(function (to, options) {
    if (options === void 0) {
      options = {};
    }

     false ? 0 : void 0;
    if (!activeRef.current) return;

    if (typeof to === "number") {
      navigator.go(to);
      return;
    }

    let path = resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, options.relative === "path"); // If we're operating within a basename, prepend it to the pathname prior
    // to handing off to history.  If this is a root navigation, then we
    // navigate to the raw basename which allows the basename to have full
    // control over the presence of a trailing slash on root links

    if (basename !== "/") {
      path.pathname = path.pathname === "/" ? basename : joinPaths([basename, path.pathname]);
    }

    (!!options.replace ? navigator.replace : navigator.push)(path, options.state, options);
  }, [basename, navigator, routePathnamesJson, locationPathname]);
  return navigate;
}
const OutletContext = /*#__PURE__*/react.createContext(null);
/**
 * Returns the context (if provided) for the child route at this level of the route
 * hierarchy.
 * @see https://reactrouter.com/hooks/use-outlet-context
 */

function useOutletContext() {
  return react.useContext(OutletContext);
}
/**
 * Returns the element for the child route at this level of the route
 * hierarchy. Used internally by <Outlet> to render child routes.
 *
 * @see https://reactrouter.com/hooks/use-outlet
 */

function useOutlet(context) {
  let outlet = react.useContext(RouteContext).outlet;

  if (outlet) {
    return /*#__PURE__*/react.createElement(OutletContext.Provider, {
      value: context
    }, outlet);
  }

  return outlet;
}
/**
 * Returns an object of key/value pairs of the dynamic params from the current
 * URL that were matched by the route path.
 *
 * @see https://reactrouter.com/hooks/use-params
 */

function useParams() {
  let {
    matches
  } = react.useContext(RouteContext);
  let routeMatch = matches[matches.length - 1];
  return routeMatch ? routeMatch.params : {};
}
/**
 * Resolves the pathname of the given `to` value against the current location.
 *
 * @see https://reactrouter.com/hooks/use-resolved-path
 */

function useResolvedPath(to, _temp2) {
  let {
    relative
  } = _temp2 === void 0 ? {} : _temp2;
  let {
    matches
  } = react.useContext(RouteContext);
  let {
    pathname: locationPathname
  } = useLocation();
  let routePathnamesJson = JSON.stringify(getPathContributingMatches(matches).map(match => match.pathnameBase));
  return react.useMemo(() => resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, relative === "path"), [to, routePathnamesJson, locationPathname, relative]);
}
/**
 * Returns the element of the route that matched the current location, prepared
 * with the correct context to render the remainder of the route tree. Route
 * elements in the tree must render an <Outlet> to render their child route's
 * element.
 *
 * @see https://reactrouter.com/hooks/use-routes
 */

function useRoutes(routes, locationArg) {
  !useInRouterContext() ?  false ? 0 : invariant(false) : void 0;
  let {
    navigator
  } = react.useContext(NavigationContext);
  let dataRouterStateContext = react.useContext(DataRouterStateContext);
  let {
    matches: parentMatches
  } = react.useContext(RouteContext);
  let routeMatch = parentMatches[parentMatches.length - 1];
  let parentParams = routeMatch ? routeMatch.params : {};
  let parentPathname = routeMatch ? routeMatch.pathname : "/";
  let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : "/";
  let parentRoute = routeMatch && routeMatch.route;

  if (false) {}

  let locationFromContext = useLocation();
  let location;

  if (locationArg) {
    var _parsedLocationArg$pa;

    let parsedLocationArg = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
    !(parentPathnameBase === "/" || ((_parsedLocationArg$pa = parsedLocationArg.pathname) == null ? void 0 : _parsedLocationArg$pa.startsWith(parentPathnameBase))) ?  false ? 0 : invariant(false) : void 0;
    location = parsedLocationArg;
  } else {
    location = locationFromContext;
  }

  let pathname = location.pathname || "/";
  let remainingPathname = parentPathnameBase === "/" ? pathname : pathname.slice(parentPathnameBase.length) || "/";
  let matches = matchRoutes(routes, {
    pathname: remainingPathname
  });

  if (false) {}

  let renderedMatches = _renderMatches(matches && matches.map(match => Object.assign({}, match, {
    params: Object.assign({}, parentParams, match.params),
    pathname: joinPaths([parentPathnameBase, // Re-encode pathnames that were decoded inside matchRoutes
    navigator.encodeLocation ? navigator.encodeLocation(match.pathname).pathname : match.pathname]),
    pathnameBase: match.pathnameBase === "/" ? parentPathnameBase : joinPaths([parentPathnameBase, // Re-encode pathnames that were decoded inside matchRoutes
    navigator.encodeLocation ? navigator.encodeLocation(match.pathnameBase).pathname : match.pathnameBase])
  })), parentMatches, dataRouterStateContext || undefined); // When a user passes in a `locationArg`, the associated routes need to
  // be wrapped in a new `LocationContext.Provider` in order for `useLocation`
  // to use the scoped location instead of the global location.


  if (locationArg && renderedMatches) {
    return /*#__PURE__*/react.createElement(LocationContext.Provider, {
      value: {
        location: dist_extends({
          pathname: "/",
          search: "",
          hash: "",
          state: null,
          key: "default"
        }, location),
        navigationType: Action.Pop
      }
    }, renderedMatches);
  }

  return renderedMatches;
}

function DefaultErrorElement() {
  let error = useRouteError();
  let message = isRouteErrorResponse(error) ? error.status + " " + error.statusText : error instanceof Error ? error.message : JSON.stringify(error);
  let stack = error instanceof Error ? error.stack : null;
  let lightgrey = "rgba(200,200,200, 0.5)";
  let preStyles = {
    padding: "0.5rem",
    backgroundColor: lightgrey
  };
  let codeStyles = {
    padding: "2px 4px",
    backgroundColor: lightgrey
  };
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement("h2", null, "Unhandled Thrown Error!"), /*#__PURE__*/react.createElement("h3", {
    style: {
      fontStyle: "italic"
    }
  }, message), stack ? /*#__PURE__*/react.createElement("pre", {
    style: preStyles
  }, stack) : null, /*#__PURE__*/react.createElement("p", null, "\uD83D\uDCBF Hey developer \uD83D\uDC4B"), /*#__PURE__*/react.createElement("p", null, "You can provide a way better UX than this when your app throws errors by providing your own\xA0", /*#__PURE__*/react.createElement("code", {
    style: codeStyles
  }, "errorElement"), " props on\xA0", /*#__PURE__*/react.createElement("code", {
    style: codeStyles
  }, "<Route>")));
}

class RenderErrorBoundary extends react.Component {
  constructor(props) {
    super(props);
    this.state = {
      location: props.location,
      error: props.error
    };
  }

  static getDerivedStateFromError(error) {
    return {
      error: error
    };
  }

  static getDerivedStateFromProps(props, state) {
    // When we get into an error state, the user will likely click "back" to the
    // previous page that didn't have an error. Because this wraps the entire
    // application, that will have no effect--the error page continues to display.
    // This gives us a mechanism to recover from the error when the location changes.
    //
    // Whether we're in an error state or not, we update the location in state
    // so that when we are in an error state, it gets reset when a new location
    // comes in and the user recovers from the error.
    if (state.location !== props.location) {
      return {
        error: props.error,
        location: props.location
      };
    } // If we're not changing locations, preserve the location but still surface
    // any new errors that may come through. We retain the existing error, we do
    // this because the error provided from the app state may be cleared without
    // the location changing.


    return {
      error: props.error || state.error,
      location: state.location
    };
  }

  componentDidCatch(error, errorInfo) {
    console.error("React Router caught the following error during render", error, errorInfo);
  }

  render() {
    return this.state.error ? /*#__PURE__*/react.createElement(RouteContext.Provider, {
      value: this.props.routeContext
    }, /*#__PURE__*/react.createElement(RouteErrorContext.Provider, {
      value: this.state.error,
      children: this.props.component
    })) : this.props.children;
  }

}

function RenderedRoute(_ref) {
  let {
    routeContext,
    match,
    children
  } = _ref;
  let dataStaticRouterContext = react.useContext(DataStaticRouterContext); // Track how deep we got in our render pass to emulate SSR componentDidCatch
  // in a DataStaticRouter

  if (dataStaticRouterContext && match.route.errorElement) {
    dataStaticRouterContext._deepestRenderedBoundaryId = match.route.id;
  }

  return /*#__PURE__*/react.createElement(RouteContext.Provider, {
    value: routeContext
  }, children);
}

function _renderMatches(matches, parentMatches, dataRouterState) {
  if (parentMatches === void 0) {
    parentMatches = [];
  }

  if (matches == null) {
    if (dataRouterState != null && dataRouterState.errors) {
      // Don't bail if we have data router errors so we can render them in the
      // boundary.  Use the pre-matched (or shimmed) matches
      matches = dataRouterState.matches;
    } else {
      return null;
    }
  }

  let renderedMatches = matches; // If we have data errors, trim matches to the highest error boundary

  let errors = dataRouterState == null ? void 0 : dataRouterState.errors;

  if (errors != null) {
    let errorIndex = renderedMatches.findIndex(m => m.route.id && (errors == null ? void 0 : errors[m.route.id]));
    !(errorIndex >= 0) ?  false ? 0 : invariant(false) : void 0;
    renderedMatches = renderedMatches.slice(0, Math.min(renderedMatches.length, errorIndex + 1));
  }

  return renderedMatches.reduceRight((outlet, match, index) => {
    let error = match.route.id ? errors == null ? void 0 : errors[match.route.id] : null; // Only data routers handle errors

    let errorElement = dataRouterState ? match.route.errorElement || /*#__PURE__*/react.createElement(DefaultErrorElement, null) : null;
    let matches = parentMatches.concat(renderedMatches.slice(0, index + 1));

    let getChildren = () => /*#__PURE__*/react.createElement(RenderedRoute, {
      match: match,
      routeContext: {
        outlet,
        matches
      }
    }, error ? errorElement : match.route.element !== undefined ? match.route.element : outlet); // Only wrap in an error boundary within data router usages when we have an
    // errorElement on this route.  Otherwise let it bubble up to an ancestor
    // errorElement


    return dataRouterState && (match.route.errorElement || index === 0) ? /*#__PURE__*/react.createElement(RenderErrorBoundary, {
      location: dataRouterState.location,
      component: errorElement,
      error: error,
      children: getChildren(),
      routeContext: {
        outlet: null,
        matches
      }
    }) : getChildren();
  }, null);
}
var DataRouterHook;

(function (DataRouterHook) {
  DataRouterHook["UseRevalidator"] = "useRevalidator";
})(DataRouterHook || (DataRouterHook = {}));

var DataRouterStateHook;

(function (DataRouterStateHook) {
  DataRouterStateHook["UseLoaderData"] = "useLoaderData";
  DataRouterStateHook["UseActionData"] = "useActionData";
  DataRouterStateHook["UseRouteError"] = "useRouteError";
  DataRouterStateHook["UseNavigation"] = "useNavigation";
  DataRouterStateHook["UseRouteLoaderData"] = "useRouteLoaderData";
  DataRouterStateHook["UseMatches"] = "useMatches";
  DataRouterStateHook["UseRevalidator"] = "useRevalidator";
})(DataRouterStateHook || (DataRouterStateHook = {}));

function getDataRouterConsoleError(hookName) {
  return hookName + " must be used within a data router.  See https://reactrouter.com/routers/picking-a-router.";
}

function useDataRouterContext(hookName) {
  let ctx = react.useContext(DataRouterContext);
  !ctx ?  false ? 0 : invariant(false) : void 0;
  return ctx;
}

function useDataRouterState(hookName) {
  let state = react.useContext(DataRouterStateContext);
  !state ?  false ? 0 : invariant(false) : void 0;
  return state;
}

function useRouteContext(hookName) {
  let route = react.useContext(RouteContext);
  !route ?  false ? 0 : invariant(false) : void 0;
  return route;
}

function useCurrentRouteId(hookName) {
  let route = useRouteContext(hookName);
  let thisRoute = route.matches[route.matches.length - 1];
  !thisRoute.route.id ?  false ? 0 : invariant(false) : void 0;
  return thisRoute.route.id;
}
/**
 * Returns the current navigation, defaulting to an "idle" navigation when
 * no navigation is in progress
 */


function useNavigation() {
  let state = useDataRouterState(DataRouterStateHook.UseNavigation);
  return state.navigation;
}
/**
 * Returns a revalidate function for manually triggering revalidation, as well
 * as the current state of any manual revalidations
 */

function useRevalidator() {
  let dataRouterContext = useDataRouterContext(DataRouterHook.UseRevalidator);
  let state = useDataRouterState(DataRouterStateHook.UseRevalidator);
  return {
    revalidate: dataRouterContext.router.revalidate,
    state: state.revalidation
  };
}
/**
 * Returns the active route matches, useful for accessing loaderData for
 * parent/child routes or the route "handle" property
 */

function useMatches() {
  let {
    matches,
    loaderData
  } = useDataRouterState(DataRouterStateHook.UseMatches);
  return react.useMemo(() => matches.map(match => {
    let {
      pathname,
      params
    } = match; // Note: This structure matches that created by createUseMatchesMatch
    // in the @remix-run/router , so if you change this please also change
    // that :)  Eventually we'll DRY this up

    return {
      id: match.route.id,
      pathname,
      params,
      data: loaderData[match.route.id],
      handle: match.route.handle
    };
  }), [matches, loaderData]);
}
/**
 * Returns the loader data for the nearest ancestor Route loader
 */

function useLoaderData() {
  let state = useDataRouterState(DataRouterStateHook.UseLoaderData);
  let routeId = useCurrentRouteId(DataRouterStateHook.UseLoaderData);

  if (state.errors && state.errors[routeId] != null) {
    console.error("You cannot `useLoaderData` in an errorElement (routeId: " + routeId + ")");
    return undefined;
  }

  return state.loaderData[routeId];
}
/**
 * Returns the loaderData for the given routeId
 */

function useRouteLoaderData(routeId) {
  let state = useDataRouterState(DataRouterStateHook.UseRouteLoaderData);
  return state.loaderData[routeId];
}
/**
 * Returns the action data for the nearest ancestor Route action
 */

function useActionData() {
  let state = useDataRouterState(DataRouterStateHook.UseActionData);
  let route = react.useContext(RouteContext);
  !route ?  false ? 0 : invariant(false) : void 0;
  return Object.values((state == null ? void 0 : state.actionData) || {})[0];
}
/**
 * Returns the nearest ancestor Route error, which could be a loader/action
 * error or a render error.  This is intended to be called from your
 * errorElement to display a proper error message.
 */

function useRouteError() {
  var _state$errors;

  let error = react.useContext(RouteErrorContext);
  let state = useDataRouterState(DataRouterStateHook.UseRouteError);
  let routeId = useCurrentRouteId(DataRouterStateHook.UseRouteError); // If this was a render error, we put it in a RouteError context inside
  // of RenderErrorBoundary

  if (error) {
    return error;
  } // Otherwise look for errors from our data router state


  return (_state$errors = state.errors) == null ? void 0 : _state$errors[routeId];
}
/**
 * Returns the happy-path data from the nearest ancestor <Await /> value
 */

function useAsyncValue() {
  let value = react.useContext(AwaitContext);
  return value == null ? void 0 : value._data;
}
/**
 * Returns the error from the nearest ancestor <Await /> value
 */

function useAsyncError() {
  let value = react.useContext(AwaitContext);
  return value == null ? void 0 : value._error;
}
const alreadyWarned = {};

function warningOnce(key, cond, message) {
  if (!cond && !alreadyWarned[key]) {
    alreadyWarned[key] = true;
     false ? 0 : void 0;
  }
}

/**
 * Given a Remix Router instance, render the appropriate UI
 */
function RouterProvider(_ref) {
  let {
    fallbackElement,
    router
  } = _ref;
  // Sync router state to our component state to force re-renders
  let state = useSyncExternalStore(router.subscribe, () => router.state, // We have to provide this so React@18 doesn't complain during hydration,
  // but we pass our serialized hydration data into the router so state here
  // is already synced with what the server saw
  () => router.state);
  let navigator = react.useMemo(() => {
    return {
      createHref: router.createHref,
      encodeLocation: router.encodeLocation,
      go: n => router.navigate(n),
      push: (to, state, opts) => router.navigate(to, {
        state,
        preventScrollReset: opts == null ? void 0 : opts.preventScrollReset
      }),
      replace: (to, state, opts) => router.navigate(to, {
        replace: true,
        state,
        preventScrollReset: opts == null ? void 0 : opts.preventScrollReset
      })
    };
  }, [router]);
  let basename = router.basename || "/";
  return /*#__PURE__*/react.createElement(DataRouterContext.Provider, {
    value: {
      router,
      navigator,
      static: false,
      // Do we need this?
      basename
    }
  }, /*#__PURE__*/react.createElement(DataRouterStateContext.Provider, {
    value: state
  }, /*#__PURE__*/react.createElement(Router, {
    basename: router.basename,
    location: router.state.location,
    navigationType: router.state.historyAction,
    navigator: navigator
  }, router.state.initialized ? /*#__PURE__*/react.createElement(Routes, null) : fallbackElement)));
}

/**
 * A <Router> that stores all entries in memory.
 *
 * @see https://reactrouter.com/router-components/memory-router
 */
function MemoryRouter(_ref2) {
  let {
    basename,
    children,
    initialEntries,
    initialIndex
  } = _ref2;
  let historyRef = react.useRef();

  if (historyRef.current == null) {
    historyRef.current = createMemoryHistory({
      initialEntries,
      initialIndex,
      v5Compat: true
    });
  }

  let history = historyRef.current;
  let [state, setState] = react.useState({
    action: history.action,
    location: history.location
  });
  react.useLayoutEffect(() => history.listen(setState), [history]);
  return /*#__PURE__*/react.createElement(Router, {
    basename: basename,
    children: children,
    location: state.location,
    navigationType: state.action,
    navigator: history
  });
}

/**
 * Changes the current location.
 *
 * Note: This API is mostly useful in React.Component subclasses that are not
 * able to use hooks. In functional components, we recommend you use the
 * `useNavigate` hook instead.
 *
 * @see https://reactrouter.com/components/navigate
 */
function Navigate(_ref3) {
  let {
    to,
    replace,
    state,
    relative
  } = _ref3;
  !useInRouterContext() ?  false ? 0 : invariant(false) : void 0;
   false ? 0 : void 0;
  let dataRouterState = react.useContext(DataRouterStateContext);
  let navigate = useNavigate();
  react.useEffect(() => {
    // Avoid kicking off multiple navigations if we're in the middle of a
    // data-router navigation, since components get re-rendered when we enter
    // a submitting/loading state
    if (dataRouterState && dataRouterState.navigation.state !== "idle") {
      return;
    }

    navigate(to, {
      replace,
      state,
      relative
    });
  });
  return null;
}

/**
 * Renders the child route's element, if there is one.
 *
 * @see https://reactrouter.com/components/outlet
 */
function Outlet(props) {
  return useOutlet(props.context);
}

/**
 * Declares an element that should be rendered at a certain URL path.
 *
 * @see https://reactrouter.com/components/route
 */
function Route(_props) {
   false ? 0 : invariant(false) ;
}

/**
 * Provides location context for the rest of the app.
 *
 * Note: You usually won't render a <Router> directly. Instead, you'll render a
 * router that is more specific to your environment such as a <BrowserRouter>
 * in web browsers or a <StaticRouter> for server rendering.
 *
 * @see https://reactrouter.com/router-components/router
 */
function Router(_ref4) {
  let {
    basename: basenameProp = "/",
    children = null,
    location: locationProp,
    navigationType = Action.Pop,
    navigator,
    static: staticProp = false
  } = _ref4;
  !!useInRouterContext() ?  false ? 0 : invariant(false) : void 0; // Preserve trailing slashes on basename, so we can let the user control
  // the enforcement of trailing slashes throughout the app

  let basename = basenameProp.replace(/^\/*/, "/");
  let navigationContext = react.useMemo(() => ({
    basename,
    navigator,
    static: staticProp
  }), [basename, navigator, staticProp]);

  if (typeof locationProp === "string") {
    locationProp = parsePath(locationProp);
  }

  let {
    pathname = "/",
    search = "",
    hash = "",
    state = null,
    key = "default"
  } = locationProp;
  let location = react.useMemo(() => {
    let trailingPathname = stripBasename(pathname, basename);

    if (trailingPathname == null) {
      return null;
    }

    return {
      pathname: trailingPathname,
      search,
      hash,
      state,
      key
    };
  }, [basename, pathname, search, hash, state, key]);
   false ? 0 : void 0;

  if (location == null) {
    return null;
  }

  return /*#__PURE__*/react.createElement(NavigationContext.Provider, {
    value: navigationContext
  }, /*#__PURE__*/react.createElement(LocationContext.Provider, {
    children: children,
    value: {
      location,
      navigationType
    }
  }));
}

/**
 * A container for a nested tree of <Route> elements that renders the branch
 * that best matches the current location.
 *
 * @see https://reactrouter.com/components/routes
 */
function Routes(_ref5) {
  let {
    children,
    location
  } = _ref5;
  let dataRouterContext = react.useContext(DataRouterContext); // When in a DataRouterContext _without_ children, we use the router routes
  // directly.  If we have children, then we're in a descendant tree and we
  // need to use child routes.

  let routes = dataRouterContext && !children ? dataRouterContext.router.routes : createRoutesFromChildren(children);
  return useRoutes(routes, location);
}

/**
 * Component to use for rendering lazily loaded data from returning defer()
 * in a loader function
 */
function Await(_ref6) {
  let {
    children,
    errorElement,
    resolve
  } = _ref6;
  return /*#__PURE__*/react.createElement(AwaitErrorBoundary, {
    resolve: resolve,
    errorElement: errorElement
  }, /*#__PURE__*/react.createElement(ResolveAwait, null, children));
}
var AwaitRenderStatus;

(function (AwaitRenderStatus) {
  AwaitRenderStatus[AwaitRenderStatus["pending"] = 0] = "pending";
  AwaitRenderStatus[AwaitRenderStatus["success"] = 1] = "success";
  AwaitRenderStatus[AwaitRenderStatus["error"] = 2] = "error";
})(AwaitRenderStatus || (AwaitRenderStatus = {}));

const neverSettledPromise = new Promise(() => {});

class AwaitErrorBoundary extends react.Component {
  constructor(props) {
    super(props);
    this.state = {
      error: null
    };
  }

  static getDerivedStateFromError(error) {
    return {
      error
    };
  }

  componentDidCatch(error, errorInfo) {
    console.error("<Await> caught the following error during render", error, errorInfo);
  }

  render() {
    let {
      children,
      errorElement,
      resolve
    } = this.props;
    let promise = null;
    let status = AwaitRenderStatus.pending;

    if (!(resolve instanceof Promise)) {
      // Didn't get a promise - provide as a resolved promise
      status = AwaitRenderStatus.success;
      promise = Promise.resolve();
      Object.defineProperty(promise, "_tracked", {
        get: () => true
      });
      Object.defineProperty(promise, "_data", {
        get: () => resolve
      });
    } else if (this.state.error) {
      // Caught a render error, provide it as a rejected promise
      status = AwaitRenderStatus.error;
      let renderError = this.state.error;
      promise = Promise.reject().catch(() => {}); // Avoid unhandled rejection warnings

      Object.defineProperty(promise, "_tracked", {
        get: () => true
      });
      Object.defineProperty(promise, "_error", {
        get: () => renderError
      });
    } else if (resolve._tracked) {
      // Already tracked promise - check contents
      promise = resolve;
      status = promise._error !== undefined ? AwaitRenderStatus.error : promise._data !== undefined ? AwaitRenderStatus.success : AwaitRenderStatus.pending;
    } else {
      // Raw (untracked) promise - track it
      status = AwaitRenderStatus.pending;
      Object.defineProperty(resolve, "_tracked", {
        get: () => true
      });
      promise = resolve.then(data => Object.defineProperty(resolve, "_data", {
        get: () => data
      }), error => Object.defineProperty(resolve, "_error", {
        get: () => error
      }));
    }

    if (status === AwaitRenderStatus.error && promise._error instanceof AbortedDeferredError) {
      // Freeze the UI by throwing a never resolved promise
      throw neverSettledPromise;
    }

    if (status === AwaitRenderStatus.error && !errorElement) {
      // No errorElement, throw to the nearest route-level error boundary
      throw promise._error;
    }

    if (status === AwaitRenderStatus.error) {
      // Render via our errorElement
      return /*#__PURE__*/react.createElement(AwaitContext.Provider, {
        value: promise,
        children: errorElement
      });
    }

    if (status === AwaitRenderStatus.success) {
      // Render children with resolved value
      return /*#__PURE__*/react.createElement(AwaitContext.Provider, {
        value: promise,
        children: children
      });
    } // Throw to the suspense boundary


    throw promise;
  }

}
/**
 * @private
 * Indirection to leverage useAsyncValue for a render-prop API on <Await>
 */


function ResolveAwait(_ref7) {
  let {
    children
  } = _ref7;
  let data = useAsyncValue();

  if (typeof children === "function") {
    return children(data);
  }

  return /*#__PURE__*/react.createElement(react.Fragment, null, children);
} ///////////////////////////////////////////////////////////////////////////////
// UTILS
///////////////////////////////////////////////////////////////////////////////

/**
 * Creates a route config from a React "children" object, which is usually
 * either a `<Route>` element or an array of them. Used internally by
 * `<Routes>` to create a route config from its children.
 *
 * @see https://reactrouter.com/utils/create-routes-from-children
 */


function createRoutesFromChildren(children, parentPath) {
  if (parentPath === void 0) {
    parentPath = [];
  }

  let routes = [];
  react.Children.forEach(children, (element, index) => {
    if (! /*#__PURE__*/react.isValidElement(element)) {
      // Ignore non-elements. This allows people to more easily inline
      // conditionals in their route config.
      return;
    }

    if (element.type === react.Fragment) {
      // Transparently support React.Fragment and its children.
      routes.push.apply(routes, createRoutesFromChildren(element.props.children, parentPath));
      return;
    }

    !(element.type === Route) ?  false ? 0 : invariant(false) : void 0;
    !(!element.props.index || !element.props.children) ?  false ? 0 : invariant(false) : void 0;
    let treePath = [...parentPath, index];
    let route = {
      id: element.props.id || treePath.join("-"),
      caseSensitive: element.props.caseSensitive,
      element: element.props.element,
      index: element.props.index,
      path: element.props.path,
      loader: element.props.loader,
      action: element.props.action,
      errorElement: element.props.errorElement,
      hasErrorBoundary: element.props.errorElement != null,
      shouldRevalidate: element.props.shouldRevalidate,
      handle: element.props.handle
    };

    if (element.props.children) {
      route.children = createRoutesFromChildren(element.props.children, treePath);
    }

    routes.push(route);
  });
  return routes;
}
/**
 * Renders the result of `matchRoutes()` into a React element.
 */

function renderMatches(matches) {
  return _renderMatches(matches);
}
/**
 * @private
 * Walk the route tree and add hasErrorBoundary if it's not provided, so that
 * users providing manual route arrays can just specify errorElement
 */

function enhanceManualRouteObjects(routes) {
  return routes.map(route => {
    let routeClone = dist_extends({}, route);

    if (routeClone.hasErrorBoundary == null) {
      routeClone.hasErrorBoundary = routeClone.errorElement != null;
    }

    if (routeClone.children) {
      routeClone.children = enhanceManualRouteObjects(routeClone.children);
    }

    return routeClone;
  });
}

function createMemoryRouter(routes, opts) {
  return createRouter({
    basename: opts == null ? void 0 : opts.basename,
    history: createMemoryHistory({
      initialEntries: opts == null ? void 0 : opts.initialEntries,
      initialIndex: opts == null ? void 0 : opts.initialIndex
    }),
    hydrationData: opts == null ? void 0 : opts.hydrationData,
    routes: enhanceManualRouteObjects(routes)
  }).initialize();
} ///////////////////////////////////////////////////////////////////////////////


//# sourceMappingURL=index.js.map

;// CONCATENATED MODULE: ./node_modules/react-router-dom/dist/index.js
/**
 * React Router DOM v6.6.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */





function react_router_dom_dist_extends() {
  react_router_dom_dist_extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return react_router_dom_dist_extends.apply(this, arguments);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

const defaultMethod = "get";
const defaultEncType = "application/x-www-form-urlencoded";
function isHtmlElement(object) {
  return object != null && typeof object.tagName === "string";
}
function isButtonElement(object) {
  return isHtmlElement(object) && object.tagName.toLowerCase() === "button";
}
function isFormElement(object) {
  return isHtmlElement(object) && object.tagName.toLowerCase() === "form";
}
function isInputElement(object) {
  return isHtmlElement(object) && object.tagName.toLowerCase() === "input";
}

function isModifiedEvent(event) {
  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
}

function shouldProcessLinkClick(event, target) {
  return event.button === 0 && ( // Ignore everything but left clicks
  !target || target === "_self") && // Let browser handle "target=_blank" etc.
  !isModifiedEvent(event) // Ignore clicks with modifier keys
  ;
}
/**
 * Creates a URLSearchParams object using the given initializer.
 *
 * This is identical to `new URLSearchParams(init)` except it also
 * supports arrays as values in the object form of the initializer
 * instead of just strings. This is convenient when you need multiple
 * values for a given key, but don't want to use an array initializer.
 *
 * For example, instead of:
 *
 *   let searchParams = new URLSearchParams([
 *     ['sort', 'name'],
 *     ['sort', 'price']
 *   ]);
 *
 * you can do:
 *
 *   let searchParams = createSearchParams({
 *     sort: ['name', 'price']
 *   });
 */

function createSearchParams(init) {
  if (init === void 0) {
    init = "";
  }

  return new URLSearchParams(typeof init === "string" || Array.isArray(init) || init instanceof URLSearchParams ? init : Object.keys(init).reduce((memo, key) => {
    let value = init[key];
    return memo.concat(Array.isArray(value) ? value.map(v => [key, v]) : [[key, value]]);
  }, []));
}
function getSearchParamsForLocation(locationSearch, defaultSearchParams) {
  let searchParams = createSearchParams(locationSearch);

  for (let key of defaultSearchParams.keys()) {
    if (!searchParams.has(key)) {
      defaultSearchParams.getAll(key).forEach(value => {
        searchParams.append(key, value);
      });
    }
  }

  return searchParams;
}
function getFormSubmissionInfo(target, defaultAction, options) {
  let method;
  let action;
  let encType;
  let formData;

  if (isFormElement(target)) {
    let submissionTrigger = options.submissionTrigger;
    method = options.method || target.getAttribute("method") || defaultMethod;
    action = options.action || target.getAttribute("action") || defaultAction;
    encType = options.encType || target.getAttribute("enctype") || defaultEncType;
    formData = new FormData(target);

    if (submissionTrigger && submissionTrigger.name) {
      formData.append(submissionTrigger.name, submissionTrigger.value);
    }
  } else if (isButtonElement(target) || isInputElement(target) && (target.type === "submit" || target.type === "image")) {
    let form = target.form;

    if (form == null) {
      throw new Error("Cannot submit a <button> or <input type=\"submit\"> without a <form>");
    } // <button>/<input type="submit"> may override attributes of <form>


    method = options.method || target.getAttribute("formmethod") || form.getAttribute("method") || defaultMethod;
    action = options.action || target.getAttribute("formaction") || form.getAttribute("action") || defaultAction;
    encType = options.encType || target.getAttribute("formenctype") || form.getAttribute("enctype") || defaultEncType;
    formData = new FormData(form); // Include name + value from a <button>, appending in case the button name
    // matches an existing input name

    if (target.name) {
      formData.append(target.name, target.value);
    }
  } else if (isHtmlElement(target)) {
    throw new Error("Cannot submit element that is not <form>, <button>, or " + "<input type=\"submit|image\">");
  } else {
    method = options.method || defaultMethod;
    action = options.action || defaultAction;
    encType = options.encType || defaultEncType;

    if (target instanceof FormData) {
      formData = target;
    } else {
      formData = new FormData();

      if (target instanceof URLSearchParams) {
        for (let [name, value] of target) {
          formData.append(name, value);
        }
      } else if (target != null) {
        for (let name of Object.keys(target)) {
          formData.append(name, target[name]);
        }
      }
    }
  }

  let {
    protocol,
    host
  } = window.location;
  let url = new URL(action, protocol + "//" + host);
  return {
    url,
    method: method.toLowerCase(),
    encType,
    formData
  };
}

const _excluded = ["onClick", "relative", "reloadDocument", "replace", "state", "target", "to", "preventScrollReset"],
      _excluded2 = ["aria-current", "caseSensitive", "className", "end", "style", "to", "children"],
      _excluded3 = ["reloadDocument", "replace", "method", "action", "onSubmit", "fetcherKey", "routeId", "relative"];
//#region Routers
////////////////////////////////////////////////////////////////////////////////

function createBrowserRouter(routes, opts) {
  return createRouter({
    basename: opts == null ? void 0 : opts.basename,
    history: createBrowserHistory({
      window: opts == null ? void 0 : opts.window
    }),
    hydrationData: (opts == null ? void 0 : opts.hydrationData) || parseHydrationData(),
    routes: enhanceManualRouteObjects(routes)
  }).initialize();
}
function createHashRouter(routes, opts) {
  return createRouter({
    basename: opts == null ? void 0 : opts.basename,
    history: createHashHistory({
      window: opts == null ? void 0 : opts.window
    }),
    hydrationData: (opts == null ? void 0 : opts.hydrationData) || parseHydrationData(),
    routes: enhanceManualRouteObjects(routes)
  }).initialize();
}

function parseHydrationData() {
  var _window;

  let state = (_window = window) == null ? void 0 : _window.__staticRouterHydrationData;

  if (state && state.errors) {
    state = react_router_dom_dist_extends({}, state, {
      errors: deserializeErrors(state.errors)
    });
  }

  return state;
}

function deserializeErrors(errors) {
  if (!errors) return null;
  let entries = Object.entries(errors);
  let serialized = {};

  for (let [key, val] of entries) {
    // Hey you!  If you change this, please change the corresponding logic in
    // serializeErrors in react-router-dom/server.tsx :)
    if (val && val.__type === "RouteErrorResponse") {
      serialized[key] = new ErrorResponse(val.status, val.statusText, val.data, val.internal === true);
    } else if (val && val.__type === "Error") {
      let error = new Error(val.message); // Wipe away the client-side stack trace.  Nothing to fill it in with
      // because we don't serialize SSR stack traces for security reasons

      error.stack = "";
      serialized[key] = error;
    } else {
      serialized[key] = val;
    }
  }

  return serialized;
}
/**
 * A `<Router>` for use in web browsers. Provides the cleanest URLs.
 */


function BrowserRouter(_ref) {
  let {
    basename,
    children,
    window
  } = _ref;
  let historyRef = react.useRef();

  if (historyRef.current == null) {
    historyRef.current = createBrowserHistory({
      window,
      v5Compat: true
    });
  }

  let history = historyRef.current;
  let [state, setState] = react.useState({
    action: history.action,
    location: history.location
  });
  react.useLayoutEffect(() => history.listen(setState), [history]);
  return /*#__PURE__*/react.createElement(Router, {
    basename: basename,
    children: children,
    location: state.location,
    navigationType: state.action,
    navigator: history
  });
}
/**
 * A `<Router>` for use in web browsers. Stores the location in the hash
 * portion of the URL so it is not sent to the server.
 */

function HashRouter(_ref2) {
  let {
    basename,
    children,
    window
  } = _ref2;
  let historyRef = react.useRef();

  if (historyRef.current == null) {
    historyRef.current = createHashHistory({
      window,
      v5Compat: true
    });
  }

  let history = historyRef.current;
  let [state, setState] = react.useState({
    action: history.action,
    location: history.location
  });
  react.useLayoutEffect(() => history.listen(setState), [history]);
  return /*#__PURE__*/react.createElement(Router, {
    basename: basename,
    children: children,
    location: state.location,
    navigationType: state.action,
    navigator: history
  });
}
/**
 * A `<Router>` that accepts a pre-instantiated history object. It's important
 * to note that using your own history object is highly discouraged and may add
 * two versions of the history library to your bundles unless you use the same
 * version of the history library that React Router uses internally.
 */

function HistoryRouter(_ref3) {
  let {
    basename,
    children,
    history
  } = _ref3;
  const [state, setState] = react.useState({
    action: history.action,
    location: history.location
  });
  react.useLayoutEffect(() => history.listen(setState), [history]);
  return /*#__PURE__*/react.createElement(Router, {
    basename: basename,
    children: children,
    location: state.location,
    navigationType: state.action,
    navigator: history
  });
}

if (false) {}
/**
 * The public API for rendering a history-aware <a>.
 */

const Link = /*#__PURE__*/react.forwardRef(function LinkWithRef(_ref4, ref) {
  let {
    onClick,
    relative,
    reloadDocument,
    replace,
    state,
    target,
    to,
    preventScrollReset
  } = _ref4,
      rest = _objectWithoutPropertiesLoose(_ref4, _excluded);

  let href = useHref(to, {
    relative
  });
  let internalOnClick = useLinkClickHandler(to, {
    replace,
    state,
    target,
    preventScrollReset,
    relative
  });

  function handleClick(event) {
    if (onClick) onClick(event);

    if (!event.defaultPrevented) {
      internalOnClick(event);
    }
  }

  return (
    /*#__PURE__*/
    // eslint-disable-next-line jsx-a11y/anchor-has-content
    react.createElement("a", react_router_dom_dist_extends({}, rest, {
      href: href,
      onClick: reloadDocument ? onClick : handleClick,
      ref: ref,
      target: target
    }))
  );
});

if (false) {}
/**
 * A <Link> wrapper that knows if it's "active" or not.
 */


const NavLink = /*#__PURE__*/react.forwardRef(function NavLinkWithRef(_ref5, ref) {
  let {
    "aria-current": ariaCurrentProp = "page",
    caseSensitive = false,
    className: classNameProp = "",
    end = false,
    style: styleProp,
    to,
    children
  } = _ref5,
      rest = _objectWithoutPropertiesLoose(_ref5, _excluded2);

  let path = useResolvedPath(to, {
    relative: rest.relative
  });
  let location = useLocation();
  let routerState = react.useContext(DataRouterStateContext);
  let {
    navigator
  } = react.useContext(NavigationContext);
  let toPathname = navigator.encodeLocation ? navigator.encodeLocation(path).pathname : path.pathname;
  let locationPathname = location.pathname;
  let nextLocationPathname = routerState && routerState.navigation && routerState.navigation.location ? routerState.navigation.location.pathname : null;

  if (!caseSensitive) {
    locationPathname = locationPathname.toLowerCase();
    nextLocationPathname = nextLocationPathname ? nextLocationPathname.toLowerCase() : null;
    toPathname = toPathname.toLowerCase();
  }

  let isActive = locationPathname === toPathname || !end && locationPathname.startsWith(toPathname) && locationPathname.charAt(toPathname.length) === "/";
  let isPending = nextLocationPathname != null && (nextLocationPathname === toPathname || !end && nextLocationPathname.startsWith(toPathname) && nextLocationPathname.charAt(toPathname.length) === "/");
  let ariaCurrent = isActive ? ariaCurrentProp : undefined;
  let className;

  if (typeof classNameProp === "function") {
    className = classNameProp({
      isActive,
      isPending
    });
  } else {
    // If the className prop is not a function, we use a default `active`
    // class for <NavLink />s that are active. In v5 `active` was the default
    // value for `activeClassName`, but we are removing that API and can still
    // use the old default behavior for a cleaner upgrade path and keep the
    // simple styling rules working as they currently do.
    className = [classNameProp, isActive ? "active" : null, isPending ? "pending" : null].filter(Boolean).join(" ");
  }

  let style = typeof styleProp === "function" ? styleProp({
    isActive,
    isPending
  }) : styleProp;
  return /*#__PURE__*/react.createElement(Link, react_router_dom_dist_extends({}, rest, {
    "aria-current": ariaCurrent,
    className: className,
    ref: ref,
    style: style,
    to: to
  }), typeof children === "function" ? children({
    isActive,
    isPending
  }) : children);
});

if (false) {}
/**
 * A `@remix-run/router`-aware `<form>`. It behaves like a normal form except
 * that the interaction with the server is with `fetch` instead of new document
 * requests, allowing components to add nicer UX to the page as the form is
 * submitted and returns with data.
 */


const Form = /*#__PURE__*/react.forwardRef((props, ref) => {
  return /*#__PURE__*/react.createElement(FormImpl, react_router_dom_dist_extends({}, props, {
    ref: ref
  }));
});

if (false) {}

const FormImpl = /*#__PURE__*/react.forwardRef((_ref6, forwardedRef) => {
  let {
    reloadDocument,
    replace,
    method = defaultMethod,
    action,
    onSubmit,
    fetcherKey,
    routeId,
    relative
  } = _ref6,
      props = _objectWithoutPropertiesLoose(_ref6, _excluded3);

  let submit = useSubmitImpl(fetcherKey, routeId);
  let formMethod = method.toLowerCase() === "get" ? "get" : "post";
  let formAction = useFormAction(action, {
    relative
  });

  let submitHandler = event => {
    onSubmit && onSubmit(event);
    if (event.defaultPrevented) return;
    event.preventDefault();
    let submitter = event.nativeEvent.submitter;
    let submitMethod = (submitter == null ? void 0 : submitter.getAttribute("formmethod")) || method;
    submit(submitter || event.currentTarget, {
      method: submitMethod,
      replace,
      relative
    });
  };

  return /*#__PURE__*/react.createElement("form", react_router_dom_dist_extends({
    ref: forwardedRef,
    method: formMethod,
    action: formAction,
    onSubmit: reloadDocument ? onSubmit : submitHandler
  }, props));
});

if (false) {}
/**
 * This component will emulate the browser's scroll restoration on location
 * changes.
 */


function ScrollRestoration(_ref7) {
  let {
    getKey,
    storageKey
  } = _ref7;
  useScrollRestoration({
    getKey,
    storageKey
  });
  return null;
}

if (false) {} //#endregion
////////////////////////////////////////////////////////////////////////////////
//#region Hooks
////////////////////////////////////////////////////////////////////////////////


var dist_DataRouterHook;

(function (DataRouterHook) {
  DataRouterHook["UseScrollRestoration"] = "useScrollRestoration";
  DataRouterHook["UseSubmitImpl"] = "useSubmitImpl";
  DataRouterHook["UseFetcher"] = "useFetcher";
})(dist_DataRouterHook || (dist_DataRouterHook = {}));

var dist_DataRouterStateHook;

(function (DataRouterStateHook) {
  DataRouterStateHook["UseFetchers"] = "useFetchers";
  DataRouterStateHook["UseScrollRestoration"] = "useScrollRestoration";
})(dist_DataRouterStateHook || (dist_DataRouterStateHook = {}));

function dist_getDataRouterConsoleError(hookName) {
  return hookName + " must be used within a data router.  See https://reactrouter.com/routers/picking-a-router.";
}

function dist_useDataRouterContext(hookName) {
  let ctx = react.useContext(DataRouterContext);
  !ctx ?  false ? 0 : invariant(false) : void 0;
  return ctx;
}

function dist_useDataRouterState(hookName) {
  let state = react.useContext(DataRouterStateContext);
  !state ?  false ? 0 : invariant(false) : void 0;
  return state;
}
/**
 * Handles the click behavior for router `<Link>` components. This is useful if
 * you need to create custom `<Link>` components with the same click behavior we
 * use in our exported `<Link>`.
 */


function useLinkClickHandler(to, _temp) {
  let {
    target,
    replace: replaceProp,
    state,
    preventScrollReset,
    relative
  } = _temp === void 0 ? {} : _temp;
  let navigate = useNavigate();
  let location = useLocation();
  let path = useResolvedPath(to, {
    relative
  });
  return react.useCallback(event => {
    if (shouldProcessLinkClick(event, target)) {
      event.preventDefault(); // If the URL hasn't changed, a regular <a> will do a replace instead of
      // a push, so do the same here unless the replace prop is explicitly set

      let replace = replaceProp !== undefined ? replaceProp : createPath(location) === createPath(path);
      navigate(to, {
        replace,
        state,
        preventScrollReset,
        relative
      });
    }
  }, [location, navigate, path, replaceProp, state, target, to, preventScrollReset, relative]);
}
/**
 * A convenient wrapper for reading and writing search parameters via the
 * URLSearchParams interface.
 */

function useSearchParams(defaultInit) {
   false ? 0 : void 0;
  let defaultSearchParamsRef = react.useRef(createSearchParams(defaultInit));
  let location = useLocation();
  let searchParams = react.useMemo(() => getSearchParamsForLocation(location.search, defaultSearchParamsRef.current), [location.search]);
  let navigate = useNavigate();
  let setSearchParams = react.useCallback((nextInit, navigateOptions) => {
    const newSearchParams = createSearchParams(typeof nextInit === "function" ? nextInit(searchParams) : nextInit);
    navigate("?" + newSearchParams, navigateOptions);
  }, [navigate, searchParams]);
  return [searchParams, setSearchParams];
}
/**
 * Returns a function that may be used to programmatically submit a form (or
 * some arbitrary data) to the server.
 */

function useSubmit() {
  return useSubmitImpl();
}

function useSubmitImpl(fetcherKey, routeId) {
  let {
    router
  } = dist_useDataRouterContext(dist_DataRouterHook.UseSubmitImpl);
  let defaultAction = useFormAction();
  return react.useCallback(function (target, options) {
    if (options === void 0) {
      options = {};
    }

    if (typeof document === "undefined") {
      throw new Error("You are calling submit during the server render. " + "Try calling submit within a `useEffect` or callback instead.");
    }

    let {
      method,
      encType,
      formData,
      url
    } = getFormSubmissionInfo(target, defaultAction, options);
    let href = url.pathname + url.search;
    let opts = {
      replace: options.replace,
      formData,
      formMethod: method,
      formEncType: encType
    };

    if (fetcherKey) {
      !(routeId != null) ?  false ? 0 : invariant(false) : void 0;
      router.fetch(fetcherKey, routeId, href, opts);
    } else {
      router.navigate(href, opts);
    }
  }, [defaultAction, router, fetcherKey, routeId]);
}

function useFormAction(action, _temp2) {
  let {
    relative
  } = _temp2 === void 0 ? {} : _temp2;
  let {
    basename
  } = react.useContext(NavigationContext);
  let routeContext = react.useContext(RouteContext);
  !routeContext ?  false ? 0 : invariant(false) : void 0;
  let [match] = routeContext.matches.slice(-1); // Shallow clone path so we can modify it below, otherwise we modify the
  // object referenced by useMemo inside useResolvedPath

  let path = react_router_dom_dist_extends({}, useResolvedPath(action ? action : ".", {
    relative
  })); // Previously we set the default action to ".". The problem with this is that
  // `useResolvedPath(".")` excludes search params and the hash of the resolved
  // URL. This is the intended behavior of when "." is specifically provided as
  // the form action, but inconsistent w/ browsers when the action is omitted.
  // https://github.com/remix-run/remix/issues/927


  let location = useLocation();

  if (action == null) {
    // Safe to write to these directly here since if action was undefined, we
    // would have called useResolvedPath(".") which will never include a search
    // or hash
    path.search = location.search;
    path.hash = location.hash; // When grabbing search params from the URL, remove the automatically
    // inserted ?index param so we match the useResolvedPath search behavior
    // which would not include ?index

    if (match.route.index) {
      let params = new URLSearchParams(path.search);
      params.delete("index");
      path.search = params.toString() ? "?" + params.toString() : "";
    }
  }

  if ((!action || action === ".") && match.route.index) {
    path.search = path.search ? path.search.replace(/^\?/, "?index&") : "?index";
  } // If we're operating within a basename, prepend it to the pathname prior
  // to creating the form action.  If this is a root navigation, then just use
  // the raw basename which allows the basename to have full control over the
  // presence of a trailing slash on root actions


  if (basename !== "/") {
    path.pathname = path.pathname === "/" ? basename : joinPaths([basename, path.pathname]);
  }

  return createPath(path);
}

function createFetcherForm(fetcherKey, routeId) {
  let FetcherForm = /*#__PURE__*/react.forwardRef((props, ref) => {
    return /*#__PURE__*/react.createElement(FormImpl, react_router_dom_dist_extends({}, props, {
      ref: ref,
      fetcherKey: fetcherKey,
      routeId: routeId
    }));
  });

  if (false) {}

  return FetcherForm;
}

let fetcherId = 0;
/**
 * Interacts with route loaders and actions without causing a navigation. Great
 * for any interaction that stays on the same page.
 */

function useFetcher() {
  var _route$matches;

  let {
    router
  } = dist_useDataRouterContext(dist_DataRouterHook.UseFetcher);
  let route = react.useContext(RouteContext);
  !route ?  false ? 0 : invariant(false) : void 0;
  let routeId = (_route$matches = route.matches[route.matches.length - 1]) == null ? void 0 : _route$matches.route.id;
  !(routeId != null) ?  false ? 0 : invariant(false) : void 0;
  let [fetcherKey] = react.useState(() => String(++fetcherId));
  let [Form] = react.useState(() => {
    !routeId ?  false ? 0 : invariant(false) : void 0;
    return createFetcherForm(fetcherKey, routeId);
  });
  let [load] = react.useState(() => href => {
    !router ?  false ? 0 : invariant(false) : void 0;
    !routeId ?  false ? 0 : invariant(false) : void 0;
    router.fetch(fetcherKey, routeId, href);
  });
  let submit = useSubmitImpl(fetcherKey, routeId);
  let fetcher = router.getFetcher(fetcherKey);
  let fetcherWithComponents = react.useMemo(() => react_router_dom_dist_extends({
    Form,
    submit,
    load
  }, fetcher), [fetcher, Form, submit, load]);
  react.useEffect(() => {
    // Is this busted when the React team gets real weird and calls effects
    // twice on mount?  We really just need to garbage collect here when this
    // fetcher is no longer around.
    return () => {
      if (!router) {
        console.warn("No fetcher available to clean up from useFetcher()");
        return;
      }

      router.deleteFetcher(fetcherKey);
    };
  }, [router, fetcherKey]);
  return fetcherWithComponents;
}
/**
 * Provides all fetchers currently on the page. Useful for layouts and parent
 * routes that need to provide pending/optimistic UI regarding the fetch.
 */

function useFetchers() {
  let state = dist_useDataRouterState(dist_DataRouterStateHook.UseFetchers);
  return [...state.fetchers.values()];
}
const SCROLL_RESTORATION_STORAGE_KEY = "react-router-scroll-positions";
let savedScrollPositions = {};
/**
 * When rendered inside a RouterProvider, will restore scroll positions on navigations
 */

function useScrollRestoration(_temp3) {
  let {
    getKey,
    storageKey
  } = _temp3 === void 0 ? {} : _temp3;
  let {
    router
  } = dist_useDataRouterContext(dist_DataRouterHook.UseScrollRestoration);
  let {
    restoreScrollPosition,
    preventScrollReset
  } = dist_useDataRouterState(dist_DataRouterStateHook.UseScrollRestoration);
  let location = useLocation();
  let matches = useMatches();
  let navigation = useNavigation(); // Trigger manual scroll restoration while we're active

  react.useEffect(() => {
    window.history.scrollRestoration = "manual";
    return () => {
      window.history.scrollRestoration = "auto";
    };
  }, []); // Save positions on unload

  useBeforeUnload(react.useCallback(() => {
    if (navigation.state === "idle") {
      let key = (getKey ? getKey(location, matches) : null) || location.key;
      savedScrollPositions[key] = window.scrollY;
    }

    sessionStorage.setItem(storageKey || SCROLL_RESTORATION_STORAGE_KEY, JSON.stringify(savedScrollPositions));
    window.history.scrollRestoration = "auto";
  }, [storageKey, getKey, navigation.state, location, matches])); // Read in any saved scroll locations

  if (typeof document !== "undefined") {
    // eslint-disable-next-line react-hooks/rules-of-hooks
    react.useLayoutEffect(() => {
      try {
        let sessionPositions = sessionStorage.getItem(storageKey || SCROLL_RESTORATION_STORAGE_KEY);

        if (sessionPositions) {
          savedScrollPositions = JSON.parse(sessionPositions);
        }
      } catch (e) {// no-op, use default empty object
      }
    }, [storageKey]); // Enable scroll restoration in the router
    // eslint-disable-next-line react-hooks/rules-of-hooks

    react.useLayoutEffect(() => {
      let disableScrollRestoration = router == null ? void 0 : router.enableScrollRestoration(savedScrollPositions, () => window.scrollY, getKey);
      return () => disableScrollRestoration && disableScrollRestoration();
    }, [router, getKey]); // Restore scrolling when state.restoreScrollPosition changes
    // eslint-disable-next-line react-hooks/rules-of-hooks

    react.useLayoutEffect(() => {
      // Explicit false means don't do anything (used for submissions)
      if (restoreScrollPosition === false) {
        return;
      } // been here before, scroll to it


      if (typeof restoreScrollPosition === "number") {
        window.scrollTo(0, restoreScrollPosition);
        return;
      } // try to scroll to the hash


      if (location.hash) {
        let el = document.getElementById(location.hash.slice(1));

        if (el) {
          el.scrollIntoView();
          return;
        }
      } // Opt out of scroll reset if this link requested it


      if (preventScrollReset === true) {
        return;
      } // otherwise go to the top on new locations


      window.scrollTo(0, 0);
    }, [location, restoreScrollPosition, preventScrollReset]);
  }
}
/**
 * Setup a callback to be fired on the window's `beforeunload` event. This is
 * useful for saving some data to `window.localStorage` just before the page
 * refreshes.
 *
 * Note: The `callback` argument should be a function created with
 * `React.useCallback()`.
 */


function useBeforeUnload(callback) {
  react.useEffect(() => {
    window.addEventListener("beforeunload", callback);
    return () => {
      window.removeEventListener("beforeunload", callback);
    };
  }, [callback]);
} //#endregion
////////////////////////////////////////////////////////////////////////////////
//#region Utils
////////////////////////////////////////////////////////////////////////////////

function dist_warning(cond, message) {
  if (!cond) {
    // eslint-disable-next-line no-console
    if (typeof console !== "undefined") console.warn(message);

    try {
      // Welcome to debugging React Router!
      //
      // This error is thrown as a convenience so you can more easily
      // find the source for a warning that appears in the console by
      // enabling "pause on exceptions" in your JavaScript debugger.
      throw new Error(message); // eslint-disable-next-line no-empty
    } catch (e) {}
  }
} //#endregion


//# sourceMappingURL=index.js.map


/***/ }),

/***/ 284:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "cn": () => (/* binding */ ENTERED),
  "d0": () => (/* binding */ ENTERING),
  "Ix": () => (/* binding */ EXITING),
  "ZP": () => (/* binding */ esm_Transition)
});

// UNUSED EXPORTS: EXITED, UNMOUNTED

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js
var objectWithoutPropertiesLoose = __webpack_require__(3560);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/inheritsLoose.js + 1 modules
var inheritsLoose = __webpack_require__(3699);
// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(4191);
// EXTERNAL MODULE: ./node_modules/react-dom/index.js
var react_dom = __webpack_require__(7668);
;// CONCATENATED MODULE: ./node_modules/react-transition-group/esm/config.js
/* harmony default export */ const config = ({
  disabled: false
});
// EXTERNAL MODULE: ./node_modules/react-transition-group/esm/TransitionGroupContext.js
var TransitionGroupContext = __webpack_require__(1605);
// EXTERNAL MODULE: ./node_modules/react-transition-group/esm/utils/reflow.js
var reflow = __webpack_require__(5879);
;// CONCATENATED MODULE: ./node_modules/react-transition-group/esm/Transition.js









var UNMOUNTED = 'unmounted';
var EXITED = 'exited';
var ENTERING = 'entering';
var ENTERED = 'entered';
var EXITING = 'exiting';
/**
 * The Transition component lets you describe a transition from one component
 * state to another _over time_ with a simple declarative API. Most commonly
 * it's used to animate the mounting and unmounting of a component, but can also
 * be used to describe in-place transition states as well.
 *
 * ---
 *
 * **Note**: `Transition` is a platform-agnostic base component. If you're using
 * transitions in CSS, you'll probably want to use
 * [`CSSTransition`](https://reactcommunity.org/react-transition-group/css-transition)
 * instead. It inherits all the features of `Transition`, but contains
 * additional features necessary to play nice with CSS transitions (hence the
 * name of the component).
 *
 * ---
 *
 * By default the `Transition` component does not alter the behavior of the
 * component it renders, it only tracks "enter" and "exit" states for the
 * components. It's up to you to give meaning and effect to those states. For
 * example we can add styles to a component when it enters or exits:
 *
 * ```jsx
 * import { Transition } from 'react-transition-group';
 *
 * const duration = 300;
 *
 * const defaultStyle = {
 *   transition: `opacity ${duration}ms ease-in-out`,
 *   opacity: 0,
 * }
 *
 * const transitionStyles = {
 *   entering: { opacity: 1 },
 *   entered:  { opacity: 1 },
 *   exiting:  { opacity: 0 },
 *   exited:  { opacity: 0 },
 * };
 *
 * const Fade = ({ in: inProp }) => (
 *   <Transition in={inProp} timeout={duration}>
 *     {state => (
 *       <div style={{
 *         ...defaultStyle,
 *         ...transitionStyles[state]
 *       }}>
 *         I'm a fade Transition!
 *       </div>
 *     )}
 *   </Transition>
 * );
 * ```
 *
 * There are 4 main states a Transition can be in:
 *  - `'entering'`
 *  - `'entered'`
 *  - `'exiting'`
 *  - `'exited'`
 *
 * Transition state is toggled via the `in` prop. When `true` the component
 * begins the "Enter" stage. During this stage, the component will shift from
 * its current transition state, to `'entering'` for the duration of the
 * transition and then to the `'entered'` stage once it's complete. Let's take
 * the following example (we'll use the
 * [useState](https://reactjs.org/docs/hooks-reference.html#usestate) hook):
 *
 * ```jsx
 * function App() {
 *   const [inProp, setInProp] = useState(false);
 *   return (
 *     <div>
 *       <Transition in={inProp} timeout={500}>
 *         {state => (
 *           // ...
 *         )}
 *       </Transition>
 *       <button onClick={() => setInProp(true)}>
 *         Click to Enter
 *       </button>
 *     </div>
 *   );
 * }
 * ```
 *
 * When the button is clicked the component will shift to the `'entering'` state
 * and stay there for 500ms (the value of `timeout`) before it finally switches
 * to `'entered'`.
 *
 * When `in` is `false` the same thing happens except the state moves from
 * `'exiting'` to `'exited'`.
 */

var Transition = /*#__PURE__*/function (_React$Component) {
  (0,inheritsLoose/* default */.Z)(Transition, _React$Component);

  function Transition(props, context) {
    var _this;

    _this = _React$Component.call(this, props, context) || this;
    var parentGroup = context; // In the context of a TransitionGroup all enters are really appears

    var appear = parentGroup && !parentGroup.isMounting ? props.enter : props.appear;
    var initialStatus;
    _this.appearStatus = null;

    if (props.in) {
      if (appear) {
        initialStatus = EXITED;
        _this.appearStatus = ENTERING;
      } else {
        initialStatus = ENTERED;
      }
    } else {
      if (props.unmountOnExit || props.mountOnEnter) {
        initialStatus = UNMOUNTED;
      } else {
        initialStatus = EXITED;
      }
    }

    _this.state = {
      status: initialStatus
    };
    _this.nextCallback = null;
    return _this;
  }

  Transition.getDerivedStateFromProps = function getDerivedStateFromProps(_ref, prevState) {
    var nextIn = _ref.in;

    if (nextIn && prevState.status === UNMOUNTED) {
      return {
        status: EXITED
      };
    }

    return null;
  } // getSnapshotBeforeUpdate(prevProps) {
  //   let nextStatus = null
  //   if (prevProps !== this.props) {
  //     const { status } = this.state
  //     if (this.props.in) {
  //       if (status !== ENTERING && status !== ENTERED) {
  //         nextStatus = ENTERING
  //       }
  //     } else {
  //       if (status === ENTERING || status === ENTERED) {
  //         nextStatus = EXITING
  //       }
  //     }
  //   }
  //   return { nextStatus }
  // }
  ;

  var _proto = Transition.prototype;

  _proto.componentDidMount = function componentDidMount() {
    this.updateStatus(true, this.appearStatus);
  };

  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    var nextStatus = null;

    if (prevProps !== this.props) {
      var status = this.state.status;

      if (this.props.in) {
        if (status !== ENTERING && status !== ENTERED) {
          nextStatus = ENTERING;
        }
      } else {
        if (status === ENTERING || status === ENTERED) {
          nextStatus = EXITING;
        }
      }
    }

    this.updateStatus(false, nextStatus);
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    this.cancelNextCallback();
  };

  _proto.getTimeouts = function getTimeouts() {
    var timeout = this.props.timeout;
    var exit, enter, appear;
    exit = enter = appear = timeout;

    if (timeout != null && typeof timeout !== 'number') {
      exit = timeout.exit;
      enter = timeout.enter; // TODO: remove fallback for next major

      appear = timeout.appear !== undefined ? timeout.appear : enter;
    }

    return {
      exit: exit,
      enter: enter,
      appear: appear
    };
  };

  _proto.updateStatus = function updateStatus(mounting, nextStatus) {
    if (mounting === void 0) {
      mounting = false;
    }

    if (nextStatus !== null) {
      // nextStatus will always be ENTERING or EXITING.
      this.cancelNextCallback();

      if (nextStatus === ENTERING) {
        if (this.props.unmountOnExit || this.props.mountOnEnter) {
          var node = this.props.nodeRef ? this.props.nodeRef.current : react_dom.findDOMNode(this); // https://github.com/reactjs/react-transition-group/pull/749
          // With unmountOnExit or mountOnEnter, the enter animation should happen at the transition between `exited` and `entering`.
          // To make the animation happen,  we have to separate each rendering and avoid being processed as batched.

          if (node) (0,reflow/* forceReflow */.Q)(node);
        }

        this.performEnter(mounting);
      } else {
        this.performExit();
      }
    } else if (this.props.unmountOnExit && this.state.status === EXITED) {
      this.setState({
        status: UNMOUNTED
      });
    }
  };

  _proto.performEnter = function performEnter(mounting) {
    var _this2 = this;

    var enter = this.props.enter;
    var appearing = this.context ? this.context.isMounting : mounting;

    var _ref2 = this.props.nodeRef ? [appearing] : [react_dom.findDOMNode(this), appearing],
        maybeNode = _ref2[0],
        maybeAppearing = _ref2[1];

    var timeouts = this.getTimeouts();
    var enterTimeout = appearing ? timeouts.appear : timeouts.enter; // no enter animation skip right to ENTERED
    // if we are mounting and running this it means appear _must_ be set

    if (!mounting && !enter || config.disabled) {
      this.safeSetState({
        status: ENTERED
      }, function () {
        _this2.props.onEntered(maybeNode);
      });
      return;
    }

    this.props.onEnter(maybeNode, maybeAppearing);
    this.safeSetState({
      status: ENTERING
    }, function () {
      _this2.props.onEntering(maybeNode, maybeAppearing);

      _this2.onTransitionEnd(enterTimeout, function () {
        _this2.safeSetState({
          status: ENTERED
        }, function () {
          _this2.props.onEntered(maybeNode, maybeAppearing);
        });
      });
    });
  };

  _proto.performExit = function performExit() {
    var _this3 = this;

    var exit = this.props.exit;
    var timeouts = this.getTimeouts();
    var maybeNode = this.props.nodeRef ? undefined : react_dom.findDOMNode(this); // no exit animation skip right to EXITED

    if (!exit || config.disabled) {
      this.safeSetState({
        status: EXITED
      }, function () {
        _this3.props.onExited(maybeNode);
      });
      return;
    }

    this.props.onExit(maybeNode);
    this.safeSetState({
      status: EXITING
    }, function () {
      _this3.props.onExiting(maybeNode);

      _this3.onTransitionEnd(timeouts.exit, function () {
        _this3.safeSetState({
          status: EXITED
        }, function () {
          _this3.props.onExited(maybeNode);
        });
      });
    });
  };

  _proto.cancelNextCallback = function cancelNextCallback() {
    if (this.nextCallback !== null) {
      this.nextCallback.cancel();
      this.nextCallback = null;
    }
  };

  _proto.safeSetState = function safeSetState(nextState, callback) {
    // This shouldn't be necessary, but there are weird race conditions with
    // setState callbacks and unmounting in testing, so always make sure that
    // we can cancel any pending setState callbacks after we unmount.
    callback = this.setNextCallback(callback);
    this.setState(nextState, callback);
  };

  _proto.setNextCallback = function setNextCallback(callback) {
    var _this4 = this;

    var active = true;

    this.nextCallback = function (event) {
      if (active) {
        active = false;
        _this4.nextCallback = null;
        callback(event);
      }
    };

    this.nextCallback.cancel = function () {
      active = false;
    };

    return this.nextCallback;
  };

  _proto.onTransitionEnd = function onTransitionEnd(timeout, handler) {
    this.setNextCallback(handler);
    var node = this.props.nodeRef ? this.props.nodeRef.current : react_dom.findDOMNode(this);
    var doesNotHaveTimeoutOrListener = timeout == null && !this.props.addEndListener;

    if (!node || doesNotHaveTimeoutOrListener) {
      setTimeout(this.nextCallback, 0);
      return;
    }

    if (this.props.addEndListener) {
      var _ref3 = this.props.nodeRef ? [this.nextCallback] : [node, this.nextCallback],
          maybeNode = _ref3[0],
          maybeNextCallback = _ref3[1];

      this.props.addEndListener(maybeNode, maybeNextCallback);
    }

    if (timeout != null) {
      setTimeout(this.nextCallback, timeout);
    }
  };

  _proto.render = function render() {
    var status = this.state.status;

    if (status === UNMOUNTED) {
      return null;
    }

    var _this$props = this.props,
        children = _this$props.children,
        _in = _this$props.in,
        _mountOnEnter = _this$props.mountOnEnter,
        _unmountOnExit = _this$props.unmountOnExit,
        _appear = _this$props.appear,
        _enter = _this$props.enter,
        _exit = _this$props.exit,
        _timeout = _this$props.timeout,
        _addEndListener = _this$props.addEndListener,
        _onEnter = _this$props.onEnter,
        _onEntering = _this$props.onEntering,
        _onEntered = _this$props.onEntered,
        _onExit = _this$props.onExit,
        _onExiting = _this$props.onExiting,
        _onExited = _this$props.onExited,
        _nodeRef = _this$props.nodeRef,
        childProps = (0,objectWithoutPropertiesLoose/* default */.Z)(_this$props, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]);

    return (
      /*#__PURE__*/
      // allows for nested Transitions
      react.createElement(TransitionGroupContext/* default.Provider */.Z.Provider, {
        value: null
      }, typeof children === 'function' ? children(status, childProps) : react.cloneElement(react.Children.only(children), childProps))
    );
  };

  return Transition;
}(react.Component);

Transition.contextType = TransitionGroupContext/* default */.Z;
Transition.propTypes =  false ? 0 : {}; // Name the function so it is clearer in the documentation

function noop() {}

Transition.defaultProps = {
  in: false,
  mountOnEnter: false,
  unmountOnExit: false,
  appear: false,
  enter: true,
  exit: true,
  onEnter: noop,
  onEntering: noop,
  onEntered: noop,
  onExit: noop,
  onExiting: noop,
  onExited: noop
};
Transition.UNMOUNTED = UNMOUNTED;
Transition.EXITED = EXITED;
Transition.ENTERING = ENTERING;
Transition.ENTERED = ENTERED;
Transition.EXITING = EXITING;
/* harmony default export */ const esm_Transition = (Transition);

/***/ }),

/***/ 1605:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4191);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (react__WEBPACK_IMPORTED_MODULE_0__.createContext(null));

/***/ }),

/***/ 5879:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Q": () => (/* binding */ forceReflow)
/* harmony export */ });
var forceReflow = function forceReflow(node) {
  return node.scrollTop;
};

/***/ }),

/***/ 1105:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var f=__webpack_require__(4191),k=Symbol.for("react.element"),l=Symbol.for("react.fragment"),m=Object.prototype.hasOwnProperty,n=f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,p={key:!0,ref:!0,__self:!0,__source:!0};
function q(c,a,g){var b,d={},e=null,h=null;void 0!==g&&(e=""+g);void 0!==a.key&&(e=""+a.key);void 0!==a.ref&&(h=a.ref);for(b in a)m.call(a,b)&&!p.hasOwnProperty(b)&&(d[b]=a[b]);if(c&&c.defaultProps)for(b in a=c.defaultProps,a)void 0===d[b]&&(d[b]=a[b]);return{$$typeof:k,type:c,key:e,ref:h,props:d,_owner:n.current}}exports.Fragment=l;exports.jsx=q;exports.jsxs=q;


/***/ }),

/***/ 4146:
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var l=Symbol.for("react.element"),n=Symbol.for("react.portal"),p=Symbol.for("react.fragment"),q=Symbol.for("react.strict_mode"),r=Symbol.for("react.profiler"),t=Symbol.for("react.provider"),u=Symbol.for("react.context"),v=Symbol.for("react.forward_ref"),w=Symbol.for("react.suspense"),x=Symbol.for("react.memo"),y=Symbol.for("react.lazy"),z=Symbol.iterator;function A(a){if(null===a||"object"!==typeof a)return null;a=z&&a[z]||a["@@iterator"];return"function"===typeof a?a:null}
var B={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},C=Object.assign,D={};function E(a,b,e){this.props=a;this.context=b;this.refs=D;this.updater=e||B}E.prototype.isReactComponent={};
E.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,a,b,"setState")};E.prototype.forceUpdate=function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};function F(){}F.prototype=E.prototype;function G(a,b,e){this.props=a;this.context=b;this.refs=D;this.updater=e||B}var H=G.prototype=new F;
H.constructor=G;C(H,E.prototype);H.isPureReactComponent=!0;var I=Array.isArray,J=Object.prototype.hasOwnProperty,K={current:null},L={key:!0,ref:!0,__self:!0,__source:!0};
function M(a,b,e){var d,c={},k=null,h=null;if(null!=b)for(d in void 0!==b.ref&&(h=b.ref),void 0!==b.key&&(k=""+b.key),b)J.call(b,d)&&!L.hasOwnProperty(d)&&(c[d]=b[d]);var g=arguments.length-2;if(1===g)c.children=e;else if(1<g){for(var f=Array(g),m=0;m<g;m++)f[m]=arguments[m+2];c.children=f}if(a&&a.defaultProps)for(d in g=a.defaultProps,g)void 0===c[d]&&(c[d]=g[d]);return{$$typeof:l,type:a,key:k,ref:h,props:c,_owner:K.current}}
function N(a,b){return{$$typeof:l,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function O(a){return"object"===typeof a&&null!==a&&a.$$typeof===l}function escape(a){var b={"=":"=0",":":"=2"};return"$"+a.replace(/[=:]/g,function(a){return b[a]})}var P=/\/+/g;function Q(a,b){return"object"===typeof a&&null!==a&&null!=a.key?escape(""+a.key):b.toString(36)}
function R(a,b,e,d,c){var k=typeof a;if("undefined"===k||"boolean"===k)a=null;var h=!1;if(null===a)h=!0;else switch(k){case "string":case "number":h=!0;break;case "object":switch(a.$$typeof){case l:case n:h=!0}}if(h)return h=a,c=c(h),a=""===d?"."+Q(h,0):d,I(c)?(e="",null!=a&&(e=a.replace(P,"$&/")+"/"),R(c,b,e,"",function(a){return a})):null!=c&&(O(c)&&(c=N(c,e+(!c.key||h&&h.key===c.key?"":(""+c.key).replace(P,"$&/")+"/")+a)),b.push(c)),1;h=0;d=""===d?".":d+":";if(I(a))for(var g=0;g<a.length;g++){k=
a[g];var f=d+Q(k,g);h+=R(k,b,e,f,c)}else if(f=A(a),"function"===typeof f)for(a=f.call(a),g=0;!(k=a.next()).done;)k=k.value,f=d+Q(k,g++),h+=R(k,b,e,f,c);else if("object"===k)throw b=String(a),Error("Objects are not valid as a React child (found: "+("[object Object]"===b?"object with keys {"+Object.keys(a).join(", ")+"}":b)+"). If you meant to render a collection of children, use an array instead.");return h}
function S(a,b,e){if(null==a)return a;var d=[],c=0;R(a,d,"","",function(a){return b.call(e,a,c++)});return d}function T(a){if(-1===a._status){var b=a._result;b=b();b.then(function(b){if(0===a._status||-1===a._status)a._status=1,a._result=b},function(b){if(0===a._status||-1===a._status)a._status=2,a._result=b});-1===a._status&&(a._status=0,a._result=b)}if(1===a._status)return a._result.default;throw a._result;}
var U={current:null},V={transition:null},W={ReactCurrentDispatcher:U,ReactCurrentBatchConfig:V,ReactCurrentOwner:K};exports.Children={map:S,forEach:function(a,b,e){S(a,function(){b.apply(this,arguments)},e)},count:function(a){var b=0;S(a,function(){b++});return b},toArray:function(a){return S(a,function(a){return a})||[]},only:function(a){if(!O(a))throw Error("React.Children.only expected to receive a single React element child.");return a}};exports.Component=E;exports.Fragment=p;
exports.Profiler=r;exports.PureComponent=G;exports.StrictMode=q;exports.Suspense=w;exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=W;
exports.cloneElement=function(a,b,e){if(null===a||void 0===a)throw Error("React.cloneElement(...): The argument must be a React element, but you passed "+a+".");var d=C({},a.props),c=a.key,k=a.ref,h=a._owner;if(null!=b){void 0!==b.ref&&(k=b.ref,h=K.current);void 0!==b.key&&(c=""+b.key);if(a.type&&a.type.defaultProps)var g=a.type.defaultProps;for(f in b)J.call(b,f)&&!L.hasOwnProperty(f)&&(d[f]=void 0===b[f]&&void 0!==g?g[f]:b[f])}var f=arguments.length-2;if(1===f)d.children=e;else if(1<f){g=Array(f);
for(var m=0;m<f;m++)g[m]=arguments[m+2];d.children=g}return{$$typeof:l,type:a.type,key:c,ref:k,props:d,_owner:h}};exports.createContext=function(a){a={$$typeof:u,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null,_defaultValue:null,_globalName:null};a.Provider={$$typeof:t,_context:a};return a.Consumer=a};exports.createElement=M;exports.createFactory=function(a){var b=M.bind(null,a);b.type=a;return b};exports.createRef=function(){return{current:null}};
exports.forwardRef=function(a){return{$$typeof:v,render:a}};exports.isValidElement=O;exports.lazy=function(a){return{$$typeof:y,_payload:{_status:-1,_result:a},_init:T}};exports.memo=function(a,b){return{$$typeof:x,type:a,compare:void 0===b?null:b}};exports.startTransition=function(a){var b=V.transition;V.transition={};try{a()}finally{V.transition=b}};exports.unstable_act=function(){throw Error("act(...) is not supported in production builds of React.");};
exports.useCallback=function(a,b){return U.current.useCallback(a,b)};exports.useContext=function(a){return U.current.useContext(a)};exports.useDebugValue=function(){};exports.useDeferredValue=function(a){return U.current.useDeferredValue(a)};exports.useEffect=function(a,b){return U.current.useEffect(a,b)};exports.useId=function(){return U.current.useId()};exports.useImperativeHandle=function(a,b,e){return U.current.useImperativeHandle(a,b,e)};
exports.useInsertionEffect=function(a,b){return U.current.useInsertionEffect(a,b)};exports.useLayoutEffect=function(a,b){return U.current.useLayoutEffect(a,b)};exports.useMemo=function(a,b){return U.current.useMemo(a,b)};exports.useReducer=function(a,b,e){return U.current.useReducer(a,b,e)};exports.useRef=function(a){return U.current.useRef(a)};exports.useState=function(a){return U.current.useState(a)};exports.useSyncExternalStore=function(a,b,e){return U.current.useSyncExternalStore(a,b,e)};
exports.useTransition=function(){return U.current.useTransition()};exports.version="18.2.0";


/***/ }),

/***/ 4191:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


if (true) {
  module.exports = __webpack_require__(4146);
} else {}


/***/ }),

/***/ 38:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


if (true) {
  module.exports = __webpack_require__(1105);
} else {}


/***/ }),

/***/ 4495:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * Module dependencies
 */
var balanced = __webpack_require__(6525)
var reduceFunctionCall = __webpack_require__(4570)
var mexp = __webpack_require__(7982)

/**
 * Constantes
 */
var MAX_STACK = 100 // should be enough for a single calc()...
var NESTED_CALC_RE = /(\+|\-|\*|\\|[^a-z]|)(\s*)(\()/g

/**
 * Global variables
 */
var stack

/**
 * Expose reduceCSSCalc plugin
 *
 * @type {Function}
 */
module.exports = reduceCSSCalc

/**
 * Reduce CSS calc() in a string, whenever it's possible
 *
 * @param {String} value css input
 */
function reduceCSSCalc(value, decimalPrecision) {
  stack = 0
  decimalPrecision = Math.pow(10, decimalPrecision === undefined ? 5 : decimalPrecision)

  // Allow calc() on multiple lines
  value = value.replace(/\n+/g, " ")

  /**
   * Evaluates an expression
   *
   * @param {String} expression
   * @returns {String}
   */
  function evaluateExpression (expression, functionIdentifier, call) {
    if (stack++ > MAX_STACK) {
      stack = 0
      throw new Error("Call stack overflow for " + call)
    }

    if (expression === "") {
      throw new Error(functionIdentifier + "(): '" + call + "' must contain a non-whitespace string")
    }

    expression = evaluateNestedExpression(expression, call)

    var units = getUnitsInExpression(expression)

    // If the expression contains multiple units or CSS variables,
    // then let the expression be (i.e. browser calc())
    if (units.length > 1 || expression.indexOf("var(") > -1) {
      return functionIdentifier + "(" + expression + ")"
    }

    var unit = units[0] || ""

    if (unit === "%") {
      // Convert percentages to numbers, to handle expressions like: 50% * 50% (will become: 25%):
      // console.log(expression)
      expression = expression.replace(/\b[0-9\.]+%/g, function(percent) {
        return parseFloat(percent.slice(0, -1)) * 0.01
      })
    }

    // Remove units in expression:
    var toEvaluate = expression.replace(new RegExp(unit, "gi"), "")
    var result

    try {
      result = mexp.eval(toEvaluate)
    }
    catch (e) {
      return functionIdentifier + "(" + expression + ")"
    }

    // Transform back to a percentage result:
    if (unit === "%") {
      result *= 100
    }

    // adjust rounding shit
    // (0.1 * 0.2 === 0.020000000000000004)
    if (functionIdentifier.length || unit === "%") {
      result = Math.round(result * decimalPrecision) / decimalPrecision
    }

    // Add unit
    result += unit

    return result
  }

  /**
   * Evaluates nested expressions
   *
   * @param {String} expression
   * @returns {String}
   */
  function evaluateNestedExpression(expression, call) {
    // Remove the calc part from nested expressions to ensure
    // better browser compatibility
    expression = expression.replace(/((?:\-[a-z]+\-)?calc)/g, "")
    var evaluatedPart = ""
    var nonEvaluatedPart = expression
    var matches
    while ((matches = NESTED_CALC_RE.exec(nonEvaluatedPart))) {
      if (matches[0].index > 0) {
        evaluatedPart += nonEvaluatedPart.substring(0, matches[0].index)
      }

      var balancedExpr = balanced("(", ")", nonEvaluatedPart.substring([0].index))
      if (balancedExpr.body === "") {
        throw new Error("'" + expression + "' must contain a non-whitespace string")
      }

      var evaluated = evaluateExpression(balancedExpr.body, "", call)

      evaluatedPart += balancedExpr.pre + evaluated
      nonEvaluatedPart = balancedExpr.post
    }

    return evaluatedPart + nonEvaluatedPart
  }

  return reduceFunctionCall(value, /((?:\-[a-z]+\-)?calc)\(/, evaluateExpression)
}

/**
 * Checks what units are used in an expression
 *
 * @param {String} expression
 * @returns {Array}
 */

function getUnitsInExpression(expression) {
  var uniqueUnits = []
  var uniqueLowerCaseUnits = []
  var unitRegEx = /[\.0-9]([%a-z]+)/gi
  var matches = unitRegEx.exec(expression)

  while (matches) {
    if (!matches || !matches[1]) {
      continue
    }

    if (uniqueLowerCaseUnits.indexOf(matches[1].toLowerCase()) === -1) {
      uniqueUnits.push(matches[1])
      uniqueLowerCaseUnits.push(matches[1].toLowerCase())
    }

    matches = unitRegEx.exec(expression)
  }

  return uniqueUnits
}


/***/ }),

/***/ 6525:
/***/ ((module) => {

module.exports = balanced;
function balanced(a, b, str) {
  if (a instanceof RegExp) a = maybeMatch(a, str);
  if (b instanceof RegExp) b = maybeMatch(b, str);

  var r = range(a, b, str);

  return r && {
    start: r[0],
    end: r[1],
    pre: str.slice(0, r[0]),
    body: str.slice(r[0] + a.length, r[1]),
    post: str.slice(r[1] + b.length)
  };
}

function maybeMatch(reg, str) {
  var m = str.match(reg);
  return m ? m[0] : null;
}

balanced.range = range;
function range(a, b, str) {
  var begs, beg, left, right, result;
  var ai = str.indexOf(a);
  var bi = str.indexOf(b, ai + 1);
  var i = ai;

  if (ai >= 0 && bi > 0) {
    begs = [];
    left = str.length;

    while (i >= 0 && !result) {
      if (i == ai) {
        begs.push(i);
        ai = str.indexOf(a, i + 1);
      } else if (begs.length == 1) {
        result = [ begs.pop(), bi ];
      } else {
        beg = begs.pop();
        if (beg < left) {
          left = beg;
          right = bi;
        }

        bi = str.indexOf(b, i + 1);
      }

      i = ai < bi && ai >= 0 ? ai : bi;
    }

    if (begs.length) {
      result = [ left, right ];
    }
  }

  return result;
}


/***/ }),

/***/ 4570:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * Module dependencies
 */
var balanced = __webpack_require__(3612)

/**
 * Expose `reduceFunctionCall`
 *
 * @type {Function}
 */
module.exports = reduceFunctionCall

/**
 * Walkthrough all expressions, evaluate them and insert them into the declaration
 *
 * @param {Array} expressions
 * @param {Object} declaration
 */

function reduceFunctionCall(string, functionRE, callback) {
  var call = string
  return getFunctionCalls(string, functionRE).reduce(function(string, obj) {
    return string.replace(obj.functionIdentifier + "(" + obj.matches.body + ")", evalFunctionCall(obj.matches.body, obj.functionIdentifier, callback, call, functionRE))
  }, string)
}

/**
 * Parses expressions in a value
 *
 * @param {String} value
 * @returns {Array}
 * @api private
 */

function getFunctionCalls(call, functionRE) {
  var expressions = []

  var fnRE = typeof functionRE === "string" ? new RegExp("\\b(" + functionRE + ")\\(") : functionRE
  do {
    var searchMatch = fnRE.exec(call)
    if (!searchMatch) {
      return expressions
    }
    if (searchMatch[1] === undefined) {
      throw new Error("Missing the first couple of parenthesis to get the function identifier in " + functionRE)
    }
    var fn = searchMatch[1]
    var startIndex = searchMatch.index
    var matches = balanced("(", ")", call.substring(startIndex))

    if (!matches || matches.start !== searchMatch[0].length - 1) {
      throw new SyntaxError(fn + "(): missing closing ')' in the value '" + call + "'")
    }

    expressions.push({matches: matches, functionIdentifier: fn})
    call = matches.post
  }
  while (fnRE.test(call))

  return expressions
}

/**
 * Evaluates an expression
 *
 * @param {String} expression
 * @returns {String}
 * @api private
 */

function evalFunctionCall (string, functionIdentifier, callback, call, functionRE) {
  // allow recursivity
  return callback(reduceFunctionCall(string, functionRE, callback), functionIdentifier, call)
}


/***/ }),

/***/ 7160:
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
function f(a,b){var c=a.length;a.push(b);a:for(;0<c;){var d=c-1>>>1,e=a[d];if(0<g(e,b))a[d]=b,a[c]=e,c=d;else break a}}function h(a){return 0===a.length?null:a[0]}function k(a){if(0===a.length)return null;var b=a[0],c=a.pop();if(c!==b){a[0]=c;a:for(var d=0,e=a.length,w=e>>>1;d<w;){var m=2*(d+1)-1,C=a[m],n=m+1,x=a[n];if(0>g(C,c))n<e&&0>g(x,C)?(a[d]=x,a[n]=c,d=n):(a[d]=C,a[m]=c,d=m);else if(n<e&&0>g(x,c))a[d]=x,a[n]=c,d=n;else break a}}return b}
function g(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}if("object"===typeof performance&&"function"===typeof performance.now){var l=performance;exports.unstable_now=function(){return l.now()}}else{var p=Date,q=p.now();exports.unstable_now=function(){return p.now()-q}}var r=[],t=[],u=1,v=null,y=3,z=!1,A=!1,B=!1,D="function"===typeof setTimeout?setTimeout:null,E="function"===typeof clearTimeout?clearTimeout:null,F="undefined"!==typeof setImmediate?setImmediate:null;
"undefined"!==typeof navigator&&void 0!==navigator.scheduling&&void 0!==navigator.scheduling.isInputPending&&navigator.scheduling.isInputPending.bind(navigator.scheduling);function G(a){for(var b=h(t);null!==b;){if(null===b.callback)k(t);else if(b.startTime<=a)k(t),b.sortIndex=b.expirationTime,f(r,b);else break;b=h(t)}}function H(a){B=!1;G(a);if(!A)if(null!==h(r))A=!0,I(J);else{var b=h(t);null!==b&&K(H,b.startTime-a)}}
function J(a,b){A=!1;B&&(B=!1,E(L),L=-1);z=!0;var c=y;try{G(b);for(v=h(r);null!==v&&(!(v.expirationTime>b)||a&&!M());){var d=v.callback;if("function"===typeof d){v.callback=null;y=v.priorityLevel;var e=d(v.expirationTime<=b);b=exports.unstable_now();"function"===typeof e?v.callback=e:v===h(r)&&k(r);G(b)}else k(r);v=h(r)}if(null!==v)var w=!0;else{var m=h(t);null!==m&&K(H,m.startTime-b);w=!1}return w}finally{v=null,y=c,z=!1}}var N=!1,O=null,L=-1,P=5,Q=-1;
function M(){return exports.unstable_now()-Q<P?!1:!0}function R(){if(null!==O){var a=exports.unstable_now();Q=a;var b=!0;try{b=O(!0,a)}finally{b?S():(N=!1,O=null)}}else N=!1}var S;if("function"===typeof F)S=function(){F(R)};else if("undefined"!==typeof MessageChannel){var T=new MessageChannel,U=T.port2;T.port1.onmessage=R;S=function(){U.postMessage(null)}}else S=function(){D(R,0)};function I(a){O=a;N||(N=!0,S())}function K(a,b){L=D(function(){a(exports.unstable_now())},b)}
exports.unstable_IdlePriority=5;exports.unstable_ImmediatePriority=1;exports.unstable_LowPriority=4;exports.unstable_NormalPriority=3;exports.unstable_Profiling=null;exports.unstable_UserBlockingPriority=2;exports.unstable_cancelCallback=function(a){a.callback=null};exports.unstable_continueExecution=function(){A||z||(A=!0,I(J))};
exports.unstable_forceFrameRate=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):P=0<a?Math.floor(1E3/a):5};exports.unstable_getCurrentPriorityLevel=function(){return y};exports.unstable_getFirstCallbackNode=function(){return h(r)};exports.unstable_next=function(a){switch(y){case 1:case 2:case 3:var b=3;break;default:b=y}var c=y;y=b;try{return a()}finally{y=c}};exports.unstable_pauseExecution=function(){};
exports.unstable_requestPaint=function(){};exports.unstable_runWithPriority=function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=y;y=a;try{return b()}finally{y=c}};
exports.unstable_scheduleCallback=function(a,b,c){var d=exports.unstable_now();"object"===typeof c&&null!==c?(c=c.delay,c="number"===typeof c&&0<c?d+c:d):c=d;switch(a){case 1:var e=-1;break;case 2:e=250;break;case 5:e=1073741823;break;case 4:e=1E4;break;default:e=5E3}e=c+e;a={id:u++,callback:b,priorityLevel:a,startTime:c,expirationTime:e,sortIndex:-1};c>d?(a.sortIndex=c,f(t,a),null===h(r)&&a===h(t)&&(B?(E(L),L=-1):B=!0,K(H,c-d))):(a.sortIndex=e,f(r,a),A||z||(A=!0,I(J)));return a};
exports.unstable_shouldYield=M;exports.unstable_wrapCallback=function(a){var b=y;return function(){var c=y;y=b;try{return a.apply(this,arguments)}finally{y=c}}};


/***/ }),

/***/ 7630:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


if (true) {
  module.exports = __webpack_require__(7160);
} else {}


/***/ }),

/***/ 7865:
/***/ ((module) => {

//

module.exports = function shallowEqual(objA, objB, compare, compareContext) {
  var ret = compare ? compare.call(compareContext, objA, objB) : void 0;

  if (ret !== void 0) {
    return !!ret;
  }

  if (objA === objB) {
    return true;
  }

  if (typeof objA !== "object" || !objA || typeof objB !== "object" || !objB) {
    return false;
  }

  var keysA = Object.keys(objA);
  var keysB = Object.keys(objB);

  if (keysA.length !== keysB.length) {
    return false;
  }

  var bHasOwnProperty = Object.prototype.hasOwnProperty.bind(objB);

  // Test for A's keys different from B.
  for (var idx = 0; idx < keysA.length; idx++) {
    var key = keysA[idx];

    if (!bHasOwnProperty(key)) {
      return false;
    }

    var valueA = objA[key];
    var valueB = objB[key];

    ret = compare ? compare.call(compareContext, valueA, valueB, key) : void 0;

    if (ret === false || (ret === void 0 && valueA !== valueB)) {
      return false;
    }
  }

  return true;
};


/***/ }),

/***/ 5568:
/***/ (function(module) {


;(function (name, root, factory) {
  if (true) {
    module.exports = factory()
    module.exports["default"] = factory()
  }
  /* istanbul ignore next */
  else {}
}('slugify', this, function () {
  var charMap = JSON.parse('{"$":"dollar","%":"percent","&":"and","<":"less",">":"greater","|":"or","":"cent","":"pound","":"currency","":"yen","":"(c)","":"a","":"(r)","":"o","":"A","":"A","":"A","":"A","":"A","":"A","":"AE","":"C","":"E","":"E","":"E","":"E","":"I","":"I","":"I","":"I","":"D","":"N","":"O","":"O","":"O","":"O","":"O","":"O","":"U","":"U","":"U","":"U","":"Y","":"TH","":"ss","":"a","":"a","":"a","":"a","":"a","":"a","":"ae","":"c","":"e","":"e","":"e","":"e","":"i","":"i","":"i","":"i","":"d","":"n","":"o","":"o","":"o","":"o","":"o","":"o","":"u","":"u","":"u","":"u","":"y","":"th","":"y","":"A","":"a","":"A","":"a","":"A","":"a","":"C","":"c","":"C","":"c","":"D","":"d","":"DJ","":"dj","":"E","":"e","":"E","":"e","":"e","":"e","":"E","":"e","":"G","":"g","":"G","":"g","":"I","":"i","":"i","":"i","":"I","":"i","":"I","":"i","":"k","":"k","":"L","":"l","":"L","":"l","":"L","":"l","":"N","":"n","":"N","":"n","":"N","":"n","":"O","":"o","":"O","":"o","":"OE","":"oe","":"R","":"r","":"R","":"r","":"S","":"s","":"S","":"s","":"S","":"s","":"T","":"t","":"T","":"t","":"U","":"u","":"u","":"u","":"U","":"u","":"U","":"u","":"U","":"u","":"W","":"w","":"Y","":"y","":"Y","":"Z","":"z","":"Z","":"z","":"Z","":"z","":"E","":"f","":"O","":"o","":"U","":"u","":"LJ","":"lj","":"NJ","":"nj","":"S","":"s","":"T","":"t","":"e","":"o","":"A","":"E","":"H","":"I","":"O","":"Y","":"W","":"i","":"A","":"B","":"G","":"D","":"E","":"Z","":"H","":"8","":"I","":"K","":"L","":"M","":"N","":"3","":"O","":"P","":"R","":"S","":"T","":"Y","":"F","":"X","":"PS","":"W","":"I","":"Y","":"a","":"e","":"h","":"i","":"y","":"a","":"b","":"g","":"d","":"e","":"z","":"h","":"8","":"i","":"k","":"l","":"m","":"n","":"3","":"o","":"p","":"r","":"s","":"s","":"t","":"y","":"f","":"x","":"ps","":"w","":"i","":"y","":"o","":"y","":"w","":"Yo","":"DJ","":"Ye","":"I","":"Yi","":"J","":"LJ","":"NJ","":"C","":"DZ","":"A","":"B","":"V","":"G","":"D","":"E","":"Zh","":"Z","":"I","":"J","":"K","":"L","":"M","":"N","":"O","":"P","":"R","":"S","":"T","":"U","":"F","":"H","":"C","":"Ch","":"Sh","":"Sh","":"U","":"Y","":"","":"E","":"Yu","":"Ya","":"a","":"b","":"v","":"g","":"d","":"e","":"zh","":"z","":"i","":"j","":"k","":"l","":"m","":"n","":"o","":"p","":"r","":"s","":"t","":"u","":"f","":"h","":"c","":"ch","":"sh","":"sh","":"u","":"y","":"","":"e","":"yu","":"ya","":"yo","":"dj","":"ye","":"i","":"yi","":"j","":"lj","":"nj","":"c","":"u","":"dz","":"G","":"g","":"GH","":"gh","":"KH","":"kh","":"NG","":"ng","":"UE","":"ue","":"U","":"u","":"H","":"h","":"AE","":"ae","":"OE","":"oe","":"A","":"B","":"G","":"D","":"E","":"Z","":"E\'","":"Y\'","":"T\'","":"JH","":"I","":"L","":"X","":"C\'","":"K","":"H","":"D\'","":"GH","":"TW","":"M","":"Y","":"N","":"SH","":"CH","":"P","":"J","":"R\'","":"S","":"V","":"T","":"R","":"C","":"P\'","":"Q\'","":"O\'\'","":"F","":"EV","":"a","":"aa","":"a","":"u","":"i","":"e","":"a","":"b","":"h","":"t","":"th","":"j","":"h","":"kh","":"d","":"th","":"r","":"z","":"s","":"sh","":"s","":"dh","":"t","":"z","":"a","":"gh","":"f","":"q","":"k","":"l","":"m","":"n","":"h","":"w","":"a","":"y","":"an","":"on","":"en","":"a","":"u","":"e","":"","":"0","":"1","":"2","":"3","":"4","":"5","":"6","":"7","":"8","":"9","":"p","":"ch","":"zh","":"k","":"g","":"y","":"0","":"1","":"2","":"3","":"4","":"5","":"6","":"7","":"8","":"9","":"baht","":"a","":"b","":"g","":"d","":"e","":"v","":"z","":"t","":"i","":"k","":"l","":"m","":"n","":"o","":"p","":"zh","":"r","":"s","":"t","":"u","":"f","":"k","":"gh","":"q","":"sh","":"ch","":"ts","":"dz","":"ts","":"ch","":"kh","":"j","":"h","":"S","":"s","":"W","":"w","":"W","":"w","":"W","":"w","":"SS","":"A","":"a","":"A","":"a","":"A","":"a","":"A","":"a","":"A","":"a","":"A","":"a","":"A","":"a","":"A","":"a","":"A","":"a","":"A","":"a","":"A","":"a","":"A","":"a","":"E","":"e","":"E","":"e","":"E","":"e","":"E","":"e","":"E","":"e","":"E","":"e","":"E","":"e","":"E","":"e","":"I","":"i","":"I","":"i","":"O","":"o","":"O","":"o","":"O","":"o","":"O","":"o","":"O","":"o","":"O","":"o","":"O","":"o","":"O","":"o","":"O","":"o","":"O","":"o","":"O","":"o","":"O","":"o","":"U","":"u","":"U","":"u","":"U","":"u","":"U","":"u","":"U","":"u","":"U","":"u","":"U","":"u","":"Y","":"y","":"Y","":"y","":"Y","":"y","":"Y","":"y","":"-","":"\'","":"\'","":"\\\"","":"\\\"","":"\\\"","":"+","":"*","":"...","":"ecu","":"cruzeiro","":"french franc","":"lira","":"mill","":"naira","":"peseta","":"rupee","":"won","":"new shequel","":"dong","":"euro","":"kip","":"tugrik","":"drachma","":"penny","":"peso","":"guarani","":"austral","":"hryvnia","":"cedi","":"kazakhstani tenge","":"indian rupee","":"turkish lira","":"russian ruble","":"bitcoin","":"sm","":"tm","":"d","":"delta","":"sum","":"infinity","":"love","":"yuan","":"yen","":"rial","":"laa","":"laa","":"lai","":"la"}')
  var locales = JSON.parse('{"bg":{"":"Y","":"Ts","":"Sht","":"A","":"Y","":"y","":"ts","":"sht","":"a","":"y"},"de":{"":"AE","":"ae","":"OE","":"oe","":"UE","":"ue","":"ss","%":"prozent","&":"und","|":"oder","":"summe","":"unendlich","":"liebe"},"es":{"%":"por ciento","&":"y","<":"menor que",">":"mayor que","|":"o","":"centavos","":"libras","":"moneda","":"francos","":"suma","":"infinito","":"amor"},"fr":{"%":"pourcent","&":"et","<":"plus petit",">":"plus grand","|":"ou","":"centime","":"livre","":"devise","":"franc","":"somme","":"infini","":"amour"},"pt":{"%":"porcento","&":"e","<":"menor",">":"maior","|":"ou","":"centavo","":"soma","":"libra","":"infinito","":"amor"},"uk":{"":"Y","":"y","":"Y","":"y","":"Ts","":"ts","":"Kh","":"kh","":"Shch","":"shch","":"H","":"h"},"vi":{"":"D","":"d"},"da":{"":"OE","":"oe","":"AA","":"aa","%":"procent","&":"og","|":"eller","$":"dollar","<":"mindre end",">":"strre end"},"nb":{"&":"og","":"AA","":"AE","":"OE","":"aa","":"ae","":"oe"},"it":{"&":"e"},"nl":{"&":"en"},"sv":{"&":"och","":"AA","":"AE","":"OE","":"aa","":"ae","":"oe"}}')

  function replace (string, options) {
    if (typeof string !== 'string') {
      throw new Error('slugify: string argument expected')
    }

    options = (typeof options === 'string')
      ? {replacement: options}
      : options || {}

    var locale = locales[options.locale] || {}

    var replacement = options.replacement === undefined ? '-' : options.replacement

    var trim = options.trim === undefined ? true : options.trim

    var slug = string.normalize().split('')
      // replace characters based on charMap
      .reduce(function (result, ch) {
        var appendChar = locale[ch] || charMap[ch] || ch;
        if (appendChar === replacement) {
          appendChar = ' ';
        }
        return result + appendChar
          // remove not allowed characters
          .replace(options.remove || /[^\w\s$*_+~.()'"!\-:@]+/g, '')
      }, '');

    if (options.strict) {
      slug = slug.replace(/[^A-Za-z0-9\s]/g, '');
    }

    if (trim) {
      slug = slug.trim()
    }

    // Replace spaces with replacement character, treating multiple consecutive
    // spaces as a single space.
    slug = slug.replace(/\s+/g, replacement);

    if (options.lower) {
      slug = slug.toLowerCase()
    }

    return slug
  }

  replace.extend = function (customMap) {
    Object.assign(charMap, customMap)
  }

  return replace
}))


/***/ }),

/***/ 2294:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "ServerStyleSheet": () => (/* binding */ Je),
  "StyleSheetConsumer": () => (/* binding */ le),
  "StyleSheetContext": () => (/* binding */ ue),
  "StyleSheetManager": () => (/* binding */ ye),
  "ThemeConsumer": () => (/* binding */ Le),
  "ThemeContext": () => (/* binding */ Ge),
  "ThemeProvider": () => (/* binding */ Fe),
  "__PRIVATE__": () => (/* binding */ Ke),
  "createGlobalStyle": () => (/* binding */ We),
  "css": () => (/* binding */ Ce),
  "default": () => (/* binding */ styled_components_browser_esm),
  "isStyledComponent": () => (/* binding */ N),
  "keyframes": () => (/* binding */ Ue),
  "useTheme": () => (/* binding */ Ze),
  "version": () => (/* binding */ C),
  "withTheme": () => (/* binding */ Xe)
});

// EXTERNAL MODULE: ./node_modules/react-is/index.js
var react_is = __webpack_require__(5167);
// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(4191);
// EXTERNAL MODULE: ./node_modules/shallowequal/index.js
var shallowequal = __webpack_require__(7865);
var shallowequal_default = /*#__PURE__*/__webpack_require__.n(shallowequal);
;// CONCATENATED MODULE: ./node_modules/@emotion/stylis/dist/stylis.browser.esm.js
function stylis_min (W) {
  function M(d, c, e, h, a) {
    for (var m = 0, b = 0, v = 0, n = 0, q, g, x = 0, K = 0, k, u = k = q = 0, l = 0, r = 0, I = 0, t = 0, B = e.length, J = B - 1, y, f = '', p = '', F = '', G = '', C; l < B;) {
      g = e.charCodeAt(l);
      l === J && 0 !== b + n + v + m && (0 !== b && (g = 47 === b ? 10 : 47), n = v = m = 0, B++, J++);

      if (0 === b + n + v + m) {
        if (l === J && (0 < r && (f = f.replace(N, '')), 0 < f.trim().length)) {
          switch (g) {
            case 32:
            case 9:
            case 59:
            case 13:
            case 10:
              break;

            default:
              f += e.charAt(l);
          }

          g = 59;
        }

        switch (g) {
          case 123:
            f = f.trim();
            q = f.charCodeAt(0);
            k = 1;

            for (t = ++l; l < B;) {
              switch (g = e.charCodeAt(l)) {
                case 123:
                  k++;
                  break;

                case 125:
                  k--;
                  break;

                case 47:
                  switch (g = e.charCodeAt(l + 1)) {
                    case 42:
                    case 47:
                      a: {
                        for (u = l + 1; u < J; ++u) {
                          switch (e.charCodeAt(u)) {
                            case 47:
                              if (42 === g && 42 === e.charCodeAt(u - 1) && l + 2 !== u) {
                                l = u + 1;
                                break a;
                              }

                              break;

                            case 10:
                              if (47 === g) {
                                l = u + 1;
                                break a;
                              }

                          }
                        }

                        l = u;
                      }

                  }

                  break;

                case 91:
                  g++;

                case 40:
                  g++;

                case 34:
                case 39:
                  for (; l++ < J && e.charCodeAt(l) !== g;) {
                  }

              }

              if (0 === k) break;
              l++;
            }

            k = e.substring(t, l);
            0 === q && (q = (f = f.replace(ca, '').trim()).charCodeAt(0));

            switch (q) {
              case 64:
                0 < r && (f = f.replace(N, ''));
                g = f.charCodeAt(1);

                switch (g) {
                  case 100:
                  case 109:
                  case 115:
                  case 45:
                    r = c;
                    break;

                  default:
                    r = O;
                }

                k = M(c, r, k, g, a + 1);
                t = k.length;
                0 < A && (r = X(O, f, I), C = H(3, k, r, c, D, z, t, g, a, h), f = r.join(''), void 0 !== C && 0 === (t = (k = C.trim()).length) && (g = 0, k = ''));
                if (0 < t) switch (g) {
                  case 115:
                    f = f.replace(da, ea);

                  case 100:
                  case 109:
                  case 45:
                    k = f + '{' + k + '}';
                    break;

                  case 107:
                    f = f.replace(fa, '$1 $2');
                    k = f + '{' + k + '}';
                    k = 1 === w || 2 === w && L('@' + k, 3) ? '@-webkit-' + k + '@' + k : '@' + k;
                    break;

                  default:
                    k = f + k, 112 === h && (k = (p += k, ''));
                } else k = '';
                break;

              default:
                k = M(c, X(c, f, I), k, h, a + 1);
            }

            F += k;
            k = I = r = u = q = 0;
            f = '';
            g = e.charCodeAt(++l);
            break;

          case 125:
          case 59:
            f = (0 < r ? f.replace(N, '') : f).trim();
            if (1 < (t = f.length)) switch (0 === u && (q = f.charCodeAt(0), 45 === q || 96 < q && 123 > q) && (t = (f = f.replace(' ', ':')).length), 0 < A && void 0 !== (C = H(1, f, c, d, D, z, p.length, h, a, h)) && 0 === (t = (f = C.trim()).length) && (f = '\x00\x00'), q = f.charCodeAt(0), g = f.charCodeAt(1), q) {
              case 0:
                break;

              case 64:
                if (105 === g || 99 === g) {
                  G += f + e.charAt(l);
                  break;
                }

              default:
                58 !== f.charCodeAt(t - 1) && (p += P(f, q, g, f.charCodeAt(2)));
            }
            I = r = u = q = 0;
            f = '';
            g = e.charCodeAt(++l);
        }
      }

      switch (g) {
        case 13:
        case 10:
          47 === b ? b = 0 : 0 === 1 + q && 107 !== h && 0 < f.length && (r = 1, f += '\x00');
          0 < A * Y && H(0, f, c, d, D, z, p.length, h, a, h);
          z = 1;
          D++;
          break;

        case 59:
        case 125:
          if (0 === b + n + v + m) {
            z++;
            break;
          }

        default:
          z++;
          y = e.charAt(l);

          switch (g) {
            case 9:
            case 32:
              if (0 === n + m + b) switch (x) {
                case 44:
                case 58:
                case 9:
                case 32:
                  y = '';
                  break;

                default:
                  32 !== g && (y = ' ');
              }
              break;

            case 0:
              y = '\\0';
              break;

            case 12:
              y = '\\f';
              break;

            case 11:
              y = '\\v';
              break;

            case 38:
              0 === n + b + m && (r = I = 1, y = '\f' + y);
              break;

            case 108:
              if (0 === n + b + m + E && 0 < u) switch (l - u) {
                case 2:
                  112 === x && 58 === e.charCodeAt(l - 3) && (E = x);

                case 8:
                  111 === K && (E = K);
              }
              break;

            case 58:
              0 === n + b + m && (u = l);
              break;

            case 44:
              0 === b + v + n + m && (r = 1, y += '\r');
              break;

            case 34:
            case 39:
              0 === b && (n = n === g ? 0 : 0 === n ? g : n);
              break;

            case 91:
              0 === n + b + v && m++;
              break;

            case 93:
              0 === n + b + v && m--;
              break;

            case 41:
              0 === n + b + m && v--;
              break;

            case 40:
              if (0 === n + b + m) {
                if (0 === q) switch (2 * x + 3 * K) {
                  case 533:
                    break;

                  default:
                    q = 1;
                }
                v++;
              }

              break;

            case 64:
              0 === b + v + n + m + u + k && (k = 1);
              break;

            case 42:
            case 47:
              if (!(0 < n + m + v)) switch (b) {
                case 0:
                  switch (2 * g + 3 * e.charCodeAt(l + 1)) {
                    case 235:
                      b = 47;
                      break;

                    case 220:
                      t = l, b = 42;
                  }

                  break;

                case 42:
                  47 === g && 42 === x && t + 2 !== l && (33 === e.charCodeAt(t + 2) && (p += e.substring(t, l + 1)), y = '', b = 0);
              }
          }

          0 === b && (f += y);
      }

      K = x;
      x = g;
      l++;
    }

    t = p.length;

    if (0 < t) {
      r = c;
      if (0 < A && (C = H(2, p, r, d, D, z, t, h, a, h), void 0 !== C && 0 === (p = C).length)) return G + p + F;
      p = r.join(',') + '{' + p + '}';

      if (0 !== w * E) {
        2 !== w || L(p, 2) || (E = 0);

        switch (E) {
          case 111:
            p = p.replace(ha, ':-moz-$1') + p;
            break;

          case 112:
            p = p.replace(Q, '::-webkit-input-$1') + p.replace(Q, '::-moz-$1') + p.replace(Q, ':-ms-input-$1') + p;
        }

        E = 0;
      }
    }

    return G + p + F;
  }

  function X(d, c, e) {
    var h = c.trim().split(ia);
    c = h;
    var a = h.length,
        m = d.length;

    switch (m) {
      case 0:
      case 1:
        var b = 0;

        for (d = 0 === m ? '' : d[0] + ' '; b < a; ++b) {
          c[b] = Z(d, c[b], e).trim();
        }

        break;

      default:
        var v = b = 0;

        for (c = []; b < a; ++b) {
          for (var n = 0; n < m; ++n) {
            c[v++] = Z(d[n] + ' ', h[b], e).trim();
          }
        }

    }

    return c;
  }

  function Z(d, c, e) {
    var h = c.charCodeAt(0);
    33 > h && (h = (c = c.trim()).charCodeAt(0));

    switch (h) {
      case 38:
        return c.replace(F, '$1' + d.trim());

      case 58:
        return d.trim() + c.replace(F, '$1' + d.trim());

      default:
        if (0 < 1 * e && 0 < c.indexOf('\f')) return c.replace(F, (58 === d.charCodeAt(0) ? '' : '$1') + d.trim());
    }

    return d + c;
  }

  function P(d, c, e, h) {
    var a = d + ';',
        m = 2 * c + 3 * e + 4 * h;

    if (944 === m) {
      d = a.indexOf(':', 9) + 1;
      var b = a.substring(d, a.length - 1).trim();
      b = a.substring(0, d).trim() + b + ';';
      return 1 === w || 2 === w && L(b, 1) ? '-webkit-' + b + b : b;
    }

    if (0 === w || 2 === w && !L(a, 1)) return a;

    switch (m) {
      case 1015:
        return 97 === a.charCodeAt(10) ? '-webkit-' + a + a : a;

      case 951:
        return 116 === a.charCodeAt(3) ? '-webkit-' + a + a : a;

      case 963:
        return 110 === a.charCodeAt(5) ? '-webkit-' + a + a : a;

      case 1009:
        if (100 !== a.charCodeAt(4)) break;

      case 969:
      case 942:
        return '-webkit-' + a + a;

      case 978:
        return '-webkit-' + a + '-moz-' + a + a;

      case 1019:
      case 983:
        return '-webkit-' + a + '-moz-' + a + '-ms-' + a + a;

      case 883:
        if (45 === a.charCodeAt(8)) return '-webkit-' + a + a;
        if (0 < a.indexOf('image-set(', 11)) return a.replace(ja, '$1-webkit-$2') + a;
        break;

      case 932:
        if (45 === a.charCodeAt(4)) switch (a.charCodeAt(5)) {
          case 103:
            return '-webkit-box-' + a.replace('-grow', '') + '-webkit-' + a + '-ms-' + a.replace('grow', 'positive') + a;

          case 115:
            return '-webkit-' + a + '-ms-' + a.replace('shrink', 'negative') + a;

          case 98:
            return '-webkit-' + a + '-ms-' + a.replace('basis', 'preferred-size') + a;
        }
        return '-webkit-' + a + '-ms-' + a + a;

      case 964:
        return '-webkit-' + a + '-ms-flex-' + a + a;

      case 1023:
        if (99 !== a.charCodeAt(8)) break;
        b = a.substring(a.indexOf(':', 15)).replace('flex-', '').replace('space-between', 'justify');
        return '-webkit-box-pack' + b + '-webkit-' + a + '-ms-flex-pack' + b + a;

      case 1005:
        return ka.test(a) ? a.replace(aa, ':-webkit-') + a.replace(aa, ':-moz-') + a : a;

      case 1e3:
        b = a.substring(13).trim();
        c = b.indexOf('-') + 1;

        switch (b.charCodeAt(0) + b.charCodeAt(c)) {
          case 226:
            b = a.replace(G, 'tb');
            break;

          case 232:
            b = a.replace(G, 'tb-rl');
            break;

          case 220:
            b = a.replace(G, 'lr');
            break;

          default:
            return a;
        }

        return '-webkit-' + a + '-ms-' + b + a;

      case 1017:
        if (-1 === a.indexOf('sticky', 9)) break;

      case 975:
        c = (a = d).length - 10;
        b = (33 === a.charCodeAt(c) ? a.substring(0, c) : a).substring(d.indexOf(':', 7) + 1).trim();

        switch (m = b.charCodeAt(0) + (b.charCodeAt(7) | 0)) {
          case 203:
            if (111 > b.charCodeAt(8)) break;

          case 115:
            a = a.replace(b, '-webkit-' + b) + ';' + a;
            break;

          case 207:
          case 102:
            a = a.replace(b, '-webkit-' + (102 < m ? 'inline-' : '') + 'box') + ';' + a.replace(b, '-webkit-' + b) + ';' + a.replace(b, '-ms-' + b + 'box') + ';' + a;
        }

        return a + ';';

      case 938:
        if (45 === a.charCodeAt(5)) switch (a.charCodeAt(6)) {
          case 105:
            return b = a.replace('-items', ''), '-webkit-' + a + '-webkit-box-' + b + '-ms-flex-' + b + a;

          case 115:
            return '-webkit-' + a + '-ms-flex-item-' + a.replace(ba, '') + a;

          default:
            return '-webkit-' + a + '-ms-flex-line-pack' + a.replace('align-content', '').replace(ba, '') + a;
        }
        break;

      case 973:
      case 989:
        if (45 !== a.charCodeAt(3) || 122 === a.charCodeAt(4)) break;

      case 931:
      case 953:
        if (!0 === la.test(d)) return 115 === (b = d.substring(d.indexOf(':') + 1)).charCodeAt(0) ? P(d.replace('stretch', 'fill-available'), c, e, h).replace(':fill-available', ':stretch') : a.replace(b, '-webkit-' + b) + a.replace(b, '-moz-' + b.replace('fill-', '')) + a;
        break;

      case 962:
        if (a = '-webkit-' + a + (102 === a.charCodeAt(5) ? '-ms-' + a : '') + a, 211 === e + h && 105 === a.charCodeAt(13) && 0 < a.indexOf('transform', 10)) return a.substring(0, a.indexOf(';', 27) + 1).replace(ma, '$1-webkit-$2') + a;
    }

    return a;
  }

  function L(d, c) {
    var e = d.indexOf(1 === c ? ':' : '{'),
        h = d.substring(0, 3 !== c ? e : 10);
    e = d.substring(e + 1, d.length - 1);
    return R(2 !== c ? h : h.replace(na, '$1'), e, c);
  }

  function ea(d, c) {
    var e = P(c, c.charCodeAt(0), c.charCodeAt(1), c.charCodeAt(2));
    return e !== c + ';' ? e.replace(oa, ' or ($1)').substring(4) : '(' + c + ')';
  }

  function H(d, c, e, h, a, m, b, v, n, q) {
    for (var g = 0, x = c, w; g < A; ++g) {
      switch (w = S[g].call(B, d, x, e, h, a, m, b, v, n, q)) {
        case void 0:
        case !1:
        case !0:
        case null:
          break;

        default:
          x = w;
      }
    }

    if (x !== c) return x;
  }

  function T(d) {
    switch (d) {
      case void 0:
      case null:
        A = S.length = 0;
        break;

      default:
        if ('function' === typeof d) S[A++] = d;else if ('object' === typeof d) for (var c = 0, e = d.length; c < e; ++c) {
          T(d[c]);
        } else Y = !!d | 0;
    }

    return T;
  }

  function U(d) {
    d = d.prefix;
    void 0 !== d && (R = null, d ? 'function' !== typeof d ? w = 1 : (w = 2, R = d) : w = 0);
    return U;
  }

  function B(d, c) {
    var e = d;
    33 > e.charCodeAt(0) && (e = e.trim());
    V = e;
    e = [V];

    if (0 < A) {
      var h = H(-1, c, e, e, D, z, 0, 0, 0, 0);
      void 0 !== h && 'string' === typeof h && (c = h);
    }

    var a = M(O, e, c, 0, 0);
    0 < A && (h = H(-2, a, e, e, D, z, a.length, 0, 0, 0), void 0 !== h && (a = h));
    V = '';
    E = 0;
    z = D = 1;
    return a;
  }

  var ca = /^\0+/g,
      N = /[\0\r\f]/g,
      aa = /: */g,
      ka = /zoo|gra/,
      ma = /([,: ])(transform)/g,
      ia = /,\r+?/g,
      F = /([\t\r\n ])*\f?&/g,
      fa = /@(k\w+)\s*(\S*)\s*/,
      Q = /::(place)/g,
      ha = /:(read-only)/g,
      G = /[svh]\w+-[tblr]{2}/,
      da = /\(\s*(.*)\s*\)/g,
      oa = /([\s\S]*?);/g,
      ba = /-self|flex-/g,
      na = /[^]*?(:[rp][el]a[\w-]+)[^]*/,
      la = /stretch|:\s*\w+\-(?:conte|avail)/,
      ja = /([^-])(image-set\()/,
      z = 1,
      D = 1,
      E = 0,
      w = 1,
      O = [],
      S = [],
      A = 0,
      R = null,
      Y = 0,
      V = '';
  B.use = T;
  B.set = U;
  void 0 !== W && U(W);
  return B;
}

/* harmony default export */ const stylis_browser_esm = (stylis_min);

;// CONCATENATED MODULE: ./node_modules/@emotion/unitless/dist/unitless.browser.esm.js
var unitlessKeys = {
  animationIterationCount: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
};

/* harmony default export */ const unitless_browser_esm = (unitlessKeys);

// EXTERNAL MODULE: ./node_modules/@emotion/is-prop-valid/dist/emotion-is-prop-valid.cjs.js
var emotion_is_prop_valid_cjs = __webpack_require__(9906);
// EXTERNAL MODULE: ./node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js
var hoist_non_react_statics_cjs = __webpack_require__(6044);
var hoist_non_react_statics_cjs_default = /*#__PURE__*/__webpack_require__.n(hoist_non_react_statics_cjs);
;// CONCATENATED MODULE: ./node_modules/styled-components/dist/styled-components.browser.esm.js
function v(){return(v=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e}).apply(this,arguments)}var g=function(e,t){for(var n=[e[0]],r=0,o=t.length;r<o;r+=1)n.push(t[r],e[r+1]);return n},S=function(t){return null!==t&&"object"==typeof t&&"[object Object]"===(t.toString?t.toString():Object.prototype.toString.call(t))&&!(0,react_is.typeOf)(t)},w=Object.freeze([]),E=Object.freeze({});function b(e){return"function"==typeof e}function _(e){return false||e.displayName||e.name||"Component"}function N(e){return e&&"string"==typeof e.styledComponentId}var A="undefined"!=typeof process&&(process.env.REACT_APP_SC_ATTR||process.env.SC_ATTR)||"data-styled",C="5.3.6",I="undefined"!=typeof window&&"HTMLElement"in window,P=Boolean("boolean"==typeof SC_DISABLE_SPEEDY?SC_DISABLE_SPEEDY:"undefined"!=typeof process&&void 0!==process.env.REACT_APP_SC_DISABLE_SPEEDY&&""!==process.env.REACT_APP_SC_DISABLE_SPEEDY?"false"!==process.env.REACT_APP_SC_DISABLE_SPEEDY&&process.env.REACT_APP_SC_DISABLE_SPEEDY:"undefined"!=typeof process&&void 0!==process.env.SC_DISABLE_SPEEDY&&""!==process.env.SC_DISABLE_SPEEDY?"false"!==process.env.SC_DISABLE_SPEEDY&&process.env.SC_DISABLE_SPEEDY:"production"!=="production"),O={},R= false?0:{};function D(){for(var e=arguments.length<=0?void 0:arguments[0],t=[],n=1,r=arguments.length;n<r;n+=1)t.push(n<0||arguments.length<=n?void 0:arguments[n]);return t.forEach((function(t){e=e.replace(/%[a-z]/,t)})),e}function j(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];throw true?new Error("An error occurred. See https://git.io/JUIaE#"+e+" for more information."+(n.length>0?" Args: "+n.join(", "):"")):0}var T=function(){function e(e){this.groupSizes=new Uint32Array(512),this.length=512,this.tag=e}var t=e.prototype;return t.indexOfGroup=function(e){for(var t=0,n=0;n<e;n++)t+=this.groupSizes[n];return t},t.insertRules=function(e,t){if(e>=this.groupSizes.length){for(var n=this.groupSizes,r=n.length,o=r;e>=o;)(o<<=1)<0&&j(16,""+e);this.groupSizes=new Uint32Array(o),this.groupSizes.set(n),this.length=o;for(var s=r;s<o;s++)this.groupSizes[s]=0}for(var i=this.indexOfGroup(e+1),a=0,c=t.length;a<c;a++)this.tag.insertRule(i,t[a])&&(this.groupSizes[e]++,i++)},t.clearGroup=function(e){if(e<this.length){var t=this.groupSizes[e],n=this.indexOfGroup(e),r=n+t;this.groupSizes[e]=0;for(var o=n;o<r;o++)this.tag.deleteRule(n)}},t.getGroup=function(e){var t="";if(e>=this.length||0===this.groupSizes[e])return t;for(var n=this.groupSizes[e],r=this.indexOfGroup(e),o=r+n,s=r;s<o;s++)t+=this.tag.getRule(s)+"/*!sc*/\n";return t},e}(),x=new Map,k=new Map,V=1,B=function(e){if(x.has(e))return x.get(e);for(;k.has(V);)V++;var t=V++;return false&&0,x.set(e,t),k.set(t,e),t},z=function(e){return k.get(e)},M=function(e,t){t>=V&&(V=t+1),x.set(e,t),k.set(t,e)},G="style["+A+'][data-styled-version="5.3.6"]',L=new RegExp("^"+A+'\\.g(\\d+)\\[id="([\\w\\d-]+)"\\].*?"([^"]*)'),F=function(e,t,n){for(var r,o=n.split(","),s=0,i=o.length;s<i;s++)(r=o[s])&&e.registerName(t,r)},Y=function(e,t){for(var n=(t.textContent||"").split("/*!sc*/\n"),r=[],o=0,s=n.length;o<s;o++){var i=n[o].trim();if(i){var a=i.match(L);if(a){var c=0|parseInt(a[1],10),u=a[2];0!==c&&(M(u,c),F(e,u,a[3]),e.getTag().insertRules(c,r)),r.length=0}else r.push(i)}}},q=function(){return true?__webpack_require__.nc:0},H=function(e){var t=document.head,n=e||t,r=document.createElement("style"),o=function(e){for(var t=e.childNodes,n=t.length;n>=0;n--){var r=t[n];if(r&&1===r.nodeType&&r.hasAttribute(A))return r}}(n),s=void 0!==o?o.nextSibling:null;r.setAttribute(A,"active"),r.setAttribute("data-styled-version","5.3.6");var i=q();return i&&r.setAttribute("nonce",i),n.insertBefore(r,s),r},$=function(){function e(e){var t=this.element=H(e);t.appendChild(document.createTextNode("")),this.sheet=function(e){if(e.sheet)return e.sheet;for(var t=document.styleSheets,n=0,r=t.length;n<r;n++){var o=t[n];if(o.ownerNode===e)return o}j(17)}(t),this.length=0}var t=e.prototype;return t.insertRule=function(e,t){try{return this.sheet.insertRule(t,e),this.length++,!0}catch(e){return!1}},t.deleteRule=function(e){this.sheet.deleteRule(e),this.length--},t.getRule=function(e){var t=this.sheet.cssRules[e];return void 0!==t&&"string"==typeof t.cssText?t.cssText:""},e}(),W=function(){function e(e){var t=this.element=H(e);this.nodes=t.childNodes,this.length=0}var t=e.prototype;return t.insertRule=function(e,t){if(e<=this.length&&e>=0){var n=document.createTextNode(t),r=this.nodes[e];return this.element.insertBefore(n,r||null),this.length++,!0}return!1},t.deleteRule=function(e){this.element.removeChild(this.nodes[e]),this.length--},t.getRule=function(e){return e<this.length?this.nodes[e].textContent:""},e}(),U=function(){function e(e){this.rules=[],this.length=0}var t=e.prototype;return t.insertRule=function(e,t){return e<=this.length&&(this.rules.splice(e,0,t),this.length++,!0)},t.deleteRule=function(e){this.rules.splice(e,1),this.length--},t.getRule=function(e){return e<this.length?this.rules[e]:""},e}(),J=I,X={isServer:!I,useCSSOMInjection:!P},Z=function(){function e(e,t,n){void 0===e&&(e=E),void 0===t&&(t={}),this.options=v({},X,{},e),this.gs=t,this.names=new Map(n),this.server=!!e.isServer,!this.server&&I&&J&&(J=!1,function(e){for(var t=document.querySelectorAll(G),n=0,r=t.length;n<r;n++){var o=t[n];o&&"active"!==o.getAttribute(A)&&(Y(e,o),o.parentNode&&o.parentNode.removeChild(o))}}(this))}e.registerId=function(e){return B(e)};var t=e.prototype;return t.reconstructWithOptions=function(t,n){return void 0===n&&(n=!0),new e(v({},this.options,{},t),this.gs,n&&this.names||void 0)},t.allocateGSInstance=function(e){return this.gs[e]=(this.gs[e]||0)+1},t.getTag=function(){return this.tag||(this.tag=(n=(t=this.options).isServer,r=t.useCSSOMInjection,o=t.target,e=n?new U(o):r?new $(o):new W(o),new T(e)));var e,t,n,r,o},t.hasNameForId=function(e,t){return this.names.has(e)&&this.names.get(e).has(t)},t.registerName=function(e,t){if(B(e),this.names.has(e))this.names.get(e).add(t);else{var n=new Set;n.add(t),this.names.set(e,n)}},t.insertRules=function(e,t,n){this.registerName(e,t),this.getTag().insertRules(B(e),n)},t.clearNames=function(e){this.names.has(e)&&this.names.get(e).clear()},t.clearRules=function(e){this.getTag().clearGroup(B(e)),this.clearNames(e)},t.clearTag=function(){this.tag=void 0},t.toString=function(){return function(e){for(var t=e.getTag(),n=t.length,r="",o=0;o<n;o++){var s=z(o);if(void 0!==s){var i=e.names.get(s),a=t.getGroup(o);if(i&&a&&i.size){var c=A+".g"+o+'[id="'+s+'"]',u="";void 0!==i&&i.forEach((function(e){e.length>0&&(u+=e+",")})),r+=""+a+c+'{content:"'+u+'"}/*!sc*/\n'}}}return r}(this)},e}(),K=/(a)(d)/gi,Q=function(e){return String.fromCharCode(e+(e>25?39:97))};function ee(e){var t,n="";for(t=Math.abs(e);t>52;t=t/52|0)n=Q(t%52)+n;return(Q(t%52)+n).replace(K,"$1-$2")}var te=function(e,t){for(var n=t.length;n;)e=33*e^t.charCodeAt(--n);return e},ne=function(e){return te(5381,e)};function re(e){for(var t=0;t<e.length;t+=1){var n=e[t];if(b(n)&&!N(n))return!1}return!0}var oe=ne("5.3.6"),se=function(){function e(e,t,n){this.rules=e,this.staticRulesId="",this.isStatic= true&&(void 0===n||n.isStatic)&&re(e),this.componentId=t,this.baseHash=te(oe,t),this.baseStyle=n,Z.registerId(t)}return e.prototype.generateAndInjectStyles=function(e,t,n){var r=this.componentId,o=[];if(this.baseStyle&&o.push(this.baseStyle.generateAndInjectStyles(e,t,n)),this.isStatic&&!n.hash)if(this.staticRulesId&&t.hasNameForId(r,this.staticRulesId))o.push(this.staticRulesId);else{var s=Ne(this.rules,e,t,n).join(""),i=ee(te(this.baseHash,s)>>>0);if(!t.hasNameForId(r,i)){var a=n(s,"."+i,void 0,r);t.insertRules(r,i,a)}o.push(i),this.staticRulesId=i}else{for(var c=this.rules.length,u=te(this.baseHash,n.hash),l="",d=0;d<c;d++){var h=this.rules[d];if("string"==typeof h)l+=h, false&&(0);else if(h){var p=Ne(h,e,t,n),f=Array.isArray(p)?p.join(""):p;u=te(u,f+d),l+=f}}if(l){var m=ee(u>>>0);if(!t.hasNameForId(r,m)){var y=n(l,"."+m,void 0,r);t.insertRules(r,m,y)}o.push(m)}}return o.join(" ")},e}(),ie=/^\s*\/\/.*$/gm,ae=[":","[",".","#"];function ce(e){var t,n,r,o,s=void 0===e?E:e,i=s.options,a=void 0===i?E:i,c=s.plugins,u=void 0===c?w:c,l=new stylis_browser_esm(a),d=[],h=function(e){function t(t){if(t)try{e(t+"}")}catch(e){}}return function(n,r,o,s,i,a,c,u,l,d){switch(n){case 1:if(0===l&&64===r.charCodeAt(0))return e(r+";"),"";break;case 2:if(0===u)return r+"/*|*/";break;case 3:switch(u){case 102:case 112:return e(o[0]+r),"";default:return r+(0===d?"/*|*/":"")}case-2:r.split("/*|*/}").forEach(t)}}}((function(e){d.push(e)})),f=function(e,r,s){return 0===r&&-1!==ae.indexOf(s[n.length])||s.match(o)?e:"."+t};function m(e,s,i,a){void 0===a&&(a="&");var c=e.replace(ie,""),u=s&&i?i+" "+s+" { "+c+" }":c;return t=a,n=s,r=new RegExp("\\"+n+"\\b","g"),o=new RegExp("(\\"+n+"\\b){2,}"),l(i||!s?"":s,u)}return l.use([].concat(u,[function(e,t,o){2===e&&o.length&&o[0].lastIndexOf(n)>0&&(o[0]=o[0].replace(r,f))},h,function(e){if(-2===e){var t=d;return d=[],t}}])),m.hash=u.length?u.reduce((function(e,t){return t.name||j(15),te(e,t.name)}),5381).toString():"",m}var ue=react.createContext(),le=ue.Consumer,de=react.createContext(),he=(de.Consumer,new Z),pe=ce();function fe(){return (0,react.useContext)(ue)||he}function me(){return (0,react.useContext)(de)||pe}function ye(e){var t=(0,react.useState)(e.stylisPlugins),n=t[0],s=t[1],c=fe(),u=(0,react.useMemo)((function(){var t=c;return e.sheet?t=e.sheet:e.target&&(t=t.reconstructWithOptions({target:e.target},!1)),e.disableCSSOMInjection&&(t=t.reconstructWithOptions({useCSSOMInjection:!1})),t}),[e.disableCSSOMInjection,e.sheet,e.target]),l=(0,react.useMemo)((function(){return ce({options:{prefix:!e.disableVendorPrefixes},plugins:n})}),[e.disableVendorPrefixes,n]);return (0,react.useEffect)((function(){shallowequal_default()(n,e.stylisPlugins)||s(e.stylisPlugins)}),[e.stylisPlugins]),react.createElement(ue.Provider,{value:u},react.createElement(de.Provider,{value:l}, false?0:e.children))}var ve=function(){function e(e,t){var n=this;this.inject=function(e,t){void 0===t&&(t=pe);var r=n.name+t.hash;e.hasNameForId(n.id,r)||e.insertRules(n.id,r,t(n.rules,r,"@keyframes"))},this.toString=function(){return j(12,String(n.name))},this.name=e,this.id="sc-keyframes-"+e,this.rules=t}return e.prototype.getName=function(e){return void 0===e&&(e=pe),this.name+e.hash},e}(),ge=/([A-Z])/,Se=/([A-Z])/g,we=/^ms-/,Ee=function(e){return"-"+e.toLowerCase()};function be(e){return ge.test(e)?e.replace(Se,Ee).replace(we,"-ms-"):e}var _e=function(e){return null==e||!1===e||""===e};function Ne(e,n,r,o){if(Array.isArray(e)){for(var s,i=[],a=0,c=e.length;a<c;a+=1)""!==(s=Ne(e[a],n,r,o))&&(Array.isArray(s)?i.push.apply(i,s):i.push(s));return i}if(_e(e))return"";if(N(e))return"."+e.styledComponentId;if(b(e)){if("function"!=typeof(l=e)||l.prototype&&l.prototype.isReactComponent||!n)return e;var u=e(n);return false&&0,Ne(u,n,r,o)}var l;return e instanceof ve?r?(e.inject(r,o),e.getName(o)):e:S(e)?function e(t,n){var r,o,s=[];for(var i in t)t.hasOwnProperty(i)&&!_e(t[i])&&(Array.isArray(t[i])&&t[i].isCss||b(t[i])?s.push(be(i)+":",t[i],";"):S(t[i])?s.push.apply(s,e(t[i],i)):s.push(be(i)+": "+(r=i,null==(o=t[i])||"boolean"==typeof o||""===o?"":"number"!=typeof o||0===o||r in unitless_browser_esm?String(o).trim():o+"px")+";"));return n?[n+" {"].concat(s,["}"]):s}(e):e.toString()}var Ae=function(e){return Array.isArray(e)&&(e.isCss=!0),e};function Ce(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];return b(e)||S(e)?Ae(Ne(g(w,[e].concat(n)))):0===n.length&&1===e.length&&"string"==typeof e[0]?e:Ae(Ne(g(e,n)))}var Ie=/invalid hook call/i,Pe=new Set,Oe=function(e,t){if(false){ var o, n, r; }},Re=function(e,t,n){return void 0===n&&(n=E),e.theme!==n.theme&&e.theme||t||n.theme},De=/[!"#$%&'()*+,./:;<=>?@[\\\]^`{|}~-]+/g,je=/(^-|-$)/g;function Te(e){return e.replace(De,"-").replace(je,"")}var xe=function(e){return ee(ne(e)>>>0)};function ke(e){return"string"==typeof e&&( true||0)}var Ve=function(e){return"function"==typeof e||"object"==typeof e&&null!==e&&!Array.isArray(e)},Be=function(e){return"__proto__"!==e&&"constructor"!==e&&"prototype"!==e};function ze(e,t,n){var r=e[n];Ve(t)&&Ve(r)?Me(r,t):e[n]=t}function Me(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];for(var o=0,s=n;o<s.length;o++){var i=s[o];if(Ve(i))for(var a in i)Be(a)&&ze(e,i[a],a)}return e}var Ge=react.createContext(),Le=Ge.Consumer;function Fe(e){var t=(0,react.useContext)(Ge),n=(0,react.useMemo)((function(){return function(e,t){if(!e)return j(14);if(b(e)){var n=e(t);return true?n:0}return Array.isArray(e)||"object"!=typeof e?j(8):t?v({},t,{},e):e}(e.theme,t)}),[e.theme,t]);return e.children?react.createElement(Ge.Provider,{value:n},e.children):null}var Ye={};function qe(e,t,n){var o=N(e),i=!ke(e),a=t.attrs,c=void 0===a?w:a,d=t.componentId,h=void 0===d?function(e,t){var n="string"!=typeof e?"sc":Te(e);Ye[n]=(Ye[n]||0)+1;var r=n+"-"+xe("5.3.6"+n+Ye[n]);return t?t+"-"+r:r}(t.displayName,t.parentComponentId):d,p=t.displayName,f=void 0===p?function(e){return ke(e)?"styled."+e:"Styled("+_(e)+")"}(e):p,g=t.displayName&&t.componentId?Te(t.displayName)+"-"+t.componentId:t.componentId||h,S=o&&e.attrs?Array.prototype.concat(e.attrs,c).filter(Boolean):c,A=t.shouldForwardProp;o&&e.shouldForwardProp&&(A=t.shouldForwardProp?function(n,r,o){return e.shouldForwardProp(n,r,o)&&t.shouldForwardProp(n,r,o)}:e.shouldForwardProp);var C,I=new se(n,g,o?e.componentStyle:void 0),P=I.isStatic&&0===c.length,O=function(e,t){return function(e,t,n,r){var o=e.attrs,i=e.componentStyle,a=e.defaultProps,c=e.foldedComponentIds,d=e.shouldForwardProp,h=e.styledComponentId,p=e.target; false&&0;var f=function(e,t,n){void 0===e&&(e=E);var r=v({},t,{theme:e}),o={};return n.forEach((function(e){var t,n,s,i=e;for(t in b(i)&&(i=i(r)),i)r[t]=o[t]="className"===t?(n=o[t],s=i[t],n&&s?n+" "+s:n||s):i[t]})),[r,o]}(Re(t,(0,react.useContext)(Ge),a)||E,t,o),y=f[0],g=f[1],S=function(e,t,n,r){var o=fe(),s=me(),i=t?e.generateAndInjectStyles(E,o,s):e.generateAndInjectStyles(n,o,s);return false&&0, false&&0,i}(i,r,y, false?0:void 0),w=n,_=g.$as||t.$as||g.as||t.as||p,N=ke(_),A=g!==t?v({},t,{},g):t,C={};for(var I in A)"$"!==I[0]&&"as"!==I&&("forwardedAs"===I?C.as=A[I]:(d?d(I,emotion_is_prop_valid_cjs["default"],_):!N||(0,emotion_is_prop_valid_cjs["default"])(I))&&(C[I]=A[I]));return t.style&&g.style!==t.style&&(C.style=v({},t.style,{},g.style)),C.className=Array.prototype.concat(c,h,S!==h?S:null,t.className,g.className).filter(Boolean).join(" "),C.ref=w,(0,react.createElement)(_,C)}(C,e,t,P)};return O.displayName=f,(C=react.forwardRef(O)).attrs=S,C.componentStyle=I,C.displayName=f,C.shouldForwardProp=A,C.foldedComponentIds=o?Array.prototype.concat(e.foldedComponentIds,e.styledComponentId):w,C.styledComponentId=g,C.target=o?e.target:e,C.withComponent=function(e){var r=t.componentId,o=function(e,t){if(null==e)return{};var n,r,o={},s=Object.keys(e);for(r=0;r<s.length;r++)n=s[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(t,["componentId"]),s=r&&r+"-"+(ke(e)?e:Te(_(e)));return qe(e,v({},o,{attrs:S,componentId:s}),n)},Object.defineProperty(C,"defaultProps",{get:function(){return this._foldedDefaultProps},set:function(t){this._foldedDefaultProps=o?Me({},e.defaultProps,t):t}}), false&&(0),C.toString=function(){return"."+C.styledComponentId},i&&hoist_non_react_statics_cjs_default()(C,e,{attrs:!0,componentStyle:!0,displayName:!0,foldedComponentIds:!0,shouldForwardProp:!0,styledComponentId:!0,target:!0,withComponent:!0}),C}var He=function(e){return function e(t,r,o){if(void 0===o&&(o=E),!(0,react_is.isValidElementType)(r))return j(1,String(r));var s=function(){return t(r,o,Ce.apply(void 0,arguments))};return s.withConfig=function(n){return e(t,r,v({},o,{},n))},s.attrs=function(n){return e(t,r,v({},o,{attrs:Array.prototype.concat(o.attrs,n).filter(Boolean)}))},s}(qe,e)};["a","abbr","address","area","article","aside","audio","b","base","bdi","bdo","big","blockquote","body","br","button","canvas","caption","cite","code","col","colgroup","data","datalist","dd","del","details","dfn","dialog","div","dl","dt","em","embed","fieldset","figcaption","figure","footer","form","h1","h2","h3","h4","h5","h6","head","header","hgroup","hr","html","i","iframe","img","input","ins","kbd","keygen","label","legend","li","link","main","map","mark","marquee","menu","menuitem","meta","meter","nav","noscript","object","ol","optgroup","option","output","p","param","picture","pre","progress","q","rp","rt","ruby","s","samp","script","section","select","small","source","span","strong","style","sub","summary","sup","table","tbody","td","textarea","tfoot","th","thead","time","title","tr","track","u","ul","var","video","wbr","circle","clipPath","defs","ellipse","foreignObject","g","image","line","linearGradient","marker","mask","path","pattern","polygon","polyline","radialGradient","rect","stop","svg","text","textPath","tspan"].forEach((function(e){He[e]=He(e)}));var $e=function(){function e(e,t){this.rules=e,this.componentId=t,this.isStatic=re(e),Z.registerId(this.componentId+1)}var t=e.prototype;return t.createStyles=function(e,t,n,r){var o=r(Ne(this.rules,t,n,r).join(""),""),s=this.componentId+e;n.insertRules(s,s,o)},t.removeStyles=function(e,t){t.clearRules(this.componentId+e)},t.renderStyles=function(e,t,n,r){e>2&&Z.registerId(this.componentId+e),this.removeStyles(e,n),this.createStyles(e,t,n,r)},e}();function We(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),o=1;o<t;o++)n[o-1]=arguments[o];var i=Ce.apply(void 0,[e].concat(n)),a="sc-global-"+xe(JSON.stringify(i)),u=new $e(i,a);function l(e){var t=fe(),n=me(),o=(0,react.useContext)(Ge),l=(0,react.useRef)(t.allocateGSInstance(a)).current;return false&&0, false&&0,t.server&&h(l,e,t,o,n),(0,react.useLayoutEffect)((function(){if(!t.server)return h(l,e,t,o,n),function(){return u.removeStyles(l,t)}}),[l,e,t,o,n]),null}function h(e,t,n,r,o){if(u.isStatic)u.renderStyles(e,O,n,o);else{var s=v({},t,{theme:Re(t,r,l.defaultProps)});u.renderStyles(e,s,n,o)}}return false&&0,react.memo(l)}function Ue(e){ false&&0;for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];var o=Ce.apply(void 0,[e].concat(n)).join(""),s=xe(o);return new ve(s,o)}var Je=function(){function e(){var e=this;this._emitSheetCSS=function(){var t=e.instance.toString();if(!t)return"";var n=q();return"<style "+[n&&'nonce="'+n+'"',A+'="true"','data-styled-version="5.3.6"'].filter(Boolean).join(" ")+">"+t+"</style>"},this.getStyleTags=function(){return e.sealed?j(2):e._emitSheetCSS()},this.getStyleElement=function(){var t;if(e.sealed)return j(2);var n=((t={})[A]="",t["data-styled-version"]="5.3.6",t.dangerouslySetInnerHTML={__html:e.instance.toString()},t),o=q();return o&&(n.nonce=o),[react.createElement("style",v({},n,{key:"sc-0-0"}))]},this.seal=function(){e.sealed=!0},this.instance=new Z({isServer:!0}),this.sealed=!1}var t=e.prototype;return t.collectStyles=function(e){return this.sealed?j(2):react.createElement(ye,{sheet:this.instance},e)},t.interleaveWithNodeStream=function(e){return j(3)},e}(),Xe=function(e){var t=react.forwardRef((function(t,n){var o=(0,react.useContext)(Ge),i=e.defaultProps,a=Re(t,o,i);return false&&0,react.createElement(e,v({},t,{theme:a,ref:n}))}));return hoist_non_react_statics_cjs_default()(t,e),t.displayName="WithTheme("+_(e)+")",t},Ze=function(){return (0,react.useContext)(Ge)},Ke={StyleSheet:Z,masterSheet:he}; false&&0, false&&(0);/* harmony default export */ const styled_components_browser_esm = (He);
//# sourceMappingURL=styled-components.browser.esm.js.map


/***/ }),

/***/ 4912:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "uk": () => (/* binding */ alignSelf),
  "Oq": () => (/* reexport */ background),
  "Cg": () => (/* reexport */ border),
  "E0": () => (/* binding */ borderRadius),
  "Wn": () => (/* reexport */ shadow_dist_index_esm),
  "$_": () => (/* reexport */ color),
  "qC": () => (/* reexport */ compose),
  "jf": () => (/* binding */ display),
  "fU": () => (/* binding */ flex),
  "GQ": () => (/* reexport */ flexbox),
  "I8": () => (/* binding */ fontFamily),
  "JB": () => (/* binding */ fontSize),
  "Ue": () => (/* binding */ fontWeight),
  "Cb": () => (/* binding */ height),
  "Nv": () => (/* binding */ lineHeight),
  "e6": () => (/* reexport */ margin),
  "kC": () => (/* binding */ maxHeight),
  "kk": () => (/* binding */ maxWidth),
  "jw": () => (/* binding */ minHeight),
  "ih": () => (/* binding */ minWidth),
  "vm": () => (/* binding */ order),
  "o3": () => (/* reexport */ padding),
  "FK": () => (/* reexport */ position),
  "dp": () => (/* binding */ size),
  "Dh": () => (/* reexport */ space),
  "By": () => (/* reexport */ system),
  "yd": () => (/* binding */ textAlign),
  "cp": () => (/* reexport */ typography),
  "bU": () => (/* reexport */ variant),
  "bf": () => (/* binding */ width)
});

// UNUSED EXPORTS: alignContent, alignItems, backgroundImage, backgroundPosition, backgroundRepeat, backgroundSize, borderBottom, borderColor, borderLeft, borderRight, borderStyle, borderTop, borderWidth, borders, bottom, buttonStyle, colorStyle, createParser, createStyleFunction, flexBasis, flexDirection, flexGrow, flexShrink, flexWrap, fontStyle, get, grid, gridArea, gridAutoColumns, gridAutoFlow, gridAutoRows, gridColumn, gridColumnGap, gridGap, gridRow, gridRowGap, gridTemplateAreas, gridTemplateColumns, gridTemplateRows, justifyContent, justifyItems, justifySelf, layout, left, letterSpacing, opacity, overflow, overflowX, overflowY, right, shadow, style, textShadow, textStyle, top, verticalAlign, zIndex

// EXTERNAL MODULE: ./node_modules/object-assign/index.js
var object_assign = __webpack_require__(6461);
var object_assign_default = /*#__PURE__*/__webpack_require__.n(object_assign);
;// CONCATENATED MODULE: ./node_modules/@styled-system/core/dist/index.esm.js

var merge = function merge(a, b) {
  var result = object_assign_default()({}, a, b);

  for (var key in a) {
    var _assign;

    if (!a[key] || typeof b[key] !== 'object') continue;
    object_assign_default()(result, (_assign = {}, _assign[key] = object_assign_default()(a[key], b[key]), _assign));
  }

  return result;
}; // sort object-value responsive styles

var sort = function sort(obj) {
  var next = {};
  Object.keys(obj).sort(function (a, b) {
    return a.localeCompare(b, undefined, {
      numeric: true,
      sensitivity: 'base'
    });
  }).forEach(function (key) {
    next[key] = obj[key];
  });
  return next;
};

var defaults = {
  breakpoints: [40, 52, 64].map(function (n) {
    return n + 'em';
  })
};

var createMediaQuery = function createMediaQuery(n) {
  return "@media screen and (min-width: " + n + ")";
};

var getValue = function getValue(n, scale) {
  return get(scale, n, n);
};

var get = function get(obj, key, def, p, undef) {
  key = key && key.split ? key.split('.') : [key];

  for (p = 0; p < key.length; p++) {
    obj = obj ? obj[key[p]] : undef;
  }

  return obj === undef ? def : obj;
};
var index_esm_createParser = function createParser(config) {
  var cache = {};

  var parse = function parse(props) {
    var styles = {};
    var shouldSort = false;
    var isCacheDisabled = props.theme && props.theme.disableStyledSystemCache;

    for (var key in props) {
      if (!config[key]) continue;
      var sx = config[key];
      var raw = props[key];
      var scale = get(props.theme, sx.scale, sx.defaults);

      if (typeof raw === 'object') {
        cache.breakpoints = !isCacheDisabled && cache.breakpoints || get(props.theme, 'breakpoints', defaults.breakpoints);

        if (Array.isArray(raw)) {
          cache.media = !isCacheDisabled && cache.media || [null].concat(cache.breakpoints.map(createMediaQuery));
          styles = merge(styles, parseResponsiveStyle(cache.media, sx, scale, raw, props));
          continue;
        }

        if (raw !== null) {
          styles = merge(styles, parseResponsiveObject(cache.breakpoints, sx, scale, raw, props));
          shouldSort = true;
        }

        continue;
      }

      object_assign_default()(styles, sx(raw, scale, props));
    } // sort object-based responsive styles


    if (shouldSort) {
      styles = sort(styles);
    }

    return styles;
  };

  parse.config = config;
  parse.propNames = Object.keys(config);
  parse.cache = cache;
  var keys = Object.keys(config).filter(function (k) {
    return k !== 'config';
  });

  if (keys.length > 1) {
    keys.forEach(function (key) {
      var _createParser;

      parse[key] = createParser((_createParser = {}, _createParser[key] = config[key], _createParser));
    });
  }

  return parse;
};

var parseResponsiveStyle = function parseResponsiveStyle(mediaQueries, sx, scale, raw, _props) {
  var styles = {};
  raw.slice(0, mediaQueries.length).forEach(function (value, i) {
    var media = mediaQueries[i];
    var style = sx(value, scale, _props);

    if (!media) {
      object_assign_default()(styles, style);
    } else {
      var _assign2;

      object_assign_default()(styles, (_assign2 = {}, _assign2[media] = object_assign_default()({}, styles[media], style), _assign2));
    }
  });
  return styles;
};

var parseResponsiveObject = function parseResponsiveObject(breakpoints, sx, scale, raw, _props) {
  var styles = {};

  for (var key in raw) {
    var breakpoint = breakpoints[key];
    var value = raw[key];
    var style = sx(value, scale, _props);

    if (!breakpoint) {
      object_assign_default()(styles, style);
    } else {
      var _assign3;

      var media = createMediaQuery(breakpoint);
      object_assign_default()(styles, (_assign3 = {}, _assign3[media] = object_assign_default()({}, styles[media], style), _assign3));
    }
  }

  return styles;
};

var index_esm_createStyleFunction = function createStyleFunction(_ref) {
  var properties = _ref.properties,
      property = _ref.property,
      scale = _ref.scale,
      _ref$transform = _ref.transform,
      transform = _ref$transform === void 0 ? getValue : _ref$transform,
      defaultScale = _ref.defaultScale;
  properties = properties || [property];

  var sx = function sx(value, scale, _props) {
    var result = {};
    var n = transform(value, scale, _props);
    if (n === null) return;
    properties.forEach(function (prop) {
      result[prop] = n;
    });
    return result;
  };

  sx.scale = scale;
  sx.defaults = defaultScale;
  return sx;
}; // new v5 API

var system = function system(args) {
  if (args === void 0) {
    args = {};
  }

  var config = {};
  Object.keys(args).forEach(function (key) {
    var conf = args[key];

    if (conf === true) {
      // shortcut definition
      config[key] = index_esm_createStyleFunction({
        property: key,
        scale: key
      });
      return;
    }

    if (typeof conf === 'function') {
      config[key] = conf;
      return;
    }

    config[key] = index_esm_createStyleFunction(conf);
  });
  var parser = index_esm_createParser(config);
  return parser;
};
var compose = function compose() {
  var config = {};

  for (var _len = arguments.length, parsers = new Array(_len), _key = 0; _key < _len; _key++) {
    parsers[_key] = arguments[_key];
  }

  parsers.forEach(function (parser) {
    if (!parser || !parser.config) return;
    object_assign_default()(config, parser.config);
  });
  var parser = index_esm_createParser(config);
  return parser;
};

;// CONCATENATED MODULE: ./node_modules/@styled-system/layout/dist/index.esm.js


var isNumber = function isNumber(n) {
  return typeof n === 'number' && !isNaN(n);
};

var getWidth = function getWidth(n, scale) {
  return get(scale, n, !isNumber(n) || n > 1 ? n : n * 100 + '%');
};

var config = {
  width: {
    property: 'width',
    scale: 'sizes',
    transform: getWidth
  },
  height: {
    property: 'height',
    scale: 'sizes'
  },
  minWidth: {
    property: 'minWidth',
    scale: 'sizes'
  },
  minHeight: {
    property: 'minHeight',
    scale: 'sizes'
  },
  maxWidth: {
    property: 'maxWidth',
    scale: 'sizes'
  },
  maxHeight: {
    property: 'maxHeight',
    scale: 'sizes'
  },
  size: {
    properties: ['width', 'height'],
    scale: 'sizes'
  },
  overflow: true,
  overflowX: true,
  overflowY: true,
  display: true,
  verticalAlign: true
};
var layout = system(config);
/* harmony default export */ const index_esm = (layout);

;// CONCATENATED MODULE: ./node_modules/@styled-system/color/dist/index.esm.js

var index_esm_config = {
  color: {
    property: 'color',
    scale: 'colors'
  },
  backgroundColor: {
    property: 'backgroundColor',
    scale: 'colors'
  },
  opacity: true
};
index_esm_config.bg = index_esm_config.backgroundColor;
var color = system(index_esm_config);
/* harmony default export */ const dist_index_esm = (color);

;// CONCATENATED MODULE: ./node_modules/@styled-system/typography/dist/index.esm.js

var index_esm_defaults = {
  fontSizes: [12, 14, 16, 20, 24, 32, 48, 64, 72]
};
var dist_index_esm_config = {
  fontFamily: {
    property: 'fontFamily',
    scale: 'fonts'
  },
  fontSize: {
    property: 'fontSize',
    scale: 'fontSizes',
    defaultScale: index_esm_defaults.fontSizes
  },
  fontWeight: {
    property: 'fontWeight',
    scale: 'fontWeights'
  },
  lineHeight: {
    property: 'lineHeight',
    scale: 'lineHeights'
  },
  letterSpacing: {
    property: 'letterSpacing',
    scale: 'letterSpacings'
  },
  textAlign: true,
  fontStyle: true
};
var typography = system(dist_index_esm_config);
/* harmony default export */ const typography_dist_index_esm = (typography);

;// CONCATENATED MODULE: ./node_modules/@styled-system/flexbox/dist/index.esm.js

var flexbox_dist_index_esm_config = {
  alignItems: true,
  alignContent: true,
  justifyItems: true,
  justifyContent: true,
  flexWrap: true,
  flexDirection: true,
  // item
  flex: true,
  flexGrow: true,
  flexShrink: true,
  flexBasis: true,
  justifySelf: true,
  alignSelf: true,
  order: true
};
var flexbox = system(flexbox_dist_index_esm_config);
/* harmony default export */ const flexbox_dist_index_esm = (flexbox);

;// CONCATENATED MODULE: ./node_modules/@styled-system/grid/dist/index.esm.js

var dist_index_esm_defaults = {
  space: [0, 4, 8, 16, 32, 64, 128, 256, 512]
};
var grid_dist_index_esm_config = {
  gridGap: {
    property: 'gridGap',
    scale: 'space',
    defaultScale: dist_index_esm_defaults.space
  },
  gridColumnGap: {
    property: 'gridColumnGap',
    scale: 'space',
    defaultScale: dist_index_esm_defaults.space
  },
  gridRowGap: {
    property: 'gridRowGap',
    scale: 'space',
    defaultScale: dist_index_esm_defaults.space
  },
  gridColumn: true,
  gridRow: true,
  gridAutoFlow: true,
  gridAutoColumns: true,
  gridAutoRows: true,
  gridTemplateColumns: true,
  gridTemplateRows: true,
  gridTemplateAreas: true,
  gridArea: true
};
var grid = system(grid_dist_index_esm_config);
/* harmony default export */ const grid_dist_index_esm = (grid);

;// CONCATENATED MODULE: ./node_modules/@styled-system/border/dist/index.esm.js

var border_dist_index_esm_config = {
  border: {
    property: 'border',
    scale: 'borders'
  },
  borderWidth: {
    property: 'borderWidth',
    scale: 'borderWidths'
  },
  borderStyle: {
    property: 'borderStyle',
    scale: 'borderStyles'
  },
  borderColor: {
    property: 'borderColor',
    scale: 'colors'
  },
  borderRadius: {
    property: 'borderRadius',
    scale: 'radii'
  },
  borderTop: {
    property: 'borderTop',
    scale: 'borders'
  },
  borderTopLeftRadius: {
    property: 'borderTopLeftRadius',
    scale: 'radii'
  },
  borderTopRightRadius: {
    property: 'borderTopRightRadius',
    scale: 'radii'
  },
  borderRight: {
    property: 'borderRight',
    scale: 'borders'
  },
  borderBottom: {
    property: 'borderBottom',
    scale: 'borders'
  },
  borderBottomLeftRadius: {
    property: 'borderBottomLeftRadius',
    scale: 'radii'
  },
  borderBottomRightRadius: {
    property: 'borderBottomRightRadius',
    scale: 'radii'
  },
  borderLeft: {
    property: 'borderLeft',
    scale: 'borders'
  },
  borderX: {
    properties: ['borderLeft', 'borderRight'],
    scale: 'borders'
  },
  borderY: {
    properties: ['borderTop', 'borderBottom'],
    scale: 'borders'
  }
};
border_dist_index_esm_config.borderTopWidth = {
  property: 'borderTopWidth',
  scale: 'borderWidths'
};
border_dist_index_esm_config.borderTopColor = {
  property: 'borderTopColor',
  scale: 'colors'
};
border_dist_index_esm_config.borderTopStyle = {
  property: 'borderTopStyle',
  scale: 'borderStyles'
};
border_dist_index_esm_config.borderTopLeftRadius = {
  property: 'borderTopLeftRadius',
  scale: 'radii'
};
border_dist_index_esm_config.borderTopRightRadius = {
  property: 'borderTopRightRadius',
  scale: 'radii'
};
border_dist_index_esm_config.borderBottomWidth = {
  property: 'borderBottomWidth',
  scale: 'borderWidths'
};
border_dist_index_esm_config.borderBottomColor = {
  property: 'borderBottomColor',
  scale: 'colors'
};
border_dist_index_esm_config.borderBottomStyle = {
  property: 'borderBottomStyle',
  scale: 'borderStyles'
};
border_dist_index_esm_config.borderBottomLeftRadius = {
  property: 'borderBottomLeftRadius',
  scale: 'radii'
};
border_dist_index_esm_config.borderBottomRightRadius = {
  property: 'borderBottomRightRadius',
  scale: 'radii'
};
border_dist_index_esm_config.borderLeftWidth = {
  property: 'borderLeftWidth',
  scale: 'borderWidths'
};
border_dist_index_esm_config.borderLeftColor = {
  property: 'borderLeftColor',
  scale: 'colors'
};
border_dist_index_esm_config.borderLeftStyle = {
  property: 'borderLeftStyle',
  scale: 'borderStyles'
};
border_dist_index_esm_config.borderRightWidth = {
  property: 'borderRightWidth',
  scale: 'borderWidths'
};
border_dist_index_esm_config.borderRightColor = {
  property: 'borderRightColor',
  scale: 'colors'
};
border_dist_index_esm_config.borderRightStyle = {
  property: 'borderRightStyle',
  scale: 'borderStyles'
};
var border = system(border_dist_index_esm_config);
/* harmony default export */ const border_dist_index_esm = (border);

;// CONCATENATED MODULE: ./node_modules/@styled-system/background/dist/index.esm.js

var background_dist_index_esm_config = {
  background: true,
  backgroundImage: true,
  backgroundSize: true,
  backgroundPosition: true,
  backgroundRepeat: true
};
background_dist_index_esm_config.bgImage = background_dist_index_esm_config.backgroundImage;
background_dist_index_esm_config.bgSize = background_dist_index_esm_config.backgroundSize;
background_dist_index_esm_config.bgPosition = background_dist_index_esm_config.backgroundPosition;
background_dist_index_esm_config.bgRepeat = background_dist_index_esm_config.backgroundRepeat;
var background = system(background_dist_index_esm_config);
/* harmony default export */ const background_dist_index_esm = (background);

;// CONCATENATED MODULE: ./node_modules/@styled-system/position/dist/index.esm.js

var position_dist_index_esm_defaults = {
  space: [0, 4, 8, 16, 32, 64, 128, 256, 512]
};
var position_dist_index_esm_config = {
  position: true,
  zIndex: {
    property: 'zIndex',
    scale: 'zIndices'
  },
  top: {
    property: 'top',
    scale: 'space',
    defaultScale: position_dist_index_esm_defaults.space
  },
  right: {
    property: 'right',
    scale: 'space',
    defaultScale: position_dist_index_esm_defaults.space
  },
  bottom: {
    property: 'bottom',
    scale: 'space',
    defaultScale: position_dist_index_esm_defaults.space
  },
  left: {
    property: 'left',
    scale: 'space',
    defaultScale: position_dist_index_esm_defaults.space
  }
};
var position = system(position_dist_index_esm_config);
/* harmony default export */ const position_dist_index_esm = (position);

;// CONCATENATED MODULE: ./node_modules/@styled-system/space/dist/index.esm.js

var space_dist_index_esm_defaults = {
  space: [0, 4, 8, 16, 32, 64, 128, 256, 512]
};

var index_esm_isNumber = function isNumber(n) {
  return typeof n === 'number' && !isNaN(n);
};

var getMargin = function getMargin(n, scale) {
  if (!index_esm_isNumber(n)) {
    return get(scale, n, n);
  }

  var isNegative = n < 0;
  var absolute = Math.abs(n);
  var value = get(scale, absolute, absolute);

  if (!index_esm_isNumber(value)) {
    return isNegative ? '-' + value : value;
  }

  return value * (isNegative ? -1 : 1);
};

var configs = {};
configs.margin = {
  margin: {
    property: 'margin',
    scale: 'space',
    transform: getMargin,
    defaultScale: space_dist_index_esm_defaults.space
  },
  marginTop: {
    property: 'marginTop',
    scale: 'space',
    transform: getMargin,
    defaultScale: space_dist_index_esm_defaults.space
  },
  marginRight: {
    property: 'marginRight',
    scale: 'space',
    transform: getMargin,
    defaultScale: space_dist_index_esm_defaults.space
  },
  marginBottom: {
    property: 'marginBottom',
    scale: 'space',
    transform: getMargin,
    defaultScale: space_dist_index_esm_defaults.space
  },
  marginLeft: {
    property: 'marginLeft',
    scale: 'space',
    transform: getMargin,
    defaultScale: space_dist_index_esm_defaults.space
  },
  marginX: {
    properties: ['marginLeft', 'marginRight'],
    scale: 'space',
    transform: getMargin,
    defaultScale: space_dist_index_esm_defaults.space
  },
  marginY: {
    properties: ['marginTop', 'marginBottom'],
    scale: 'space',
    transform: getMargin,
    defaultScale: space_dist_index_esm_defaults.space
  }
};
configs.margin.m = configs.margin.margin;
configs.margin.mt = configs.margin.marginTop;
configs.margin.mr = configs.margin.marginRight;
configs.margin.mb = configs.margin.marginBottom;
configs.margin.ml = configs.margin.marginLeft;
configs.margin.mx = configs.margin.marginX;
configs.margin.my = configs.margin.marginY;
configs.padding = {
  padding: {
    property: 'padding',
    scale: 'space',
    defaultScale: space_dist_index_esm_defaults.space
  },
  paddingTop: {
    property: 'paddingTop',
    scale: 'space',
    defaultScale: space_dist_index_esm_defaults.space
  },
  paddingRight: {
    property: 'paddingRight',
    scale: 'space',
    defaultScale: space_dist_index_esm_defaults.space
  },
  paddingBottom: {
    property: 'paddingBottom',
    scale: 'space',
    defaultScale: space_dist_index_esm_defaults.space
  },
  paddingLeft: {
    property: 'paddingLeft',
    scale: 'space',
    defaultScale: space_dist_index_esm_defaults.space
  },
  paddingX: {
    properties: ['paddingLeft', 'paddingRight'],
    scale: 'space',
    defaultScale: space_dist_index_esm_defaults.space
  },
  paddingY: {
    properties: ['paddingTop', 'paddingBottom'],
    scale: 'space',
    defaultScale: space_dist_index_esm_defaults.space
  }
};
configs.padding.p = configs.padding.padding;
configs.padding.pt = configs.padding.paddingTop;
configs.padding.pr = configs.padding.paddingRight;
configs.padding.pb = configs.padding.paddingBottom;
configs.padding.pl = configs.padding.paddingLeft;
configs.padding.px = configs.padding.paddingX;
configs.padding.py = configs.padding.paddingY;
var margin = system(configs.margin);
var padding = system(configs.padding);
var space = compose(margin, padding);
/* harmony default export */ const space_dist_index_esm = ((/* unused pure expression or super */ null && (space)));

;// CONCATENATED MODULE: ./node_modules/@styled-system/shadow/dist/index.esm.js

var shadow = system({
  boxShadow: {
    property: 'boxShadow',
    scale: 'shadows'
  },
  textShadow: {
    property: 'textShadow',
    scale: 'shadows'
  }
});
/* harmony default export */ const shadow_dist_index_esm = (shadow);

;// CONCATENATED MODULE: ./node_modules/@styled-system/css/dist/index.esm.js
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

// based on https://github.com/developit/dlv
var index_esm_get = function get(obj, key, def, p, undef) {
  key = key && key.split ? key.split('.') : [key];

  for (p = 0; p < key.length; p++) {
    obj = obj ? obj[key[p]] : undef;
  }

  return obj === undef ? def : obj;
};
var defaultBreakpoints = [40, 52, 64].map(function (n) {
  return n + 'em';
});
var defaultTheme = {
  space: [0, 4, 8, 16, 32, 64, 128, 256, 512],
  fontSizes: [12, 14, 16, 20, 24, 32, 48, 64, 72]
};
var aliases = {
  bg: 'backgroundColor',
  m: 'margin',
  mt: 'marginTop',
  mr: 'marginRight',
  mb: 'marginBottom',
  ml: 'marginLeft',
  mx: 'marginX',
  my: 'marginY',
  p: 'padding',
  pt: 'paddingTop',
  pr: 'paddingRight',
  pb: 'paddingBottom',
  pl: 'paddingLeft',
  px: 'paddingX',
  py: 'paddingY'
};
var multiples = {
  marginX: ['marginLeft', 'marginRight'],
  marginY: ['marginTop', 'marginBottom'],
  paddingX: ['paddingLeft', 'paddingRight'],
  paddingY: ['paddingTop', 'paddingBottom'],
  size: ['width', 'height']
};
var scales = {
  color: 'colors',
  backgroundColor: 'colors',
  borderColor: 'colors',
  margin: 'space',
  marginTop: 'space',
  marginRight: 'space',
  marginBottom: 'space',
  marginLeft: 'space',
  marginX: 'space',
  marginY: 'space',
  padding: 'space',
  paddingTop: 'space',
  paddingRight: 'space',
  paddingBottom: 'space',
  paddingLeft: 'space',
  paddingX: 'space',
  paddingY: 'space',
  top: 'space',
  right: 'space',
  bottom: 'space',
  left: 'space',
  gridGap: 'space',
  gridColumnGap: 'space',
  gridRowGap: 'space',
  gap: 'space',
  columnGap: 'space',
  rowGap: 'space',
  fontFamily: 'fonts',
  fontSize: 'fontSizes',
  fontWeight: 'fontWeights',
  lineHeight: 'lineHeights',
  letterSpacing: 'letterSpacings',
  border: 'borders',
  borderTop: 'borders',
  borderRight: 'borders',
  borderBottom: 'borders',
  borderLeft: 'borders',
  borderWidth: 'borderWidths',
  borderStyle: 'borderStyles',
  borderRadius: 'radii',
  borderTopRightRadius: 'radii',
  borderTopLeftRadius: 'radii',
  borderBottomRightRadius: 'radii',
  borderBottomLeftRadius: 'radii',
  borderTopWidth: 'borderWidths',
  borderTopColor: 'colors',
  borderTopStyle: 'borderStyles',
  borderBottomWidth: 'borderWidths',
  borderBottomColor: 'colors',
  borderBottomStyle: 'borderStyles',
  borderLeftWidth: 'borderWidths',
  borderLeftColor: 'colors',
  borderLeftStyle: 'borderStyles',
  borderRightWidth: 'borderWidths',
  borderRightColor: 'colors',
  borderRightStyle: 'borderStyles',
  outlineColor: 'colors',
  boxShadow: 'shadows',
  textShadow: 'shadows',
  zIndex: 'zIndices',
  width: 'sizes',
  minWidth: 'sizes',
  maxWidth: 'sizes',
  height: 'sizes',
  minHeight: 'sizes',
  maxHeight: 'sizes',
  flexBasis: 'sizes',
  size: 'sizes',
  // svg
  fill: 'colors',
  stroke: 'colors'
};

var positiveOrNegative = function positiveOrNegative(scale, value) {
  if (typeof value !== 'number' || value >= 0) {
    return index_esm_get(scale, value, value);
  }

  var absolute = Math.abs(value);
  var n = index_esm_get(scale, absolute, absolute);
  if (typeof n === 'string') return '-' + n;
  return n * -1;
};

var transforms = ['margin', 'marginTop', 'marginRight', 'marginBottom', 'marginLeft', 'marginX', 'marginY', 'top', 'bottom', 'left', 'right'].reduce(function (acc, curr) {
  var _extends2;

  return _extends({}, acc, (_extends2 = {}, _extends2[curr] = positiveOrNegative, _extends2));
}, {});
var responsive = function responsive(styles) {
  return function (theme) {
    var next = {};
    var breakpoints = index_esm_get(theme, 'breakpoints', defaultBreakpoints);
    var mediaQueries = [null].concat(breakpoints.map(function (n) {
      return "@media screen and (min-width: " + n + ")";
    }));

    for (var key in styles) {
      var value = typeof styles[key] === 'function' ? styles[key](theme) : styles[key];
      if (value == null) continue;

      if (!Array.isArray(value)) {
        next[key] = value;
        continue;
      }

      for (var i = 0; i < value.slice(0, mediaQueries.length).length; i++) {
        var media = mediaQueries[i];

        if (!media) {
          next[key] = value[i];
          continue;
        }

        next[media] = next[media] || {};
        if (value[i] == null) continue;
        next[media][key] = value[i];
      }
    }

    return next;
  };
};
var css = function css(args) {
  return function (props) {
    if (props === void 0) {
      props = {};
    }

    var theme = _extends({}, defaultTheme, {}, props.theme || props);

    var result = {};
    var obj = typeof args === 'function' ? args(theme) : args;
    var styles = responsive(obj)(theme);

    for (var key in styles) {
      var x = styles[key];
      var val = typeof x === 'function' ? x(theme) : x;

      if (key === 'variant') {
        var variant = css(index_esm_get(theme, val))(theme);
        result = _extends({}, result, {}, variant);
        continue;
      }

      if (val && typeof val === 'object') {
        result[key] = css(val)(theme);
        continue;
      }

      var prop = index_esm_get(aliases, key, key);
      var scaleName = index_esm_get(scales, prop);
      var scale = index_esm_get(theme, scaleName, index_esm_get(theme, prop, {}));
      var transform = index_esm_get(transforms, prop, index_esm_get);
      var value = transform(scale, val, val);

      if (multiples[prop]) {
        var dirs = multiples[prop];

        for (var i = 0; i < dirs.length; i++) {
          result[dirs[i]] = value;
        }
      } else {
        result[prop] = value;
      }
    }

    return result;
  };
};
/* harmony default export */ const css_dist_index_esm = (css);

;// CONCATENATED MODULE: ./node_modules/@styled-system/variant/dist/index.esm.js


var variant = function variant(_ref) {
  var _config;

  var scale = _ref.scale,
      _ref$prop = _ref.prop,
      prop = _ref$prop === void 0 ? 'variant' : _ref$prop,
      _ref$variants = _ref.variants,
      variants = _ref$variants === void 0 ? {} : _ref$variants,
      key = _ref.key;
  var sx;

  if (Object.keys(variants).length) {
    sx = function sx(value, scale, props) {
      return css_dist_index_esm(get(scale, value, null))(props.theme);
    };
  } else {
    sx = function sx(value, scale) {
      return get(scale, value, null);
    };
  }

  sx.scale = scale || key;
  sx.defaults = variants;
  var config = (_config = {}, _config[prop] = sx, _config);
  var parser = index_esm_createParser(config);
  return parser;
};
/* harmony default export */ const variant_dist_index_esm = ((/* unused pure expression or super */ null && (variant)));
var buttonStyle = variant({
  key: 'buttons'
});
var textStyle = variant({
  key: 'textStyles',
  prop: 'textStyle'
});
var colorStyle = variant({
  key: 'colorStyles',
  prop: 'colors'
});

;// CONCATENATED MODULE: ./node_modules/styled-system/dist/index.esm.js
 // v4 api shims






















var width = index_esm.width,
    height = index_esm.height,
    minWidth = index_esm.minWidth,
    minHeight = index_esm.minHeight,
    maxWidth = index_esm.maxWidth,
    maxHeight = index_esm.maxHeight,
    size = index_esm.size,
    verticalAlign = index_esm.verticalAlign,
    display = index_esm.display,
    overflow = index_esm.overflow,
    overflowX = index_esm.overflowX,
    overflowY = index_esm.overflowY;
var opacity = dist_index_esm.opacity;
var fontSize = typography_dist_index_esm.fontSize,
    fontFamily = typography_dist_index_esm.fontFamily,
    fontWeight = typography_dist_index_esm.fontWeight,
    lineHeight = typography_dist_index_esm.lineHeight,
    textAlign = typography_dist_index_esm.textAlign,
    fontStyle = typography_dist_index_esm.fontStyle,
    letterSpacing = typography_dist_index_esm.letterSpacing;
var alignItems = flexbox_dist_index_esm.alignItems,
    alignContent = flexbox_dist_index_esm.alignContent,
    justifyItems = flexbox_dist_index_esm.justifyItems,
    justifyContent = flexbox_dist_index_esm.justifyContent,
    flexWrap = flexbox_dist_index_esm.flexWrap,
    flexDirection = flexbox_dist_index_esm.flexDirection,
    flex = flexbox_dist_index_esm.flex,
    flexGrow = flexbox_dist_index_esm.flexGrow,
    flexShrink = flexbox_dist_index_esm.flexShrink,
    flexBasis = flexbox_dist_index_esm.flexBasis,
    justifySelf = flexbox_dist_index_esm.justifySelf,
    alignSelf = flexbox_dist_index_esm.alignSelf,
    order = flexbox_dist_index_esm.order;
var gridGap = grid_dist_index_esm.gridGap,
    gridColumnGap = grid_dist_index_esm.gridColumnGap,
    gridRowGap = grid_dist_index_esm.gridRowGap,
    gridColumn = grid_dist_index_esm.gridColumn,
    gridRow = grid_dist_index_esm.gridRow,
    gridAutoFlow = grid_dist_index_esm.gridAutoFlow,
    gridAutoColumns = grid_dist_index_esm.gridAutoColumns,
    gridAutoRows = grid_dist_index_esm.gridAutoRows,
    gridTemplateColumns = grid_dist_index_esm.gridTemplateColumns,
    gridTemplateRows = grid_dist_index_esm.gridTemplateRows,
    gridTemplateAreas = grid_dist_index_esm.gridTemplateAreas,
    gridArea = grid_dist_index_esm.gridArea;
var borderWidth = border_dist_index_esm.borderWidth,
    borderStyle = border_dist_index_esm.borderStyle,
    borderColor = border_dist_index_esm.borderColor,
    borderTop = border_dist_index_esm.borderTop,
    borderRight = border_dist_index_esm.borderRight,
    borderBottom = border_dist_index_esm.borderBottom,
    borderLeft = border_dist_index_esm.borderLeft,
    borderRadius = border_dist_index_esm.borderRadius;
var backgroundImage = background_dist_index_esm.backgroundImage,
    backgroundSize = background_dist_index_esm.backgroundSize,
    backgroundPosition = background_dist_index_esm.backgroundPosition,
    backgroundRepeat = background_dist_index_esm.backgroundRepeat;
var zIndex = position_dist_index_esm.zIndex,
    index_esm_top = position_dist_index_esm.top,
    right = position_dist_index_esm.right,
    bottom = position_dist_index_esm.bottom,
    left = position_dist_index_esm.left;

 // v4 style API shim

var style = function style(_ref) {
  var prop = _ref.prop,
      cssProperty = _ref.cssProperty,
      alias = _ref.alias,
      key = _ref.key,
      transformValue = _ref.transformValue,
      scale = _ref.scale,
      properties = _ref.properties;
  var config = {};
  config[prop] = createStyleFunction({
    properties: properties,
    property: cssProperty || prop,
    scale: key,
    defaultScale: scale,
    transform: transformValue
  });
  if (alias) config[alias] = config[prop];
  var parse = createParser(config);
  return parse;
};


/***/ }),

/***/ 4088:
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8397);
/* harmony import */ var _css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8268);
/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".rdp {\n  --rdp-cell-size: 40px;\n  --rdp-accent-color: #0000ff;\n  --rdp-background-color: #e7edff;\n  --rdp-accent-color-dark: #3003e1;\n  --rdp-background-color-dark: #180270;\n  --rdp-outline: 2px solid var(--rdp-accent-color); /* Outline border for focused elements */\n  --rdp-outline-selected: 3px solid var(--rdp-accent-color); /* Outline border for focused _and_ selected elements */\n\n  margin: 1em;\n}\n\n/* Hide elements for devices that are not screen readers */\n.rdp-vhidden {\n  box-sizing: border-box;\n  padding: 0;\n  margin: 0;\n  background: transparent;\n  border: 0;\n  -moz-appearance: none;\n  -webkit-appearance: none;\n  appearance: none;\n  position: absolute !important;\n  top: 0;\n  width: 1px !important;\n  height: 1px !important;\n  padding: 0 !important;\n  overflow: hidden !important;\n  clip: rect(1px, 1px, 1px, 1px) !important;\n  border: 0 !important;\n}\n\n/* Buttons */\n.rdp-button_reset {\n  appearance: none;\n  position: relative;\n  margin: 0;\n  padding: 0;\n  cursor: default;\n  color: inherit;\n  background: none;\n  font: inherit;\n\n  -moz-appearance: none;\n  -webkit-appearance: none;\n}\n\n.rdp-button_reset:focus-visible {\n  /* Make sure to reset outline only when :focus-visible is supported */\n  outline: none;\n}\n\n.rdp-button {\n  border: 2px solid transparent;\n}\n\n.rdp-button[disabled]:not(.rdp-day_selected) {\n  opacity: 0.25;\n}\n\n.rdp-button:not([disabled]) {\n  cursor: pointer;\n}\n\n.rdp-button:focus-visible:not([disabled]) {\n  color: inherit;\n  background-color: var(--rdp-background-color);\n  border: var(--rdp-outline);\n}\n\n.rdp-button:hover:not([disabled]):not(.rdp-day_selected) {\n  background-color: var(--rdp-background-color);\n}\n\n.rdp-months {\n  display: flex;\n}\n\n.rdp-month {\n  margin: 0 1em;\n}\n\n.rdp-month:first-child {\n  margin-left: 0;\n}\n\n.rdp-month:last-child {\n  margin-right: 0;\n}\n\n.rdp-table {\n  margin: 0;\n  max-width: calc(var(--rdp-cell-size) * 7);\n  border-collapse: collapse;\n}\n\n.rdp-with_weeknumber .rdp-table {\n  max-width: calc(var(--rdp-cell-size) * 8);\n  border-collapse: collapse;\n}\n\n.rdp-caption {\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n  padding: 0;\n  text-align: left;\n}\n\n.rdp-multiple_months .rdp-caption {\n  position: relative;\n  display: block;\n  text-align: center;\n}\n\n.rdp-caption_dropdowns {\n  position: relative;\n  display: inline-flex;\n}\n\n.rdp-caption_label {\n  position: relative;\n  z-index: 1;\n  display: inline-flex;\n  align-items: center;\n  margin: 0;\n  padding: 0 0.25em;\n  white-space: nowrap;\n  color: currentColor;\n  border: 0;\n  border: 2px solid transparent;\n  font-family: inherit;\n  font-size: 140%;\n  font-weight: bold;\n}\n\n.rdp-nav {\n  white-space: nowrap;\n}\n\n.rdp-multiple_months .rdp-caption_start .rdp-nav {\n  position: absolute;\n  top: 50%;\n  left: 0;\n  transform: translateY(-50%);\n}\n\n.rdp-multiple_months .rdp-caption_end .rdp-nav {\n  position: absolute;\n  top: 50%;\n  right: 0;\n  transform: translateY(-50%);\n}\n\n.rdp-nav_button {\n  display: inline-flex;\n  align-items: center;\n  justify-content: center;\n  width: var(--rdp-cell-size);\n  height: var(--rdp-cell-size);\n  padding: 0.25em;\n  border-radius: 100%;\n}\n\n/* ---------- */\n/* Dropdowns  */\n/* ---------- */\n\n.rdp-dropdown_year,\n.rdp-dropdown_month {\n  position: relative;\n  display: inline-flex;\n  align-items: center;\n}\n\n.rdp-dropdown {\n  appearance: none;\n  position: absolute;\n  z-index: 2;\n  top: 0;\n  bottom: 0;\n  left: 0;\n  width: 100%;\n  margin: 0;\n  padding: 0;\n  cursor: inherit;\n  opacity: 0;\n  border: none;\n  background-color: transparent;\n  font-family: inherit;\n  font-size: inherit;\n  line-height: inherit;\n}\n\n.rdp-dropdown[disabled] {\n  opacity: unset;\n  color: unset;\n}\n\n.rdp-dropdown:focus-visible:not([disabled]) + .rdp-caption_label {\n  background-color: var(--rdp-background-color);\n  border: var(--rdp-outline);\n  border-radius: 6px;\n}\n\n.rdp-dropdown_icon {\n  margin: 0 0 0 5px;\n}\n\n.rdp-head {\n  border: 0;\n}\n\n.rdp-head_row,\n.rdp-row {\n  height: 100%;\n}\n\n.rdp-head_cell {\n  vertical-align: middle;\n  text-transform: uppercase;\n  font-size: 0.75em;\n  font-weight: 700;\n  text-align: center;\n  height: 100%;\n  height: var(--rdp-cell-size);\n  padding: 0;\n}\n\n.rdp-tbody {\n  border: 0;\n}\n\n.rdp-tfoot {\n  margin: 0.5em;\n}\n\n.rdp-cell {\n  width: var(--rdp-cell-size);\n  height: 100%;\n  height: var(--rdp-cell-size);\n  padding: 0;\n  text-align: center;\n}\n\n.rdp-weeknumber {\n  font-size: 0.75em;\n}\n\n.rdp-weeknumber,\n.rdp-day {\n  display: flex;\n  overflow: hidden;\n  align-items: center;\n  justify-content: center;\n  box-sizing: border-box;\n  width: var(--rdp-cell-size);\n  max-width: var(--rdp-cell-size);\n  height: var(--rdp-cell-size);\n  margin: 0;\n  border: 2px solid transparent;\n  border-radius: 100%;\n}\n\n.rdp-day_today:not(.rdp-day_outside) {\n  font-weight: bold;\n}\n\n.rdp-day_selected,\n.rdp-day_selected:focus-visible,\n.rdp-day_selected:hover {\n  color: white;\n  opacity: 1;\n  background-color: var(--rdp-accent-color);\n}\n\n.rdp-day_outside {\n  opacity: 0.5;\n}\n\n.rdp-day_selected:focus-visible {\n  /* Since the background is the same use again the outline */\n  outline: var(--rdp-outline);\n  outline-offset: 2px;\n  z-index: 1;\n}\n\n.rdp:not([dir='rtl']) .rdp-day_range_start:not(.rdp-day_range_end) {\n  border-top-right-radius: 0;\n  border-bottom-right-radius: 0;\n}\n\n.rdp:not([dir='rtl']) .rdp-day_range_end:not(.rdp-day_range_start) {\n  border-top-left-radius: 0;\n  border-bottom-left-radius: 0;\n}\n\n.rdp[dir='rtl'] .rdp-day_range_start:not(.rdp-day_range_end) {\n  border-top-left-radius: 0;\n  border-bottom-left-radius: 0;\n}\n\n.rdp[dir='rtl'] .rdp-day_range_end:not(.rdp-day_range_start) {\n  border-top-right-radius: 0;\n  border-bottom-right-radius: 0;\n}\n\n.rdp-day_range_end.rdp-day_range_start {\n  border-radius: 100%;\n}\n\n.rdp-day_range_middle {\n  border-radius: 0;\n}\n", "",{"version":3,"sources":["webpack://./node_modules/react-day-picker/dist/style.css"],"names":[],"mappings":"AAAA;EACE,qBAAqB;EACrB,2BAA2B;EAC3B,+BAA+B;EAC/B,gCAAgC;EAChC,oCAAoC;EACpC,gDAAgD,EAAE,wCAAwC;EAC1F,yDAAyD,EAAE,uDAAuD;;EAElH,WAAW;AACb;;AAEA,0DAA0D;AAC1D;EACE,sBAAsB;EACtB,UAAU;EACV,SAAS;EACT,uBAAuB;EACvB,SAAS;EACT,qBAAqB;EACrB,wBAAwB;EACxB,gBAAgB;EAChB,6BAA6B;EAC7B,MAAM;EACN,qBAAqB;EACrB,sBAAsB;EACtB,qBAAqB;EACrB,2BAA2B;EAC3B,yCAAyC;EACzC,oBAAoB;AACtB;;AAEA,YAAY;AACZ;EACE,gBAAgB;EAChB,kBAAkB;EAClB,SAAS;EACT,UAAU;EACV,eAAe;EACf,cAAc;EACd,gBAAgB;EAChB,aAAa;;EAEb,qBAAqB;EACrB,wBAAwB;AAC1B;;AAEA;EACE,qEAAqE;EACrE,aAAa;AACf;;AAEA;EACE,6BAA6B;AAC/B;;AAEA;EACE,aAAa;AACf;;AAEA;EACE,eAAe;AACjB;;AAEA;EACE,cAAc;EACd,6CAA6C;EAC7C,0BAA0B;AAC5B;;AAEA;EACE,6CAA6C;AAC/C;;AAEA;EACE,aAAa;AACf;;AAEA;EACE,aAAa;AACf;;AAEA;EACE,cAAc;AAChB;;AAEA;EACE,eAAe;AACjB;;AAEA;EACE,SAAS;EACT,yCAAyC;EACzC,yBAAyB;AAC3B;;AAEA;EACE,yCAAyC;EACzC,yBAAyB;AAC3B;;AAEA;EACE,aAAa;EACb,mBAAmB;EACnB,8BAA8B;EAC9B,UAAU;EACV,gBAAgB;AAClB;;AAEA;EACE,kBAAkB;EAClB,cAAc;EACd,kBAAkB;AACpB;;AAEA;EACE,kBAAkB;EAClB,oBAAoB;AACtB;;AAEA;EACE,kBAAkB;EAClB,UAAU;EACV,oBAAoB;EACpB,mBAAmB;EACnB,SAAS;EACT,iBAAiB;EACjB,mBAAmB;EACnB,mBAAmB;EACnB,SAAS;EACT,6BAA6B;EAC7B,oBAAoB;EACpB,eAAe;EACf,iBAAiB;AACnB;;AAEA;EACE,mBAAmB;AACrB;;AAEA;EACE,kBAAkB;EAClB,QAAQ;EACR,OAAO;EACP,2BAA2B;AAC7B;;AAEA;EACE,kBAAkB;EAClB,QAAQ;EACR,QAAQ;EACR,2BAA2B;AAC7B;;AAEA;EACE,oBAAoB;EACpB,mBAAmB;EACnB,uBAAuB;EACvB,2BAA2B;EAC3B,4BAA4B;EAC5B,eAAe;EACf,mBAAmB;AACrB;;AAEA,eAAe;AACf,eAAe;AACf,eAAe;;AAEf;;EAEE,kBAAkB;EAClB,oBAAoB;EACpB,mBAAmB;AACrB;;AAEA;EACE,gBAAgB;EAChB,kBAAkB;EAClB,UAAU;EACV,MAAM;EACN,SAAS;EACT,OAAO;EACP,WAAW;EACX,SAAS;EACT,UAAU;EACV,eAAe;EACf,UAAU;EACV,YAAY;EACZ,6BAA6B;EAC7B,oBAAoB;EACpB,kBAAkB;EAClB,oBAAoB;AACtB;;AAEA;EACE,cAAc;EACd,YAAY;AACd;;AAEA;EACE,6CAA6C;EAC7C,0BAA0B;EAC1B,kBAAkB;AACpB;;AAEA;EACE,iBAAiB;AACnB;;AAEA;EACE,SAAS;AACX;;AAEA;;EAEE,YAAY;AACd;;AAEA;EACE,sBAAsB;EACtB,yBAAyB;EACzB,iBAAiB;EACjB,gBAAgB;EAChB,kBAAkB;EAClB,YAAY;EACZ,4BAA4B;EAC5B,UAAU;AACZ;;AAEA;EACE,SAAS;AACX;;AAEA;EACE,aAAa;AACf;;AAEA;EACE,2BAA2B;EAC3B,YAAY;EACZ,4BAA4B;EAC5B,UAAU;EACV,kBAAkB;AACpB;;AAEA;EACE,iBAAiB;AACnB;;AAEA;;EAEE,aAAa;EACb,gBAAgB;EAChB,mBAAmB;EACnB,uBAAuB;EACvB,sBAAsB;EACtB,2BAA2B;EAC3B,+BAA+B;EAC/B,4BAA4B;EAC5B,SAAS;EACT,6BAA6B;EAC7B,mBAAmB;AACrB;;AAEA;EACE,iBAAiB;AACnB;;AAEA;;;EAGE,YAAY;EACZ,UAAU;EACV,yCAAyC;AAC3C;;AAEA;EACE,YAAY;AACd;;AAEA;EACE,2DAA2D;EAC3D,2BAA2B;EAC3B,mBAAmB;EACnB,UAAU;AACZ;;AAEA;EACE,0BAA0B;EAC1B,6BAA6B;AAC/B;;AAEA;EACE,yBAAyB;EACzB,4BAA4B;AAC9B;;AAEA;EACE,yBAAyB;EACzB,4BAA4B;AAC9B;;AAEA;EACE,0BAA0B;EAC1B,6BAA6B;AAC/B;;AAEA;EACE,mBAAmB;AACrB;;AAEA;EACE,gBAAgB;AAClB","sourcesContent":[".rdp {\n  --rdp-cell-size: 40px;\n  --rdp-accent-color: #0000ff;\n  --rdp-background-color: #e7edff;\n  --rdp-accent-color-dark: #3003e1;\n  --rdp-background-color-dark: #180270;\n  --rdp-outline: 2px solid var(--rdp-accent-color); /* Outline border for focused elements */\n  --rdp-outline-selected: 3px solid var(--rdp-accent-color); /* Outline border for focused _and_ selected elements */\n\n  margin: 1em;\n}\n\n/* Hide elements for devices that are not screen readers */\n.rdp-vhidden {\n  box-sizing: border-box;\n  padding: 0;\n  margin: 0;\n  background: transparent;\n  border: 0;\n  -moz-appearance: none;\n  -webkit-appearance: none;\n  appearance: none;\n  position: absolute !important;\n  top: 0;\n  width: 1px !important;\n  height: 1px !important;\n  padding: 0 !important;\n  overflow: hidden !important;\n  clip: rect(1px, 1px, 1px, 1px) !important;\n  border: 0 !important;\n}\n\n/* Buttons */\n.rdp-button_reset {\n  appearance: none;\n  position: relative;\n  margin: 0;\n  padding: 0;\n  cursor: default;\n  color: inherit;\n  background: none;\n  font: inherit;\n\n  -moz-appearance: none;\n  -webkit-appearance: none;\n}\n\n.rdp-button_reset:focus-visible {\n  /* Make sure to reset outline only when :focus-visible is supported */\n  outline: none;\n}\n\n.rdp-button {\n  border: 2px solid transparent;\n}\n\n.rdp-button[disabled]:not(.rdp-day_selected) {\n  opacity: 0.25;\n}\n\n.rdp-button:not([disabled]) {\n  cursor: pointer;\n}\n\n.rdp-button:focus-visible:not([disabled]) {\n  color: inherit;\n  background-color: var(--rdp-background-color);\n  border: var(--rdp-outline);\n}\n\n.rdp-button:hover:not([disabled]):not(.rdp-day_selected) {\n  background-color: var(--rdp-background-color);\n}\n\n.rdp-months {\n  display: flex;\n}\n\n.rdp-month {\n  margin: 0 1em;\n}\n\n.rdp-month:first-child {\n  margin-left: 0;\n}\n\n.rdp-month:last-child {\n  margin-right: 0;\n}\n\n.rdp-table {\n  margin: 0;\n  max-width: calc(var(--rdp-cell-size) * 7);\n  border-collapse: collapse;\n}\n\n.rdp-with_weeknumber .rdp-table {\n  max-width: calc(var(--rdp-cell-size) * 8);\n  border-collapse: collapse;\n}\n\n.rdp-caption {\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n  padding: 0;\n  text-align: left;\n}\n\n.rdp-multiple_months .rdp-caption {\n  position: relative;\n  display: block;\n  text-align: center;\n}\n\n.rdp-caption_dropdowns {\n  position: relative;\n  display: inline-flex;\n}\n\n.rdp-caption_label {\n  position: relative;\n  z-index: 1;\n  display: inline-flex;\n  align-items: center;\n  margin: 0;\n  padding: 0 0.25em;\n  white-space: nowrap;\n  color: currentColor;\n  border: 0;\n  border: 2px solid transparent;\n  font-family: inherit;\n  font-size: 140%;\n  font-weight: bold;\n}\n\n.rdp-nav {\n  white-space: nowrap;\n}\n\n.rdp-multiple_months .rdp-caption_start .rdp-nav {\n  position: absolute;\n  top: 50%;\n  left: 0;\n  transform: translateY(-50%);\n}\n\n.rdp-multiple_months .rdp-caption_end .rdp-nav {\n  position: absolute;\n  top: 50%;\n  right: 0;\n  transform: translateY(-50%);\n}\n\n.rdp-nav_button {\n  display: inline-flex;\n  align-items: center;\n  justify-content: center;\n  width: var(--rdp-cell-size);\n  height: var(--rdp-cell-size);\n  padding: 0.25em;\n  border-radius: 100%;\n}\n\n/* ---------- */\n/* Dropdowns  */\n/* ---------- */\n\n.rdp-dropdown_year,\n.rdp-dropdown_month {\n  position: relative;\n  display: inline-flex;\n  align-items: center;\n}\n\n.rdp-dropdown {\n  appearance: none;\n  position: absolute;\n  z-index: 2;\n  top: 0;\n  bottom: 0;\n  left: 0;\n  width: 100%;\n  margin: 0;\n  padding: 0;\n  cursor: inherit;\n  opacity: 0;\n  border: none;\n  background-color: transparent;\n  font-family: inherit;\n  font-size: inherit;\n  line-height: inherit;\n}\n\n.rdp-dropdown[disabled] {\n  opacity: unset;\n  color: unset;\n}\n\n.rdp-dropdown:focus-visible:not([disabled]) + .rdp-caption_label {\n  background-color: var(--rdp-background-color);\n  border: var(--rdp-outline);\n  border-radius: 6px;\n}\n\n.rdp-dropdown_icon {\n  margin: 0 0 0 5px;\n}\n\n.rdp-head {\n  border: 0;\n}\n\n.rdp-head_row,\n.rdp-row {\n  height: 100%;\n}\n\n.rdp-head_cell {\n  vertical-align: middle;\n  text-transform: uppercase;\n  font-size: 0.75em;\n  font-weight: 700;\n  text-align: center;\n  height: 100%;\n  height: var(--rdp-cell-size);\n  padding: 0;\n}\n\n.rdp-tbody {\n  border: 0;\n}\n\n.rdp-tfoot {\n  margin: 0.5em;\n}\n\n.rdp-cell {\n  width: var(--rdp-cell-size);\n  height: 100%;\n  height: var(--rdp-cell-size);\n  padding: 0;\n  text-align: center;\n}\n\n.rdp-weeknumber {\n  font-size: 0.75em;\n}\n\n.rdp-weeknumber,\n.rdp-day {\n  display: flex;\n  overflow: hidden;\n  align-items: center;\n  justify-content: center;\n  box-sizing: border-box;\n  width: var(--rdp-cell-size);\n  max-width: var(--rdp-cell-size);\n  height: var(--rdp-cell-size);\n  margin: 0;\n  border: 2px solid transparent;\n  border-radius: 100%;\n}\n\n.rdp-day_today:not(.rdp-day_outside) {\n  font-weight: bold;\n}\n\n.rdp-day_selected,\n.rdp-day_selected:focus-visible,\n.rdp-day_selected:hover {\n  color: white;\n  opacity: 1;\n  background-color: var(--rdp-accent-color);\n}\n\n.rdp-day_outside {\n  opacity: 0.5;\n}\n\n.rdp-day_selected:focus-visible {\n  /* Since the background is the same use again the outline */\n  outline: var(--rdp-outline);\n  outline-offset: 2px;\n  z-index: 1;\n}\n\n.rdp:not([dir='rtl']) .rdp-day_range_start:not(.rdp-day_range_end) {\n  border-top-right-radius: 0;\n  border-bottom-right-radius: 0;\n}\n\n.rdp:not([dir='rtl']) .rdp-day_range_end:not(.rdp-day_range_start) {\n  border-top-left-radius: 0;\n  border-bottom-left-radius: 0;\n}\n\n.rdp[dir='rtl'] .rdp-day_range_start:not(.rdp-day_range_end) {\n  border-top-left-radius: 0;\n  border-bottom-left-radius: 0;\n}\n\n.rdp[dir='rtl'] .rdp-day_range_end:not(.rdp-day_range_start) {\n  border-top-right-radius: 0;\n  border-bottom-right-radius: 0;\n}\n\n.rdp-day_range_end.rdp-day_range_start {\n  border-radius: 100%;\n}\n\n.rdp-day_range_middle {\n  border-radius: 0;\n}\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ 3379:
/***/ ((module) => {

"use strict";


var stylesInDOM = [];

function getIndexByIdentifier(identifier) {
  var result = -1;

  for (var i = 0; i < stylesInDOM.length; i++) {
    if (stylesInDOM[i].identifier === identifier) {
      result = i;
      break;
    }
  }

  return result;
}

function modulesToDom(list, options) {
  var idCountMap = {};
  var identifiers = [];

  for (var i = 0; i < list.length; i++) {
    var item = list[i];
    var id = options.base ? item[0] + options.base : item[0];
    var count = idCountMap[id] || 0;
    var identifier = "".concat(id, " ").concat(count);
    idCountMap[id] = count + 1;
    var indexByIdentifier = getIndexByIdentifier(identifier);
    var obj = {
      css: item[1],
      media: item[2],
      sourceMap: item[3],
      supports: item[4],
      layer: item[5]
    };

    if (indexByIdentifier !== -1) {
      stylesInDOM[indexByIdentifier].references++;
      stylesInDOM[indexByIdentifier].updater(obj);
    } else {
      var updater = addElementStyle(obj, options);
      options.byIndex = i;
      stylesInDOM.splice(i, 0, {
        identifier: identifier,
        updater: updater,
        references: 1
      });
    }

    identifiers.push(identifier);
  }

  return identifiers;
}

function addElementStyle(obj, options) {
  var api = options.domAPI(options);
  api.update(obj);

  var updater = function updater(newObj) {
    if (newObj) {
      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {
        return;
      }

      api.update(obj = newObj);
    } else {
      api.remove();
    }
  };

  return updater;
}

module.exports = function (list, options) {
  options = options || {};
  list = list || [];
  var lastIdentifiers = modulesToDom(list, options);
  return function update(newList) {
    newList = newList || [];

    for (var i = 0; i < lastIdentifiers.length; i++) {
      var identifier = lastIdentifiers[i];
      var index = getIndexByIdentifier(identifier);
      stylesInDOM[index].references--;
    }

    var newLastIdentifiers = modulesToDom(newList, options);

    for (var _i = 0; _i < lastIdentifiers.length; _i++) {
      var _identifier = lastIdentifiers[_i];

      var _index = getIndexByIdentifier(_identifier);

      if (stylesInDOM[_index].references === 0) {
        stylesInDOM[_index].updater();

        stylesInDOM.splice(_index, 1);
      }
    }

    lastIdentifiers = newLastIdentifiers;
  };
};

/***/ }),

/***/ 569:
/***/ ((module) => {

"use strict";


var memo = {};
/* istanbul ignore next  */

function getTarget(target) {
  if (typeof memo[target] === "undefined") {
    var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself

    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
      try {
        // This will throw an exception if access to iframe is blocked
        // due to cross-origin restrictions
        styleTarget = styleTarget.contentDocument.head;
      } catch (e) {
        // istanbul ignore next
        styleTarget = null;
      }
    }

    memo[target] = styleTarget;
  }

  return memo[target];
}
/* istanbul ignore next  */


function insertBySelector(insert, style) {
  var target = getTarget(insert);

  if (!target) {
    throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
  }

  target.appendChild(style);
}

module.exports = insertBySelector;

/***/ }),

/***/ 9216:
/***/ ((module) => {

"use strict";


/* istanbul ignore next  */
function insertStyleElement(options) {
  var element = document.createElement("style");
  options.setAttributes(element, options.attributes);
  options.insert(element, options.options);
  return element;
}

module.exports = insertStyleElement;

/***/ }),

/***/ 3565:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


/* istanbul ignore next  */
function setAttributesWithoutAttributes(styleElement) {
  var nonce =  true ? __webpack_require__.nc : 0;

  if (nonce) {
    styleElement.setAttribute("nonce", nonce);
  }
}

module.exports = setAttributesWithoutAttributes;

/***/ }),

/***/ 7795:
/***/ ((module) => {

"use strict";


/* istanbul ignore next  */
function apply(styleElement, options, obj) {
  var css = "";

  if (obj.supports) {
    css += "@supports (".concat(obj.supports, ") {");
  }

  if (obj.media) {
    css += "@media ".concat(obj.media, " {");
  }

  var needLayer = typeof obj.layer !== "undefined";

  if (needLayer) {
    css += "@layer".concat(obj.layer.length > 0 ? " ".concat(obj.layer) : "", " {");
  }

  css += obj.css;

  if (needLayer) {
    css += "}";
  }

  if (obj.media) {
    css += "}";
  }

  if (obj.supports) {
    css += "}";
  }

  var sourceMap = obj.sourceMap;

  if (sourceMap && typeof btoa !== "undefined") {
    css += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), " */");
  } // For old IE

  /* istanbul ignore if  */


  options.styleTagTransform(css, styleElement, options.options);
}

function removeStyleElement(styleElement) {
  // istanbul ignore if
  if (styleElement.parentNode === null) {
    return false;
  }

  styleElement.parentNode.removeChild(styleElement);
}
/* istanbul ignore next  */


function domAPI(options) {
  var styleElement = options.insertStyleElement(options);
  return {
    update: function update(obj) {
      apply(styleElement, options, obj);
    },
    remove: function remove() {
      removeStyleElement(styleElement);
    }
  };
}

module.exports = domAPI;

/***/ }),

/***/ 4589:
/***/ ((module) => {

"use strict";


/* istanbul ignore next  */
function styleTagTransform(css, styleElement) {
  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = css;
  } else {
    while (styleElement.firstChild) {
      styleElement.removeChild(styleElement.firstChild);
    }

    styleElement.appendChild(document.createTextNode(css));
  }
}

module.exports = styleTagTransform;

/***/ }),

/***/ 1121:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 8023:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.unwrap = exports.ErrorResult = exports.Result = exports.Events = exports.Requests = void 0;
var api_1 = __webpack_require__(1121);
Object.defineProperty(exports, "Requests", ({ enumerable: true, get: function () { return api_1.Requests; } }));
Object.defineProperty(exports, "Events", ({ enumerable: true, get: function () { return api_1.Events; } }));
var types_1 = __webpack_require__(1573);
Object.defineProperty(exports, "Result", ({ enumerable: true, get: function () { return types_1.Result; } }));
Object.defineProperty(exports, "ErrorResult", ({ enumerable: true, get: function () { return types_1.ErrorResult; } }));
Object.defineProperty(exports, "unwrap", ({ enumerable: true, get: function () { return types_1.unwrap; } }));


/***/ }),

/***/ 1573:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.unwrap = exports.isErrorResult = void 0;
const types_1 = __webpack_require__(9581);
const isErrorResult = (result) => {
    return !!result && Object.prototype.hasOwnProperty.call(result, 'error_code');
};
exports.isErrorResult = isErrorResult;
const unwrap = (result) => {
    if ((0, exports.isErrorResult)(result)) {
        const { error_code, error_message } = result;
        throw new types_1.ErrorWithCode(error_code, error_message);
    }
    return result;
};
exports.unwrap = unwrap;


/***/ }),

/***/ 9771:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// @ts-nocheck
/* tslint:disable */
/* eslint-disable */
/**
 * robotd
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UtilitiesApi = exports.UtilitiesApiFactory = exports.UtilitiesApiFp = exports.UtilitiesApiAxiosParamCreator = exports.StatusApi = exports.StatusApiFactory = exports.StatusApiFp = exports.StatusApiAxiosParamCreator = exports.ProjectsApi = exports.ProjectsApiFactory = exports.ProjectsApiFp = exports.ProjectsApiAxiosParamCreator = exports.InspectorApi = exports.InspectorApiFactory = exports.InspectorApiFp = exports.InspectorApiAxiosParamCreator = exports.WorkItemRunResult = exports.VariableKind = exports.ValueType = exports.Type = exports.Status = exports.Scope = exports.RunEventKind = exports.PatternType = exports.LogicalOperators = exports.LogLevel = exports.LocatorType = exports.InspectorType = exports.ImportKind = exports.Icon = exports.ForKind = exports.ErrorCode = exports.DocType = exports.ComparisonOperators = exports.Color = exports.BrowserStatus = exports.ArgumentKind = void 0;
const axios_1 = __importDefault(__webpack_require__(795));
// Some imports not used depending on template conditions
// @ts-ignore
const common_1 = __webpack_require__(3424);
// @ts-ignore
const base_1 = __webpack_require__(5262);
/**
 * An enumeration.
 * @export
 * @enum {string}
 */
var ArgumentKind;
(function (ArgumentKind) {
    ArgumentKind["PositionalOrNamed"] = "positional-or-named";
    ArgumentKind["PositionalOnly"] = "positional-only";
    ArgumentKind["NamedOnly"] = "named-only";
    ArgumentKind["VarPositional"] = "var-positional";
    ArgumentKind["VarNamed"] = "var-named";
})(ArgumentKind = exports.ArgumentKind || (exports.ArgumentKind = {}));
/**
 * An enumeration.
 * @export
 * @enum {string}
 */
var BrowserStatus;
(function (BrowserStatus) {
    BrowserStatus["Stopped"] = "stopped";
    BrowserStatus["Started"] = "started";
    BrowserStatus["Running"] = "running";
})(BrowserStatus = exports.BrowserStatus || (exports.BrowserStatus = {}));
/**
 * An enumeration.
 * @export
 * @enum {string}
 */
var Color;
(function (Color) {
    Color["None"] = "none";
    Color["Purple"] = "purple";
    Color["Peach"] = "peach";
    Color["Orange"] = "orange";
    Color["Yellow"] = "yellow";
    Color["Teal"] = "teal";
    Color["Green"] = "green";
    Color["Blue"] = "blue";
})(Color = exports.Color || (exports.Color = {}));
/**
 * An enumeration.
 * @export
 * @enum {string}
 */
var ComparisonOperators;
(function (ComparisonOperators) {
    ComparisonOperators["Equals"] = "==";
    ComparisonOperators["NotEqual"] = "!=";
    ComparisonOperators["GreaterThan"] = ">";
    ComparisonOperators["GreaterThanOrEqualTo"] = ">=";
    ComparisonOperators["LessThan"] = "<";
    ComparisonOperators["LessThanOrEqualTo"] = "<=";
    ComparisonOperators["Is"] = "is";
    ComparisonOperators["IsNot"] = "is not";
    ComparisonOperators["In"] = "in";
    ComparisonOperators["NotIn"] = "not in";
})(ComparisonOperators = exports.ComparisonOperators || (exports.ComparisonOperators = {}));
/**
 * An enumeration.
 * @export
 * @enum {string}
 */
var DocType;
(function (DocType) {
    DocType["Library"] = "library";
    DocType["Keyword"] = "keyword";
    DocType["Argument"] = "argument";
    DocType["Variable"] = "variable";
    DocType["Locator"] = "locator";
    DocType["WorkItem"] = "work-item";
})(DocType = exports.DocType || (exports.DocType = {}));
/**
 * An enumeration.
 * @export
 * @enum {string}
 */
var ErrorCode;
(function (ErrorCode) {
    ErrorCode["Unknown"] = "unknown";
    ErrorCode["InternalError"] = "internal-error";
    ErrorCode["ValidationError"] = "validation-error";
    ErrorCode["TimedOutError"] = "timed-out-error";
    ErrorCode["NotAvailable"] = "not-available";
    ErrorCode["InvalidRequest"] = "invalid-request";
    ErrorCode["InvalidValue"] = "invalid-value";
})(ErrorCode = exports.ErrorCode || (exports.ErrorCode = {}));
/**
 * An enumeration.
 * @export
 * @enum {string}
 */
var ForKind;
(function (ForKind) {
    ForKind["In"] = "in";
    ForKind["InRange"] = "in-range";
    ForKind["InEnumerate"] = "in-enumerate";
    ForKind["InZip"] = "in-zip";
})(ForKind = exports.ForKind || (exports.ForKind = {}));
/**
 * An enumeration.
 * @export
 * @enum {string}
 */
var Icon;
(function (Icon) {
    Icon["Image"] = "image";
    Icon["Text"] = "text";
    Icon["Button"] = "button";
    Icon["Input"] = "input";
    Icon["Link"] = "link";
    Icon["GridCell"] = "grid-cell";
    Icon["Heading"] = "heading";
    Icon["Table"] = "table";
    Icon["Form"] = "form";
    Icon["VariableSquare"] = "variable-square";
    Icon["Loop"] = "loop";
    Icon["Branch"] = "branch";
    Icon["TryCatch"] = "try-catch";
    Icon["Pass"] = "pass";
    Icon["Exit"] = "exit";
    Icon["Play"] = "play";
    Icon["Close"] = "close";
    Icon["Continue"] = "continue";
    Icon["Return"] = "return";
    Icon["Document"] = "document";
    Icon["DisabledFile"] = "disabled-file";
    Icon["Time"] = "time";
    Icon["Camera"] = "camera";
    Icon["Pointer"] = "pointer";
    Icon["CodeFile"] = "code-file";
    Icon["Browser"] = "browser";
    Icon["CloudDownload"] = "cloud-download";
    Icon["ExcelDocument"] = "excel-document";
    Icon["Corner"] = "corner";
    Icon["VariableX"] = "variable-x";
    Icon["Code"] = "code";
    Icon["Warning"] = "warning";
    Icon["FileError"] = "file-error";
    Icon["Remove"] = "remove";
    Icon["RemoveItem"] = "remove-item";
    Icon["RemoveFile"] = "remove-file";
    Icon["Add"] = "add";
    Icon["AddItem"] = "add-item";
    Icon["AddFile"] = "add-file";
    Icon["CloseFile"] = "close-file";
    Icon["SaveFile"] = "save-file";
    Icon["OpenFile"] = "open-file";
    Icon["Mail"] = "mail";
    Icon["Pdf"] = "pdf";
    Icon["Database"] = "database";
    Icon["Stop"] = "stop";
    Icon["Pause"] = "pause";
    Icon["Print"] = "print";
    Icon["Number"] = "number";
    Icon["List"] = "list";
    Icon["Windows"] = "windows";
    Icon["Lock"] = "lock";
})(Icon = exports.Icon || (exports.Icon = {}));
/**
 * An enumeration.
 * @export
 * @enum {string}
 */
var ImportKind;
(function (ImportKind) {
    ImportKind["Library"] = "library";
    ImportKind["Resource"] = "resource";
    ImportKind["Variables"] = "variables";
})(ImportKind = exports.ImportKind || (exports.ImportKind = {}));
/**
 * An enumeration.
 * @export
 * @enum {string}
 */
var InspectorType;
(function (InspectorType) {
    InspectorType["Picker"] = "picker";
    InspectorType["WebRecorder"] = "web-recorder";
})(InspectorType = exports.InspectorType || (exports.InspectorType = {}));
/**
 * An enumeration.
 * @export
 * @enum {string}
 */
var LocatorType;
(function (LocatorType) {
    LocatorType["Browser"] = "browser";
    LocatorType["Windows"] = "windows";
    LocatorType["Image"] = "image";
    LocatorType["WebRecorder"] = "web-recorder";
})(LocatorType = exports.LocatorType || (exports.LocatorType = {}));
/**
 * An enumeration.
 * @export
 * @enum {string}
 */
var LogLevel;
(function (LogLevel) {
    LogLevel["Trace"] = "trace";
    LogLevel["Debug"] = "debug";
    LogLevel["Info"] = "info";
    LogLevel["Warn"] = "warn";
    LogLevel["Error"] = "error";
    LogLevel["Fail"] = "fail";
})(LogLevel = exports.LogLevel || (exports.LogLevel = {}));
/**
 * An enumeration.
 * @export
 * @enum {string}
 */
var LogicalOperators;
(function (LogicalOperators) {
    LogicalOperators["And"] = "and";
    LogicalOperators["Or"] = "or";
    LogicalOperators["Not"] = "not";
})(LogicalOperators = exports.LogicalOperators || (exports.LogicalOperators = {}));
/**
 * An enumeration.
 * @export
 * @enum {string}
 */
var PatternType;
(function (PatternType) {
    PatternType["Glob"] = "glob";
    PatternType["Regexp"] = "regexp";
    PatternType["Start"] = "start";
    PatternType["Literal"] = "literal";
})(PatternType = exports.PatternType || (exports.PatternType = {}));
/**
 * An enumeration.
 * @export
 * @enum {string}
 */
var RunEventKind;
(function (RunEventKind) {
    RunEventKind["StartSuite"] = "start_suite";
    RunEventKind["EndSuite"] = "end_suite";
    RunEventKind["StartTest"] = "start_test";
    RunEventKind["EndTest"] = "end_test";
    RunEventKind["StartKeyword"] = "start_keyword";
    RunEventKind["EndKeyword"] = "end_keyword";
    RunEventKind["LogMessage"] = "log_message";
    RunEventKind["LibraryImport"] = "library_import";
    RunEventKind["ResourceImport"] = "resource_import";
    RunEventKind["VariablesImport"] = "variables_import";
    RunEventKind["OutputFile"] = "output_file";
    RunEventKind["LogFile"] = "log_file";
    RunEventKind["ReportFile"] = "report_file";
    RunEventKind["WorkItemsUpdate"] = "work_items_update";
    RunEventKind["Close"] = "close";
})(RunEventKind = exports.RunEventKind || (exports.RunEventKind = {}));
/**
 * An enumeration.
 * @export
 * @enum {string}
 */
var Scope;
(function (Scope) {
    Scope["Keyword"] = "keyword";
    Scope["Task"] = "task";
    Scope["Suite"] = "suite";
    Scope["Global"] = "global";
})(Scope = exports.Scope || (exports.Scope = {}));
/**
 * An enumeration.
 * @export
 * @enum {string}
 */
var Status;
(function (Status) {
    Status["Pass"] = "pass";
    Status["Fail"] = "fail";
    Status["Skip"] = "skip";
    Status["NotRun"] = "not-run";
    Status["NotSet"] = "not-set";
})(Status = exports.Status || (exports.Status = {}));
/**
 * An enumeration.
 * @export
 * @enum {string}
 */
var Type;
(function (Type) {
    Type["Suite"] = "suite";
    Type["Task"] = "task";
    Type["UserKeyword"] = "user-keyword";
    Type["Import"] = "import";
    Type["SuiteVariable"] = "suite-variable";
    Type["Variable"] = "variable";
    Type["Keyword"] = "keyword";
    Type["For"] = "for";
    Type["ForIteration"] = "for-iteration";
    Type["While"] = "while";
    Type["If"] = "if";
    Type["IfBranch"] = "if-branch";
    Type["ElseIfBranch"] = "else-if-branch";
    Type["ElseBranch"] = "else-branch";
    Type["Try"] = "try";
    Type["TryBranch"] = "try-branch";
    Type["ExceptBranch"] = "except-branch";
    Type["FinallyBranch"] = "finally-branch";
    Type["Return"] = "return";
    Type["Break"] = "break";
    Type["Continue"] = "continue";
    Type["Conditional"] = "conditional";
    Type["Expression"] = "expression";
    Type["ExpressionGroup"] = "expression_group";
})(Type = exports.Type || (exports.Type = {}));
/**
 * An enumeration.
 * @export
 * @enum {string}
 */
var ValueType;
(function (ValueType) {
    ValueType["Unknown"] = "unknown";
    ValueType["String"] = "string";
    ValueType["Boolean"] = "boolean";
    ValueType["Number"] = "number";
    ValueType["PathDir"] = "path-dir";
    ValueType["PathFile"] = "path-file";
    ValueType["LocatorBrowser"] = "locator-browser";
    ValueType["LocatorWindows"] = "locator-windows";
})(ValueType = exports.ValueType || (exports.ValueType = {}));
/**
 * An enumeration.
 * @export
 * @enum {string}
 */
var VariableKind;
(function (VariableKind) {
    VariableKind["Scalar"] = "scalar";
    VariableKind["List"] = "list";
    VariableKind["Dictionary"] = "dictionary";
    VariableKind["Environment"] = "environment";
    VariableKind["Constant"] = "constant";
    VariableKind["Locator"] = "locator";
})(VariableKind = exports.VariableKind || (exports.VariableKind = {}));
/**
 * An enumeration.
 * @export
 * @enum {string}
 */
var WorkItemRunResult;
(function (WorkItemRunResult) {
    WorkItemRunResult["Completed"] = "COMPLETED";
    WorkItemRunResult["Failed"] = "FAILED";
})(WorkItemRunResult = exports.WorkItemRunResult || (exports.WorkItemRunResult = {}));
/**
 * InspectorApi - axios parameter creator
 * @export
 */
const InspectorApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Browser Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        browserStatus: async (options = {}) => {
            const localVarPath = `/inspector/browser`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'GET',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Connect Browser
         * @param {BrowserConnectRequest} browserConnectRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectBrowser: async (browserConnectRequest, options = {}) => {
            // verify required parameter 'browserConnectRequest' is not null or undefined
            (0, common_1.assertParamExists)('connectBrowser', 'browserConnectRequest', browserConnectRequest);
            const localVarPath = `/inspector/browser/connect`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'POST',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(browserConnectRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Focus Browser
         * @param {BrowserFocusRequest} browserFocusRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        focusBrowser: async (browserFocusRequest, options = {}) => {
            // verify required parameter 'browserFocusRequest' is not null or undefined
            (0, common_1.assertParamExists)('focusBrowser', 'browserFocusRequest', browserFocusRequest);
            const localVarPath = `/inspector/browser/focus`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'POST',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(browserFocusRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Focus Window
         * @param {WindowsFocusRequest} windowsFocusRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        focusWindow: async (windowsFocusRequest, options = {}) => {
            // verify required parameter 'windowsFocusRequest' is not null or undefined
            (0, common_1.assertParamExists)('focusWindow', 'windowsFocusRequest', windowsFocusRequest);
            const localVarPath = `/inspector/windows/focus`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'POST',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(windowsFocusRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Inspector Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inspectorStatus: async (options = {}) => {
            const localVarPath = `/inspector`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'GET',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary List Browser
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBrowser: async (options = {}) => {
            const localVarPath = `/inspector/browser/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'GET',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary List Windows
         * @param {Array<string>} [exclude]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWindows: async (exclude, options = {}) => {
            const localVarPath = `/inspector/windows/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'GET',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (exclude) {
                localVarQueryParameter['exclude'] = exclude;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Pick Browser
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pickBrowser: async (options = {}) => {
            const localVarPath = `/inspector/browser/pick`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'POST',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Pick Window
         * @param {WindowsPickRequest} windowsPickRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pickWindow: async (windowsPickRequest, options = {}) => {
            // verify required parameter 'windowsPickRequest' is not null or undefined
            (0, common_1.assertParamExists)('pickWindow', 'windowsPickRequest', windowsPickRequest);
            const localVarPath = `/inspector/windows/pick`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'POST',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(windowsPickRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Record Browser
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recordBrowser: async (options = {}) => {
            const localVarPath = `/inspector/browser/record`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'POST',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Start Browser
         * @param {BrowserStartRequest} browserStartRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startBrowser: async (browserStartRequest, options = {}) => {
            // verify required parameter 'browserStartRequest' is not null or undefined
            (0, common_1.assertParamExists)('startBrowser', 'browserStartRequest', browserStartRequest);
            const localVarPath = `/inspector/browser`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'POST',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(browserStartRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Stop Browser
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopBrowser: async (options = {}) => {
            const localVarPath = `/inspector/browser`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'DELETE',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Stop Recording Browser
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopRecordingBrowser: async (options = {}) => {
            const localVarPath = `/inspector/browser/record`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'DELETE',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Validate Browser
         * @param {BrowserValidateRequest} browserValidateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateBrowser: async (browserValidateRequest, options = {}) => {
            // verify required parameter 'browserValidateRequest' is not null or undefined
            (0, common_1.assertParamExists)('validateBrowser', 'browserValidateRequest', browserValidateRequest);
            const localVarPath = `/inspector/browser/validate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'POST',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(browserValidateRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Validate Window
         * @param {WindowsValidateRequest} windowsValidateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateWindow: async (windowsValidateRequest, options = {}) => {
            // verify required parameter 'windowsValidateRequest' is not null or undefined
            (0, common_1.assertParamExists)('validateWindow', 'windowsValidateRequest', windowsValidateRequest);
            const localVarPath = `/inspector/windows/validate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'POST',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(windowsValidateRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.InspectorApiAxiosParamCreator = InspectorApiAxiosParamCreator;
/**
 * InspectorApi - functional programming interface
 * @export
 */
const InspectorApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.InspectorApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Browser Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async browserStatus(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.browserStatus(options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Connect Browser
         * @param {BrowserConnectRequest} browserConnectRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async connectBrowser(browserConnectRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.connectBrowser(browserConnectRequest, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Focus Browser
         * @param {BrowserFocusRequest} browserFocusRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async focusBrowser(browserFocusRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.focusBrowser(browserFocusRequest, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Focus Window
         * @param {WindowsFocusRequest} windowsFocusRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async focusWindow(windowsFocusRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.focusWindow(windowsFocusRequest, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Inspector Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async inspectorStatus(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.inspectorStatus(options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary List Browser
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listBrowser(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listBrowser(options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary List Windows
         * @param {Array<string>} [exclude]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listWindows(exclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listWindows(exclude, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Pick Browser
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pickBrowser(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pickBrowser(options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Pick Window
         * @param {WindowsPickRequest} windowsPickRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pickWindow(windowsPickRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pickWindow(windowsPickRequest, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Record Browser
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recordBrowser(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recordBrowser(options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Start Browser
         * @param {BrowserStartRequest} browserStartRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startBrowser(browserStartRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startBrowser(browserStartRequest, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Stop Browser
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stopBrowser(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stopBrowser(options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Stop Recording Browser
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stopRecordingBrowser(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stopRecordingBrowser(options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Validate Browser
         * @param {BrowserValidateRequest} browserValidateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validateBrowser(browserValidateRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validateBrowser(browserValidateRequest, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Validate Window
         * @param {WindowsValidateRequest} windowsValidateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validateWindow(windowsValidateRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validateWindow(windowsValidateRequest, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
    };
};
exports.InspectorApiFp = InspectorApiFp;
/**
 * InspectorApi - factory interface
 * @export
 */
const InspectorApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.InspectorApiFp)(configuration);
    return {
        /**
         *
         * @summary Browser Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        browserStatus(options) {
            return localVarFp
                .browserStatus(options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Connect Browser
         * @param {BrowserConnectRequest} browserConnectRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectBrowser(browserConnectRequest, options) {
            return localVarFp
                .connectBrowser(browserConnectRequest, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Focus Browser
         * @param {BrowserFocusRequest} browserFocusRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        focusBrowser(browserFocusRequest, options) {
            return localVarFp
                .focusBrowser(browserFocusRequest, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Focus Window
         * @param {WindowsFocusRequest} windowsFocusRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        focusWindow(windowsFocusRequest, options) {
            return localVarFp
                .focusWindow(windowsFocusRequest, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Inspector Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inspectorStatus(options) {
            return localVarFp
                .inspectorStatus(options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary List Browser
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBrowser(options) {
            return localVarFp
                .listBrowser(options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary List Windows
         * @param {Array<string>} [exclude]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWindows(exclude, options) {
            return localVarFp
                .listWindows(exclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Pick Browser
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pickBrowser(options) {
            return localVarFp
                .pickBrowser(options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Pick Window
         * @param {WindowsPickRequest} windowsPickRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pickWindow(windowsPickRequest, options) {
            return localVarFp
                .pickWindow(windowsPickRequest, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Record Browser
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recordBrowser(options) {
            return localVarFp
                .recordBrowser(options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Start Browser
         * @param {BrowserStartRequest} browserStartRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startBrowser(browserStartRequest, options) {
            return localVarFp
                .startBrowser(browserStartRequest, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Stop Browser
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopBrowser(options) {
            return localVarFp
                .stopBrowser(options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Stop Recording Browser
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopRecordingBrowser(options) {
            return localVarFp
                .stopRecordingBrowser(options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Validate Browser
         * @param {BrowserValidateRequest} browserValidateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateBrowser(browserValidateRequest, options) {
            return localVarFp
                .validateBrowser(browserValidateRequest, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Validate Window
         * @param {WindowsValidateRequest} windowsValidateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateWindow(windowsValidateRequest, options) {
            return localVarFp
                .validateWindow(windowsValidateRequest, options)
                .then((request) => request(axios, basePath));
        },
    };
};
exports.InspectorApiFactory = InspectorApiFactory;
/**
 * InspectorApi - object-oriented interface
 * @export
 * @class InspectorApi
 * @extends {BaseAPI}
 */
class InspectorApi extends base_1.BaseAPI {
    /**
     *
     * @summary Browser Status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InspectorApi
     */
    browserStatus(options) {
        return (0, exports.InspectorApiFp)(this.configuration)
            .browserStatus(options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Connect Browser
     * @param {BrowserConnectRequest} browserConnectRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InspectorApi
     */
    connectBrowser(browserConnectRequest, options) {
        return (0, exports.InspectorApiFp)(this.configuration)
            .connectBrowser(browserConnectRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Focus Browser
     * @param {BrowserFocusRequest} browserFocusRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InspectorApi
     */
    focusBrowser(browserFocusRequest, options) {
        return (0, exports.InspectorApiFp)(this.configuration)
            .focusBrowser(browserFocusRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Focus Window
     * @param {WindowsFocusRequest} windowsFocusRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InspectorApi
     */
    focusWindow(windowsFocusRequest, options) {
        return (0, exports.InspectorApiFp)(this.configuration)
            .focusWindow(windowsFocusRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Inspector Status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InspectorApi
     */
    inspectorStatus(options) {
        return (0, exports.InspectorApiFp)(this.configuration)
            .inspectorStatus(options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary List Browser
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InspectorApi
     */
    listBrowser(options) {
        return (0, exports.InspectorApiFp)(this.configuration)
            .listBrowser(options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary List Windows
     * @param {Array<string>} [exclude]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InspectorApi
     */
    listWindows(exclude, options) {
        return (0, exports.InspectorApiFp)(this.configuration)
            .listWindows(exclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Pick Browser
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InspectorApi
     */
    pickBrowser(options) {
        return (0, exports.InspectorApiFp)(this.configuration)
            .pickBrowser(options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Pick Window
     * @param {WindowsPickRequest} windowsPickRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InspectorApi
     */
    pickWindow(windowsPickRequest, options) {
        return (0, exports.InspectorApiFp)(this.configuration)
            .pickWindow(windowsPickRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Record Browser
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InspectorApi
     */
    recordBrowser(options) {
        return (0, exports.InspectorApiFp)(this.configuration)
            .recordBrowser(options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Start Browser
     * @param {BrowserStartRequest} browserStartRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InspectorApi
     */
    startBrowser(browserStartRequest, options) {
        return (0, exports.InspectorApiFp)(this.configuration)
            .startBrowser(browserStartRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Stop Browser
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InspectorApi
     */
    stopBrowser(options) {
        return (0, exports.InspectorApiFp)(this.configuration)
            .stopBrowser(options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Stop Recording Browser
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InspectorApi
     */
    stopRecordingBrowser(options) {
        return (0, exports.InspectorApiFp)(this.configuration)
            .stopRecordingBrowser(options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Validate Browser
     * @param {BrowserValidateRequest} browserValidateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InspectorApi
     */
    validateBrowser(browserValidateRequest, options) {
        return (0, exports.InspectorApiFp)(this.configuration)
            .validateBrowser(browserValidateRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Validate Window
     * @param {WindowsValidateRequest} windowsValidateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InspectorApi
     */
    validateWindow(windowsValidateRequest, options) {
        return (0, exports.InspectorApiFp)(this.configuration)
            .validateWindow(windowsValidateRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }
}
exports.InspectorApi = InspectorApi;
/**
 * ProjectsApi - axios parameter creator
 * @export
 */
const ProjectsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Add Input Work Item
         * @param {number} projectId
         * @param {AddWorkItemRequest} addWorkItemRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addInputWorkItem: async (projectId, addWorkItemRequest, options = {}) => {
            // verify required parameter 'projectId' is not null or undefined
            (0, common_1.assertParamExists)('addInputWorkItem', 'projectId', projectId);
            // verify required parameter 'addWorkItemRequest' is not null or undefined
            (0, common_1.assertParamExists)('addInputWorkItem', 'addWorkItemRequest', addWorkItemRequest);
            const localVarPath = `/projects/{project_id}/work-items/in`.replace(`{${'project_id'}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'POST',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(addWorkItemRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Add Suite
         * @param {number} projectId
         * @param {AddSuiteRequest} addSuiteRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSuite: async (projectId, addSuiteRequest, options = {}) => {
            // verify required parameter 'projectId' is not null or undefined
            (0, common_1.assertParamExists)('addSuite', 'projectId', projectId);
            // verify required parameter 'addSuiteRequest' is not null or undefined
            (0, common_1.assertParamExists)('addSuite', 'addSuiteRequest', addSuiteRequest);
            const localVarPath = `/projects/{project_id}/model/suites/add`.replace(`{${'project_id'}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'POST',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(addSuiteRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Close Project
         * @param {number} projectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        closeProject: async (projectId, options = {}) => {
            // verify required parameter 'projectId' is not null or undefined
            (0, common_1.assertParamExists)('closeProject', 'projectId', projectId);
            const localVarPath = `/projects/{project_id}`.replace(`{${'project_id'}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'DELETE',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete Locator
         * @param {number} projectId
         * @param {DeleteLocatorRequest} deleteLocatorRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLocator: async (projectId, deleteLocatorRequest, options = {}) => {
            // verify required parameter 'projectId' is not null or undefined
            (0, common_1.assertParamExists)('deleteLocator', 'projectId', projectId);
            // verify required parameter 'deleteLocatorRequest' is not null or undefined
            (0, common_1.assertParamExists)('deleteLocator', 'deleteLocatorRequest', deleteLocatorRequest);
            const localVarPath = `/projects/{project_id}/locators`.replace(`{${'project_id'}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'DELETE',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(deleteLocatorRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Export Project
         * @param {number} projectId
         * @param {string} path
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportProject: async (projectId, path, options = {}) => {
            // verify required parameter 'projectId' is not null or undefined
            (0, common_1.assertParamExists)('exportProject', 'projectId', projectId);
            // verify required parameter 'path' is not null or undefined
            (0, common_1.assertParamExists)('exportProject', 'path', path);
            const localVarPath = `/projects/{project_id}/export`.replace(`{${'project_id'}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'POST',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (path !== undefined) {
                localVarQueryParameter['path'] = path;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Export Project By Path
         * @param {string} src
         * @param {string} dst
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportProjectByPath: async (src, dst, options = {}) => {
            // verify required parameter 'src' is not null or undefined
            (0, common_1.assertParamExists)('exportProjectByPath', 'src', src);
            // verify required parameter 'dst' is not null or undefined
            (0, common_1.assertParamExists)('exportProjectByPath', 'dst', dst);
            const localVarPath = `/projects/export`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'POST',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (src !== undefined) {
                localVarQueryParameter['src'] = src;
            }
            if (dst !== undefined) {
                localVarQueryParameter['dst'] = dst;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get Code
         * @param {number} projectId
         * @param {string} path
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCode: async (projectId, path, options = {}) => {
            // verify required parameter 'projectId' is not null or undefined
            (0, common_1.assertParamExists)('getCode', 'projectId', projectId);
            // verify required parameter 'path' is not null or undefined
            (0, common_1.assertParamExists)('getCode', 'path', path);
            const localVarPath = `/projects/{project_id}/code`.replace(`{${'project_id'}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'GET',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (path !== undefined) {
                localVarQueryParameter['path'] = path;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get Current Input Work Item
         * @param {number} projectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentInputWorkItem: async (projectId, options = {}) => {
            // verify required parameter 'projectId' is not null or undefined
            (0, common_1.assertParamExists)('getCurrentInputWorkItem', 'projectId', projectId);
            const localVarPath = `/projects/{project_id}/work-items/current`.replace(`{${'project_id'}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'GET',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get Keywords
         * @param {number} projectId
         * @param {string} [library]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKeywords: async (projectId, library, options = {}) => {
            // verify required parameter 'projectId' is not null or undefined
            (0, common_1.assertParamExists)('getKeywords', 'projectId', projectId);
            const localVarPath = `/projects/{project_id}/keywords`.replace(`{${'project_id'}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'GET',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (library !== undefined) {
                localVarQueryParameter['library'] = library;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get Locators
         * @param {number} projectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLocators: async (projectId, options = {}) => {
            // verify required parameter 'projectId' is not null or undefined
            (0, common_1.assertParamExists)('getLocators', 'projectId', projectId);
            const localVarPath = `/projects/{project_id}/locators`.replace(`{${'project_id'}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'GET',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get Metadata
         * @param {number} projectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetadata: async (projectId, options = {}) => {
            // verify required parameter 'projectId' is not null or undefined
            (0, common_1.assertParamExists)('getMetadata', 'projectId', projectId);
            const localVarPath = `/projects/{project_id}`.replace(`{${'project_id'}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'GET',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get Model
         * @param {number} projectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getModel: async (projectId, options = {}) => {
            // verify required parameter 'projectId' is not null or undefined
            (0, common_1.assertParamExists)('getModel', 'projectId', projectId);
            const localVarPath = `/projects/{project_id}/model`.replace(`{${'project_id'}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'GET',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get Variables
         * @param {number} projectId
         * @param {string} [source]
         * @param {number} [lineno]
         * @param {boolean} [showHidden]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVariables: async (projectId, source, lineno, showHidden, options = {}) => {
            // verify required parameter 'projectId' is not null or undefined
            (0, common_1.assertParamExists)('getVariables', 'projectId', projectId);
            const localVarPath = `/projects/{project_id}/variables`.replace(`{${'project_id'}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'GET',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (source !== undefined) {
                localVarQueryParameter['source'] = source;
            }
            if (lineno !== undefined) {
                localVarQueryParameter['lineno'] = lineno;
            }
            if (showHidden !== undefined) {
                localVarQueryParameter['show_hidden'] = showHidden;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary List Files
         * @param {number} projectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFiles: async (projectId, options = {}) => {
            // verify required parameter 'projectId' is not null or undefined
            (0, common_1.assertParamExists)('listFiles', 'projectId', projectId);
            const localVarPath = `/projects/{project_id}/files`.replace(`{${'project_id'}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'GET',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary List Input Work Items
         * @param {number} projectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listInputWorkItems: async (projectId, options = {}) => {
            // verify required parameter 'projectId' is not null or undefined
            (0, common_1.assertParamExists)('listInputWorkItems', 'projectId', projectId);
            const localVarPath = `/projects/{project_id}/work-items/in`.replace(`{${'project_id'}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'GET',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary List Output Work Items
         * @param {number} projectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOutputWorkItems: async (projectId, options = {}) => {
            // verify required parameter 'projectId' is not null or undefined
            (0, common_1.assertParamExists)('listOutputWorkItems', 'projectId', projectId);
            const localVarPath = `/projects/{project_id}/work-items/out`.replace(`{${'project_id'}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'GET',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary List Runs
         * @param {number} projectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRuns: async (projectId, options = {}) => {
            // verify required parameter 'projectId' is not null or undefined
            (0, common_1.assertParamExists)('listRuns', 'projectId', projectId);
            const localVarPath = `/projects/{project_id}/run`.replace(`{${'project_id'}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'GET',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Open Project
         * @param {ProjectRequest} projectRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        openProject: async (projectRequest, options = {}) => {
            // verify required parameter 'projectRequest' is not null or undefined
            (0, common_1.assertParamExists)('openProject', 'projectRequest', projectRequest);
            const localVarPath = `/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'POST',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(projectRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Remove Input Work Item
         * @param {number} projectId
         * @param {RemoveWorkItemRequest} removeWorkItemRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeInputWorkItem: async (projectId, removeWorkItemRequest, options = {}) => {
            // verify required parameter 'projectId' is not null or undefined
            (0, common_1.assertParamExists)('removeInputWorkItem', 'projectId', projectId);
            // verify required parameter 'removeWorkItemRequest' is not null or undefined
            (0, common_1.assertParamExists)('removeInputWorkItem', 'removeWorkItemRequest', removeWorkItemRequest);
            const localVarPath = `/projects/{project_id}/work-items/in`.replace(`{${'project_id'}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'DELETE',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(removeWorkItemRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Remove Output Work Item
         * @param {number} projectId
         * @param {RemoveWorkItemRequest} removeWorkItemRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeOutputWorkItem: async (projectId, removeWorkItemRequest, options = {}) => {
            // verify required parameter 'projectId' is not null or undefined
            (0, common_1.assertParamExists)('removeOutputWorkItem', 'projectId', projectId);
            // verify required parameter 'removeWorkItemRequest' is not null or undefined
            (0, common_1.assertParamExists)('removeOutputWorkItem', 'removeWorkItemRequest', removeWorkItemRequest);
            const localVarPath = `/projects/{project_id}/work-items/out`.replace(`{${'project_id'}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'DELETE',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(removeWorkItemRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Remove Suite
         * @param {number} projectId
         * @param {RemoveSuiteRequest} removeSuiteRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeSuite: async (projectId, removeSuiteRequest, options = {}) => {
            // verify required parameter 'projectId' is not null or undefined
            (0, common_1.assertParamExists)('removeSuite', 'projectId', projectId);
            // verify required parameter 'removeSuiteRequest' is not null or undefined
            (0, common_1.assertParamExists)('removeSuite', 'removeSuiteRequest', removeSuiteRequest);
            const localVarPath = `/projects/{project_id}/model/suites/remove`.replace(`{${'project_id'}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'POST',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(removeSuiteRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Rename Suite
         * @param {number} projectId
         * @param {RenameSuiteRequest} renameSuiteRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        renameSuite: async (projectId, renameSuiteRequest, options = {}) => {
            // verify required parameter 'projectId' is not null or undefined
            (0, common_1.assertParamExists)('renameSuite', 'projectId', projectId);
            // verify required parameter 'renameSuiteRequest' is not null or undefined
            (0, common_1.assertParamExists)('renameSuite', 'renameSuiteRequest', renameSuiteRequest);
            const localVarPath = `/projects/{project_id}/model/suites/rename`.replace(`{${'project_id'}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'POST',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(renameSuiteRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Run Event
         * @param {number} runId
         * @param {number} projectId
         * @param {RunEventRequest} runEventRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runEvent: async (runId, projectId, runEventRequest, options = {}) => {
            // verify required parameter 'runId' is not null or undefined
            (0, common_1.assertParamExists)('runEvent', 'runId', runId);
            // verify required parameter 'projectId' is not null or undefined
            (0, common_1.assertParamExists)('runEvent', 'projectId', projectId);
            // verify required parameter 'runEventRequest' is not null or undefined
            (0, common_1.assertParamExists)('runEvent', 'runEventRequest', runEventRequest);
            const localVarPath = `/projects/{project_id}/run/{run_id}/events`
                .replace(`{${'run_id'}}`, encodeURIComponent(String(runId)))
                .replace(`{${'project_id'}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'POST',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(runEventRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Run Status
         * @param {number} runId
         * @param {number} projectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runStatus: async (runId, projectId, options = {}) => {
            // verify required parameter 'runId' is not null or undefined
            (0, common_1.assertParamExists)('runStatus', 'runId', runId);
            // verify required parameter 'projectId' is not null or undefined
            (0, common_1.assertParamExists)('runStatus', 'projectId', projectId);
            const localVarPath = `/projects/{project_id}/run/{run_id}`
                .replace(`{${'run_id'}}`, encodeURIComponent(String(runId)))
                .replace(`{${'project_id'}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'GET',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Run Stream
         * @param {number} runId
         * @param {number} projectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runStream: async (runId, projectId, options = {}) => {
            // verify required parameter 'runId' is not null or undefined
            (0, common_1.assertParamExists)('runStream', 'runId', runId);
            // verify required parameter 'projectId' is not null or undefined
            (0, common_1.assertParamExists)('runStream', 'projectId', projectId);
            const localVarPath = `/projects/{project_id}/run/{run_id}/stream`
                .replace(`{${'run_id'}}`, encodeURIComponent(String(runId)))
                .replace(`{${'project_id'}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'GET',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Run Work Items
         * @param {number} projectId
         * @param {number} runId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runWorkItems: async (projectId, runId, options = {}) => {
            // verify required parameter 'projectId' is not null or undefined
            (0, common_1.assertParamExists)('runWorkItems', 'projectId', projectId);
            // verify required parameter 'runId' is not null or undefined
            (0, common_1.assertParamExists)('runWorkItems', 'runId', runId);
            const localVarPath = `/projects/{project_id}/run/{run_id}/work-items`
                .replace(`{${'project_id'}}`, encodeURIComponent(String(projectId)))
                .replace(`{${'run_id'}}`, encodeURIComponent(String(runId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'GET',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Save Locator
         * @param {number} projectId
         * @param {SaveLocatorRequest} saveLocatorRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveLocator: async (projectId, saveLocatorRequest, options = {}) => {
            // verify required parameter 'projectId' is not null or undefined
            (0, common_1.assertParamExists)('saveLocator', 'projectId', projectId);
            // verify required parameter 'saveLocatorRequest' is not null or undefined
            (0, common_1.assertParamExists)('saveLocator', 'saveLocatorRequest', saveLocatorRequest);
            const localVarPath = `/projects/{project_id}/locators`.replace(`{${'project_id'}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'POST',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(saveLocatorRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Set Code
         * @param {number} projectId
         * @param {CodeRequest} codeRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setCode: async (projectId, codeRequest, options = {}) => {
            // verify required parameter 'projectId' is not null or undefined
            (0, common_1.assertParamExists)('setCode', 'projectId', projectId);
            // verify required parameter 'codeRequest' is not null or undefined
            (0, common_1.assertParamExists)('setCode', 'codeRequest', codeRequest);
            const localVarPath = `/projects/{project_id}/code`.replace(`{${'project_id'}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'POST',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(codeRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Set Current Input Work Item
         * @param {number} projectId
         * @param {CurrentWorkItemRequest} currentWorkItemRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setCurrentInputWorkItem: async (projectId, currentWorkItemRequest, options = {}) => {
            // verify required parameter 'projectId' is not null or undefined
            (0, common_1.assertParamExists)('setCurrentInputWorkItem', 'projectId', projectId);
            // verify required parameter 'currentWorkItemRequest' is not null or undefined
            (0, common_1.assertParamExists)('setCurrentInputWorkItem', 'currentWorkItemRequest', currentWorkItemRequest);
            const localVarPath = `/projects/{project_id}/work-items/current`.replace(`{${'project_id'}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'POST',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(currentWorkItemRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Set Model
         * @param {number} projectId
         * @param {Suite} suite
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setModel: async (projectId, suite, options = {}) => {
            // verify required parameter 'projectId' is not null or undefined
            (0, common_1.assertParamExists)('setModel', 'projectId', projectId);
            // verify required parameter 'suite' is not null or undefined
            (0, common_1.assertParamExists)('setModel', 'suite', suite);
            const localVarPath = `/projects/{project_id}/model`.replace(`{${'project_id'}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'POST',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(suite, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Start Run
         * @param {number} projectId
         * @param {RunRequest} runRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startRun: async (projectId, runRequest, options = {}) => {
            // verify required parameter 'projectId' is not null or undefined
            (0, common_1.assertParamExists)('startRun', 'projectId', projectId);
            // verify required parameter 'runRequest' is not null or undefined
            (0, common_1.assertParamExists)('startRun', 'runRequest', runRequest);
            const localVarPath = `/projects/{project_id}/run`.replace(`{${'project_id'}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'POST',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(runRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Stop Run
         * @param {number} projectId
         * @param {StopRequest} stopRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopRun: async (projectId, stopRequest, options = {}) => {
            // verify required parameter 'projectId' is not null or undefined
            (0, common_1.assertParamExists)('stopRun', 'projectId', projectId);
            // verify required parameter 'stopRequest' is not null or undefined
            (0, common_1.assertParamExists)('stopRun', 'stopRequest', stopRequest);
            const localVarPath = `/projects/{project_id}/stop`.replace(`{${'project_id'}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'POST',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(stopRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.ProjectsApiAxiosParamCreator = ProjectsApiAxiosParamCreator;
/**
 * ProjectsApi - functional programming interface
 * @export
 */
const ProjectsApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.ProjectsApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Add Input Work Item
         * @param {number} projectId
         * @param {AddWorkItemRequest} addWorkItemRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addInputWorkItem(projectId, addWorkItemRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addInputWorkItem(projectId, addWorkItemRequest, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Add Suite
         * @param {number} projectId
         * @param {AddSuiteRequest} addSuiteRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addSuite(projectId, addSuiteRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addSuite(projectId, addSuiteRequest, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Close Project
         * @param {number} projectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async closeProject(projectId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.closeProject(projectId, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Delete Locator
         * @param {number} projectId
         * @param {DeleteLocatorRequest} deleteLocatorRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteLocator(projectId, deleteLocatorRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteLocator(projectId, deleteLocatorRequest, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Export Project
         * @param {number} projectId
         * @param {string} path
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exportProject(projectId, path, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exportProject(projectId, path, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Export Project By Path
         * @param {string} src
         * @param {string} dst
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exportProjectByPath(src, dst, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exportProjectByPath(src, dst, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get Code
         * @param {number} projectId
         * @param {string} path
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCode(projectId, path, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCode(projectId, path, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get Current Input Work Item
         * @param {number} projectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCurrentInputWorkItem(projectId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCurrentInputWorkItem(projectId, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get Keywords
         * @param {number} projectId
         * @param {string} [library]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getKeywords(projectId, library, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getKeywords(projectId, library, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get Locators
         * @param {number} projectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLocators(projectId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLocators(projectId, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get Metadata
         * @param {number} projectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMetadata(projectId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMetadata(projectId, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get Model
         * @param {number} projectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getModel(projectId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getModel(projectId, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get Variables
         * @param {number} projectId
         * @param {string} [source]
         * @param {number} [lineno]
         * @param {boolean} [showHidden]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVariables(projectId, source, lineno, showHidden, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVariables(projectId, source, lineno, showHidden, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary List Files
         * @param {number} projectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listFiles(projectId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listFiles(projectId, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary List Input Work Items
         * @param {number} projectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listInputWorkItems(projectId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listInputWorkItems(projectId, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary List Output Work Items
         * @param {number} projectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOutputWorkItems(projectId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOutputWorkItems(projectId, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary List Runs
         * @param {number} projectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRuns(projectId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRuns(projectId, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Open Project
         * @param {ProjectRequest} projectRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async openProject(projectRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.openProject(projectRequest, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Remove Input Work Item
         * @param {number} projectId
         * @param {RemoveWorkItemRequest} removeWorkItemRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeInputWorkItem(projectId, removeWorkItemRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeInputWorkItem(projectId, removeWorkItemRequest, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Remove Output Work Item
         * @param {number} projectId
         * @param {RemoveWorkItemRequest} removeWorkItemRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeOutputWorkItem(projectId, removeWorkItemRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeOutputWorkItem(projectId, removeWorkItemRequest, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Remove Suite
         * @param {number} projectId
         * @param {RemoveSuiteRequest} removeSuiteRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeSuite(projectId, removeSuiteRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeSuite(projectId, removeSuiteRequest, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Rename Suite
         * @param {number} projectId
         * @param {RenameSuiteRequest} renameSuiteRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async renameSuite(projectId, renameSuiteRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.renameSuite(projectId, renameSuiteRequest, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Run Event
         * @param {number} runId
         * @param {number} projectId
         * @param {RunEventRequest} runEventRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async runEvent(runId, projectId, runEventRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.runEvent(runId, projectId, runEventRequest, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Run Status
         * @param {number} runId
         * @param {number} projectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async runStatus(runId, projectId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.runStatus(runId, projectId, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Run Stream
         * @param {number} runId
         * @param {number} projectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async runStream(runId, projectId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.runStream(runId, projectId, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Run Work Items
         * @param {number} projectId
         * @param {number} runId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async runWorkItems(projectId, runId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.runWorkItems(projectId, runId, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Save Locator
         * @param {number} projectId
         * @param {SaveLocatorRequest} saveLocatorRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveLocator(projectId, saveLocatorRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveLocator(projectId, saveLocatorRequest, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Set Code
         * @param {number} projectId
         * @param {CodeRequest} codeRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setCode(projectId, codeRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setCode(projectId, codeRequest, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Set Current Input Work Item
         * @param {number} projectId
         * @param {CurrentWorkItemRequest} currentWorkItemRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setCurrentInputWorkItem(projectId, currentWorkItemRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setCurrentInputWorkItem(projectId, currentWorkItemRequest, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Set Model
         * @param {number} projectId
         * @param {Suite} suite
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setModel(projectId, suite, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setModel(projectId, suite, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Start Run
         * @param {number} projectId
         * @param {RunRequest} runRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startRun(projectId, runRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startRun(projectId, runRequest, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Stop Run
         * @param {number} projectId
         * @param {StopRequest} stopRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stopRun(projectId, stopRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stopRun(projectId, stopRequest, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
    };
};
exports.ProjectsApiFp = ProjectsApiFp;
/**
 * ProjectsApi - factory interface
 * @export
 */
const ProjectsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.ProjectsApiFp)(configuration);
    return {
        /**
         *
         * @summary Add Input Work Item
         * @param {number} projectId
         * @param {AddWorkItemRequest} addWorkItemRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addInputWorkItem(projectId, addWorkItemRequest, options) {
            return localVarFp
                .addInputWorkItem(projectId, addWorkItemRequest, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Add Suite
         * @param {number} projectId
         * @param {AddSuiteRequest} addSuiteRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSuite(projectId, addSuiteRequest, options) {
            return localVarFp
                .addSuite(projectId, addSuiteRequest, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Close Project
         * @param {number} projectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        closeProject(projectId, options) {
            return localVarFp
                .closeProject(projectId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete Locator
         * @param {number} projectId
         * @param {DeleteLocatorRequest} deleteLocatorRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLocator(projectId, deleteLocatorRequest, options) {
            return localVarFp
                .deleteLocator(projectId, deleteLocatorRequest, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Export Project
         * @param {number} projectId
         * @param {string} path
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportProject(projectId, path, options) {
            return localVarFp
                .exportProject(projectId, path, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Export Project By Path
         * @param {string} src
         * @param {string} dst
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportProjectByPath(src, dst, options) {
            return localVarFp
                .exportProjectByPath(src, dst, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get Code
         * @param {number} projectId
         * @param {string} path
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCode(projectId, path, options) {
            return localVarFp
                .getCode(projectId, path, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get Current Input Work Item
         * @param {number} projectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentInputWorkItem(projectId, options) {
            return localVarFp
                .getCurrentInputWorkItem(projectId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get Keywords
         * @param {number} projectId
         * @param {string} [library]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKeywords(projectId, library, options) {
            return localVarFp
                .getKeywords(projectId, library, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get Locators
         * @param {number} projectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLocators(projectId, options) {
            return localVarFp
                .getLocators(projectId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get Metadata
         * @param {number} projectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetadata(projectId, options) {
            return localVarFp
                .getMetadata(projectId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get Model
         * @param {number} projectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getModel(projectId, options) {
            return localVarFp
                .getModel(projectId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get Variables
         * @param {number} projectId
         * @param {string} [source]
         * @param {number} [lineno]
         * @param {boolean} [showHidden]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVariables(projectId, source, lineno, showHidden, options) {
            return localVarFp
                .getVariables(projectId, source, lineno, showHidden, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary List Files
         * @param {number} projectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFiles(projectId, options) {
            return localVarFp
                .listFiles(projectId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary List Input Work Items
         * @param {number} projectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listInputWorkItems(projectId, options) {
            return localVarFp
                .listInputWorkItems(projectId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary List Output Work Items
         * @param {number} projectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOutputWorkItems(projectId, options) {
            return localVarFp
                .listOutputWorkItems(projectId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary List Runs
         * @param {number} projectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRuns(projectId, options) {
            return localVarFp
                .listRuns(projectId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Open Project
         * @param {ProjectRequest} projectRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        openProject(projectRequest, options) {
            return localVarFp
                .openProject(projectRequest, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Remove Input Work Item
         * @param {number} projectId
         * @param {RemoveWorkItemRequest} removeWorkItemRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeInputWorkItem(projectId, removeWorkItemRequest, options) {
            return localVarFp
                .removeInputWorkItem(projectId, removeWorkItemRequest, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Remove Output Work Item
         * @param {number} projectId
         * @param {RemoveWorkItemRequest} removeWorkItemRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeOutputWorkItem(projectId, removeWorkItemRequest, options) {
            return localVarFp
                .removeOutputWorkItem(projectId, removeWorkItemRequest, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Remove Suite
         * @param {number} projectId
         * @param {RemoveSuiteRequest} removeSuiteRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeSuite(projectId, removeSuiteRequest, options) {
            return localVarFp
                .removeSuite(projectId, removeSuiteRequest, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Rename Suite
         * @param {number} projectId
         * @param {RenameSuiteRequest} renameSuiteRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        renameSuite(projectId, renameSuiteRequest, options) {
            return localVarFp
                .renameSuite(projectId, renameSuiteRequest, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Run Event
         * @param {number} runId
         * @param {number} projectId
         * @param {RunEventRequest} runEventRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runEvent(runId, projectId, runEventRequest, options) {
            return localVarFp
                .runEvent(runId, projectId, runEventRequest, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Run Status
         * @param {number} runId
         * @param {number} projectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runStatus(runId, projectId, options) {
            return localVarFp
                .runStatus(runId, projectId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Run Stream
         * @param {number} runId
         * @param {number} projectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runStream(runId, projectId, options) {
            return localVarFp
                .runStream(runId, projectId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Run Work Items
         * @param {number} projectId
         * @param {number} runId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runWorkItems(projectId, runId, options) {
            return localVarFp
                .runWorkItems(projectId, runId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Save Locator
         * @param {number} projectId
         * @param {SaveLocatorRequest} saveLocatorRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveLocator(projectId, saveLocatorRequest, options) {
            return localVarFp
                .saveLocator(projectId, saveLocatorRequest, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Set Code
         * @param {number} projectId
         * @param {CodeRequest} codeRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setCode(projectId, codeRequest, options) {
            return localVarFp
                .setCode(projectId, codeRequest, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Set Current Input Work Item
         * @param {number} projectId
         * @param {CurrentWorkItemRequest} currentWorkItemRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setCurrentInputWorkItem(projectId, currentWorkItemRequest, options) {
            return localVarFp
                .setCurrentInputWorkItem(projectId, currentWorkItemRequest, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Set Model
         * @param {number} projectId
         * @param {Suite} suite
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setModel(projectId, suite, options) {
            return localVarFp
                .setModel(projectId, suite, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Start Run
         * @param {number} projectId
         * @param {RunRequest} runRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startRun(projectId, runRequest, options) {
            return localVarFp
                .startRun(projectId, runRequest, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Stop Run
         * @param {number} projectId
         * @param {StopRequest} stopRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopRun(projectId, stopRequest, options) {
            return localVarFp
                .stopRun(projectId, stopRequest, options)
                .then((request) => request(axios, basePath));
        },
    };
};
exports.ProjectsApiFactory = ProjectsApiFactory;
/**
 * ProjectsApi - object-oriented interface
 * @export
 * @class ProjectsApi
 * @extends {BaseAPI}
 */
class ProjectsApi extends base_1.BaseAPI {
    /**
     *
     * @summary Add Input Work Item
     * @param {number} projectId
     * @param {AddWorkItemRequest} addWorkItemRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    addInputWorkItem(projectId, addWorkItemRequest, options) {
        return (0, exports.ProjectsApiFp)(this.configuration)
            .addInputWorkItem(projectId, addWorkItemRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Add Suite
     * @param {number} projectId
     * @param {AddSuiteRequest} addSuiteRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    addSuite(projectId, addSuiteRequest, options) {
        return (0, exports.ProjectsApiFp)(this.configuration)
            .addSuite(projectId, addSuiteRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Close Project
     * @param {number} projectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    closeProject(projectId, options) {
        return (0, exports.ProjectsApiFp)(this.configuration)
            .closeProject(projectId, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Delete Locator
     * @param {number} projectId
     * @param {DeleteLocatorRequest} deleteLocatorRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    deleteLocator(projectId, deleteLocatorRequest, options) {
        return (0, exports.ProjectsApiFp)(this.configuration)
            .deleteLocator(projectId, deleteLocatorRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Export Project
     * @param {number} projectId
     * @param {string} path
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    exportProject(projectId, path, options) {
        return (0, exports.ProjectsApiFp)(this.configuration)
            .exportProject(projectId, path, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Export Project By Path
     * @param {string} src
     * @param {string} dst
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    exportProjectByPath(src, dst, options) {
        return (0, exports.ProjectsApiFp)(this.configuration)
            .exportProjectByPath(src, dst, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get Code
     * @param {number} projectId
     * @param {string} path
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    getCode(projectId, path, options) {
        return (0, exports.ProjectsApiFp)(this.configuration)
            .getCode(projectId, path, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get Current Input Work Item
     * @param {number} projectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    getCurrentInputWorkItem(projectId, options) {
        return (0, exports.ProjectsApiFp)(this.configuration)
            .getCurrentInputWorkItem(projectId, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get Keywords
     * @param {number} projectId
     * @param {string} [library]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    getKeywords(projectId, library, options) {
        return (0, exports.ProjectsApiFp)(this.configuration)
            .getKeywords(projectId, library, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get Locators
     * @param {number} projectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    getLocators(projectId, options) {
        return (0, exports.ProjectsApiFp)(this.configuration)
            .getLocators(projectId, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get Metadata
     * @param {number} projectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    getMetadata(projectId, options) {
        return (0, exports.ProjectsApiFp)(this.configuration)
            .getMetadata(projectId, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get Model
     * @param {number} projectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    getModel(projectId, options) {
        return (0, exports.ProjectsApiFp)(this.configuration)
            .getModel(projectId, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get Variables
     * @param {number} projectId
     * @param {string} [source]
     * @param {number} [lineno]
     * @param {boolean} [showHidden]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    getVariables(projectId, source, lineno, showHidden, options) {
        return (0, exports.ProjectsApiFp)(this.configuration)
            .getVariables(projectId, source, lineno, showHidden, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary List Files
     * @param {number} projectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    listFiles(projectId, options) {
        return (0, exports.ProjectsApiFp)(this.configuration)
            .listFiles(projectId, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary List Input Work Items
     * @param {number} projectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    listInputWorkItems(projectId, options) {
        return (0, exports.ProjectsApiFp)(this.configuration)
            .listInputWorkItems(projectId, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary List Output Work Items
     * @param {number} projectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    listOutputWorkItems(projectId, options) {
        return (0, exports.ProjectsApiFp)(this.configuration)
            .listOutputWorkItems(projectId, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary List Runs
     * @param {number} projectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    listRuns(projectId, options) {
        return (0, exports.ProjectsApiFp)(this.configuration)
            .listRuns(projectId, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Open Project
     * @param {ProjectRequest} projectRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    openProject(projectRequest, options) {
        return (0, exports.ProjectsApiFp)(this.configuration)
            .openProject(projectRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Remove Input Work Item
     * @param {number} projectId
     * @param {RemoveWorkItemRequest} removeWorkItemRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    removeInputWorkItem(projectId, removeWorkItemRequest, options) {
        return (0, exports.ProjectsApiFp)(this.configuration)
            .removeInputWorkItem(projectId, removeWorkItemRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Remove Output Work Item
     * @param {number} projectId
     * @param {RemoveWorkItemRequest} removeWorkItemRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    removeOutputWorkItem(projectId, removeWorkItemRequest, options) {
        return (0, exports.ProjectsApiFp)(this.configuration)
            .removeOutputWorkItem(projectId, removeWorkItemRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Remove Suite
     * @param {number} projectId
     * @param {RemoveSuiteRequest} removeSuiteRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    removeSuite(projectId, removeSuiteRequest, options) {
        return (0, exports.ProjectsApiFp)(this.configuration)
            .removeSuite(projectId, removeSuiteRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Rename Suite
     * @param {number} projectId
     * @param {RenameSuiteRequest} renameSuiteRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    renameSuite(projectId, renameSuiteRequest, options) {
        return (0, exports.ProjectsApiFp)(this.configuration)
            .renameSuite(projectId, renameSuiteRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Run Event
     * @param {number} runId
     * @param {number} projectId
     * @param {RunEventRequest} runEventRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    runEvent(runId, projectId, runEventRequest, options) {
        return (0, exports.ProjectsApiFp)(this.configuration)
            .runEvent(runId, projectId, runEventRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Run Status
     * @param {number} runId
     * @param {number} projectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    runStatus(runId, projectId, options) {
        return (0, exports.ProjectsApiFp)(this.configuration)
            .runStatus(runId, projectId, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Run Stream
     * @param {number} runId
     * @param {number} projectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    runStream(runId, projectId, options) {
        return (0, exports.ProjectsApiFp)(this.configuration)
            .runStream(runId, projectId, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Run Work Items
     * @param {number} projectId
     * @param {number} runId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    runWorkItems(projectId, runId, options) {
        return (0, exports.ProjectsApiFp)(this.configuration)
            .runWorkItems(projectId, runId, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Save Locator
     * @param {number} projectId
     * @param {SaveLocatorRequest} saveLocatorRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    saveLocator(projectId, saveLocatorRequest, options) {
        return (0, exports.ProjectsApiFp)(this.configuration)
            .saveLocator(projectId, saveLocatorRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Set Code
     * @param {number} projectId
     * @param {CodeRequest} codeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    setCode(projectId, codeRequest, options) {
        return (0, exports.ProjectsApiFp)(this.configuration)
            .setCode(projectId, codeRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Set Current Input Work Item
     * @param {number} projectId
     * @param {CurrentWorkItemRequest} currentWorkItemRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    setCurrentInputWorkItem(projectId, currentWorkItemRequest, options) {
        return (0, exports.ProjectsApiFp)(this.configuration)
            .setCurrentInputWorkItem(projectId, currentWorkItemRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Set Model
     * @param {number} projectId
     * @param {Suite} suite
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    setModel(projectId, suite, options) {
        return (0, exports.ProjectsApiFp)(this.configuration)
            .setModel(projectId, suite, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Start Run
     * @param {number} projectId
     * @param {RunRequest} runRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    startRun(projectId, runRequest, options) {
        return (0, exports.ProjectsApiFp)(this.configuration)
            .startRun(projectId, runRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Stop Run
     * @param {number} projectId
     * @param {StopRequest} stopRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    stopRun(projectId, stopRequest, options) {
        return (0, exports.ProjectsApiFp)(this.configuration)
            .stopRun(projectId, stopRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }
}
exports.ProjectsApi = ProjectsApi;
/**
 * StatusApi - axios parameter creator
 * @export
 */
const StatusApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        status: async (options = {}) => {
            const localVarPath = `/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'GET',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.StatusApiAxiosParamCreator = StatusApiAxiosParamCreator;
/**
 * StatusApi - functional programming interface
 * @export
 */
const StatusApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.StatusApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async status(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.status(options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
    };
};
exports.StatusApiFp = StatusApiFp;
/**
 * StatusApi - factory interface
 * @export
 */
const StatusApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.StatusApiFp)(configuration);
    return {
        /**
         *
         * @summary Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        status(options) {
            return localVarFp
                .status(options)
                .then((request) => request(axios, basePath));
        },
    };
};
exports.StatusApiFactory = StatusApiFactory;
/**
 * StatusApi - object-oriented interface
 * @export
 * @class StatusApi
 * @extends {BaseAPI}
 */
class StatusApi extends base_1.BaseAPI {
    /**
     *
     * @summary Status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatusApi
     */
    status(options) {
        return (0, exports.StatusApiFp)(this.configuration)
            .status(options)
            .then((request) => request(this.axios, this.basePath));
    }
}
exports.StatusApi = StatusApi;
/**
 * UtilitiesApi - axios parameter creator
 * @export
 */
const UtilitiesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Validate Variable
         * @param {ValidateVariableRequest} validateVariableRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateVariable: async (validateVariableRequest, options = {}) => {
            // verify required parameter 'validateVariableRequest' is not null or undefined
            (0, common_1.assertParamExists)('validateVariable', 'validateVariableRequest', validateVariableRequest);
            const localVarPath = `/utilities/validate/variable`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'POST',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(validateVariableRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.UtilitiesApiAxiosParamCreator = UtilitiesApiAxiosParamCreator;
/**
 * UtilitiesApi - functional programming interface
 * @export
 */
const UtilitiesApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.UtilitiesApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Validate Variable
         * @param {ValidateVariableRequest} validateVariableRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validateVariable(validateVariableRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validateVariable(validateVariableRequest, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
    };
};
exports.UtilitiesApiFp = UtilitiesApiFp;
/**
 * UtilitiesApi - factory interface
 * @export
 */
const UtilitiesApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.UtilitiesApiFp)(configuration);
    return {
        /**
         *
         * @summary Validate Variable
         * @param {ValidateVariableRequest} validateVariableRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateVariable(validateVariableRequest, options) {
            return localVarFp
                .validateVariable(validateVariableRequest, options)
                .then((request) => request(axios, basePath));
        },
    };
};
exports.UtilitiesApiFactory = UtilitiesApiFactory;
/**
 * UtilitiesApi - object-oriented interface
 * @export
 * @class UtilitiesApi
 * @extends {BaseAPI}
 */
class UtilitiesApi extends base_1.BaseAPI {
    /**
     *
     * @summary Validate Variable
     * @param {ValidateVariableRequest} validateVariableRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UtilitiesApi
     */
    validateVariable(validateVariableRequest, options) {
        return (0, exports.UtilitiesApiFp)(this.configuration)
            .validateVariable(validateVariableRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }
}
exports.UtilitiesApi = UtilitiesApi;


/***/ }),

/***/ 5262:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/* tslint:disable */
/* eslint-disable */
/**
 * robotd
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RequiredError = exports.BaseAPI = exports.COLLECTION_FORMATS = exports.BASE_PATH = void 0;
// Some imports not used depending on template conditions
// @ts-ignore
const axios_1 = __importDefault(__webpack_require__(795));
exports.BASE_PATH = 'http://localhost'.replace(/\/+$/, '');
/**
 *
 * @export
 */
exports.COLLECTION_FORMATS = {
    csv: ',',
    ssv: ' ',
    tsv: '\t',
    pipes: '|',
};
/**
 *
 * @export
 * @class BaseAPI
 */
class BaseAPI {
    constructor(configuration, basePath = exports.BASE_PATH, axios = axios_1.default) {
        this.basePath = basePath;
        this.axios = axios;
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
}
exports.BaseAPI = BaseAPI;
/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
class RequiredError extends Error {
    constructor(field, msg) {
        super(msg);
        this.field = field;
        this.name = 'RequiredError';
    }
}
exports.RequiredError = RequiredError;


/***/ }),

/***/ 3424:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* tslint:disable */
/* eslint-disable */
/**
 * robotd
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createRequestFunction = exports.toPathString = exports.serializeDataIfNeeded = exports.setSearchParams = exports.setOAuthToObject = exports.setBearerAuthToObject = exports.setBasicAuthToObject = exports.setApiKeyToObject = exports.assertParamExists = exports.DUMMY_BASE_URL = void 0;
const base_1 = __webpack_require__(5262);
/**
 *
 * @export
 */
exports.DUMMY_BASE_URL = 'https://example.com';
/**
 *
 * @throws {RequiredError}
 * @export
 */
const assertParamExists = function (functionName, paramName, paramValue) {
    if (paramValue === null || paramValue === undefined) {
        throw new base_1.RequiredError(paramName, `Required parameter ${paramName} was null or undefined when calling ${functionName}.`);
    }
};
exports.assertParamExists = assertParamExists;
/**
 *
 * @export
 */
const setApiKeyToObject = async function (object, keyParamName, configuration) {
    if (configuration && configuration.apiKey) {
        const localVarApiKeyValue = typeof configuration.apiKey === 'function'
            ? await configuration.apiKey(keyParamName)
            : await configuration.apiKey;
        object[keyParamName] = localVarApiKeyValue;
    }
};
exports.setApiKeyToObject = setApiKeyToObject;
/**
 *
 * @export
 */
const setBasicAuthToObject = function (object, configuration) {
    if (configuration && (configuration.username || configuration.password)) {
        object['auth'] = {
            username: configuration.username,
            password: configuration.password,
        };
    }
};
exports.setBasicAuthToObject = setBasicAuthToObject;
/**
 *
 * @export
 */
const setBearerAuthToObject = async function (object, configuration) {
    if (configuration && configuration.accessToken) {
        const accessToken = typeof configuration.accessToken === 'function'
            ? await configuration.accessToken()
            : await configuration.accessToken;
        object['Authorization'] = 'Bearer ' + accessToken;
    }
};
exports.setBearerAuthToObject = setBearerAuthToObject;
/**
 *
 * @export
 */
const setOAuthToObject = async function (object, name, scopes, configuration) {
    if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
            ? await configuration.accessToken(name, scopes)
            : await configuration.accessToken;
        object['Authorization'] = 'Bearer ' + localVarAccessTokenValue;
    }
};
exports.setOAuthToObject = setOAuthToObject;
/**
 *
 * @export
 */
const setSearchParams = function (url, ...objects) {
    const searchParams = new URLSearchParams(url.search);
    for (const object of objects) {
        for (const key in object) {
            if (Array.isArray(object[key])) {
                searchParams.delete(key);
                for (const item of object[key]) {
                    searchParams.append(key, item);
                }
            }
            else {
                searchParams.set(key, object[key]);
            }
        }
    }
    url.search = searchParams.toString();
};
exports.setSearchParams = setSearchParams;
/**
 *
 * @export
 */
const serializeDataIfNeeded = function (value, requestOptions, configuration) {
    const nonString = typeof value !== 'string';
    const needsSerialization = nonString && configuration && configuration.isJsonMime
        ? configuration.isJsonMime(requestOptions.headers['Content-Type'])
        : nonString;
    return needsSerialization
        ? JSON.stringify(value !== undefined ? value : {})
        : value || '';
};
exports.serializeDataIfNeeded = serializeDataIfNeeded;
/**
 *
 * @export
 */
const toPathString = function (url) {
    return url.pathname + url.search + url.hash;
};
exports.toPathString = toPathString;
/**
 *
 * @export
 */
const createRequestFunction = function (axiosArgs, globalAxios, BASE_PATH, configuration) {
    return (axios = globalAxios, basePath = BASE_PATH) => {
        const axiosRequestArgs = {
            ...axiosArgs.options,
            url: (configuration?.basePath || basePath) + axiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
    };
};
exports.createRequestFunction = createRequestFunction;


/***/ }),

/***/ 2088:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/* tslint:disable */
/* eslint-disable */
/**
 * robotd
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Configuration = void 0;
class Configuration {
    constructor(param = {}) {
        this.apiKey = param.apiKey;
        this.username = param.username;
        this.password = param.password;
        this.accessToken = param.accessToken;
        this.basePath = param.basePath;
        this.baseOptions = param.baseOptions;
        this.formDataCtor = param.formDataCtor;
    }
    /**
     * Check if the given MIME is a JSON MIME.
     * JSON MIME examples:
     *   application/json
     *   application/json; charset=UTF8
     *   APPLICATION/JSON
     *   application/vnd.company+json
     * @param mime - MIME (Multipurpose Internet Mail Extensions)
     * @return True if the given MIME is JSON, false otherwise.
     */
    isJsonMime(mime) {
        const jsonMime = new RegExp('^(application/json|[^;/ \t]+/[^;/ \t]+[+]json)[ \t]*(;.*)?$', 'i');
        return (mime !== null &&
            (jsonMime.test(mime) ||
                mime.toLowerCase() === 'application/json-patch+json'));
    }
}
exports.Configuration = Configuration;


/***/ }),

/***/ 9080:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/* tslint:disable */
/* eslint-disable */
/**
 * robotd
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(9771), exports);
__exportStar(__webpack_require__(2088), exports);


/***/ }),

/***/ 6115:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(3251), exports);
__exportStar(__webpack_require__(3901), exports);
__exportStar(__webpack_require__(3233), exports);
__exportStar(__webpack_require__(5482), exports);


/***/ }),

/***/ 3251:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InspectorBase = void 0;
const renderer_1 = __webpack_require__(1977);
const robotd_1 = __webpack_require__(695);
class InspectorBase {
    constructor() {
        this.setProjectId = (projectId) => {
            this._projectId = projectId;
        };
        this.getProjectId = () => this._projectId;
        this.stop = async () => {
            await window.ipc.invoke('closeWindow');
            await robotd_1.robotd.inspectorStopBrowser();
        };
        this.save = async (name, locator, existingLocator) => {
            if (this._projectId === null)
                return;
            if (existingLocator) {
                await robotd_1.robotd.deleteLocator(this._projectId, existingLocator);
            }
            await robotd_1.robotd.saveLocator(this._projectId, name, locator);
            await renderer_1.ipcRenderer.invoke('locatorsChanged', this._projectId, name);
        };
        this.windowSize = async (height) => {
            await renderer_1.ipcRenderer.invoke('setInspectorWindowSize', height);
        };
        this._projectId = null;
    }
}
exports.InspectorBase = InspectorBase;


/***/ }),

/***/ 3901:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.browserInspector = exports.BrowserInspector = void 0;
const robotd_1 = __webpack_require__(695);
const robotd_2 = __webpack_require__(9080);
const inspector_1 = __webpack_require__(6115);
class BrowserInspector extends inspector_1.InspectorBase {
    constructor() {
        super();
        this.status = async () => {
            const { status } = await robotd_1.robotd.inspectorStatusBrowser();
            return status;
        };
        this.list = async () => {
            const { browsers } = await robotd_1.robotd.inspectorListBrowser();
            return browsers;
        };
        this.connect = async (browser) => {
            await robotd_1.robotd.inspectorConnectBrowser(browser);
        };
        this.start = async (url) => {
            return robotd_1.robotd.inspectorStartBrowser(url, robotd_2.InspectorType.Picker);
        };
        this.pick = async () => {
            const { options } = await robotd_1.robotd.inspectorPickBrowser();
            return options;
        };
        this.validate = async (strategy, value) => {
            const response = await robotd_1.robotd.inspectorValidateBrowser({ strategy, value });
            return {
                matches: response.matches,
                source: response.url,
                screenshot: response.screenshot,
            };
        };
        this.focus = async (index) => {
            await robotd_1.robotd.inspectorFocusBrowser(index);
        };
    }
}
exports.BrowserInspector = BrowserInspector;
exports.browserInspector = new BrowserInspector();


/***/ }),

/***/ 3233:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.recorderInspector = exports.RecorderInspector = void 0;
const robotd_1 = __webpack_require__(695);
const inspector_1 = __webpack_require__(6115);
const robotd_2 = __webpack_require__(9080);
class RecorderInspector extends inspector_1.BrowserInspector {
    constructor() {
        super();
        this.start = async (url) => {
            return robotd_1.robotd.inspectorStartBrowser(url, robotd_2.InspectorType.WebRecorder);
        };
        this.getLocators = async () => {
            const projectId = this.getProjectId();
            if (projectId !== null) {
                const { locators } = await robotd_1.robotd.getLocators(projectId);
                return locators;
            }
            return {};
        };
        this.record = async () => {
            const response = await robotd_1.robotd.inspectorRecord();
            return response.ops;
        };
        this.stopRecording = async () => {
            const response = await robotd_1.robotd.inspectorStopRecording();
            return response.ops;
        };
    }
}
exports.RecorderInspector = RecorderInspector;
exports.recorderInspector = new RecorderInspector();


/***/ }),

/***/ 5482:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.windowsInspector = exports.WindowsInspector = void 0;
const inspector_1 = __webpack_require__(6115);
const robotd_1 = __webpack_require__(695);
const renderer_1 = __webpack_require__(1977);
const robotd_2 = __webpack_require__(9080);
class WindowsInspector extends inspector_1.InspectorBase {
    constructor() {
        super();
        this.listWindows = async () => {
            const result = await renderer_1.ipcRenderer.invoke('getWindowTitles');
            const { windows } = await robotd_1.robotd.inspectorListWindows(result.titles);
            return windows;
        };
        this.pick = async (window) => {
            const { locators } = await robotd_1.robotd.inspectorPickWindow(window);
            const pickResults = locators.map((locator) => ({
                type: robotd_2.DocType.Locator,
                kind: robotd_2.LocatorType.Windows,
                value: locator.value,
                window: locator.window,
                version: locator.version,
                screenshot: locator.screenshot,
            }));
            return pickResults;
        };
        this.validate = async (window, value) => {
            const response = await robotd_1.robotd.inspectorValidateWindow(window, value);
            return {
                matches: response.matches,
            };
        };
        this.focus = async (window, value) => {
            await robotd_1.robotd.inspectorFocusWindow(window, value);
        };
        this._latestWindow = null;
        renderer_1.ipcRenderer.invoke('getLatestWindow').then((win) => {
            this._latestWindow = win;
        });
    }
    get latestWindow() {
        return this._latestWindow;
    }
    set latestWindow(window) {
        this._latestWindow = window;
        renderer_1.ipcRenderer.invoke('setLatestWindow', window);
    }
}
exports.WindowsInspector = WindowsInspector;
exports.windowsInspector = new WindowsInspector();


/***/ }),

/***/ 1977:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ipcRenderer = void 0;
const ipc_1 = __webpack_require__(8023);
exports.ipcRenderer = {
    invoke: async (type, ...args) => {
        if (!window.ipc)
            throw new Error('Electron IPC not available');
        const result = (await window.ipc.invoke(type, ...args));
        return (0, ipc_1.unwrap)(result);
    },
    on: (type, listener) => {
        // eslint-disable-next-line @typescript-eslint/no-empty-function
        if (!window.ipc)
            return () => { };
        return window.ipc.on(type, listener);
    },
    removeAllListeners: (type) => {
        if (window.ipc)
            window.ipc.removeAllListeners(type);
    },
};


/***/ }),

/***/ 2794:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RobotdClient = void 0;
const axios_1 = __importDefault(__webpack_require__(795));
const robotd_1 = __webpack_require__(9080);
const types_1 = __webpack_require__(9581);
const errors_1 = __webpack_require__(9823);
const renderer_1 = __webpack_require__(1977);
class RobotdClient {
    constructor() {
        this._listeners = [];
        this._port = null;
        this._status = null;
        this._projects = null;
        this._inspector = null;
        this._utilities = null;
        renderer_1.ipcRenderer.on('robotdStatusChange', (_, port) => this.setPort(port));
        renderer_1.ipcRenderer.invoke('getRobotdStatus').then(({ port }) => {
            if (port) {
                this.setPort(port);
            }
        });
    }
    setPort(port) {
        console.log(`robotd available [port=${port}]`);
        this._port = port;
        const config = new robotd_1.Configuration({ basePath: `http://localhost:${port}` });
        this._status = new robotd_1.StatusApi(config);
        this._projects = new robotd_1.ProjectsApi(config);
        this._inspector = new robotd_1.InspectorApi(config);
        this._utilities = new robotd_1.UtilitiesApi(config);
        this._listeners.forEach((resolve) => resolve());
        this._listeners = [];
    }
    waitPort() {
        return new Promise((resolve) => {
            if (this._port) {
                resolve();
            }
            else {
                this._listeners.push(resolve);
            }
        });
    }
    async statusApi() {
        await this.waitPort();
        if (!this._status)
            throw new Error('No status API available');
        return this._status;
    }
    async projectsApi() {
        await this.waitPort();
        if (!this._projects)
            throw new Error('No projects API available');
        return this._projects;
    }
    async inspectorApi() {
        await this.waitPort();
        if (!this._inspector)
            throw new Error('No inspector API available');
        return this._inspector;
    }
    async utilitiesApi() {
        await this.waitPort();
        if (!this._utilities)
            throw new Error('No utilities API available');
        return this._utilities;
    }
    handleError(error) {
        if (axios_1.default.isAxiosError(error)) {
            const response = error?.response?.data;
            if ((0, errors_1.isErrorResponse)(response)) {
                throw new errors_1.ErrorResponse(response.error_code, response.message);
            }
        }
        throw error;
    }
    // TODO: Figure out some decent pattern to de-duplicate code
    async getStatus() {
        const api = await this.statusApi();
        const response = await api.status();
        return response.data;
    }
    async exportProjectByPath(src, path) {
        const api = await this.projectsApi();
        try {
            await api.exportProjectByPath(src, path);
        }
        catch (error) {
            this.handleError(error);
        }
    }
    async openProject(path, runnerPath) {
        const api = await this.projectsApi();
        try {
            const response = await api.openProject({ path, runner_path: runnerPath });
            return response.data;
        }
        catch (error) {
            this.handleError(error);
        }
    }
    async closeProject(projectId) {
        const api = await this.projectsApi();
        await api.closeProject(projectId);
    }
    async getMetadata(projectId) {
        const api = await this.projectsApi();
        const response = await api.getMetadata(projectId);
        return response.data;
    }
    async listFiles(projectId) {
        const api = await this.projectsApi();
        const response = await api.listFiles(projectId);
        return response.data;
    }
    async getModel(projectId) {
        const api = await this.projectsApi();
        const response = await api.getModel(projectId);
        return response.data;
    }
    async setModel(projectId, model) {
        const api = await this.projectsApi();
        const response = await api.setModel(projectId, model);
        return response.data;
    }
    async addSuite(projectId, source, name) {
        const api = await this.projectsApi();
        try {
            const response = await api.addSuite(projectId, { source, name });
            return response.data;
        }
        catch (error) {
            this.handleError(error);
        }
    }
    async renameSuite(projectId, source, name) {
        const api = await this.projectsApi();
        try {
            const response = await api.renameSuite(projectId, { source, name });
            return response.data;
        }
        catch (error) {
            this.handleError(error);
        }
    }
    async removeSuite(projectId, source) {
        const api = await this.projectsApi();
        try {
            const response = await api.removeSuite(projectId, { source });
            return response.data;
        }
        catch (error) {
            this.handleError(error);
        }
    }
    async getCode(projectId, path) {
        const api = await this.projectsApi();
        const response = await api.getCode(projectId, path);
        return response.data;
    }
    async setCode(projectId, path, content, tidy = false) {
        const request = { path, content };
        const api = await this.projectsApi();
        const response = await api.setCode(projectId, request, tidy);
        return response.data;
    }
    async getKeywords(projectId, library) {
        const api = await this.projectsApi();
        const response = await api.getKeywords(projectId, library);
        return response.data;
    }
    async getVariables(projectId, source, lineno, showHidden = false) {
        const api = await this.projectsApi();
        const response = await api.getVariables(projectId, source, lineno, showHidden);
        return response.data;
    }
    async listRuns(projectId) {
        const api = await this.projectsApi();
        const response = await api.listRuns(projectId);
        return response.data;
    }
    async startRun(projectId, ref, env) {
        const api = await this.projectsApi();
        renderer_1.ipcRenderer.invoke('sendMetrics', types_1.Metrics.RUN_ROBOT, '');
        const response = await api.startRun(projectId, { ref, env: env || {} });
        return response.data;
    }
    async stopRun(projectId, runId) {
        const api = await this.projectsApi();
        await api.stopRun(projectId, { run_id: runId });
    }
    getRunStreamUrl(projectId, runId) {
        return `http://localhost:${this._port}/projects/${projectId}/run/${runId}/stream`;
    }
    async runWorkItems(projectId, runId) {
        const api = await this.projectsApi();
        const response = await api.runWorkItems(projectId, runId);
        return response.data;
    }
    async exportProject(projectId, path) {
        const api = await this.projectsApi();
        try {
            await api.exportProject(projectId, path);
        }
        catch (error) {
            this.handleError(error);
        }
    }
    async inspectorStatus() {
        const api = await this.inspectorApi();
        const response = await api.inspectorStatus();
        return response.data;
    }
    async inspectorStatusBrowser() {
        const api = await this.inspectorApi();
        const response = await api.browserStatus();
        return response.data;
    }
    async inspectorStartBrowser(url, type) {
        const api = await this.inspectorApi();
        try {
            await api.startBrowser({ url, type });
        }
        catch (error) {
            this.handleError(error);
        }
    }
    async inspectorStopBrowser() {
        const api = await this.inspectorApi();
        try {
            await api.stopBrowser();
        }
        catch (error) {
            this.handleError(error);
        }
    }
    async inspectorConnectBrowser(browser) {
        const api = await this.inspectorApi();
        await api.connectBrowser({ browser });
    }
    async inspectorListBrowser() {
        const api = await this.inspectorApi();
        const response = await api.listBrowser();
        return response.data;
    }
    async inspectorPickBrowser() {
        const api = await this.inspectorApi();
        try {
            const response = await api.pickBrowser();
            return response.data;
        }
        catch (error) {
            this.handleError(error);
        }
    }
    async inspectorValidateBrowser(selector) {
        const api = await this.inspectorApi();
        try {
            const response = await api.validateBrowser({ selector });
            return response.data;
        }
        catch (error) {
            this.handleError(error);
        }
    }
    async inspectorFocusBrowser(index) {
        const api = await this.inspectorApi();
        try {
            await api.focusBrowser({ index });
        }
        catch (error) {
            this.handleError(error);
        }
    }
    async inspectorListWindows(exclude) {
        const api = await this.inspectorApi();
        const response = await api.listWindows(exclude);
        return response.data;
    }
    async inspectorPickWindow(window) {
        const api = await this.inspectorApi();
        try {
            const response = await api.pickWindow({ window });
            return response.data;
        }
        catch (error) {
            this.handleError(error);
        }
    }
    async inspectorValidateWindow(window, value) {
        const api = await this.inspectorApi();
        try {
            const response = await api.validateWindow({ window, value });
            return response.data;
        }
        catch (error) {
            this.handleError(error);
        }
    }
    async inspectorFocusWindow(window, value) {
        const api = await this.inspectorApi();
        try {
            await api.focusWindow({ window, value });
        }
        catch (error) {
            this.handleError(error);
        }
    }
    async inspectorRecord() {
        const api = await this.inspectorApi();
        try {
            const response = await api.recordBrowser();
            return response.data;
        }
        catch (error) {
            this.handleError(error);
        }
    }
    async inspectorStopRecording() {
        const api = await this.inspectorApi();
        try {
            const response = await api.stopRecordingBrowser();
            return response.data;
        }
        catch (error) {
            this.handleError(error);
        }
    }
    async getLocators(projectId) {
        const api = await this.projectsApi();
        const response = await api.getLocators(projectId);
        return response.data;
    }
    async saveLocator(projectId, name, locator) {
        const api = await this.projectsApi();
        const response = await api.saveLocator(projectId, { name, locator });
        return response.data;
    }
    async deleteLocator(projectId, name) {
        const api = await this.projectsApi();
        const response = await api.deleteLocator(projectId, { name });
        return response.data;
    }
    async validateVariableName(name) {
        const api = await this.utilitiesApi();
        const response = await api.validateVariable({ name });
        return response.data;
    }
    async listInputWorkItems(projectId) {
        const api = await this.projectsApi();
        const response = await api.listInputWorkItems(projectId);
        return Object.values(response.data.items);
    }
    async listOutputWorkItems(projectId) {
        const api = await this.projectsApi();
        const response = await api.listOutputWorkItems(projectId);
        return Object.values(response.data.items);
    }
    async addInputWorkItem(projectId, name, items) {
        const api = await this.projectsApi();
        await api.addInputWorkItem(projectId, { name, items });
        await renderer_1.ipcRenderer.invoke('workItemsChanged', projectId);
    }
    async updateInputWorkItem(projectId, name, items) {
        const api = await this.projectsApi();
        await api.removeInputWorkItem(projectId, { name });
        await api.addInputWorkItem(projectId, { name, items });
        await renderer_1.ipcRenderer.invoke('workItemsChanged', projectId);
    }
    async removeInputWorkItem(projectId, name) {
        const api = await this.projectsApi();
        await api.removeInputWorkItem(projectId, { name });
        await renderer_1.ipcRenderer.invoke('workItemsChanged', projectId);
    }
    async removeOutputWorkItem(projectId, name) {
        const api = await this.projectsApi();
        await api.removeOutputWorkItem(projectId, { name });
        await renderer_1.ipcRenderer.invoke('workItemsChanged', projectId);
    }
    async getCurrentInputWorkItem(projectId) {
        const api = await this.projectsApi();
        const response = await api.getCurrentInputWorkItem(projectId);
        return response.data;
    }
    async setCurrentInputWorkItem(projectId, name) {
        const api = await this.projectsApi();
        await api.setCurrentInputWorkItem(projectId, { name });
    }
}
exports.RobotdClient = RobotdClient;


/***/ }),

/***/ 9823:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isErrorResponse = exports.ErrorResponse = void 0;
class ErrorResponse extends Error {
    constructor(error_code, message) {
        super(message);
        this.name = 'ErrorResponse';
        this.error_code = error_code;
        this.message = message;
    }
}
exports.ErrorResponse = ErrorResponse;
const isErrorResponse = (body) => body !== null &&
    body !== undefined &&
    Object.prototype.hasOwnProperty.call(body, 'error_code') &&
    Object.prototype.hasOwnProperty.call(body, 'message');
exports.isErrorResponse = isErrorResponse;


/***/ }),

/***/ 695:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.robotd = exports.ErrorResponse = void 0;
const client_1 = __webpack_require__(2794);
var errors_1 = __webpack_require__(9823);
Object.defineProperty(exports, "ErrorResponse", ({ enumerable: true, get: function () { return errors_1.ErrorResponse; } }));
exports.robotd = new client_1.RobotdClient();


/***/ }),

/***/ 1069:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getMenuItems = void 0;
const types_1 = __webpack_require__(9581);
const utils_1 = __webpack_require__(1528);
const getMenuItems = () => {
    const platform = typeof process === 'object' ? process?.platform : (0, utils_1.getPlatform)();
    const defaultApp = typeof process === 'object' && process?.defaultApp;
    const menu = [
        {
            label: 'File',
            submenu: [
                {
                    label: 'New Robot',
                    id: types_1.GlobalMenuItem.robotNew,
                    accelerator: 'CmdOrCtrl+N',
                    enabled: false,
                },
                {
                    label: 'Open a Robot Folder',
                    id: types_1.GlobalMenuItem.robotOpen,
                    accelerator: 'CmdOrCtrl+O',
                    enabled: false,
                },
                {
                    label: 'Close Robot',
                    id: types_1.GlobalMenuItem.robotClose,
                    accelerator: 'CmdOrCtrl+W',
                    enabled: false,
                },
                {
                    type: 'separator',
                },
                {
                    label: 'Export Robot',
                    id: types_1.GlobalMenuItem.robotExport,
                    accelerator: 'Shift+CmdOrCtrl+E',
                    enabled: false,
                },
                {
                    label: 'Reveal in File System',
                    id: types_1.GlobalMenuItem.robotRevealFileSystem,
                    enabled: false,
                },
            ],
        },
        {
            label: 'Edit',
            submenu: [
                {
                    id: types_1.GlobalMenuItem.undo,
                    label: 'Undo',
                    accelerator: 'CmdOrCtrl+Z',
                },
                {
                    id: types_1.GlobalMenuItem.redo,
                    label: 'Redo',
                    accelerator: 'Shift+CmdOrCtrl+Z',
                },
                {
                    type: 'separator',
                },
                {
                    label: 'Cut',
                    accelerator: 'CmdOrCtrl+X',
                    role: 'cut',
                },
                {
                    label: 'Copy',
                    accelerator: 'CmdOrCtrl+C',
                    role: 'copy',
                },
                {
                    label: 'Paste',
                    accelerator: 'CmdOrCtrl+V',
                    role: 'paste',
                },
                {
                    label: 'Select All',
                    accelerator: 'CmdOrCtrl+A',
                    role: 'selectAll',
                },
                {
                    type: 'separator',
                },
                {
                    id: types_1.GlobalMenuItem.editorDeselect,
                    label: 'Deselect',
                    accelerator: 'Escape',
                    visible: false,
                },
                {
                    label: 'Duplicate',
                    id: types_1.GlobalMenuItem.editorDuplicateKeyword,
                    accelerator: 'CmdOrCtrl+D',
                    enabled: false,
                },
                {
                    label: 'Remove',
                    id: types_1.GlobalMenuItem.editorRemoveKeyword,
                    accelerator: 'Delete',
                    enabled: false,
                },
                {
                    label: 'Remove (alternative)',
                    id: types_1.GlobalMenuItem.editorRemoveKeywordAlt,
                    accelerator: 'Backspace',
                    enabled: false,
                    visible: false,
                    acceleratorWorksWhenHidden: true,
                },
            ],
        },
        {
            label: 'View',
            submenu: [
                {
                    id: types_1.GlobalMenuItem.commandPalette,
                    label: 'Open Command Palette',
                    accelerator: 'CmdOrCtrl+K',
                },
                {
                    type: 'separator',
                },
                {
                    id: types_1.GlobalMenuItem.toggleEditorMode,
                    label: 'Toggle Editor Mode',
                    accelerator: 'Ctrl+Tab',
                    enabled: false,
                },
                {
                    type: 'separator',
                },
                {
                    id: types_1.GlobalMenuItem.toggleFullScreen,
                    label: 'Toggle Full Screen',
                    accelerator: platform === 'darwin' ? 'Ctrl+Command+F' : 'F11',
                },
            ],
        },
        {
            label: 'Run',
            submenu: [
                {
                    id: types_1.GlobalMenuItem.runCurrentTask,
                    label: 'Run Current Task',
                    accelerator: 'CmdOrCtrl+R',
                    enabled: false,
                },
                {
                    id: types_1.GlobalMenuItem.runTask,
                    label: 'Run Task',
                    accelerator: 'Shift+CmdOrCtrl+R',
                    enabled: false,
                },
                {
                    type: 'separator',
                },
                {
                    id: types_1.GlobalMenuItem.runWithWorkItemSet,
                    label: 'Run with Work Item Set',
                    enabled: false,
                    submenu: [],
                },
                {
                    type: 'separator',
                },
                {
                    id: types_1.GlobalMenuItem.stopTaskRun,
                    label: 'Stop Task Run',
                    accelerator: 'Alt+CmdOrCtrl+T',
                    enabled: false,
                },
                {
                    type: 'separator',
                },
                {
                    id: types_1.GlobalMenuItem.runResults,
                    label: 'Run Results',
                    enabled: false,
                    submenu: [],
                },
            ],
        },
        {
            label: 'Help',
            role: 'help',
            submenu: [
                {
                    id: types_1.GlobalMenuItem.openDocs,
                    label: 'Robocorp Docs',
                },
                {
                    id: types_1.GlobalMenuItem.releaseNotes,
                    label: 'Release Notes',
                },
                {
                    id: types_1.GlobalMenuItem.submitIssue,
                    label: 'Submit Issue',
                },
            ],
        },
    ];
    /**
     * Windows / Linux specific menu items
     */
    if (platform !== 'darwin' && Array.isArray(menu[0].submenu)) {
        menu[0].submenu.push({
            label: 'Settings',
            id: types_1.GlobalMenuItem.settings,
        });
        menu[0].submenu.push({
            type: 'separator',
        });
        menu[0].submenu.push({
            label: 'Exit',
            id: types_1.GlobalMenuItem.quit,
        });
    }
    /**
     * macOS specific menu items
     */
    if (platform === 'darwin') {
        menu.unshift({
            label: 'Solventek',
            submenu: [
                {
                    label: 'About Solventek',
                    role: 'about',
                },
                {
                    type: 'separator',
                },
                {
                    label: 'Settings',
                    id: types_1.GlobalMenuItem.settings,
                },
                {
                    type: 'separator',
                },
                {
                    label: 'Services',
                    role: 'services',
                },
                {
                    type: 'separator',
                },
                {
                    label: 'Hide Solventek',
                    accelerator: 'Command+H',
                    role: 'hide',
                },
                {
                    label: 'Hide Others',
                    accelerator: 'Command+Shift+H',
                    role: 'hideOthers',
                },
                {
                    label: 'Show All',
                    role: 'unhide',
                },
                {
                    type: 'separator',
                },
                {
                    label: 'Quit',
                    id: types_1.GlobalMenuItem.quit,
                    accelerator: 'Command+Q',
                },
            ],
        });
    }
    /**
     * Development menu items
     */
    if (defaultApp && Array.isArray(menu[3].submenu)) {
        menu[3].submenu.push({
            label: 'Debug tools',
            id: types_1.GlobalMenuItem.debug,
        });
    }
    return menu;
};
exports.getMenuItems = getMenuItems;


/***/ }),

/***/ 9581:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WorkItemType = exports.ErrorWithCode = exports.ErrorCode = exports.LogicalOperators = exports.ComparisonOperators = exports.Metrics = exports.ControlRoomLinkStatus = exports.GlobalMenuItem = exports.Hotkey = exports.ModelUpdate = exports.KeywordIteration = exports.TreeItemType = exports.TreeHelperType = exports.DragType = void 0;
const api_1 = __webpack_require__(9771);
var DragType;
(function (DragType) {
    DragType["Keyword"] = "Keyword";
    DragType["Variable"] = "Variable";
    DragType["Locator"] = "Locator";
    DragType["KeywordArgument"] = "KeywordArgument";
})(DragType = exports.DragType || (exports.DragType = {}));
var TreeHelperType;
(function (TreeHelperType) {
    TreeHelperType["Error"] = "Error";
    TreeHelperType["Image"] = "Image";
    TreeHelperType["Teardown"] = "Teardown";
    TreeHelperType["Setup"] = "Setup";
    TreeHelperType["Tail"] = "Tail";
})(TreeHelperType = exports.TreeHelperType || (exports.TreeHelperType = {}));
exports.TreeItemType = { ...api_1.Type, ...TreeHelperType };
var KeywordIteration;
(function (KeywordIteration) {
    KeywordIteration["UserKeyword"] = "UserKeywordIteration";
    KeywordIteration["Keyword"] = "KeywordIteration";
})(KeywordIteration = exports.KeywordIteration || (exports.KeywordIteration = {}));
var ModelUpdate;
(function (ModelUpdate) {
    // Update that requires to update the model by calling `setModel` to the backend
    ModelUpdate["model"] = "model";
    // Update that requires to update the model by calling `setCode` to the backend
    ModelUpdate["code"] = "code";
    // Global update that does not require to update the model to the backend
    ModelUpdate["global"] = "global";
    // Update that requires to update the model without calling `setModel` or `setCode` to the backend
    ModelUpdate["suite"] = "suite";
    // Model update that requires to update `setModel` and skip adding a history state
    ModelUpdate["history"] = "history";
})(ModelUpdate = exports.ModelUpdate || (exports.ModelUpdate = {}));
var Hotkey;
(function (Hotkey) {
    Hotkey["robotNew"] = "robotoNew";
    Hotkey["robotOpen"] = "robotOpen";
    Hotkey["robotClose"] = "robotClose";
    Hotkey["robotExport"] = "robotExport";
    Hotkey["robotRevealFileSystem"] = "robotRevealFileSystem";
    Hotkey["undo"] = "undo";
    Hotkey["redo"] = "redo";
    Hotkey["delete"] = "delete";
    Hotkey["deselect"] = "deselect";
    Hotkey["duplicate"] = "duplicate";
    Hotkey["editorMode"] = "editorMode";
    Hotkey["commandPalette"] = "commandPalette";
    Hotkey["runTask"] = "RunTask";
    Hotkey["runCurrentTask"] = "RunCurrentTask";
    Hotkey["stopTaskRun"] = "StopTaskRun";
})(Hotkey = exports.Hotkey || (exports.Hotkey = {}));
var GlobalMenuItem;
(function (GlobalMenuItem) {
    GlobalMenuItem["undo"] = "Undo";
    GlobalMenuItem["redo"] = "Redo";
    GlobalMenuItem["commandPalette"] = "CommandPalette";
    GlobalMenuItem["settings"] = "Settings";
    GlobalMenuItem["editorDeselect"] = "EditorDeselect";
    GlobalMenuItem["editorRemoveKeyword"] = "EditorRemoveKeyword";
    GlobalMenuItem["editorRemoveKeywordAlt"] = "EditorRemoveKeywordAlt";
    GlobalMenuItem["editorDuplicateKeyword"] = "EditorDuplicateKeyword";
    GlobalMenuItem["robotNew"] = "RobotNew";
    GlobalMenuItem["robotOpen"] = "RobotOpen";
    GlobalMenuItem["robotClose"] = "RobotClose";
    GlobalMenuItem["robotExport"] = "RobotExport";
    GlobalMenuItem["robotRevealFileSystem"] = "robotRevealFileSystem";
    GlobalMenuItem["toggleFullScreen"] = "toggleFullScreen";
    GlobalMenuItem["toggleEditorMode"] = "toggleEditorMode";
    GlobalMenuItem["openDocs"] = "openDocs";
    GlobalMenuItem["releaseNotes"] = "releaseNotes";
    GlobalMenuItem["submitIssue"] = "submitIssue";
    GlobalMenuItem["quit"] = "Quit";
    GlobalMenuItem["debug"] = "Debug";
    GlobalMenuItem["runTask"] = "RunTask";
    GlobalMenuItem["runWithWorkItemSet"] = "runWithWorkItemSet";
    GlobalMenuItem["newWorkItemSet"] = "newWorkItemSet";
    GlobalMenuItem["runCurrentTask"] = "RunCurrentTask";
    GlobalMenuItem["stopTaskRun"] = "StopTaskRun";
    GlobalMenuItem["runResults"] = "RunResults";
})(GlobalMenuItem = exports.GlobalMenuItem || (exports.GlobalMenuItem = {}));
var ControlRoomLinkStatus;
(function (ControlRoomLinkStatus) {
    ControlRoomLinkStatus["started"] = "Started";
    ControlRoomLinkStatus["success"] = "Success";
    ControlRoomLinkStatus["failure"] = "Failure";
})(ControlRoomLinkStatus = exports.ControlRoomLinkStatus || (exports.ControlRoomLinkStatus = {}));
var Metrics;
(function (Metrics) {
    Metrics["STARTED_OS"] = "studio.started.os";
    Metrics["STARTED_VERSION"] = "studio.started.version";
    Metrics["ERROR_MESSAGE"] = "studio.error.message";
    Metrics["ERROR_AUTOUPDATE"] = "studio.error.autoupdate";
    Metrics["CONVERTER_USED"] = "studio.converter.used";
    Metrics["CREATE_ROBOT"] = "studio.create.robot";
    Metrics["OPEN_ROBOT"] = "studio.open.robot";
    Metrics["RUN_ROBOT"] = "studio.run.robot";
    Metrics["CONVERTER_ERROR"] = "studio.converter.error";
    Metrics["FLOW_USED"] = "studio.flow.used";
    Metrics["LINK_STATUS"] = "studio.linking.status";
    Metrics["UNLINK_STATUS"] = "studio.unlinking.status";
})(Metrics = exports.Metrics || (exports.Metrics = {}));
var ComparisonOperators;
(function (ComparisonOperators) {
    ComparisonOperators["=="] = "==";
    ComparisonOperators["!="] = "!=";
    ComparisonOperators[">"] = ">";
    ComparisonOperators[">="] = ">=";
    ComparisonOperators["<"] = "<";
    ComparisonOperators["<="] = "<=";
    ComparisonOperators["is"] = "is";
    ComparisonOperators["in"] = "in";
    ComparisonOperators["true"] = "is True";
    ComparisonOperators["false"] = "is False";
})(ComparisonOperators = exports.ComparisonOperators || (exports.ComparisonOperators = {}));
var LogicalOperators;
(function (LogicalOperators) {
    LogicalOperators["and"] = "and";
    LogicalOperators["or"] = "or";
    LogicalOperators["not"] = "not";
})(LogicalOperators = exports.LogicalOperators || (exports.LogicalOperators = {}));
var ErrorCode;
(function (ErrorCode) {
    ErrorCode["UNKNOWN"] = "unknown";
    ErrorCode["UNSUPPORTED_ENVIRONMENT"] = "unsupported-environment";
    ErrorCode["NETWORK_ERROR"] = "network-error";
    ErrorCode["HOLOTREE_INIT"] = "holotree-init";
})(ErrorCode = exports.ErrorCode || (exports.ErrorCode = {}));
class ErrorWithCode extends Error {
    constructor(code, message) {
        super(message);
        this.name = 'ErrorWithCode';
        this.code = code;
    }
    toString() {
        return `${this.code}: ${this.message}`;
    }
}
exports.ErrorWithCode = ErrorWithCode;
var WorkItemType;
(function (WorkItemType) {
    WorkItemType["Input"] = "input";
    WorkItemType["Output"] = "output";
})(WorkItemType = exports.WorkItemType || (exports.WorkItemType = {}));


/***/ }),

/***/ 1528:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getPlatform = exports.getSuites = exports.getSuite = exports.isBranchedItem = exports.formatTime = exports.isWindowsLocator = exports.isBrowserLocator = exports.isVariable = exports.ctrlOrCmd = exports.isWindows = exports.extractErrorFrom = exports.toErrorCode = exports.getSlug = exports.getRunStatusIcon = exports.isContainerType = exports.hasTeardown = exports.hasSetup = exports.isInput = exports.isLocatorDoc = exports.isVariableDoc = exports.isArgumentDoc = exports.isKeywordDoc = exports.isLibraryDoc = exports.getTypeColor = exports.stringSearch = exports.shortenPath = exports.getIcon = exports.toColor = void 0;
const icons_1 = __webpack_require__(274);
const Icon = __importStar(__webpack_require__(1645));
const slugify_1 = __importDefault(__webpack_require__(5568));
const robotd_1 = __webpack_require__(9080);
const errors_1 = __webpack_require__(9823);
const types_1 = __webpack_require__(9581);
const toColor = (color) => {
    const variants = [
        'purple',
        'peach',
        'yellow',
        'teal',
        'green',
        'blue',
    ];
    const variantIndex = variants.indexOf(color);
    return variantIndex > -1 ? variants[variantIndex] : 'secondary';
};
exports.toColor = toColor;
const docIcons = {
    [robotd_1.Icon.Image]: Icon.IconImage,
    [robotd_1.Icon.Text]: Icon.IconText,
    [robotd_1.Icon.Button]: Icon.IconButton,
    [robotd_1.Icon.Input]: Icon.IconInput,
    [robotd_1.Icon.Link]: Icon.IconLink,
    [robotd_1.Icon.GridCell]: Icon.IconGridCell,
    [robotd_1.Icon.Heading]: Icon.IconText,
    [robotd_1.Icon.Table]: Icon.IconTable,
    [robotd_1.Icon.Form]: Icon.IconForm,
    [robotd_1.Icon.VariableSquare]: Icon.IconVariableSquare,
    [robotd_1.Icon.Loop]: Icon.IconLoop,
    [robotd_1.Icon.Branch]: Icon.IconBranch,
    [robotd_1.Icon.TryCatch]: Icon.IconTryCatch,
    [robotd_1.Icon.Pass]: Icon.IconPass,
    [robotd_1.Icon.Exit]: Icon.IconExit,
    [robotd_1.Icon.Play]: Icon.IconPlay,
    [robotd_1.Icon.Close]: Icon.IconClose,
    [robotd_1.Icon.Continue]: Icon.IconContinue,
    [robotd_1.Icon.Return]: Icon.IconReturn,
    [robotd_1.Icon.Document]: Icon.IconDocument,
    [robotd_1.Icon.DisabledFile]: Icon.IconDisabledFile,
    [robotd_1.Icon.Time]: Icon.IconTime,
    [robotd_1.Icon.Camera]: Icon.IconCamera,
    [robotd_1.Icon.Pointer]: Icon.IconClickHand,
    [robotd_1.Icon.CodeFile]: Icon.IconDocument,
    [robotd_1.Icon.Browser]: Icon.IconBrowser,
    [robotd_1.Icon.CloudDownload]: Icon.IconCloudDownload,
    [robotd_1.Icon.ExcelDocument]: Icon.IconExcelDocument,
    [robotd_1.Icon.Corner]: Icon.IconCorner,
    [robotd_1.Icon.VariableX]: Icon.IconVariableX,
    [robotd_1.Icon.Code]: Icon.IconCode,
    [robotd_1.Icon.Warning]: Icon.IconWarning,
    [robotd_1.Icon.FileError]: Icon.IconFileError,
    [robotd_1.Icon.Remove]: Icon.IconRemove,
    [robotd_1.Icon.RemoveItem]: Icon.IconRemoveItem,
    [robotd_1.Icon.RemoveFile]: Icon.IconRemoveFile,
    [robotd_1.Icon.Add]: Icon.IconAdd,
    [robotd_1.Icon.AddItem]: Icon.IconAddItem,
    [robotd_1.Icon.AddFile]: Icon.IconAddFile,
    [robotd_1.Icon.CloseFile]: Icon.IconCloseFile,
    [robotd_1.Icon.SaveFile]: Icon.IconSaveFile,
    [robotd_1.Icon.OpenFile]: Icon.IconOpenFile,
    [robotd_1.Icon.Mail]: Icon.IconMail,
    [robotd_1.Icon.Pdf]: Icon.IconPdf,
    [robotd_1.Icon.Database]: Icon.IconDatabase,
    [robotd_1.Icon.Stop]: Icon.IconStop,
    [robotd_1.Icon.Pause]: Icon.IconPause,
    [robotd_1.Icon.Print]: Icon.IconPrint,
    [robotd_1.Icon.Number]: Icon.IconNumber,
    [robotd_1.Icon.List]: Icon.IconList,
    [robotd_1.Icon.Windows]: icons_1.IconWindows,
    [robotd_1.Icon.Lock]: icons_1.IconLockLocked,
};
const getIcon = (icon, fallback) => icon ? docIcons[icon] : fallback;
exports.getIcon = getIcon;
const shortenPath = (path, length = 42) => {
    if (!path || path.length <= length) {
        return path;
    }
    return (path.substring(0, length * 0.25) +
        '...' +
        path.substring(path.length - length * 0.75));
};
exports.shortenPath = shortenPath;
const stringSearch = (str, search) => {
    return str.toLowerCase().includes(search.toLowerCase());
};
exports.stringSearch = stringSearch;
const getTypeColor = (type, theme, asBranch) => {
    const { colors, name } = theme;
    const dark = name === 'dark';
    switch (type) {
        case robotd_1.Type.Task:
            return dark ? colors.dark60 : colors.light60;
        case robotd_1.VariableKind.Locator:
            return dark ? colors.green40 : colors.green60;
        case robotd_1.VariableKind.Constant:
        case robotd_1.VariableKind.Dictionary:
        case robotd_1.VariableKind.Environment:
        case robotd_1.VariableKind.List:
        case robotd_1.VariableKind.Scalar:
        case robotd_1.Type.Variable:
            return dark ? colors.blue40 : colors.blue60;
        case robotd_1.Type.For:
        case robotd_1.Type.If:
        case robotd_1.Type.IfBranch:
        case robotd_1.Type.ElseBranch:
        case robotd_1.Type.ElseIfBranch:
        case robotd_1.Type.Try:
        case robotd_1.Type.TryBranch:
        case robotd_1.Type.While:
            return dark ? colors.blue10 : colors.blue90;
        case robotd_1.Type.Break:
        case robotd_1.Type.Continue:
        case robotd_1.Type.Return:
            return dark ? colors.blue50 : colors.blue70;
        case robotd_1.Type.UserKeyword:
            if (asBranch) {
                return dark ? colors.dark70 : colors.light70;
            }
            return dark ? colors.purple40 : colors.purple60;
        case robotd_1.Type.ForIteration:
            return dark ? colors.dark60 : colors.light70;
        case types_1.KeywordIteration.UserKeyword:
        case types_1.KeywordIteration.Keyword:
            return dark ? colors.dark70 : colors.light70;
        case robotd_1.Type.Keyword:
        default:
            if (asBranch) {
                return dark ? colors.dark70 : colors.light70;
            }
            return dark ? colors.yellow50 : colors.yellow70;
    }
};
exports.getTypeColor = getTypeColor;
const isDocType = (type) => {
    return (doc) => typeof doc === 'object' && doc.type === type;
};
exports.isLibraryDoc = isDocType(robotd_1.DocType.Library);
exports.isKeywordDoc = isDocType(robotd_1.DocType.Keyword);
exports.isArgumentDoc = isDocType(robotd_1.DocType.Argument);
exports.isVariableDoc = isDocType(robotd_1.DocType.Variable);
exports.isLocatorDoc = isDocType(robotd_1.DocType.Locator);
const isInput = (target) => {
    if (target?.getAttribute('contenteditable') === 'true') {
        return true;
    }
    return ['INPUT', 'TEXTAREA', 'BUTTON'].indexOf(target?.tagName || '') > -1;
};
exports.isInput = isInput;
const hasSetup = (target) => {
    return target && 'setup' in target ? !!target.setup : false;
};
exports.hasSetup = hasSetup;
const hasTeardown = (target) => {
    return target && 'teardown' in target ? !!target.teardown : false;
};
exports.hasTeardown = hasTeardown;
const isContainerType = (type) => [
    robotd_1.Type.If,
    robotd_1.Type.For,
    robotd_1.Type.While,
    robotd_1.Type.Try,
    types_1.TreeItemType.Setup,
    types_1.TreeItemType.Teardown,
].indexOf(type) > -1;
exports.isContainerType = isContainerType;
const getRunStatusIcon = (status) => {
    switch (status) {
        case robotd_1.Status.Fail:
            return '';
        case robotd_1.Status.Pass:
            return '';
        default:
            return '';
    }
};
exports.getRunStatusIcon = getRunStatusIcon;
const getSlug = (input, fallback) => {
    const slug = (0, slugify_1.default)(input, {
        strict: true,
        lower: true,
    })
        .substring(0, 255)
        .replaceAll(/^-+|-+$/g, '');
    return slug.length > 0 ? slug : fallback || '';
};
exports.getSlug = getSlug;
const toErrorCode = (error) => {
    if (error instanceof types_1.ErrorWithCode) {
        return { code: error.code, message: error.message };
    }
    else if (error instanceof errors_1.ErrorResponse) {
        // TODO: Map robotd error codes to common error codes
        return { code: types_1.ErrorCode.UNKNOWN, message: error.message };
    }
    else if (error instanceof Error) {
        return { code: types_1.ErrorCode.UNKNOWN, message: error.message };
    }
    else {
        return { code: types_1.ErrorCode.UNKNOWN, message: `${error}` };
    }
};
exports.toErrorCode = toErrorCode;
const extractErrorFrom = (json) => {
    try {
        const matches = json.match(/(\{.*\})/gm);
        if (!matches) {
            return json;
        }
        const err = JSON.parse(matches[0]);
        return Object.prototype.hasOwnProperty.call(err, 'error')
            ? err.error.message
            : err.message;
    }
    catch {
        return json;
    }
};
exports.extractErrorFrom = extractErrorFrom;
const isWindows = () => (0, exports.getPlatform)() === 'win32';
exports.isWindows = isWindows;
const ctrlOrCmd = () => {
    return (0, exports.getPlatform)() === 'darwin' ? '' : 'CTRL+';
};
exports.ctrlOrCmd = ctrlOrCmd;
const isVariable = (value) => value !== null && typeof value === 'object' && value.type === robotd_1.Type.Variable;
exports.isVariable = isVariable;
const isBrowserLocator = (locator) => locator.kind === robotd_1.LocatorType.Browser;
exports.isBrowserLocator = isBrowserLocator;
const isWindowsLocator = (locator) => locator.kind === robotd_1.LocatorType.Windows;
exports.isWindowsLocator = isWindowsLocator;
const formatTime = (timestamp) => {
    const time = new Date(timestamp).toLocaleTimeString();
    const date = new Date(timestamp).toLocaleDateString('en-GB', {
        day: 'numeric',
        month: 'short',
        year: 'numeric',
    });
    return `${time} (${date})`;
};
exports.formatTime = formatTime;
const isBranchedItem = (item) => {
    if (item.type === robotd_1.Type.Keyword && item.body && item.body.length > 0) {
        return true;
    }
    const branchTypes = [
        robotd_1.Type.If,
        robotd_1.Type.IfBranch,
        robotd_1.Type.For,
        robotd_1.Type.ForIteration,
        robotd_1.Type.UserKeyword,
        robotd_1.Type.Try,
        robotd_1.Type.TryBranch,
        robotd_1.Type.For,
        robotd_1.Type.While,
    ];
    return branchTypes.includes(item.type);
};
exports.isBranchedItem = isBranchedItem;
const getSuite = (suite, path) => {
    if (!suite || !path) {
        return undefined;
    }
    let targetSuite;
    path.forEach((name, index) => {
        if (index === 0) {
            targetSuite = suite;
        }
        else {
            targetSuite = targetSuite?.suites.find((item) => item.name === name);
        }
    });
    return targetSuite;
};
exports.getSuite = getSuite;
const getSuites = (parent, parentPath) => {
    if (!parent?.suites || parent.suites.length === 0) {
        return [];
    }
    let result = [];
    parent.suites.forEach((item) => {
        const path = (parentPath || [parent.name]).concat([item.name]);
        if (item.suites.length === 0) {
            result.push({
                label: item.name,
                source: item.source,
                path,
                directory: item.suites.length > 0,
            });
        }
        result = result.concat((0, exports.getSuites)(item, path));
    });
    return result;
};
exports.getSuites = getSuites;
/**
 * Get user operating systems platform
 */
const getPlatform = () => {
    const { navigator: { platform }, } = window;
    let os;
    if (['Macintosh', 'MacIntel', 'MacPPC', 'Mac68K'].indexOf(platform) !== -1) {
        os = 'darwin';
    }
    else if (/Linux/.test(platform)) {
        os = 'linux';
    }
    else {
        os = 'win32';
    }
    return os;
};
exports.getPlatform = getPlatform;


/***/ }),

/***/ 901:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InspectorMainView = exports.Loading = void 0;
const jsx_runtime_1 = __webpack_require__(38);
const react_1 = __webpack_require__(4191);
const ds_1 = __webpack_require__(8203);
const inspector_1 = __webpack_require__(8460);
const inspector_2 = __webpack_require__(6115);
const robotd_1 = __webpack_require__(9080);
const Titlebar_1 = __webpack_require__(8815);
const renderer_1 = __webpack_require__(1977);
const robotd_2 = __webpack_require__(695);
const utils_1 = __webpack_require__(1528);
const isValidType = (locator) => {
    return (locator.kind === robotd_1.LocatorType.Browser || locator.kind === robotd_1.LocatorType.Windows);
};
const Container = ds_1.styled.main `
  display: block;
  user-select: none;
  padding-top: ${({ isLinux }) => isLinux ? '0' : 'env(titlebar-area-height, 32px)'};
  overflow: hidden;
`;
const Loading = () => ((0, jsx_runtime_1.jsx)(ds_1.Box, { px: 32, py: 14, children: (0, jsx_runtime_1.jsx)(ds_1.Progress, {}, void 0) }, void 0));
exports.Loading = Loading;
const EditorView = (props) => {
    let elem;
    switch (props.type) {
        case 'web-picker':
            elem = (0, jsx_runtime_1.jsx)(inspector_1.BrowserEditor, { bridge: inspector_2.browserInspector }, void 0);
            break;
        case 'web-recorder':
            elem = ((0, jsx_runtime_1.jsx)(inspector_1.WebRecorderEditor, { bridge: inspector_2.recorderInspector, onSave: props.onSaveRecording, mode: "solventek-rpa" }, void 0));
            break;
        case 'windows-picker':
            elem = (0, jsx_runtime_1.jsx)(inspector_1.WindowsEditor, { bridge: inspector_2.windowsInspector }, void 0);
            break;
        default:
            elem = (0, jsx_runtime_1.jsx)(exports.Loading, {}, void 0);
            break;
    }
    return elem;
};
const InspectorMainView = () => {
    const [isReady, setIsReady] = (0, react_1.useState)(false);
    const [existingLocator, setExistingLocator] = (0, react_1.useState)(undefined);
    const [locatorName, setLocatorName] = (0, react_1.useState)('');
    const [locator, setLocator] = (0, react_1.useState)();
    const [editor, setEditor] = (0, react_1.useState)();
    (0, react_1.useEffect)(() => {
        const getCurrentLocator = async () => {
            const currentLocator = await renderer_1.ipcRenderer.invoke('currentLocator');
            console.log(`Current locator: ${JSON.stringify(currentLocator, null, 2)}`);
            const currentWindowType = await renderer_1.ipcRenderer.invoke('inspectorWindowType');
            console.log(`Current window type: ${currentWindowType}`);
            switch (currentWindowType) {
                case 'web-picker':
                    inspector_2.browserInspector.setProjectId(currentLocator.projectId);
                    break;
                case 'web-recorder':
                    inspector_2.recorderInspector.setProjectId(currentLocator.projectId);
                    break;
                case 'windows-picker':
                    inspector_2.windowsInspector.setProjectId(currentLocator.projectId);
                    break;
            }
            if (currentLocator.locator &&
                isValidType(currentLocator.locator) &&
                currentLocator.name) {
                setExistingLocator(currentLocator.name);
                setLocatorName(currentLocator.name);
                setLocator({
                    ...currentLocator.locator,
                });
            }
            setEditor(currentWindowType);
            setIsReady(true);
        };
        getCurrentLocator();
    }, []);
    (0, react_1.useEffect)(() => {
        return renderer_1.ipcRenderer.on('inspectorWindowOnClose', () => {
            inspector_2.browserInspector.stop();
        });
    }, []);
    const contextValue = (0, react_1.useMemo)(() => ({
        existingLocator,
        locatorName,
        setLocatorName,
        locator,
        setLocator,
    }), [locator, locatorName]);
    const onSaveRecording = async (code, ops) => {
        // suite details will current active suite, task or keyword and project id
        const currentLocator = await renderer_1.ipcRenderer.invoke('currentLocator');
        // create the newly recorded selectors as locators
        let index = 0;
        for (const op of ops || []) {
            index++;
            if (op?.selectors && op.selectors.length > 0) {
                await robotd_2.robotd.saveLocator(currentLocator.projectId, (0, inspector_1.generateSelectorName)(op.selectors[0].strategy, op.selectors[0].value, undefined, index), {
                    kind: robotd_1.LocatorType.Browser,
                    type: robotd_1.DocType.Locator,
                    value: op.selectors[0].value,
                    strategy: op.selectors[0].strategy,
                });
            }
        }
        // notify listeners about actions
        await renderer_1.ipcRenderer.invoke('locatorsChanged', currentLocator.projectId);
        if (code) {
            await renderer_1.ipcRenderer.invoke('insertRecording', currentLocator.projectId, code);
        }
        // close inspector window after everything is saved
        await window.ipc.invoke('closeWindow');
        await robotd_2.robotd.inspectorStopBrowser();
    };
    return ((0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: [(0, jsx_runtime_1.jsx)(Titlebar_1.TitleBar, { title: "Robocorp Inspector", empty: true }, void 0), (0, jsx_runtime_1.jsx)(inspector_1.LocatorContext.Provider, { value: contextValue, children: (0, jsx_runtime_1.jsx)(Container, { isLinux: (0, utils_1.getPlatform)() === 'linux', children: isReady ? ((0, jsx_runtime_1.jsx)(EditorView, { type: editor, onSaveRecording: onSaveRecording }, void 0)) : ((0, jsx_runtime_1.jsx)(exports.Loading, {}, void 0)) }, void 0) }, void 0)] }, void 0));
};
exports.InspectorMainView = InspectorMainView;


/***/ }),

/***/ 6356:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(901), exports);


/***/ }),

/***/ 3807:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(6356), exports);


/***/ }),

/***/ 8316:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotFound = void 0;
const jsx_runtime_1 = __webpack_require__(38);
const react_router_dom_1 = __webpack_require__(384);
const ds_1 = __webpack_require__(8203);
const NotFound = () => {
    // TODO: Send metrics / log error if this is reached?
    const navigate = (0, react_router_dom_1.useNavigate)();
    return ((0, jsx_runtime_1.jsx)(ds_1.Box, { width: "100%", height: "100%", backgroundColor: "dark80", children: (0, jsx_runtime_1.jsx)(ds_1.Box, { display: "flex", width: "100%", height: "100%", flexDirection: "column", textAlign: "center", justifyContent: "space-between", children: (0, jsx_runtime_1.jsx)(ds_1.Box, { flex: "auto", display: "flex", px: 64, children: (0, jsx_runtime_1.jsxs)(ds_1.Box, { alignSelf: "center", m: "0 auto", children: [(0, jsx_runtime_1.jsx)(ds_1.Typography, { fontSize: "$32", mb: 16, children: ":(" }, void 0), (0, jsx_runtime_1.jsx)(ds_1.Typography, { fontSize: "$24", mb: 32, children: "Oops, this view doesn't exist" }, void 0), (0, jsx_runtime_1.jsx)(ds_1.Button, { variant: "primary", onClick: () => navigate('/'), children: "Go back" }, void 0)] }, void 0) }, void 0) }, void 0) }, void 0));
};
exports.NotFound = NotFound;


/***/ }),

/***/ 5861:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(8316), exports);


/***/ }),

/***/ 8815:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TitleBar = void 0;
const jsx_runtime_1 = __webpack_require__(38);
const react_1 = __webpack_require__(4191);
const ds_1 = __webpack_require__(8203);
const renderer_1 = __webpack_require__(1977);
const menu_1 = __webpack_require__(1069);
const types_1 = __webpack_require__(9581);
const utils_1 = __webpack_require__(1528);
const Container = ds_1.styled.header `
  display: flex;
  align-items: center;
  justify-content: center;
  position: fixed;
  z-index: 9999;
  top: 0px;
  left: 0px;
  width: 100vw;
  height: env(titlebar-area-height, 32px);
  background: ${({ theme }) => theme.color('dark80')};
  -webkit-app-region: drag;
  user-select: none;
  padding: 0 ${({ isWindows }) => (isWindows ? '300px' : '0px')};

  h1 {
    font-size: 12px;
    line-height: env(titlebar-area-height, 32px);
    color: ${({ theme }) => theme.color('dark10')};
    font-family: ${({ isWindows, theme }) => isWindows ? 'Segoe UI' : theme.fonts.default};
    font-weight: ${({ isWindows }) => (isWindows ? 400 : 500)};
    white-space: nowrap;
    overflow: hidden;
  }

  nav {
    position: absolute;
    left: 0px;
    display: flex;
    -webkit-app-region: no-drag;

    button {
      background: none;
      border: none;
      border-radius: 0px;
      height: env(titlebar-area-height, 32px);
      min-height: env(titlebar-area-height, 32px);
      font-family: ${({ isWindows, theme }) => isWindows ? 'Segoe UI' : theme.fonts.default};
    }
  }

  ${({ theme }) => theme.screen.m} {
    h1 {
      display: ${({ isWindows }) => (isWindows ? 'none' : 'block')};
    }
  }
`;
const WinControls = ds_1.styled.div `
  display: flex;
  position: fixed;
  top: 0px;
  right: 0px;

  button {
    cursor: pointer;
    display: block;
    height: env(titlebar-area-height, 32px);
    width: calc(env(titlebar-area-height, 32px) + 12px);
    background: ${({ theme }) => theme.color('dark80')};
    -webkit-app-region: no-drag;

    &:hover {
      background: ${({ theme }) => theme.color('dark50')};
    }

    svg path {
      fill: ${({ theme }) => theme.color('dark0')};
    }

    &:last-of-type:hover {
      background: ${({ theme }) => theme.color('red50')};

      svg path {
        fill: ${({ theme }) => theme.color('white')};
      }
    }
  }
`;
const getShortcut = (accelerator) => {
    return accelerator?.replace('CmdOrCtrl', 'Ctrl') || '';
};
const TitleBar = ({ empty, title }) => {
    const [menu, setMenu] = (0, react_1.useState)((0, menu_1.getMenuItems)());
    const [runs, setRuns] = (0, react_1.useState)([]);
    const [workItemSets, setWorkItemSets] = (0, react_1.useState)([]);
    const [appVersion, setAppVersion] = (0, react_1.useState)();
    const [isMaximized, setIsMaximized] = (0, react_1.useState)(false);
    const [isResizable, setIsResizable] = (0, react_1.useState)(true);
    const onClick = (0, react_1.useCallback)((id) => () => {
        renderer_1.ipcRenderer.invoke('triggerMenuItem', { id });
    }, []);
    const onMimimize = (0, react_1.useCallback)(() => {
        renderer_1.ipcRenderer.invoke('handleWindowControls', 'minimize');
    }, []);
    const onMaximize = (0, react_1.useCallback)(() => {
        renderer_1.ipcRenderer.invoke('handleWindowControls', 'maximize');
    }, []);
    const onClose = (0, react_1.useCallback)(() => {
        renderer_1.ipcRenderer.invoke('handleWindowControls', 'close');
    }, []);
    const onRunResult = (0, react_1.useCallback)((id) => () => {
        renderer_1.ipcRenderer.invoke('openRunResult', id);
    }, []);
    const onWorkItemSet = (0, react_1.useCallback)((name) => () => {
        renderer_1.ipcRenderer.invoke('runWithWorkItemSet', name);
    }, []);
    (0, react_1.useEffect)(() => {
        const getMaximizeState = async () => {
            const state = await renderer_1.ipcRenderer.invoke('getWindowMaximizeState');
            setIsMaximized(state);
        };
        getMaximizeState();
        return renderer_1.ipcRenderer.on('onMaximizeChange', (_, state) => {
            setIsMaximized(state);
        });
    }, []);
    (0, react_1.useEffect)(() => {
        const getIsResizable = async () => {
            const state = await renderer_1.ipcRenderer.invoke('getWindowResizable');
            setIsResizable(state);
        };
        getIsResizable();
    }, []);
    (0, react_1.useEffect)(() => {
        renderer_1.ipcRenderer
            .invoke('getBuildInfo')
            .then(({ version }) => setAppVersion(version));
        return renderer_1.ipcRenderer.on('setMenuItems', (_, { ids, enabled }) => {
            setMenu((state) => {
                const target = state.map((item) => {
                    if (!Array.isArray(item.submenu)) {
                        return item;
                    }
                    const submenu = item.submenu.map((item) => {
                        return {
                            ...item,
                            enabled: ids.indexOf(item.id) > -1
                                ? enabled
                                : item.enabled,
                        };
                    });
                    return { label: item.label, submenu };
                });
                return target;
            });
        });
    }, []);
    (0, react_1.useEffect)(() => {
        return renderer_1.ipcRenderer.on('setMenuRunResults', (_, runs) => {
            setRuns(runs);
        });
    }, []);
    (0, react_1.useEffect)(() => {
        return renderer_1.ipcRenderer.on('setMenuWorkItemSets', (_, sets) => {
            setWorkItemSets(sets);
        });
    }, []);
    if ((0, utils_1.getPlatform)() === 'linux') {
        return null;
    }
    return ((0, jsx_runtime_1.jsxs)(Container, { isWindows: (0, utils_1.isWindows)(), children: [(0, utils_1.isWindows)() && isResizable && ((0, jsx_runtime_1.jsx)("nav", { children: menu.map(({ label, submenu }) => ((0, jsx_runtime_1.jsx)(ds_1.Dropdown, { title: label, width: "auto", position: "bottom-start", size: "small", children: Array.isArray(submenu) &&
                        submenu.map(({ accelerator, enabled, type, id, label }, index) => type === 'separator' ? ((0, jsx_runtime_1.jsx)(ds_1.Divider, {}, index)) : id === types_1.GlobalMenuItem.runResults ? ((0, jsx_runtime_1.jsx)(ds_1.Menu, { size: "small", trigger: (0, jsx_runtime_1.jsx)(ds_1.Menu.Item, { disabled: runs.length === 0, children: "Run results" }, void 0), children: runs.map(({ label, id }) => ((0, jsx_runtime_1.jsx)(ds_1.Menu.Item, { onClick: onRunResult(id), children: label }, id))) }, void 0)) : id === types_1.GlobalMenuItem.runWithWorkItemSet ? ((0, jsx_runtime_1.jsx)(ds_1.Menu, { size: "small", trigger: (0, jsx_runtime_1.jsx)(ds_1.Menu.Item, { disabled: runs.length === 0, children: "Run with Work item Set" }, void 0), children: workItemSets.map(({ name }) => ((0, jsx_runtime_1.jsxs)(ds_1.Menu.Item, { onClick: onWorkItemSet(name), children: ["Run with \"", name, "\""] }, name))) }, void 0)) : ((0, jsx_runtime_1.jsx)(ds_1.Menu.Item, { disabled: enabled === false, hotkey: getShortcut(accelerator), onClick: onClick(id), children: label }, label))) }, label))) }, void 0)), (0, jsx_runtime_1.jsxs)("h1", { children: [title && `${title}`, !empty && ((0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: [title && '  ', "Solventek", appVersion && ` v${appVersion}`] }, void 0))] }, void 0), (0, utils_1.isWindows)() && ((0, jsx_runtime_1.jsxs)(WinControls, { children: [(0, jsx_runtime_1.jsx)("button", { onClick: onMimimize, children: (0, jsx_runtime_1.jsx)("svg", { width: "10", height: "10", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: (0, jsx_runtime_1.jsx)("path", { d: "M10 5.5H0v-1h10v1Z" }, void 0) }, void 0) }, void 0), isResizable && ((0, jsx_runtime_1.jsx)("button", { onClick: onMaximize, children: isMaximized ? ((0, jsx_runtime_1.jsxs)("svg", { width: "10", height: "10", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [(0, jsx_runtime_1.jsx)("path", { d: "M2 1h7v7h1V0H2v1Z" }, void 0), (0, jsx_runtime_1.jsx)("path", { fillRule: "evenodd", d: "M0 2h8v8H0V2Zm1 1h6v6H1V3Z" }, void 0)] }, void 0)) : ((0, jsx_runtime_1.jsx)("svg", { width: "10", height: "10", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: (0, jsx_runtime_1.jsx)("path", { fillRule: "evenodd", d: "M9 1H1v8h8V1ZM0 0v10h10V0H0Z" }, void 0) }, void 0)) }, void 0)), (0, jsx_runtime_1.jsx)("button", { onClick: onClose, children: (0, jsx_runtime_1.jsx)("svg", { width: "10", height: "10", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: (0, jsx_runtime_1.jsx)("path", { d: "M.646.646a.5.5 0 0 1 .708 0L5 4.293 8.646.646a.5.5 0 1 1 .708.708L5.707 5l3.647 3.646a.5.5 0 1 1-.708.708L5 5.707 1.354 9.354a.5.5 0 1 1-.708-.708L4.293 5 .646 1.354a.5.5 0 0 1 0-.708Z" }, void 0) }, void 0) }, void 0)] }, void 0))] }, void 0));
};
exports.TitleBar = TitleBar;


/***/ }),

/***/ 2192:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InspectorApp = void 0;
const jsx_runtime_1 = __webpack_require__(38);
const react_router_dom_1 = __webpack_require__(384);
const react_dnd_1 = __webpack_require__(9013);
const react_dnd_html5_backend_1 = __webpack_require__(5696);
const ds_1 = __webpack_require__(8203);
const InspectorView_1 = __webpack_require__(3807);
const NotFound_1 = __webpack_require__(5861);
const react_1 = __webpack_require__(4191);
const user_schema_1 = __webpack_require__(7231);
const renderer_1 = __webpack_require__(1977);
const Container = ds_1.styled.main `
  user-select: none;
`;
const InspectorApp = () => {
    const [settings, setSettings] = (0, react_1.useState)(null);
    const systemTheme = (0, ds_1.useSystemTheme)();
    (0, react_1.useMemo)(() => {
        renderer_1.ipcRenderer.invoke('getUserSettings').then(({ settings }) => {
            setSettings(settings);
        });
    }, []);
    const theme = (0, react_1.useMemo)(() => {
        if (!settings?.theme || settings.theme === user_schema_1.ThemeTypes.SYSTEM) {
            return systemTheme;
        }
        return settings.theme;
    }, [settings, systemTheme]);
    return ((0, jsx_runtime_1.jsx)(react_router_dom_1.HashRouter, { children: (0, jsx_runtime_1.jsx)(ds_1.ThemeProvider, { name: theme, children: (0, jsx_runtime_1.jsx)(react_dnd_1.DndProvider, { backend: react_dnd_html5_backend_1.HTML5Backend, children: (0, jsx_runtime_1.jsx)(Container, { children: (0, jsx_runtime_1.jsxs)(react_router_dom_1.Routes, { children: [(0, jsx_runtime_1.jsx)(react_router_dom_1.Route, { path: "/", element: (0, jsx_runtime_1.jsx)(react_router_dom_1.Navigate, { to: "/inspector" }, void 0) }, void 0), (0, jsx_runtime_1.jsx)(react_router_dom_1.Route, { path: "/inspector/*", element: (0, jsx_runtime_1.jsx)(InspectorView_1.InspectorMainView, {}, void 0) }, void 0), (0, jsx_runtime_1.jsx)(react_router_dom_1.Route, { element: (0, jsx_runtime_1.jsx)(NotFound_1.NotFound, {}, void 0) }, void 0)] }, void 0) }, void 0) }, void 0) }, void 0) }, void 0));
};
exports.InspectorApp = InspectorApp;


/***/ }),

/***/ 7231:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.userSettingsDefaults = exports.ThemeTypes = void 0;
var ThemeTypes;
(function (ThemeTypes) {
    ThemeTypes["SYSTEM"] = "system";
    ThemeTypes["LIGHT"] = "light";
    ThemeTypes["DARK"] = "dark";
})(ThemeTypes = exports.ThemeTypes || (exports.ThemeTypes = {}));
exports.userSettingsDefaults = {
    userSettings: {
        theme: ThemeTypes.SYSTEM,
    },
};


/***/ }),

/***/ 2733:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (/* binding */ _extends)
/* harmony export */ });
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends.apply(this, arguments);
}

/***/ }),

/***/ 3699:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "Z": () => (/* binding */ _inheritsLoose)
});

;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf(o, p);
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/inheritsLoose.js

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf(subClass, superClass);
}

/***/ }),

/***/ 3560:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (/* binding */ _objectWithoutPropertiesLoose)
/* harmony export */ });
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

/***/ }),

/***/ 4123:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Gn": () => (/* binding */ IndentContext),
/* harmony export */   "K0": () => (/* binding */ getIndentation),
/* harmony export */   "Qf": () => (/* binding */ HighlightStyle),
/* harmony export */   "SS": () => (/* binding */ indentString),
/* harmony export */   "c": () => (/* binding */ indentUnit),
/* harmony export */   "il": () => (/* binding */ StreamLanguage),
/* harmony export */   "nF": () => (/* binding */ syntaxHighlighting),
/* harmony export */   "qz": () => (/* binding */ syntaxTree),
/* harmony export */   "y1": () => (/* binding */ getIndentUnit)
/* harmony export */ });
/* unused harmony exports LRLanguage, Language, LanguageDescription, LanguageSupport, ParseContext, StringStream, TreeIndentContext, bracketMatching, codeFolding, continuedIndent, defaultHighlightStyle, defineLanguageFacet, delimitedIndent, ensureSyntaxTree, flatIndent, foldAll, foldCode, foldEffect, foldGutter, foldInside, foldKeymap, foldNodeProp, foldService, foldState, foldable, foldedRanges, forceParsing, highlightingFor, indentNodeProp, indentOnInput, indentRange, indentService, language, languageDataProp, matchBrackets, syntaxParserRunning, syntaxTreeAvailable, unfoldAll, unfoldCode, unfoldEffect */
/* harmony import */ var _lezer_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8731);
/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(802);
/* harmony import */ var _codemirror_view__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(4512);
/* harmony import */ var _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1087);
/* harmony import */ var style_mod__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(1609);






var _a;
/**
Node prop stored in a parser's top syntax node to provide the
facet that stores language-specific data for that language.
*/
const languageDataProp = /*@__PURE__*/new _lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .NodeProp */ .md();
/**
Helper function to define a facet (to be added to the top syntax
node(s) for a language via
[`languageDataProp`](https://codemirror.net/6/docs/ref/#language.languageDataProp)), that will be
used to associate language data with the language. You
probably only need this when subclassing
[`Language`](https://codemirror.net/6/docs/ref/#language.Language).
*/
function defineLanguageFacet(baseData) {
    return _codemirror_state__WEBPACK_IMPORTED_MODULE_3__/* .Facet.define */ .r$.define({
        combine: baseData ? values => values.concat(baseData) : undefined
    });
}
/**
A language object manages parsing and per-language
[metadata](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt). Parse data is
managed as a [Lezer](https://lezer.codemirror.net) tree. The class
can be used directly, via the [`LRLanguage`](https://codemirror.net/6/docs/ref/#language.LRLanguage)
subclass for [Lezer](https://lezer.codemirror.net/) LR parsers, or
via the [`StreamLanguage`](https://codemirror.net/6/docs/ref/#language.StreamLanguage) subclass
for stream parsers.
*/
class Language {
    /**
    Construct a language object. If you need to invoke this
    directly, first define a data facet with
    [`defineLanguageFacet`](https://codemirror.net/6/docs/ref/#language.defineLanguageFacet), and then
    configure your parser to [attach](https://codemirror.net/6/docs/ref/#language.languageDataProp) it
    to the language's outer syntax node.
    */
    constructor(
    /**
    The [language data](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt) facet
    used for this language.
    */
    data, parser, extraExtensions = []) {
        this.data = data;
        // Kludge to define EditorState.tree as a debugging helper,
        // without the EditorState package actually knowing about
        // languages and lezer trees.
        if (!_codemirror_state__WEBPACK_IMPORTED_MODULE_3__/* .EditorState.prototype.hasOwnProperty */ .yy.prototype.hasOwnProperty("tree"))
            Object.defineProperty(_codemirror_state__WEBPACK_IMPORTED_MODULE_3__/* .EditorState.prototype */ .yy.prototype, "tree", { get() { return syntaxTree(this); } });
        this.parser = parser;
        this.extension = [
            language.of(this),
            _codemirror_state__WEBPACK_IMPORTED_MODULE_3__/* .EditorState.languageData.of */ .yy.languageData.of((state, pos, side) => state.facet(languageDataFacetAt(state, pos, side)))
        ].concat(extraExtensions);
    }
    /**
    Query whether this language is active at the given position.
    */
    isActiveAt(state, pos, side = -1) {
        return languageDataFacetAt(state, pos, side) == this.data;
    }
    /**
    Find the document regions that were parsed using this language.
    The returned regions will _include_ any nested languages rooted
    in this language, when those exist.
    */
    findRegions(state) {
        let lang = state.facet(language);
        if ((lang === null || lang === void 0 ? void 0 : lang.data) == this.data)
            return [{ from: 0, to: state.doc.length }];
        if (!lang || !lang.allowsNesting)
            return [];
        let result = [];
        let explore = (tree, from) => {
            if (tree.prop(languageDataProp) == this.data) {
                result.push({ from, to: from + tree.length });
                return;
            }
            let mount = tree.prop(_lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .NodeProp.mounted */ .md.mounted);
            if (mount) {
                if (mount.tree.prop(languageDataProp) == this.data) {
                    if (mount.overlay)
                        for (let r of mount.overlay)
                            result.push({ from: r.from + from, to: r.to + from });
                    else
                        result.push({ from: from, to: from + tree.length });
                    return;
                }
                else if (mount.overlay) {
                    let size = result.length;
                    explore(mount.tree, mount.overlay[0].from + from);
                    if (result.length > size)
                        return;
                }
            }
            for (let i = 0; i < tree.children.length; i++) {
                let ch = tree.children[i];
                if (ch instanceof _lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .Tree */ .mp)
                    explore(ch, tree.positions[i] + from);
            }
        };
        explore(syntaxTree(state), 0);
        return result;
    }
    /**
    Indicates whether this language allows nested languages. The
    default implementation returns true.
    */
    get allowsNesting() { return true; }
}
/**
@internal
*/
Language.setState = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_3__/* .StateEffect.define */ .Py.define();
function languageDataFacetAt(state, pos, side) {
    let topLang = state.facet(language);
    if (!topLang)
        return null;
    let facet = topLang.data;
    if (topLang.allowsNesting) {
        for (let node = syntaxTree(state).topNode; node; node = node.enter(pos, side, _lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .IterMode.ExcludeBuffers */ .vj.ExcludeBuffers))
            facet = node.type.prop(languageDataProp) || facet;
    }
    return facet;
}
/**
A subclass of [`Language`](https://codemirror.net/6/docs/ref/#language.Language) for use with Lezer
[LR parsers](https://lezer.codemirror.net/docs/ref#lr.LRParser)
parsers.
*/
class LRLanguage extends (/* unused pure expression or super */ null && (Language)) {
    constructor(data, parser) {
        super(data, parser);
        this.parser = parser;
    }
    /**
    Define a language from a parser.
    */
    static define(spec) {
        let data = defineLanguageFacet(spec.languageData);
        return new LRLanguage(data, spec.parser.configure({
            props: [languageDataProp.add(type => type.isTop ? data : undefined)]
        }));
    }
    /**
    Create a new instance of this language with a reconfigured
    version of its parser.
    */
    configure(options) {
        return new LRLanguage(this.data, this.parser.configure(options));
    }
    get allowsNesting() { return this.parser.hasWrappers(); }
}
/**
Get the syntax tree for a state, which is the current (possibly
incomplete) parse tree of the active
[language](https://codemirror.net/6/docs/ref/#language.Language), or the empty tree if there is no
language available.
*/
function syntaxTree(state) {
    let field = state.field(Language.state, false);
    return field ? field.tree : _lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .Tree.empty */ .mp.empty;
}
/**
Try to get a parse tree that spans at least up to `upto`. The
method will do at most `timeout` milliseconds of work to parse
up to that point if the tree isn't already available.
*/
function ensureSyntaxTree(state, upto, timeout = 50) {
    var _a;
    let parse = (_a = state.field(Language.state, false)) === null || _a === void 0 ? void 0 : _a.context;
    return !parse ? null : parse.isDone(upto) || parse.work(timeout, upto) ? parse.tree : null;
}
/**
Queries whether there is a full syntax tree available up to the
given document position. If there isn't, the background parse
process _might_ still be working and update the tree further, but
there is no guarantee of thatthe parser will [stop
working](https://codemirror.net/6/docs/ref/#language.syntaxParserRunning) when it has spent a
certain amount of time or has moved beyond the visible viewport.
Always returns false if no language has been enabled.
*/
function syntaxTreeAvailable(state, upto = state.doc.length) {
    var _a;
    return ((_a = state.field(Language.state, false)) === null || _a === void 0 ? void 0 : _a.context.isDone(upto)) || false;
}
/**
Move parsing forward, and update the editor state afterwards to
reflect the new tree. Will work for at most `timeout`
milliseconds. Returns true if the parser managed get to the given
position in that time.
*/
function forceParsing(view, upto = view.viewport.to, timeout = 100) {
    let success = ensureSyntaxTree(view.state, upto, timeout);
    if (success != syntaxTree(view.state))
        view.dispatch({});
    return !!success;
}
/**
Tells you whether the language parser is planning to do more
parsing work (in a `requestIdleCallback` pseudo-thread) or has
stopped running, either because it parsed the entire document,
because it spent too much time and was cut off, or because there
is no language parser enabled.
*/
function syntaxParserRunning(view) {
    var _a;
    return ((_a = view.plugin(parseWorker)) === null || _a === void 0 ? void 0 : _a.isWorking()) || false;
}
// Lezer-style Input object for a Text document.
class DocInput {
    constructor(doc, length = doc.length) {
        this.doc = doc;
        this.length = length;
        this.cursorPos = 0;
        this.string = "";
        this.cursor = doc.iter();
    }
    syncTo(pos) {
        this.string = this.cursor.next(pos - this.cursorPos).value;
        this.cursorPos = pos + this.string.length;
        return this.cursorPos - this.string.length;
    }
    chunk(pos) {
        this.syncTo(pos);
        return this.string;
    }
    get lineChunks() { return true; }
    read(from, to) {
        let stringStart = this.cursorPos - this.string.length;
        if (from < stringStart || to >= this.cursorPos)
            return this.doc.sliceString(from, to);
        else
            return this.string.slice(from - stringStart, to - stringStart);
    }
}
let currentContext = null;
/**
A parse context provided to parsers working on the editor content.
*/
class ParseContext {
    constructor(parser, 
    /**
    The current editor state.
    */
    state, 
    /**
    Tree fragments that can be reused by incremental re-parses.
    */
    fragments = [], 
    /**
    @internal
    */
    tree, 
    /**
    @internal
    */
    treeLen, 
    /**
    The current editor viewport (or some overapproximation
    thereof). Intended to be used for opportunistically avoiding
    work (in which case
    [`skipUntilInView`](https://codemirror.net/6/docs/ref/#language.ParseContext.skipUntilInView)
    should be called to make sure the parser is restarted when the
    skipped region becomes visible).
    */
    viewport, 
    /**
    @internal
    */
    skipped, 
    /**
    This is where skipping parsers can register a promise that,
    when resolved, will schedule a new parse. It is cleared when
    the parse worker picks up the promise. @internal
    */
    scheduleOn) {
        this.parser = parser;
        this.state = state;
        this.fragments = fragments;
        this.tree = tree;
        this.treeLen = treeLen;
        this.viewport = viewport;
        this.skipped = skipped;
        this.scheduleOn = scheduleOn;
        this.parse = null;
        /**
        @internal
        */
        this.tempSkipped = [];
    }
    /**
    @internal
    */
    static create(parser, state, viewport) {
        return new ParseContext(parser, state, [], _lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .Tree.empty */ .mp.empty, 0, viewport, [], null);
    }
    startParse() {
        return this.parser.startParse(new DocInput(this.state.doc), this.fragments);
    }
    /**
    @internal
    */
    work(until, upto) {
        if (upto != null && upto >= this.state.doc.length)
            upto = undefined;
        if (this.tree != _lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .Tree.empty */ .mp.empty && this.isDone(upto !== null && upto !== void 0 ? upto : this.state.doc.length)) {
            this.takeTree();
            return true;
        }
        return this.withContext(() => {
            var _a;
            if (typeof until == "number") {
                let endTime = Date.now() + until;
                until = () => Date.now() > endTime;
            }
            if (!this.parse)
                this.parse = this.startParse();
            if (upto != null && (this.parse.stoppedAt == null || this.parse.stoppedAt > upto) &&
                upto < this.state.doc.length)
                this.parse.stopAt(upto);
            for (;;) {
                let done = this.parse.advance();
                if (done) {
                    this.fragments = this.withoutTempSkipped(_lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .TreeFragment.addTree */ .i9.addTree(done, this.fragments, this.parse.stoppedAt != null));
                    this.treeLen = (_a = this.parse.stoppedAt) !== null && _a !== void 0 ? _a : this.state.doc.length;
                    this.tree = done;
                    this.parse = null;
                    if (this.treeLen < (upto !== null && upto !== void 0 ? upto : this.state.doc.length))
                        this.parse = this.startParse();
                    else
                        return true;
                }
                if (until())
                    return false;
            }
        });
    }
    /**
    @internal
    */
    takeTree() {
        let pos, tree;
        if (this.parse && (pos = this.parse.parsedPos) >= this.treeLen) {
            if (this.parse.stoppedAt == null || this.parse.stoppedAt > pos)
                this.parse.stopAt(pos);
            this.withContext(() => { while (!(tree = this.parse.advance())) { } });
            this.treeLen = pos;
            this.tree = tree;
            this.fragments = this.withoutTempSkipped(_lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .TreeFragment.addTree */ .i9.addTree(this.tree, this.fragments, true));
            this.parse = null;
        }
    }
    withContext(f) {
        let prev = currentContext;
        currentContext = this;
        try {
            return f();
        }
        finally {
            currentContext = prev;
        }
    }
    withoutTempSkipped(fragments) {
        for (let r; r = this.tempSkipped.pop();)
            fragments = cutFragments(fragments, r.from, r.to);
        return fragments;
    }
    /**
    @internal
    */
    changes(changes, newState) {
        let { fragments, tree, treeLen, viewport, skipped } = this;
        this.takeTree();
        if (!changes.empty) {
            let ranges = [];
            changes.iterChangedRanges((fromA, toA, fromB, toB) => ranges.push({ fromA, toA, fromB, toB }));
            fragments = _lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .TreeFragment.applyChanges */ .i9.applyChanges(fragments, ranges);
            tree = _lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .Tree.empty */ .mp.empty;
            treeLen = 0;
            viewport = { from: changes.mapPos(viewport.from, -1), to: changes.mapPos(viewport.to, 1) };
            if (this.skipped.length) {
                skipped = [];
                for (let r of this.skipped) {
                    let from = changes.mapPos(r.from, 1), to = changes.mapPos(r.to, -1);
                    if (from < to)
                        skipped.push({ from, to });
                }
            }
        }
        return new ParseContext(this.parser, newState, fragments, tree, treeLen, viewport, skipped, this.scheduleOn);
    }
    /**
    @internal
    */
    updateViewport(viewport) {
        if (this.viewport.from == viewport.from && this.viewport.to == viewport.to)
            return false;
        this.viewport = viewport;
        let startLen = this.skipped.length;
        for (let i = 0; i < this.skipped.length; i++) {
            let { from, to } = this.skipped[i];
            if (from < viewport.to && to > viewport.from) {
                this.fragments = cutFragments(this.fragments, from, to);
                this.skipped.splice(i--, 1);
            }
        }
        if (this.skipped.length >= startLen)
            return false;
        this.reset();
        return true;
    }
    /**
    @internal
    */
    reset() {
        if (this.parse) {
            this.takeTree();
            this.parse = null;
        }
    }
    /**
    Notify the parse scheduler that the given region was skipped
    because it wasn't in view, and the parse should be restarted
    when it comes into view.
    */
    skipUntilInView(from, to) {
        this.skipped.push({ from, to });
    }
    /**
    Returns a parser intended to be used as placeholder when
    asynchronously loading a nested parser. It'll skip its input and
    mark it as not-really-parsed, so that the next update will parse
    it again.
    
    When `until` is given, a reparse will be scheduled when that
    promise resolves.
    */
    static getSkippingParser(until) {
        return new class extends _lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .Parser */ ._b {
            createParse(input, fragments, ranges) {
                let from = ranges[0].from, to = ranges[ranges.length - 1].to;
                let parser = {
                    parsedPos: from,
                    advance() {
                        let cx = currentContext;
                        if (cx) {
                            for (let r of ranges)
                                cx.tempSkipped.push(r);
                            if (until)
                                cx.scheduleOn = cx.scheduleOn ? Promise.all([cx.scheduleOn, until]) : until;
                        }
                        this.parsedPos = to;
                        return new _lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .Tree */ .mp(_lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .NodeType.none */ .Jq.none, [], [], to - from);
                    },
                    stoppedAt: null,
                    stopAt() { }
                };
                return parser;
            }
        };
    }
    /**
    @internal
    */
    isDone(upto) {
        upto = Math.min(upto, this.state.doc.length);
        let frags = this.fragments;
        return this.treeLen >= upto && frags.length && frags[0].from == 0 && frags[0].to >= upto;
    }
    /**
    Get the context for the current parse, or `null` if no editor
    parse is in progress.
    */
    static get() { return currentContext; }
}
function cutFragments(fragments, from, to) {
    return _lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .TreeFragment.applyChanges */ .i9.applyChanges(fragments, [{ fromA: from, toA: to, fromB: from, toB: to }]);
}
class LanguageState {
    constructor(
    // A mutable parse state that is used to preserve work done during
    // the lifetime of a state when moving to the next state.
    context) {
        this.context = context;
        this.tree = context.tree;
    }
    apply(tr) {
        if (!tr.docChanged && this.tree == this.context.tree)
            return this;
        let newCx = this.context.changes(tr.changes, tr.state);
        // If the previous parse wasn't done, go forward only up to its
        // end position or the end of the viewport, to avoid slowing down
        // state updates with parse work beyond the viewport.
        let upto = this.context.treeLen == tr.startState.doc.length ? undefined
            : Math.max(tr.changes.mapPos(this.context.treeLen), newCx.viewport.to);
        if (!newCx.work(20 /* Apply */, upto))
            newCx.takeTree();
        return new LanguageState(newCx);
    }
    static init(state) {
        let vpTo = Math.min(3000 /* InitViewport */, state.doc.length);
        let parseState = ParseContext.create(state.facet(language).parser, state, { from: 0, to: vpTo });
        if (!parseState.work(20 /* Apply */, vpTo))
            parseState.takeTree();
        return new LanguageState(parseState);
    }
}
Language.state = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_3__/* .StateField.define */ .QQ.define({
    create: LanguageState.init,
    update(value, tr) {
        for (let e of tr.effects)
            if (e.is(Language.setState))
                return e.value;
        if (tr.startState.facet(language) != tr.state.facet(language))
            return LanguageState.init(tr.state);
        return value.apply(tr);
    }
});
let requestIdle = (callback) => {
    let timeout = setTimeout(() => callback(), 500 /* MaxPause */);
    return () => clearTimeout(timeout);
};
if (typeof requestIdleCallback != "undefined")
    requestIdle = (callback) => {
        let idle = -1, timeout = setTimeout(() => {
            idle = requestIdleCallback(callback, { timeout: 500 /* MaxPause */ - 100 /* MinPause */ });
        }, 100 /* MinPause */);
        return () => idle < 0 ? clearTimeout(timeout) : cancelIdleCallback(idle);
    };
const isInputPending = typeof navigator != "undefined" && ((_a = navigator.scheduling) === null || _a === void 0 ? void 0 : _a.isInputPending)
    ? () => navigator.scheduling.isInputPending() : null;
const parseWorker = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_4__/* .ViewPlugin.fromClass */ .lg.fromClass(class ParseWorker {
    constructor(view) {
        this.view = view;
        this.working = null;
        this.workScheduled = 0;
        // End of the current time chunk
        this.chunkEnd = -1;
        // Milliseconds of budget left for this chunk
        this.chunkBudget = -1;
        this.work = this.work.bind(this);
        this.scheduleWork();
    }
    update(update) {
        let cx = this.view.state.field(Language.state).context;
        if (cx.updateViewport(update.view.viewport) || this.view.viewport.to > cx.treeLen)
            this.scheduleWork();
        if (update.docChanged) {
            if (this.view.hasFocus)
                this.chunkBudget += 50 /* ChangeBonus */;
            this.scheduleWork();
        }
        this.checkAsyncSchedule(cx);
    }
    scheduleWork() {
        if (this.working)
            return;
        let { state } = this.view, field = state.field(Language.state);
        if (field.tree != field.context.tree || !field.context.isDone(state.doc.length))
            this.working = requestIdle(this.work);
    }
    work(deadline) {
        this.working = null;
        let now = Date.now();
        if (this.chunkEnd < now && (this.chunkEnd < 0 || this.view.hasFocus)) { // Start a new chunk
            this.chunkEnd = now + 30000 /* ChunkTime */;
            this.chunkBudget = 3000 /* ChunkBudget */;
        }
        if (this.chunkBudget <= 0)
            return; // No more budget
        let { state, viewport: { to: vpTo } } = this.view, field = state.field(Language.state);
        if (field.tree == field.context.tree && field.context.isDone(vpTo + 100000 /* MaxParseAhead */))
            return;
        let endTime = Date.now() + Math.min(this.chunkBudget, 100 /* Slice */, deadline && !isInputPending ? Math.max(25 /* MinSlice */, deadline.timeRemaining() - 5) : 1e9);
        let viewportFirst = field.context.treeLen < vpTo && state.doc.length > vpTo + 1000;
        let done = field.context.work(() => {
            return isInputPending && isInputPending() || Date.now() > endTime;
        }, vpTo + (viewportFirst ? 0 : 100000 /* MaxParseAhead */));
        this.chunkBudget -= Date.now() - now;
        if (done || this.chunkBudget <= 0) {
            field.context.takeTree();
            this.view.dispatch({ effects: Language.setState.of(new LanguageState(field.context)) });
        }
        if (this.chunkBudget > 0 && !(done && !viewportFirst))
            this.scheduleWork();
        this.checkAsyncSchedule(field.context);
    }
    checkAsyncSchedule(cx) {
        if (cx.scheduleOn) {
            this.workScheduled++;
            cx.scheduleOn
                .then(() => this.scheduleWork())
                .catch(err => (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_4__/* .logException */ .OO)(this.view.state, err))
                .then(() => this.workScheduled--);
            cx.scheduleOn = null;
        }
    }
    destroy() {
        if (this.working)
            this.working();
    }
    isWorking() {
        return !!(this.working || this.workScheduled > 0);
    }
}, {
    eventHandlers: { focus() { this.scheduleWork(); } }
});
/**
The facet used to associate a language with an editor state. Used
by `Language` object's `extension` property (so you don't need to
manually wrap your languages in this). Can be used to access the
current language on a state.
*/
const language = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_3__/* .Facet.define */ .r$.define({
    combine(languages) { return languages.length ? languages[0] : null; },
    enables: [Language.state, parseWorker]
});
/**
This class bundles a [language](https://codemirror.net/6/docs/ref/#language.Language) with an
optional set of supporting extensions. Language packages are
encouraged to export a function that optionally takes a
configuration object and returns a `LanguageSupport` instance, as
the main way for client code to use the package.
*/
class LanguageSupport {
    /**
    Create a language support object.
    */
    constructor(
    /**
    The language object.
    */
    language, 
    /**
    An optional set of supporting extensions. When nesting a
    language in another language, the outer language is encouraged
    to include the supporting extensions for its inner languages
    in its own set of support extensions.
    */
    support = []) {
        this.language = language;
        this.support = support;
        this.extension = [language, support];
    }
}
/**
Language descriptions are used to store metadata about languages
and to dynamically load them. Their main role is finding the
appropriate language for a filename or dynamically loading nested
parsers.
*/
class LanguageDescription {
    constructor(
    /**
    The name of this language.
    */
    name, 
    /**
    Alternative names for the mode (lowercased, includes `this.name`).
    */
    alias, 
    /**
    File extensions associated with this language.
    */
    extensions, 
    /**
    Optional filename pattern that should be associated with this
    language.
    */
    filename, loadFunc, 
    /**
    If the language has been loaded, this will hold its value.
    */
    support = undefined) {
        this.name = name;
        this.alias = alias;
        this.extensions = extensions;
        this.filename = filename;
        this.loadFunc = loadFunc;
        this.support = support;
        this.loading = null;
    }
    /**
    Start loading the the language. Will return a promise that
    resolves to a [`LanguageSupport`](https://codemirror.net/6/docs/ref/#language.LanguageSupport)
    object when the language successfully loads.
    */
    load() {
        return this.loading || (this.loading = this.loadFunc().then(support => this.support = support, err => { this.loading = null; throw err; }));
    }
    /**
    Create a language description.
    */
    static of(spec) {
        let { load, support } = spec;
        if (!load) {
            if (!support)
                throw new RangeError("Must pass either 'load' or 'support' to LanguageDescription.of");
            load = () => Promise.resolve(support);
        }
        return new LanguageDescription(spec.name, (spec.alias || []).concat(spec.name).map(s => s.toLowerCase()), spec.extensions || [], spec.filename, load, support);
    }
    /**
    Look for a language in the given array of descriptions that
    matches the filename. Will first match
    [`filename`](https://codemirror.net/6/docs/ref/#language.LanguageDescription.filename) patterns,
    and then [extensions](https://codemirror.net/6/docs/ref/#language.LanguageDescription.extensions),
    and return the first language that matches.
    */
    static matchFilename(descs, filename) {
        for (let d of descs)
            if (d.filename && d.filename.test(filename))
                return d;
        let ext = /\.([^.]+)$/.exec(filename);
        if (ext)
            for (let d of descs)
                if (d.extensions.indexOf(ext[1]) > -1)
                    return d;
        return null;
    }
    /**
    Look for a language whose name or alias matches the the given
    name (case-insensitively). If `fuzzy` is true, and no direct
    matchs is found, this'll also search for a language whose name
    or alias occurs in the string (for names shorter than three
    characters, only when surrounded by non-word characters).
    */
    static matchLanguageName(descs, name, fuzzy = true) {
        name = name.toLowerCase();
        for (let d of descs)
            if (d.alias.some(a => a == name))
                return d;
        if (fuzzy)
            for (let d of descs)
                for (let a of d.alias) {
                    let found = name.indexOf(a);
                    if (found > -1 && (a.length > 2 || !/\w/.test(name[found - 1]) && !/\w/.test(name[found + a.length])))
                        return d;
                }
        return null;
    }
}

/**
Facet that defines a way to provide a function that computes the
appropriate indentation depth at the start of a given line, or
`null` to indicate no appropriate indentation could be determined.
*/
const indentService = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_3__/* .Facet.define */ .r$.define();
/**
Facet for overriding the unit by which indentation happens.
Should be a string consisting either entirely of spaces or
entirely of tabs. When not set, this defaults to 2 spaces.
*/
const indentUnit = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_3__/* .Facet.define */ .r$.define({
    combine: values => {
        if (!values.length)
            return "  ";
        if (!/^(?: +|\t+)$/.test(values[0]))
            throw new Error("Invalid indent unit: " + JSON.stringify(values[0]));
        return values[0];
    }
});
/**
Return the _column width_ of an indent unit in the state.
Determined by the [`indentUnit`](https://codemirror.net/6/docs/ref/#language.indentUnit)
facet, and [`tabSize`](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize) when that
contains tabs.
*/
function getIndentUnit(state) {
    let unit = state.facet(indentUnit);
    return unit.charCodeAt(0) == 9 ? state.tabSize * unit.length : unit.length;
}
/**
Create an indentation string that covers columns 0 to `cols`.
Will use tabs for as much of the columns as possible when the
[`indentUnit`](https://codemirror.net/6/docs/ref/#language.indentUnit) facet contains
tabs.
*/
function indentString(state, cols) {
    let result = "", ts = state.tabSize;
    if (state.facet(indentUnit).charCodeAt(0) == 9)
        while (cols >= ts) {
            result += "\t";
            cols -= ts;
        }
    for (let i = 0; i < cols; i++)
        result += " ";
    return result;
}
/**
Get the indentation at the given position. Will first consult any
[indent services](https://codemirror.net/6/docs/ref/#language.indentService) that are registered,
and if none of those return an indentation, this will check the
syntax tree for the [indent node prop](https://codemirror.net/6/docs/ref/#language.indentNodeProp)
and use that if found. Returns a number when an indentation could
be determined, and null otherwise.
*/
function getIndentation(context, pos) {
    if (context instanceof _codemirror_state__WEBPACK_IMPORTED_MODULE_3__/* .EditorState */ .yy)
        context = new IndentContext(context);
    for (let service of context.state.facet(indentService)) {
        let result = service(context, pos);
        if (result != null)
            return result;
    }
    let tree = syntaxTree(context.state);
    return tree ? syntaxIndentation(context, tree, pos) : null;
}
/**
Create a change set that auto-indents all lines touched by the
given document range.
*/
function indentRange(state, from, to) {
    let updated = Object.create(null);
    let context = new IndentContext(state, { overrideIndentation: start => { var _a; return (_a = updated[start]) !== null && _a !== void 0 ? _a : -1; } });
    let changes = [];
    for (let pos = from; pos <= to;) {
        let line = state.doc.lineAt(pos);
        pos = line.to + 1;
        let indent = getIndentation(context, line.from);
        if (indent == null)
            continue;
        if (!/\S/.test(line.text))
            indent = 0;
        let cur = /^\s*/.exec(line.text)[0];
        let norm = indentString(state, indent);
        if (cur != norm) {
            updated[line.from] = indent;
            changes.push({ from: line.from, to: line.from + cur.length, insert: norm });
        }
    }
    return state.changes(changes);
}
/**
Indentation contexts are used when calling [indentation
services](https://codemirror.net/6/docs/ref/#language.indentService). They provide helper utilities
useful in indentation logic, and can selectively override the
indentation reported for some lines.
*/
class IndentContext {
    /**
    Create an indent context.
    */
    constructor(
    /**
    The editor state.
    */
    state, 
    /**
    @internal
    */
    options = {}) {
        this.state = state;
        this.options = options;
        this.unit = getIndentUnit(state);
    }
    /**
    Get a description of the line at the given position, taking
    [simulated line
    breaks](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
    into account. If there is such a break at `pos`, the `bias`
    argument determines whether the part of the line line before or
    after the break is used.
    */
    lineAt(pos, bias = 1) {
        let line = this.state.doc.lineAt(pos);
        let { simulateBreak, simulateDoubleBreak } = this.options;
        if (simulateBreak != null && simulateBreak >= line.from && simulateBreak <= line.to) {
            if (simulateDoubleBreak && simulateBreak == pos)
                return { text: "", from: pos };
            else if (bias < 0 ? simulateBreak < pos : simulateBreak <= pos)
                return { text: line.text.slice(simulateBreak - line.from), from: simulateBreak };
            else
                return { text: line.text.slice(0, simulateBreak - line.from), from: line.from };
        }
        return line;
    }
    /**
    Get the text directly after `pos`, either the entire line
    or the next 100 characters, whichever is shorter.
    */
    textAfterPos(pos, bias = 1) {
        if (this.options.simulateDoubleBreak && pos == this.options.simulateBreak)
            return "";
        let { text, from } = this.lineAt(pos, bias);
        return text.slice(pos - from, Math.min(text.length, pos + 100 - from));
    }
    /**
    Find the column for the given position.
    */
    column(pos, bias = 1) {
        let { text, from } = this.lineAt(pos, bias);
        let result = this.countColumn(text, pos - from);
        let override = this.options.overrideIndentation ? this.options.overrideIndentation(from) : -1;
        if (override > -1)
            result += override - this.countColumn(text, text.search(/\S|$/));
        return result;
    }
    /**
    Find the column position (taking tabs into account) of the given
    position in the given string.
    */
    countColumn(line, pos = line.length) {
        return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_3__/* .countColumn */ .IS)(line, this.state.tabSize, pos);
    }
    /**
    Find the indentation column of the line at the given point.
    */
    lineIndent(pos, bias = 1) {
        let { text, from } = this.lineAt(pos, bias);
        let override = this.options.overrideIndentation;
        if (override) {
            let overriden = override(from);
            if (overriden > -1)
                return overriden;
        }
        return this.countColumn(text, text.search(/\S|$/));
    }
    /**
    Returns the [simulated line
    break](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
    for this context, if any.
    */
    get simulatedBreak() {
        return this.options.simulateBreak || null;
    }
}
/**
A syntax tree node prop used to associate indentation strategies
with node types. Such a strategy is a function from an indentation
context to a column number or null, where null indicates that no
definitive indentation can be determined.
*/
const indentNodeProp = /*@__PURE__*/new _lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .NodeProp */ .md();
// Compute the indentation for a given position from the syntax tree.
function syntaxIndentation(cx, ast, pos) {
    return indentFrom(ast.resolveInner(pos).enterUnfinishedNodesBefore(pos), pos, cx);
}
function ignoreClosed(cx) {
    return cx.pos == cx.options.simulateBreak && cx.options.simulateDoubleBreak;
}
function indentStrategy(tree) {
    let strategy = tree.type.prop(indentNodeProp);
    if (strategy)
        return strategy;
    let first = tree.firstChild, close;
    if (first && (close = first.type.prop(_lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .NodeProp.closedBy */ .md.closedBy))) {
        let last = tree.lastChild, closed = last && close.indexOf(last.name) > -1;
        return cx => delimitedStrategy(cx, true, 1, undefined, closed && !ignoreClosed(cx) ? last.from : undefined);
    }
    return tree.parent == null ? topIndent : null;
}
function indentFrom(node, pos, base) {
    for (; node; node = node.parent) {
        let strategy = indentStrategy(node);
        if (strategy)
            return strategy(TreeIndentContext.create(base, pos, node));
    }
    return null;
}
function topIndent() { return 0; }
/**
Objects of this type provide context information and helper
methods to indentation functions registered on syntax nodes.
*/
class TreeIndentContext extends IndentContext {
    constructor(base, 
    /**
    The position at which indentation is being computed.
    */
    pos, 
    /**
    The syntax tree node to which the indentation strategy
    applies.
    */
    node) {
        super(base.state, base.options);
        this.base = base;
        this.pos = pos;
        this.node = node;
    }
    /**
    @internal
    */
    static create(base, pos, node) {
        return new TreeIndentContext(base, pos, node);
    }
    /**
    Get the text directly after `this.pos`, either the entire line
    or the next 100 characters, whichever is shorter.
    */
    get textAfter() {
        return this.textAfterPos(this.pos);
    }
    /**
    Get the indentation at the reference line for `this.node`, which
    is the line on which it starts, unless there is a node that is
    _not_ a parent of this node covering the start of that line. If
    so, the line at the start of that node is tried, again skipping
    on if it is covered by another such node.
    */
    get baseIndent() {
        let line = this.state.doc.lineAt(this.node.from);
        // Skip line starts that are covered by a sibling (or cousin, etc)
        for (;;) {
            let atBreak = this.node.resolve(line.from);
            while (atBreak.parent && atBreak.parent.from == atBreak.from)
                atBreak = atBreak.parent;
            if (isParent(atBreak, this.node))
                break;
            line = this.state.doc.lineAt(atBreak.from);
        }
        return this.lineIndent(line.from);
    }
    /**
    Continue looking for indentations in the node's parent nodes,
    and return the result of that.
    */
    continue() {
        let parent = this.node.parent;
        return parent ? indentFrom(parent, this.pos, this.base) : 0;
    }
}
function isParent(parent, of) {
    for (let cur = of; cur; cur = cur.parent)
        if (parent == cur)
            return true;
    return false;
}
// Check whether a delimited node is aligned (meaning there are
// non-skipped nodes on the same line as the opening delimiter). And
// if so, return the opening token.
function bracketedAligned(context) {
    let tree = context.node;
    let openToken = tree.childAfter(tree.from), last = tree.lastChild;
    if (!openToken)
        return null;
    let sim = context.options.simulateBreak;
    let openLine = context.state.doc.lineAt(openToken.from);
    let lineEnd = sim == null || sim <= openLine.from ? openLine.to : Math.min(openLine.to, sim);
    for (let pos = openToken.to;;) {
        let next = tree.childAfter(pos);
        if (!next || next == last)
            return null;
        if (!next.type.isSkipped)
            return next.from < lineEnd ? openToken : null;
        pos = next.to;
    }
}
/**
An indentation strategy for delimited (usually bracketed) nodes.
Will, by default, indent one unit more than the parent's base
indent unless the line starts with a closing token. When `align`
is true and there are non-skipped nodes on the node's opening
line, the content of the node will be aligned with the end of the
opening node, like this:

    foo(bar,
        baz)
*/
function delimitedIndent({ closing, align = true, units = 1 }) {
    return (context) => delimitedStrategy(context, align, units, closing);
}
function delimitedStrategy(context, align, units, closing, closedAt) {
    let after = context.textAfter, space = after.match(/^\s*/)[0].length;
    let closed = closing && after.slice(space, space + closing.length) == closing || closedAt == context.pos + space;
    let aligned = align ? bracketedAligned(context) : null;
    if (aligned)
        return closed ? context.column(aligned.from) : context.column(aligned.to);
    return context.baseIndent + (closed ? 0 : context.unit * units);
}
/**
An indentation strategy that aligns a node's content to its base
indentation.
*/
const flatIndent = (context) => context.baseIndent;
/**
Creates an indentation strategy that, by default, indents
continued lines one unit more than the node's base indentation.
You can provide `except` to prevent indentation of lines that
match a pattern (for example `/^else\b/` in `if`/`else`
constructs), and you can change the amount of units used with the
`units` option.
*/
function continuedIndent({ except, units = 1 } = {}) {
    return (context) => {
        let matchExcept = except && except.test(context.textAfter);
        return context.baseIndent + (matchExcept ? 0 : units * context.unit);
    };
}
const DontIndentBeyond = 200;
/**
Enables reindentation on input. When a language defines an
`indentOnInput` field in its [language
data](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt), which must hold a regular
expression, the line at the cursor will be reindented whenever new
text is typed and the input from the start of the line up to the
cursor matches that regexp.

To avoid unneccesary reindents, it is recommended to start the
regexp with `^` (usually followed by `\s*`), and end it with `$`.
For example, `/^\s*\}$/` will reindent when a closing brace is
added at the start of a line.
*/
function indentOnInput() {
    return EditorState.transactionFilter.of(tr => {
        if (!tr.docChanged || !tr.isUserEvent("input.type") && !tr.isUserEvent("input.complete"))
            return tr;
        let rules = tr.startState.languageDataAt("indentOnInput", tr.startState.selection.main.head);
        if (!rules.length)
            return tr;
        let doc = tr.newDoc, { head } = tr.newSelection.main, line = doc.lineAt(head);
        if (head > line.from + DontIndentBeyond)
            return tr;
        let lineStart = doc.sliceString(line.from, head);
        if (!rules.some(r => r.test(lineStart)))
            return tr;
        let { state } = tr, last = -1, changes = [];
        for (let { head } of state.selection.ranges) {
            let line = state.doc.lineAt(head);
            if (line.from == last)
                continue;
            last = line.from;
            let indent = getIndentation(state, line.from);
            if (indent == null)
                continue;
            let cur = /^\s*/.exec(line.text)[0];
            let norm = indentString(state, indent);
            if (cur != norm)
                changes.push({ from: line.from, to: line.from + cur.length, insert: norm });
        }
        return changes.length ? [tr, { changes, sequential: true }] : tr;
    });
}

/**
A facet that registers a code folding service. When called with
the extent of a line, such a function should return a foldable
range that starts on that line (but continues beyond it), if one
can be found.
*/
const foldService = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_3__/* .Facet.define */ .r$.define();
/**
This node prop is used to associate folding information with
syntax node types. Given a syntax node, it should check whether
that tree is foldable and return the range that can be collapsed
when it is.
*/
const foldNodeProp = /*@__PURE__*/new _lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .NodeProp */ .md();
/**
[Fold](https://codemirror.net/6/docs/ref/#language.foldNodeProp) function that folds everything but
the first and the last child of a syntax node. Useful for nodes
that start and end with delimiters.
*/
function foldInside(node) {
    let first = node.firstChild, last = node.lastChild;
    return first && first.to < last.from ? { from: first.to, to: last.type.isError ? node.to : last.from } : null;
}
function syntaxFolding(state, start, end) {
    let tree = syntaxTree(state);
    if (tree.length < end)
        return null;
    let inner = tree.resolveInner(end);
    let found = null;
    for (let cur = inner; cur; cur = cur.parent) {
        if (cur.to <= end || cur.from > end)
            continue;
        if (found && cur.from < start)
            break;
        let prop = cur.type.prop(foldNodeProp);
        if (prop && (cur.to < tree.length - 50 || tree.length == state.doc.length || !isUnfinished(cur))) {
            let value = prop(cur, state);
            if (value && value.from <= end && value.from >= start && value.to > end)
                found = value;
        }
    }
    return found;
}
function isUnfinished(node) {
    let ch = node.lastChild;
    return ch && ch.to == node.to && ch.type.isError;
}
/**
Check whether the given line is foldable. First asks any fold
services registered through
[`foldService`](https://codemirror.net/6/docs/ref/#language.foldService), and if none of them return
a result, tries to query the [fold node
prop](https://codemirror.net/6/docs/ref/#language.foldNodeProp) of syntax nodes that cover the end
of the line.
*/
function foldable(state, lineStart, lineEnd) {
    for (let service of state.facet(foldService)) {
        let result = service(state, lineStart, lineEnd);
        if (result)
            return result;
    }
    return syntaxFolding(state, lineStart, lineEnd);
}
function mapRange(range, mapping) {
    let from = mapping.mapPos(range.from, 1), to = mapping.mapPos(range.to, -1);
    return from >= to ? undefined : { from, to };
}
/**
State effect that can be attached to a transaction to fold the
given range. (You probably only need this in exceptional
circumstancesusually you'll just want to let
[`foldCode`](https://codemirror.net/6/docs/ref/#language.foldCode) and the [fold
gutter](https://codemirror.net/6/docs/ref/#language.foldGutter) create the transactions.)
*/
const foldEffect = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_3__/* .StateEffect.define */ .Py.define({ map: mapRange });
/**
State effect that unfolds the given range (if it was folded).
*/
const unfoldEffect = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_3__/* .StateEffect.define */ .Py.define({ map: mapRange });
function selectedLines(view) {
    let lines = [];
    for (let { head } of view.state.selection.ranges) {
        if (lines.some(l => l.from <= head && l.to >= head))
            continue;
        lines.push(view.lineBlockAt(head));
    }
    return lines;
}
/**
The state field that stores the folded ranges (as a [decoration
set](https://codemirror.net/6/docs/ref/#view.DecorationSet)). Can be passed to
[`EditorState.toJSON`](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) and
[`fromJSON`](https://codemirror.net/6/docs/ref/#state.EditorState^fromJSON) to serialize the fold
state.
*/
const foldState = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_3__/* .StateField.define */ .QQ.define({
    create() {
        return _codemirror_view__WEBPACK_IMPORTED_MODULE_4__/* .Decoration.none */ .p.none;
    },
    update(folded, tr) {
        folded = folded.map(tr.changes);
        for (let e of tr.effects) {
            if (e.is(foldEffect) && !foldExists(folded, e.value.from, e.value.to))
                folded = folded.update({ add: [foldWidget.range(e.value.from, e.value.to)] });
            else if (e.is(unfoldEffect))
                folded = folded.update({ filter: (from, to) => e.value.from != from || e.value.to != to,
                    filterFrom: e.value.from, filterTo: e.value.to });
        }
        // Clear folded ranges that cover the selection head
        if (tr.selection) {
            let onSelection = false, { head } = tr.selection.main;
            folded.between(head, head, (a, b) => { if (a < head && b > head)
                onSelection = true; });
            if (onSelection)
                folded = folded.update({
                    filterFrom: head,
                    filterTo: head,
                    filter: (a, b) => b <= head || a >= head
                });
        }
        return folded;
    },
    provide: f => _codemirror_view__WEBPACK_IMPORTED_MODULE_4__/* .EditorView.decorations.from */ .tk.decorations.from(f),
    toJSON(folded, state) {
        let ranges = [];
        folded.between(0, state.doc.length, (from, to) => { ranges.push(from, to); });
        return ranges;
    },
    fromJSON(value) {
        if (!Array.isArray(value) || value.length % 2)
            throw new RangeError("Invalid JSON for fold state");
        let ranges = [];
        for (let i = 0; i < value.length;) {
            let from = value[i++], to = value[i++];
            if (typeof from != "number" || typeof to != "number")
                throw new RangeError("Invalid JSON for fold state");
            ranges.push(foldWidget.range(from, to));
        }
        return _codemirror_view__WEBPACK_IMPORTED_MODULE_4__/* .Decoration.set */ .p.set(ranges, true);
    }
});
/**
Get a [range set](https://codemirror.net/6/docs/ref/#state.RangeSet) containing the folded ranges
in the given state.
*/
function foldedRanges(state) {
    return state.field(foldState, false) || RangeSet.empty;
}
function findFold(state, from, to) {
    var _a;
    let found = null;
    (_a = state.field(foldState, false)) === null || _a === void 0 ? void 0 : _a.between(from, to, (from, to) => {
        if (!found || found.from > from)
            found = { from, to };
    });
    return found;
}
function foldExists(folded, from, to) {
    let found = false;
    folded.between(from, from, (a, b) => { if (a == from && b == to)
        found = true; });
    return found;
}
function maybeEnable(state, other) {
    return state.field(foldState, false) ? other : other.concat(_codemirror_state__WEBPACK_IMPORTED_MODULE_3__/* .StateEffect.appendConfig.of */ .Py.appendConfig.of(codeFolding()));
}
/**
Fold the lines that are selected, if possible.
*/
const foldCode = view => {
    for (let line of selectedLines(view)) {
        let range = foldable(view.state, line.from, line.to);
        if (range) {
            view.dispatch({ effects: maybeEnable(view.state, [foldEffect.of(range), announceFold(view, range)]) });
            return true;
        }
    }
    return false;
};
/**
Unfold folded ranges on selected lines.
*/
const unfoldCode = view => {
    if (!view.state.field(foldState, false))
        return false;
    let effects = [];
    for (let line of selectedLines(view)) {
        let folded = findFold(view.state, line.from, line.to);
        if (folded)
            effects.push(unfoldEffect.of(folded), announceFold(view, folded, false));
    }
    if (effects.length)
        view.dispatch({ effects });
    return effects.length > 0;
};
function announceFold(view, range, fold = true) {
    let lineFrom = view.state.doc.lineAt(range.from).number, lineTo = view.state.doc.lineAt(range.to).number;
    return _codemirror_view__WEBPACK_IMPORTED_MODULE_4__/* .EditorView.announce.of */ .tk.announce.of(`${view.state.phrase(fold ? "Folded lines" : "Unfolded lines")} ${lineFrom} ${view.state.phrase("to")} ${lineTo}.`);
}
/**
Fold all top-level foldable ranges. Note that, in most cases,
folding information will depend on the [syntax
tree](https://codemirror.net/6/docs/ref/#language.syntaxTree), and folding everything may not work
reliably when the document hasn't been fully parsed (either
because the editor state was only just initialized, or because the
document is so big that the parser decided not to parse it
entirely).
*/
const foldAll = view => {
    let { state } = view, effects = [];
    for (let pos = 0; pos < state.doc.length;) {
        let line = view.lineBlockAt(pos), range = foldable(state, line.from, line.to);
        if (range)
            effects.push(foldEffect.of(range));
        pos = (range ? view.lineBlockAt(range.to) : line).to + 1;
    }
    if (effects.length)
        view.dispatch({ effects: maybeEnable(view.state, effects) });
    return !!effects.length;
};
/**
Unfold all folded code.
*/
const unfoldAll = view => {
    let field = view.state.field(foldState, false);
    if (!field || !field.size)
        return false;
    let effects = [];
    field.between(0, view.state.doc.length, (from, to) => { effects.push(unfoldEffect.of({ from, to })); });
    view.dispatch({ effects });
    return true;
};
/**
Default fold-related key bindings.

 - Ctrl-Shift-[ (Cmd-Alt-[ on macOS): [`foldCode`](https://codemirror.net/6/docs/ref/#language.foldCode).
 - Ctrl-Shift-] (Cmd-Alt-] on macOS): [`unfoldCode`](https://codemirror.net/6/docs/ref/#language.unfoldCode).
 - Ctrl-Alt-[: [`foldAll`](https://codemirror.net/6/docs/ref/#language.foldAll).
 - Ctrl-Alt-]: [`unfoldAll`](https://codemirror.net/6/docs/ref/#language.unfoldAll).
*/
const foldKeymap = [
    { key: "Ctrl-Shift-[", mac: "Cmd-Alt-[", run: foldCode },
    { key: "Ctrl-Shift-]", mac: "Cmd-Alt-]", run: unfoldCode },
    { key: "Ctrl-Alt-[", run: foldAll },
    { key: "Ctrl-Alt-]", run: unfoldAll }
];
const defaultConfig = {
    placeholderDOM: null,
    placeholderText: ""
};
const foldConfig = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_3__/* .Facet.define */ .r$.define({
    combine(values) { return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_3__/* .combineConfig */ .BO)(values, defaultConfig); }
});
/**
Create an extension that configures code folding.
*/
function codeFolding(config) {
    let result = [foldState, baseTheme$1];
    if (config)
        result.push(foldConfig.of(config));
    return result;
}
const foldWidget = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_4__/* .Decoration.replace */ .p.replace({ widget: /*@__PURE__*/new class extends _codemirror_view__WEBPACK_IMPORTED_MODULE_4__/* .WidgetType */ .l9 {
        toDOM(view) {
            let { state } = view, conf = state.facet(foldConfig);
            let onclick = (event) => {
                let line = view.lineBlockAt(view.posAtDOM(event.target));
                let folded = findFold(view.state, line.from, line.to);
                if (folded)
                    view.dispatch({ effects: unfoldEffect.of(folded) });
                event.preventDefault();
            };
            if (conf.placeholderDOM)
                return conf.placeholderDOM(view, onclick);
            let element = document.createElement("span");
            element.textContent = conf.placeholderText;
            element.setAttribute("aria-label", state.phrase("folded code"));
            element.title = state.phrase("unfold");
            element.className = "cm-foldPlaceholder";
            element.onclick = onclick;
            return element;
        }
    } });
const foldGutterDefaults = {
    openText: "",
    closedText: "",
    markerDOM: null,
    domEventHandlers: {},
    foldingChanged: () => false
};
class FoldMarker extends (/* unused pure expression or super */ null && (GutterMarker)) {
    constructor(config, open) {
        super();
        this.config = config;
        this.open = open;
    }
    eq(other) { return this.config == other.config && this.open == other.open; }
    toDOM(view) {
        if (this.config.markerDOM)
            return this.config.markerDOM(this.open);
        let span = document.createElement("span");
        span.textContent = this.open ? this.config.openText : this.config.closedText;
        span.title = view.state.phrase(this.open ? "Fold line" : "Unfold line");
        return span;
    }
}
/**
Create an extension that registers a fold gutter, which shows a
fold status indicator before foldable lines (which can be clicked
to fold or unfold the line).
*/
function foldGutter(config = {}) {
    let fullConfig = Object.assign(Object.assign({}, foldGutterDefaults), config);
    let canFold = new FoldMarker(fullConfig, true), canUnfold = new FoldMarker(fullConfig, false);
    let markers = ViewPlugin.fromClass(class {
        constructor(view) {
            this.from = view.viewport.from;
            this.markers = this.buildMarkers(view);
        }
        update(update) {
            if (update.docChanged || update.viewportChanged ||
                update.startState.facet(language) != update.state.facet(language) ||
                update.startState.field(foldState, false) != update.state.field(foldState, false) ||
                syntaxTree(update.startState) != syntaxTree(update.state) ||
                fullConfig.foldingChanged(update))
                this.markers = this.buildMarkers(update.view);
        }
        buildMarkers(view) {
            let builder = new RangeSetBuilder();
            for (let line of view.viewportLineBlocks) {
                let mark = findFold(view.state, line.from, line.to) ? canUnfold
                    : foldable(view.state, line.from, line.to) ? canFold : null;
                if (mark)
                    builder.add(line.from, line.from, mark);
            }
            return builder.finish();
        }
    });
    let { domEventHandlers } = fullConfig;
    return [
        markers,
        gutter({
            class: "cm-foldGutter",
            markers(view) { var _a; return ((_a = view.plugin(markers)) === null || _a === void 0 ? void 0 : _a.markers) || RangeSet.empty; },
            initialSpacer() {
                return new FoldMarker(fullConfig, false);
            },
            domEventHandlers: Object.assign(Object.assign({}, domEventHandlers), { click: (view, line, event) => {
                    if (domEventHandlers.click && domEventHandlers.click(view, line, event))
                        return true;
                    let folded = findFold(view.state, line.from, line.to);
                    if (folded) {
                        view.dispatch({ effects: unfoldEffect.of(folded) });
                        return true;
                    }
                    let range = foldable(view.state, line.from, line.to);
                    if (range) {
                        view.dispatch({ effects: foldEffect.of(range) });
                        return true;
                    }
                    return false;
                } })
        }),
        codeFolding()
    ];
}
const baseTheme$1 = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_4__/* .EditorView.baseTheme */ .tk.baseTheme({
    ".cm-foldPlaceholder": {
        backgroundColor: "#eee",
        border: "1px solid #ddd",
        color: "#888",
        borderRadius: ".2em",
        margin: "0 1px",
        padding: "0 1px",
        cursor: "pointer"
    },
    ".cm-foldGutter span": {
        padding: "0 1px",
        cursor: "pointer"
    }
});

/**
A highlight style associates CSS styles with higlighting
[tags](https://lezer.codemirror.net/docs/ref#highlight.Tag).
*/
class HighlightStyle {
    constructor(spec, options) {
        let modSpec;
        function def(spec) {
            let cls = style_mod__WEBPACK_IMPORTED_MODULE_2__/* .StyleModule.newName */ .V.newName();
            (modSpec || (modSpec = Object.create(null)))["." + cls] = spec;
            return cls;
        }
        const all = typeof options.all == "string" ? options.all : options.all ? def(options.all) : undefined;
        const scopeOpt = options.scope;
        this.scope = scopeOpt instanceof Language ? (type) => type.prop(languageDataProp) == scopeOpt.data
            : scopeOpt ? (type) => type == scopeOpt : undefined;
        this.style = (0,_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__/* .tagHighlighter */ .QR)(spec.map(style => ({
            tag: style.tag,
            class: style.class || def(Object.assign({}, style, { tag: null }))
        })), {
            all,
        }).style;
        this.module = modSpec ? new style_mod__WEBPACK_IMPORTED_MODULE_2__/* .StyleModule */ .V(modSpec) : null;
        this.themeType = options.themeType;
    }
    /**
    Create a highlighter style that associates the given styles to
    the given tags. The specs must be objects that hold a style tag
    or array of tags in their `tag` property, and either a single
    `class` property providing a static CSS class (for highlighter
    that rely on external styling), or a
    [`style-mod`](https://github.com/marijnh/style-mod#documentation)-style
    set of CSS properties (which define the styling for those tags).
    
    The CSS rules created for a highlighter will be emitted in the
    order of the spec's properties. That means that for elements that
    have multiple tags associated with them, styles defined further
    down in the list will have a higher CSS precedence than styles
    defined earlier.
    */
    static define(specs, options) {
        return new HighlightStyle(specs, options || {});
    }
}
const highlighterFacet = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_3__/* .Facet.define */ .r$.define();
const fallbackHighlighter = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_3__/* .Facet.define */ .r$.define({
    combine(values) { return values.length ? [values[0]] : null; }
});
function getHighlighters(state) {
    let main = state.facet(highlighterFacet);
    return main.length ? main : state.facet(fallbackHighlighter);
}
/**
Wrap a highlighter in an editor extension that uses it to apply
syntax highlighting to the editor content.

When multiple (non-fallback) styles are provided, the styling
applied is the union of the classes they emit.
*/
function syntaxHighlighting(highlighter, options) {
    let ext = [treeHighlighter], themeType;
    if (highlighter instanceof HighlightStyle) {
        if (highlighter.module)
            ext.push(_codemirror_view__WEBPACK_IMPORTED_MODULE_4__/* .EditorView.styleModule.of */ .tk.styleModule.of(highlighter.module));
        themeType = highlighter.themeType;
    }
    if (options === null || options === void 0 ? void 0 : options.fallback)
        ext.push(fallbackHighlighter.of(highlighter));
    else if (themeType)
        ext.push(highlighterFacet.computeN([_codemirror_view__WEBPACK_IMPORTED_MODULE_4__/* .EditorView.darkTheme */ .tk.darkTheme], state => {
            return state.facet(_codemirror_view__WEBPACK_IMPORTED_MODULE_4__/* .EditorView.darkTheme */ .tk.darkTheme) == (themeType == "dark") ? [highlighter] : [];
        }));
    else
        ext.push(highlighterFacet.of(highlighter));
    return ext;
}
/**
Returns the CSS classes (if any) that the highlighters active in
the state would assign to the given style
[tags](https://lezer.codemirror.net/docs/ref#highlight.Tag) and
(optional) language
[scope](https://codemirror.net/6/docs/ref/#language.HighlightStyle^define^options.scope).
*/
function highlightingFor(state, tags, scope) {
    let highlighters = getHighlighters(state);
    let result = null;
    if (highlighters)
        for (let highlighter of highlighters) {
            if (!highlighter.scope || scope && highlighter.scope(scope)) {
                let cls = highlighter.style(tags);
                if (cls)
                    result = result ? result + " " + cls : cls;
            }
        }
    return result;
}
class TreeHighlighter {
    constructor(view) {
        this.markCache = Object.create(null);
        this.tree = syntaxTree(view.state);
        this.decorations = this.buildDeco(view, getHighlighters(view.state));
    }
    update(update) {
        let tree = syntaxTree(update.state), highlighters = getHighlighters(update.state);
        let styleChange = highlighters != getHighlighters(update.startState);
        if (tree.length < update.view.viewport.to && !styleChange && tree.type == this.tree.type) {
            this.decorations = this.decorations.map(update.changes);
        }
        else if (tree != this.tree || update.viewportChanged || styleChange) {
            this.tree = tree;
            this.decorations = this.buildDeco(update.view, highlighters);
        }
    }
    buildDeco(view, highlighters) {
        if (!highlighters || !this.tree.length)
            return _codemirror_view__WEBPACK_IMPORTED_MODULE_4__/* .Decoration.none */ .p.none;
        let builder = new _codemirror_state__WEBPACK_IMPORTED_MODULE_3__/* .RangeSetBuilder */ .f_();
        for (let { from, to } of view.visibleRanges) {
            (0,_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__/* .highlightTree */ .bW)(this.tree, highlighters, (from, to, style) => {
                builder.add(from, to, this.markCache[style] || (this.markCache[style] = _codemirror_view__WEBPACK_IMPORTED_MODULE_4__/* .Decoration.mark */ .p.mark({ class: style })));
            }, from, to);
        }
        return builder.finish();
    }
}
const treeHighlighter = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_3__/* .Prec.high */ .Wl.high(/*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_4__/* .ViewPlugin.fromClass */ .lg.fromClass(TreeHighlighter, {
    decorations: v => v.decorations
}));
/**
A default highlight style (works well with light themes).
*/
const defaultHighlightStyle = /*@__PURE__*/HighlightStyle.define([
    { tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__/* .tags.meta */ .pJ.meta,
        color: "#7a757a" },
    { tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__/* .tags.link */ .pJ.link,
        textDecoration: "underline" },
    { tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__/* .tags.heading */ .pJ.heading,
        textDecoration: "underline",
        fontWeight: "bold" },
    { tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__/* .tags.emphasis */ .pJ.emphasis,
        fontStyle: "italic" },
    { tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__/* .tags.strong */ .pJ.strong,
        fontWeight: "bold" },
    { tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__/* .tags.strikethrough */ .pJ.strikethrough,
        textDecoration: "line-through" },
    { tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__/* .tags.keyword */ .pJ.keyword,
        color: "#708" },
    { tag: [_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__/* .tags.atom */ .pJ.atom, _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__/* .tags.bool */ .pJ.bool, _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__/* .tags.url */ .pJ.url, _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__/* .tags.contentSeparator */ .pJ.contentSeparator, _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__/* .tags.labelName */ .pJ.labelName],
        color: "#219" },
    { tag: [_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__/* .tags.literal */ .pJ.literal, _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__/* .tags.inserted */ .pJ.inserted],
        color: "#164" },
    { tag: [_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__/* .tags.string */ .pJ.string, _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__/* .tags.deleted */ .pJ.deleted],
        color: "#a11" },
    { tag: [_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__/* .tags.regexp */ .pJ.regexp, _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__/* .tags.escape */ .pJ.escape, /*@__PURE__*/_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__/* .tags.special */ .pJ.special(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__/* .tags.string */ .pJ.string)],
        color: "#e40" },
    { tag: /*@__PURE__*/_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__/* .tags.definition */ .pJ.definition(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__/* .tags.variableName */ .pJ.variableName),
        color: "#00f" },
    { tag: /*@__PURE__*/_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__/* .tags.local */ .pJ.local(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__/* .tags.variableName */ .pJ.variableName),
        color: "#30a" },
    { tag: [_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__/* .tags.typeName */ .pJ.typeName, _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__/* .tags.namespace */ .pJ.namespace],
        color: "#085" },
    { tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__/* .tags.className */ .pJ.className,
        color: "#167" },
    { tag: [/*@__PURE__*/_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__/* .tags.special */ .pJ.special(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__/* .tags.variableName */ .pJ.variableName), _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__/* .tags.macroName */ .pJ.macroName],
        color: "#256" },
    { tag: /*@__PURE__*/_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__/* .tags.definition */ .pJ.definition(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__/* .tags.propertyName */ .pJ.propertyName),
        color: "#00c" },
    { tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__/* .tags.comment */ .pJ.comment,
        color: "#940" },
    { tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__/* .tags.invalid */ .pJ.invalid,
        color: "#f00" }
]);

const baseTheme = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_4__/* .EditorView.baseTheme */ .tk.baseTheme({
    "&.cm-focused .cm-matchingBracket": { backgroundColor: "#328c8252" },
    "&.cm-focused .cm-nonmatchingBracket": { backgroundColor: "#bb555544" }
});
const DefaultScanDist = 10000, DefaultBrackets = "()[]{}";
const bracketMatchingConfig = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_3__/* .Facet.define */ .r$.define({
    combine(configs) {
        return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_3__/* .combineConfig */ .BO)(configs, {
            afterCursor: true,
            brackets: DefaultBrackets,
            maxScanDistance: DefaultScanDist,
            renderMatch: defaultRenderMatch
        });
    }
});
const matchingMark = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_4__/* .Decoration.mark */ .p.mark({ class: "cm-matchingBracket" }), nonmatchingMark = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_4__/* .Decoration.mark */ .p.mark({ class: "cm-nonmatchingBracket" });
function defaultRenderMatch(match) {
    let decorations = [];
    let mark = match.matched ? matchingMark : nonmatchingMark;
    decorations.push(mark.range(match.start.from, match.start.to));
    if (match.end)
        decorations.push(mark.range(match.end.from, match.end.to));
    return decorations;
}
const bracketMatchingState = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_3__/* .StateField.define */ .QQ.define({
    create() { return _codemirror_view__WEBPACK_IMPORTED_MODULE_4__/* .Decoration.none */ .p.none; },
    update(deco, tr) {
        if (!tr.docChanged && !tr.selection)
            return deco;
        let decorations = [];
        let config = tr.state.facet(bracketMatchingConfig);
        for (let range of tr.state.selection.ranges) {
            if (!range.empty)
                continue;
            let match = matchBrackets(tr.state, range.head, -1, config)
                || (range.head > 0 && matchBrackets(tr.state, range.head - 1, 1, config))
                || (config.afterCursor &&
                    (matchBrackets(tr.state, range.head, 1, config) ||
                        (range.head < tr.state.doc.length && matchBrackets(tr.state, range.head + 1, -1, config))));
            if (match)
                decorations = decorations.concat(config.renderMatch(match, tr.state));
        }
        return _codemirror_view__WEBPACK_IMPORTED_MODULE_4__/* .Decoration.set */ .p.set(decorations, true);
    },
    provide: f => _codemirror_view__WEBPACK_IMPORTED_MODULE_4__/* .EditorView.decorations.from */ .tk.decorations.from(f)
});
const bracketMatchingUnique = [
    bracketMatchingState,
    baseTheme
];
/**
Create an extension that enables bracket matching. Whenever the
cursor is next to a bracket, that bracket and the one it matches
are highlighted. Or, when no matching bracket is found, another
highlighting style is used to indicate this.
*/
function bracketMatching(config = {}) {
    return [bracketMatchingConfig.of(config), bracketMatchingUnique];
}
function matchingNodes(node, dir, brackets) {
    let byProp = node.prop(dir < 0 ? _lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .NodeProp.openedBy */ .md.openedBy : _lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .NodeProp.closedBy */ .md.closedBy);
    if (byProp)
        return byProp;
    if (node.name.length == 1) {
        let index = brackets.indexOf(node.name);
        if (index > -1 && index % 2 == (dir < 0 ? 1 : 0))
            return [brackets[index + dir]];
    }
    return null;
}
/**
Find the matching bracket for the token at `pos`, scanning
direction `dir`. Only the `brackets` and `maxScanDistance`
properties are used from `config`, if given. Returns null if no
bracket was found at `pos`, or a match result otherwise.
*/
function matchBrackets(state, pos, dir, config = {}) {
    let maxScanDistance = config.maxScanDistance || DefaultScanDist, brackets = config.brackets || DefaultBrackets;
    let tree = syntaxTree(state), node = tree.resolveInner(pos, dir);
    for (let cur = node; cur; cur = cur.parent) {
        let matches = matchingNodes(cur.type, dir, brackets);
        if (matches && cur.from < cur.to)
            return matchMarkedBrackets(state, pos, dir, cur, matches, brackets);
    }
    return matchPlainBrackets(state, pos, dir, tree, node.type, maxScanDistance, brackets);
}
function matchMarkedBrackets(_state, _pos, dir, token, matching, brackets) {
    let parent = token.parent, firstToken = { from: token.from, to: token.to };
    let depth = 0, cursor = parent === null || parent === void 0 ? void 0 : parent.cursor();
    if (cursor && (dir < 0 ? cursor.childBefore(token.from) : cursor.childAfter(token.to)))
        do {
            if (dir < 0 ? cursor.to <= token.from : cursor.from >= token.to) {
                if (depth == 0 && matching.indexOf(cursor.type.name) > -1 && cursor.from < cursor.to) {
                    return { start: firstToken, end: { from: cursor.from, to: cursor.to }, matched: true };
                }
                else if (matchingNodes(cursor.type, dir, brackets)) {
                    depth++;
                }
                else if (matchingNodes(cursor.type, -dir, brackets)) {
                    if (depth == 0)
                        return {
                            start: firstToken,
                            end: cursor.from == cursor.to ? undefined : { from: cursor.from, to: cursor.to },
                            matched: false
                        };
                    depth--;
                }
            }
        } while (dir < 0 ? cursor.prevSibling() : cursor.nextSibling());
    return { start: firstToken, matched: false };
}
function matchPlainBrackets(state, pos, dir, tree, tokenType, maxScanDistance, brackets) {
    let startCh = dir < 0 ? state.sliceDoc(pos - 1, pos) : state.sliceDoc(pos, pos + 1);
    let bracket = brackets.indexOf(startCh);
    if (bracket < 0 || (bracket % 2 == 0) != (dir > 0))
        return null;
    let startToken = { from: dir < 0 ? pos - 1 : pos, to: dir > 0 ? pos + 1 : pos };
    let iter = state.doc.iterRange(pos, dir > 0 ? state.doc.length : 0), depth = 0;
    for (let distance = 0; !(iter.next()).done && distance <= maxScanDistance;) {
        let text = iter.value;
        if (dir < 0)
            distance += text.length;
        let basePos = pos + distance * dir;
        for (let pos = dir > 0 ? 0 : text.length - 1, end = dir > 0 ? text.length : -1; pos != end; pos += dir) {
            let found = brackets.indexOf(text[pos]);
            if (found < 0 || tree.resolveInner(basePos + pos, 1).type != tokenType)
                continue;
            if ((found % 2 == 0) == (dir > 0)) {
                depth++;
            }
            else if (depth == 1) { // Closing
                return { start: startToken, end: { from: basePos + pos, to: basePos + pos + 1 }, matched: (found >> 1) == (bracket >> 1) };
            }
            else {
                depth--;
            }
        }
        if (dir > 0)
            distance += text.length;
    }
    return iter.done ? { start: startToken, matched: false } : null;
}

// Counts the column offset in a string, taking tabs into account.
// Used mostly to find indentation.
function countCol(string, end, tabSize, startIndex = 0, startValue = 0) {
    if (end == null) {
        end = string.search(/[^\s\u00a0]/);
        if (end == -1)
            end = string.length;
    }
    let n = startValue;
    for (let i = startIndex; i < end; i++) {
        if (string.charCodeAt(i) == 9)
            n += tabSize - (n % tabSize);
        else
            n++;
    }
    return n;
}
/**
Encapsulates a single line of input. Given to stream syntax code,
which uses it to tokenize the content.
*/
class StringStream {
    /**
    Create a stream.
    */
    constructor(
    /**
    The line.
    */
    string, tabSize, 
    /**
    The current indent unit size.
    */
    indentUnit) {
        this.string = string;
        this.tabSize = tabSize;
        this.indentUnit = indentUnit;
        /**
        The current position on the line.
        */
        this.pos = 0;
        /**
        The start position of the current token.
        */
        this.start = 0;
        this.lastColumnPos = 0;
        this.lastColumnValue = 0;
    }
    /**
    True if we are at the end of the line.
    */
    eol() { return this.pos >= this.string.length; }
    /**
    True if we are at the start of the line.
    */
    sol() { return this.pos == 0; }
    /**
    Get the next code unit after the current position, or undefined
    if we're at the end of the line.
    */
    peek() { return this.string.charAt(this.pos) || undefined; }
    /**
    Read the next code unit and advance `this.pos`.
    */
    next() {
        if (this.pos < this.string.length)
            return this.string.charAt(this.pos++);
    }
    /**
    Match the next character against the given string, regular
    expression, or predicate. Consume and return it if it matches.
    */
    eat(match) {
        let ch = this.string.charAt(this.pos);
        let ok;
        if (typeof match == "string")
            ok = ch == match;
        else
            ok = ch && (match instanceof RegExp ? match.test(ch) : match(ch));
        if (ok) {
            ++this.pos;
            return ch;
        }
    }
    /**
    Continue matching characters that match the given string,
    regular expression, or predicate function. Return true if any
    characters were consumed.
    */
    eatWhile(match) {
        let start = this.pos;
        while (this.eat(match)) { }
        return this.pos > start;
    }
    /**
    Consume whitespace ahead of `this.pos`. Return true if any was
    found.
    */
    eatSpace() {
        let start = this.pos;
        while (/[\s\u00a0]/.test(this.string.charAt(this.pos)))
            ++this.pos;
        return this.pos > start;
    }
    /**
    Move to the end of the line.
    */
    skipToEnd() { this.pos = this.string.length; }
    /**
    Move to directly before the given character, if found on the
    current line.
    */
    skipTo(ch) {
        let found = this.string.indexOf(ch, this.pos);
        if (found > -1) {
            this.pos = found;
            return true;
        }
    }
    /**
    Move back `n` characters.
    */
    backUp(n) { this.pos -= n; }
    /**
    Get the column position at `this.pos`.
    */
    column() {
        if (this.lastColumnPos < this.start) {
            this.lastColumnValue = countCol(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);
            this.lastColumnPos = this.start;
        }
        return this.lastColumnValue;
    }
    /**
    Get the indentation column of the current line.
    */
    indentation() {
        return countCol(this.string, null, this.tabSize);
    }
    /**
    Match the input against the given string or regular expression
    (which should start with a `^`). Return true or the regexp match
    if it matches.
    
    Unless `consume` is set to `false`, this will move `this.pos`
    past the matched text.
    
    When matching a string `caseInsensitive` can be set to true to
    make the match case-insensitive.
    */
    match(pattern, consume, caseInsensitive) {
        if (typeof pattern == "string") {
            let cased = (str) => caseInsensitive ? str.toLowerCase() : str;
            let substr = this.string.substr(this.pos, pattern.length);
            if (cased(substr) == cased(pattern)) {
                if (consume !== false)
                    this.pos += pattern.length;
                return true;
            }
            else
                return null;
        }
        else {
            let match = this.string.slice(this.pos).match(pattern);
            if (match && match.index > 0)
                return null;
            if (match && consume !== false)
                this.pos += match[0].length;
            return match;
        }
    }
    /**
    Get the current token.
    */
    current() { return this.string.slice(this.start, this.pos); }
}

function fullParser(spec) {
    return {
        token: spec.token,
        blankLine: spec.blankLine || (() => { }),
        startState: spec.startState || (() => true),
        copyState: spec.copyState || defaultCopyState,
        indent: spec.indent || (() => null),
        languageData: spec.languageData || {},
        tokenTable: spec.tokenTable || noTokens
    };
}
function defaultCopyState(state) {
    if (typeof state != "object")
        return state;
    let newState = {};
    for (let prop in state) {
        let val = state[prop];
        newState[prop] = (val instanceof Array ? val.slice() : val);
    }
    return newState;
}
/**
A [language](https://codemirror.net/6/docs/ref/#language.Language) class based on a CodeMirror
5-style [streaming parser](https://codemirror.net/6/docs/ref/#language.StreamParser).
*/
class StreamLanguage extends Language {
    constructor(parser) {
        let data = defineLanguageFacet(parser.languageData);
        let p = fullParser(parser), self;
        let impl = new class extends _lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .Parser */ ._b {
            createParse(input, fragments, ranges) {
                return new Parse(self, input, fragments, ranges);
            }
        };
        super(data, impl, [indentService.of((cx, pos) => this.getIndent(cx, pos))]);
        this.topNode = docID(data);
        self = this;
        this.streamParser = p;
        this.stateAfter = new _lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .NodeProp */ .md({ perNode: true });
        this.tokenTable = parser.tokenTable ? new TokenTable(p.tokenTable) : defaultTokenTable;
    }
    /**
    Define a stream language.
    */
    static define(spec) { return new StreamLanguage(spec); }
    getIndent(cx, pos) {
        let tree = syntaxTree(cx.state), at = tree.resolve(pos);
        while (at && at.type != this.topNode)
            at = at.parent;
        if (!at)
            return null;
        let start = findState(this, tree, 0, at.from, pos), statePos, state;
        if (start) {
            state = start.state;
            statePos = start.pos + 1;
        }
        else {
            state = this.streamParser.startState(cx.unit);
            statePos = 0;
        }
        if (pos - statePos > 10000 /* MaxIndentScanDist */)
            return null;
        while (statePos < pos) {
            let line = cx.state.doc.lineAt(statePos), end = Math.min(pos, line.to);
            if (line.length) {
                let stream = new StringStream(line.text, cx.state.tabSize, cx.unit);
                while (stream.pos < end - line.from)
                    readToken(this.streamParser.token, stream, state);
            }
            else {
                this.streamParser.blankLine(state, cx.unit);
            }
            if (end == pos)
                break;
            statePos = line.to + 1;
        }
        let { text } = cx.lineAt(pos);
        return this.streamParser.indent(state, /^\s*(.*)/.exec(text)[1], cx);
    }
    get allowsNesting() { return false; }
}
function findState(lang, tree, off, startPos, before) {
    let state = off >= startPos && off + tree.length <= before && tree.prop(lang.stateAfter);
    if (state)
        return { state: lang.streamParser.copyState(state), pos: off + tree.length };
    for (let i = tree.children.length - 1; i >= 0; i--) {
        let child = tree.children[i], pos = off + tree.positions[i];
        let found = child instanceof _lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .Tree */ .mp && pos < before && findState(lang, child, pos, startPos, before);
        if (found)
            return found;
    }
    return null;
}
function cutTree(lang, tree, from, to, inside) {
    if (inside && from <= 0 && to >= tree.length)
        return tree;
    if (!inside && tree.type == lang.topNode)
        inside = true;
    for (let i = tree.children.length - 1; i >= 0; i--) {
        let pos = tree.positions[i], child = tree.children[i], inner;
        if (pos < to && child instanceof _lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .Tree */ .mp) {
            if (!(inner = cutTree(lang, child, from - pos, to - pos, inside)))
                break;
            return !inside ? inner
                : new _lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .Tree */ .mp(tree.type, tree.children.slice(0, i).concat(inner), tree.positions.slice(0, i + 1), pos + inner.length);
        }
    }
    return null;
}
function findStartInFragments(lang, fragments, startPos, editorState) {
    for (let f of fragments) {
        let from = f.from + (f.openStart ? 25 : 0), to = f.to - (f.openEnd ? 25 : 0);
        let found = from <= startPos && to > startPos && findState(lang, f.tree, 0 - f.offset, startPos, to), tree;
        if (found && (tree = cutTree(lang, f.tree, startPos + f.offset, found.pos + f.offset, false)))
            return { state: found.state, tree };
    }
    return { state: lang.streamParser.startState(editorState ? getIndentUnit(editorState) : 4), tree: _lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .Tree.empty */ .mp.empty };
}
class Parse {
    constructor(lang, input, fragments, ranges) {
        this.lang = lang;
        this.input = input;
        this.fragments = fragments;
        this.ranges = ranges;
        this.stoppedAt = null;
        this.chunks = [];
        this.chunkPos = [];
        this.chunk = [];
        this.chunkReused = undefined;
        this.rangeIndex = 0;
        this.to = ranges[ranges.length - 1].to;
        let context = ParseContext.get(), from = ranges[0].from;
        let { state, tree } = findStartInFragments(lang, fragments, from, context === null || context === void 0 ? void 0 : context.state);
        this.state = state;
        this.parsedPos = this.chunkStart = from + tree.length;
        for (let i = 0; i < tree.children.length; i++) {
            this.chunks.push(tree.children[i]);
            this.chunkPos.push(tree.positions[i]);
        }
        if (context && this.parsedPos < context.viewport.from - 100000 /* MaxDistanceBeforeViewport */) {
            this.state = this.lang.streamParser.startState(getIndentUnit(context.state));
            context.skipUntilInView(this.parsedPos, context.viewport.from);
            this.parsedPos = context.viewport.from;
        }
        this.moveRangeIndex();
    }
    advance() {
        let context = ParseContext.get();
        let parseEnd = this.stoppedAt == null ? this.to : Math.min(this.to, this.stoppedAt);
        let end = Math.min(parseEnd, this.chunkStart + 2048 /* ChunkSize */);
        if (context)
            end = Math.min(end, context.viewport.to);
        while (this.parsedPos < end)
            this.parseLine(context);
        if (this.chunkStart < this.parsedPos)
            this.finishChunk();
        if (this.parsedPos >= parseEnd)
            return this.finish();
        if (context && this.parsedPos >= context.viewport.to) {
            context.skipUntilInView(this.parsedPos, parseEnd);
            return this.finish();
        }
        return null;
    }
    stopAt(pos) {
        this.stoppedAt = pos;
    }
    lineAfter(pos) {
        let chunk = this.input.chunk(pos);
        if (!this.input.lineChunks) {
            let eol = chunk.indexOf("\n");
            if (eol > -1)
                chunk = chunk.slice(0, eol);
        }
        else if (chunk == "\n") {
            chunk = "";
        }
        return pos + chunk.length <= this.to ? chunk : chunk.slice(0, this.to - pos);
    }
    nextLine() {
        let from = this.parsedPos, line = this.lineAfter(from), end = from + line.length;
        for (let index = this.rangeIndex;;) {
            let rangeEnd = this.ranges[index].to;
            if (rangeEnd >= end)
                break;
            line = line.slice(0, rangeEnd - (end - line.length));
            index++;
            if (index == this.ranges.length)
                break;
            let rangeStart = this.ranges[index].from;
            let after = this.lineAfter(rangeStart);
            line += after;
            end = rangeStart + after.length;
        }
        return { line, end };
    }
    skipGapsTo(pos, offset, side) {
        for (;;) {
            let end = this.ranges[this.rangeIndex].to, offPos = pos + offset;
            if (side > 0 ? end > offPos : end >= offPos)
                break;
            let start = this.ranges[++this.rangeIndex].from;
            offset += start - end;
        }
        return offset;
    }
    moveRangeIndex() {
        while (this.ranges[this.rangeIndex].to < this.parsedPos)
            this.rangeIndex++;
    }
    emitToken(id, from, to, size, offset) {
        if (this.ranges.length > 1) {
            offset = this.skipGapsTo(from, offset, 1);
            from += offset;
            let len0 = this.chunk.length;
            offset = this.skipGapsTo(to, offset, -1);
            to += offset;
            size += this.chunk.length - len0;
        }
        this.chunk.push(id, from, to, size);
        return offset;
    }
    parseLine(context) {
        let { line, end } = this.nextLine(), offset = 0, { streamParser } = this.lang;
        let stream = new StringStream(line, context ? context.state.tabSize : 4, context ? getIndentUnit(context.state) : 2);
        if (stream.eol()) {
            streamParser.blankLine(this.state, stream.indentUnit);
        }
        else {
            while (!stream.eol()) {
                let token = readToken(streamParser.token, stream, this.state);
                if (token)
                    offset = this.emitToken(this.lang.tokenTable.resolve(token), this.parsedPos + stream.start, this.parsedPos + stream.pos, 4, offset);
                if (stream.start > 10000 /* MaxLineLength */)
                    break;
            }
        }
        this.parsedPos = end;
        this.moveRangeIndex();
        if (this.parsedPos < this.to)
            this.parsedPos++;
    }
    finishChunk() {
        let tree = _lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .Tree.build */ .mp.build({
            buffer: this.chunk,
            start: this.chunkStart,
            length: this.parsedPos - this.chunkStart,
            nodeSet,
            topID: 0,
            maxBufferLength: 2048 /* ChunkSize */,
            reused: this.chunkReused
        });
        tree = new _lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .Tree */ .mp(tree.type, tree.children, tree.positions, tree.length, [[this.lang.stateAfter, this.lang.streamParser.copyState(this.state)]]);
        this.chunks.push(tree);
        this.chunkPos.push(this.chunkStart - this.ranges[0].from);
        this.chunk = [];
        this.chunkReused = undefined;
        this.chunkStart = this.parsedPos;
    }
    finish() {
        return new _lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .Tree */ .mp(this.lang.topNode, this.chunks, this.chunkPos, this.parsedPos - this.ranges[0].from).balance();
    }
}
function readToken(token, stream, state) {
    stream.start = stream.pos;
    for (let i = 0; i < 10; i++) {
        let result = token(stream, state);
        if (stream.pos > stream.start)
            return result;
    }
    throw new Error("Stream parser failed to advance stream.");
}
const noTokens = /*@__PURE__*/Object.create(null);
const typeArray = [_lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .NodeType.none */ .Jq.none];
const nodeSet = /*@__PURE__*/new _lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .NodeSet */ .Lj(typeArray);
const warned = [];
const defaultTable = /*@__PURE__*/Object.create(null);
for (let [legacyName, name] of [
    ["variable", "variableName"],
    ["variable-2", "variableName.special"],
    ["string-2", "string.special"],
    ["def", "variableName.definition"],
    ["tag", "tagName"],
    ["attribute", "attributeName"],
    ["type", "typeName"],
    ["builtin", "variableName.standard"],
    ["qualifier", "modifier"],
    ["error", "invalid"],
    ["header", "heading"],
    ["property", "propertyName"]
])
    defaultTable[legacyName] = /*@__PURE__*/createTokenType(noTokens, name);
class TokenTable {
    constructor(extra) {
        this.extra = extra;
        this.table = Object.assign(Object.create(null), defaultTable);
    }
    resolve(tag) {
        return !tag ? 0 : this.table[tag] || (this.table[tag] = createTokenType(this.extra, tag));
    }
}
const defaultTokenTable = /*@__PURE__*/new TokenTable(noTokens);
function warnForPart(part, msg) {
    if (warned.indexOf(part) > -1)
        return;
    warned.push(part);
    console.warn(msg);
}
function createTokenType(extra, tagStr) {
    let tag = null;
    for (let part of tagStr.split(".")) {
        let value = (extra[part] || _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__/* .tags */ .pJ[part]);
        if (!value) {
            warnForPart(part, `Unknown highlighting tag ${part}`);
        }
        else if (typeof value == "function") {
            if (!tag)
                warnForPart(part, `Modifier ${part} used at start of tag`);
            else
                tag = value(tag);
        }
        else {
            if (tag)
                warnForPart(part, `Tag ${part} used as modifier`);
            else
                tag = value;
        }
    }
    if (!tag)
        return 0;
    let name = tagStr.replace(/ /g, "_"), type = _lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .NodeType.define */ .Jq.define({
        id: typeArray.length,
        name,
        props: [(0,_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__/* .styleTags */ .Gv)({ [name]: tag })]
    });
    typeArray.push(type);
    return type.id;
}
function docID(data) {
    let type = _lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .NodeType.define */ .Jq.define({ id: typeArray.length, name: "Document", props: [languageDataProp.add(() => data)] });
    typeArray.push(type);
    return type;
}




/***/ }),

/***/ 802:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BO": () => (/* binding */ combineConfig),
/* harmony export */   "D0": () => (/* binding */ CharCategory),
/* harmony export */   "Gz": () => (/* binding */ findColumn),
/* harmony export */   "IS": () => (/* binding */ countColumn),
/* harmony export */   "Py": () => (/* binding */ StateEffect),
/* harmony export */   "QQ": () => (/* binding */ StateField),
/* harmony export */   "Wl": () => (/* binding */ Prec),
/* harmony export */   "Xs": () => (/* binding */ RangeSet),
/* harmony export */   "YW": () => (/* binding */ Transaction),
/* harmony export */   "as": () => (/* binding */ ChangeSet),
/* harmony export */   "cp": () => (/* binding */ findClusterBreak),
/* harmony export */   "f_": () => (/* binding */ RangeSetBuilder),
/* harmony export */   "gc": () => (/* binding */ MapMode),
/* harmony export */   "gm": () => (/* binding */ codePointAt),
/* harmony export */   "jT": () => (/* binding */ EditorSelection),
/* harmony export */   "n0": () => (/* binding */ ChangeDesc),
/* harmony export */   "nZ": () => (/* binding */ codePointSize),
/* harmony export */   "q6": () => (/* binding */ Annotation),
/* harmony export */   "r$": () => (/* binding */ Facet),
/* harmony export */   "uU": () => (/* binding */ RangeValue),
/* harmony export */   "xv": () => (/* binding */ Text),
/* harmony export */   "yy": () => (/* binding */ EditorState)
/* harmony export */ });
/* unused harmony exports AnnotationType, Compartment, Line, Range, SelectionRange, StateEffectType, fromCodePoint */
/**
The data structure for documents. @nonabstract
*/
class Text {
    /**
    @internal
    */
    constructor() { }
    /**
    Get the line description around the given position.
    */
    lineAt(pos) {
        if (pos < 0 || pos > this.length)
            throw new RangeError(`Invalid position ${pos} in document of length ${this.length}`);
        return this.lineInner(pos, false, 1, 0);
    }
    /**
    Get the description for the given (1-based) line number.
    */
    line(n) {
        if (n < 1 || n > this.lines)
            throw new RangeError(`Invalid line number ${n} in ${this.lines}-line document`);
        return this.lineInner(n, true, 1, 0);
    }
    /**
    Replace a range of the text with the given content.
    */
    replace(from, to, text) {
        let parts = [];
        this.decompose(0, from, parts, 2 /* Open.To */);
        if (text.length)
            text.decompose(0, text.length, parts, 1 /* Open.From */ | 2 /* Open.To */);
        this.decompose(to, this.length, parts, 1 /* Open.From */);
        return TextNode.from(parts, this.length - (to - from) + text.length);
    }
    /**
    Append another document to this one.
    */
    append(other) {
        return this.replace(this.length, this.length, other);
    }
    /**
    Retrieve the text between the given points.
    */
    slice(from, to = this.length) {
        let parts = [];
        this.decompose(from, to, parts, 0);
        return TextNode.from(parts, to - from);
    }
    /**
    Test whether this text is equal to another instance.
    */
    eq(other) {
        if (other == this)
            return true;
        if (other.length != this.length || other.lines != this.lines)
            return false;
        let start = this.scanIdentical(other, 1), end = this.length - this.scanIdentical(other, -1);
        let a = new RawTextCursor(this), b = new RawTextCursor(other);
        for (let skip = start, pos = start;;) {
            a.next(skip);
            b.next(skip);
            skip = 0;
            if (a.lineBreak != b.lineBreak || a.done != b.done || a.value != b.value)
                return false;
            pos += a.value.length;
            if (a.done || pos >= end)
                return true;
        }
    }
    /**
    Iterate over the text. When `dir` is `-1`, iteration happens
    from end to start. This will return lines and the breaks between
    them as separate strings.
    */
    iter(dir = 1) { return new RawTextCursor(this, dir); }
    /**
    Iterate over a range of the text. When `from` > `to`, the
    iterator will run in reverse.
    */
    iterRange(from, to = this.length) { return new PartialTextCursor(this, from, to); }
    /**
    Return a cursor that iterates over the given range of lines,
    _without_ returning the line breaks between, and yielding empty
    strings for empty lines.
    
    When `from` and `to` are given, they should be 1-based line numbers.
    */
    iterLines(from, to) {
        let inner;
        if (from == null) {
            inner = this.iter();
        }
        else {
            if (to == null)
                to = this.lines + 1;
            let start = this.line(from).from;
            inner = this.iterRange(start, Math.max(start, to == this.lines + 1 ? this.length : to <= 1 ? 0 : this.line(to - 1).to));
        }
        return new LineCursor(inner);
    }
    /**
    @internal
    */
    toString() { return this.sliceString(0); }
    /**
    Convert the document to an array of lines (which can be
    deserialized again via [`Text.of`](https://codemirror.net/6/docs/ref/#state.Text^of)).
    */
    toJSON() {
        let lines = [];
        this.flatten(lines);
        return lines;
    }
    /**
    Create a `Text` instance for the given array of lines.
    */
    static of(text) {
        if (text.length == 0)
            throw new RangeError("A document must have at least one line");
        if (text.length == 1 && !text[0])
            return Text.empty;
        return text.length <= 32 /* Tree.Branch */ ? new TextLeaf(text) : TextNode.from(TextLeaf.split(text, []));
    }
}
// Leaves store an array of line strings. There are always line breaks
// between these strings. Leaves are limited in size and have to be
// contained in TextNode instances for bigger documents.
class TextLeaf extends Text {
    constructor(text, length = textLength(text)) {
        super();
        this.text = text;
        this.length = length;
    }
    get lines() { return this.text.length; }
    get children() { return null; }
    lineInner(target, isLine, line, offset) {
        for (let i = 0;; i++) {
            let string = this.text[i], end = offset + string.length;
            if ((isLine ? line : end) >= target)
                return new Line(offset, end, line, string);
            offset = end + 1;
            line++;
        }
    }
    decompose(from, to, target, open) {
        let text = from <= 0 && to >= this.length ? this
            : new TextLeaf(sliceText(this.text, from, to), Math.min(to, this.length) - Math.max(0, from));
        if (open & 1 /* Open.From */) {
            let prev = target.pop();
            let joined = appendText(text.text, prev.text.slice(), 0, text.length);
            if (joined.length <= 32 /* Tree.Branch */) {
                target.push(new TextLeaf(joined, prev.length + text.length));
            }
            else {
                let mid = joined.length >> 1;
                target.push(new TextLeaf(joined.slice(0, mid)), new TextLeaf(joined.slice(mid)));
            }
        }
        else {
            target.push(text);
        }
    }
    replace(from, to, text) {
        if (!(text instanceof TextLeaf))
            return super.replace(from, to, text);
        let lines = appendText(this.text, appendText(text.text, sliceText(this.text, 0, from)), to);
        let newLen = this.length + text.length - (to - from);
        if (lines.length <= 32 /* Tree.Branch */)
            return new TextLeaf(lines, newLen);
        return TextNode.from(TextLeaf.split(lines, []), newLen);
    }
    sliceString(from, to = this.length, lineSep = "\n") {
        let result = "";
        for (let pos = 0, i = 0; pos <= to && i < this.text.length; i++) {
            let line = this.text[i], end = pos + line.length;
            if (pos > from && i)
                result += lineSep;
            if (from < end && to > pos)
                result += line.slice(Math.max(0, from - pos), to - pos);
            pos = end + 1;
        }
        return result;
    }
    flatten(target) {
        for (let line of this.text)
            target.push(line);
    }
    scanIdentical() { return 0; }
    static split(text, target) {
        let part = [], len = -1;
        for (let line of text) {
            part.push(line);
            len += line.length + 1;
            if (part.length == 32 /* Tree.Branch */) {
                target.push(new TextLeaf(part, len));
                part = [];
                len = -1;
            }
        }
        if (len > -1)
            target.push(new TextLeaf(part, len));
        return target;
    }
}
// Nodes provide the tree structure of the `Text` type. They store a
// number of other nodes or leaves, taking care to balance themselves
// on changes. There are implied line breaks _between_ the children of
// a node (but not before the first or after the last child).
class TextNode extends Text {
    constructor(children, length) {
        super();
        this.children = children;
        this.length = length;
        this.lines = 0;
        for (let child of children)
            this.lines += child.lines;
    }
    lineInner(target, isLine, line, offset) {
        for (let i = 0;; i++) {
            let child = this.children[i], end = offset + child.length, endLine = line + child.lines - 1;
            if ((isLine ? endLine : end) >= target)
                return child.lineInner(target, isLine, line, offset);
            offset = end + 1;
            line = endLine + 1;
        }
    }
    decompose(from, to, target, open) {
        for (let i = 0, pos = 0; pos <= to && i < this.children.length; i++) {
            let child = this.children[i], end = pos + child.length;
            if (from <= end && to >= pos) {
                let childOpen = open & ((pos <= from ? 1 /* Open.From */ : 0) | (end >= to ? 2 /* Open.To */ : 0));
                if (pos >= from && end <= to && !childOpen)
                    target.push(child);
                else
                    child.decompose(from - pos, to - pos, target, childOpen);
            }
            pos = end + 1;
        }
    }
    replace(from, to, text) {
        if (text.lines < this.lines)
            for (let i = 0, pos = 0; i < this.children.length; i++) {
                let child = this.children[i], end = pos + child.length;
                // Fast path: if the change only affects one child and the
                // child's size remains in the acceptable range, only update
                // that child
                if (from >= pos && to <= end) {
                    let updated = child.replace(from - pos, to - pos, text);
                    let totalLines = this.lines - child.lines + updated.lines;
                    if (updated.lines < (totalLines >> (5 /* Tree.BranchShift */ - 1)) &&
                        updated.lines > (totalLines >> (5 /* Tree.BranchShift */ + 1))) {
                        let copy = this.children.slice();
                        copy[i] = updated;
                        return new TextNode(copy, this.length - (to - from) + text.length);
                    }
                    return super.replace(pos, end, updated);
                }
                pos = end + 1;
            }
        return super.replace(from, to, text);
    }
    sliceString(from, to = this.length, lineSep = "\n") {
        let result = "";
        for (let i = 0, pos = 0; i < this.children.length && pos <= to; i++) {
            let child = this.children[i], end = pos + child.length;
            if (pos > from && i)
                result += lineSep;
            if (from < end && to > pos)
                result += child.sliceString(from - pos, to - pos, lineSep);
            pos = end + 1;
        }
        return result;
    }
    flatten(target) {
        for (let child of this.children)
            child.flatten(target);
    }
    scanIdentical(other, dir) {
        if (!(other instanceof TextNode))
            return 0;
        let length = 0;
        let [iA, iB, eA, eB] = dir > 0 ? [0, 0, this.children.length, other.children.length]
            : [this.children.length - 1, other.children.length - 1, -1, -1];
        for (;; iA += dir, iB += dir) {
            if (iA == eA || iB == eB)
                return length;
            let chA = this.children[iA], chB = other.children[iB];
            if (chA != chB)
                return length + chA.scanIdentical(chB, dir);
            length += chA.length + 1;
        }
    }
    static from(children, length = children.reduce((l, ch) => l + ch.length + 1, -1)) {
        let lines = 0;
        for (let ch of children)
            lines += ch.lines;
        if (lines < 32 /* Tree.Branch */) {
            let flat = [];
            for (let ch of children)
                ch.flatten(flat);
            return new TextLeaf(flat, length);
        }
        let chunk = Math.max(32 /* Tree.Branch */, lines >> 5 /* Tree.BranchShift */), maxChunk = chunk << 1, minChunk = chunk >> 1;
        let chunked = [], currentLines = 0, currentLen = -1, currentChunk = [];
        function add(child) {
            let last;
            if (child.lines > maxChunk && child instanceof TextNode) {
                for (let node of child.children)
                    add(node);
            }
            else if (child.lines > minChunk && (currentLines > minChunk || !currentLines)) {
                flush();
                chunked.push(child);
            }
            else if (child instanceof TextLeaf && currentLines &&
                (last = currentChunk[currentChunk.length - 1]) instanceof TextLeaf &&
                child.lines + last.lines <= 32 /* Tree.Branch */) {
                currentLines += child.lines;
                currentLen += child.length + 1;
                currentChunk[currentChunk.length - 1] = new TextLeaf(last.text.concat(child.text), last.length + 1 + child.length);
            }
            else {
                if (currentLines + child.lines > chunk)
                    flush();
                currentLines += child.lines;
                currentLen += child.length + 1;
                currentChunk.push(child);
            }
        }
        function flush() {
            if (currentLines == 0)
                return;
            chunked.push(currentChunk.length == 1 ? currentChunk[0] : TextNode.from(currentChunk, currentLen));
            currentLen = -1;
            currentLines = currentChunk.length = 0;
        }
        for (let child of children)
            add(child);
        flush();
        return chunked.length == 1 ? chunked[0] : new TextNode(chunked, length);
    }
}
Text.empty = /*@__PURE__*/new TextLeaf([""], 0);
function textLength(text) {
    let length = -1;
    for (let line of text)
        length += line.length + 1;
    return length;
}
function appendText(text, target, from = 0, to = 1e9) {
    for (let pos = 0, i = 0, first = true; i < text.length && pos <= to; i++) {
        let line = text[i], end = pos + line.length;
        if (end >= from) {
            if (end > to)
                line = line.slice(0, to - pos);
            if (pos < from)
                line = line.slice(from - pos);
            if (first) {
                target[target.length - 1] += line;
                first = false;
            }
            else
                target.push(line);
        }
        pos = end + 1;
    }
    return target;
}
function sliceText(text, from, to) {
    return appendText(text, [""], from, to);
}
class RawTextCursor {
    constructor(text, dir = 1) {
        this.dir = dir;
        this.done = false;
        this.lineBreak = false;
        this.value = "";
        this.nodes = [text];
        this.offsets = [dir > 0 ? 1 : (text instanceof TextLeaf ? text.text.length : text.children.length) << 1];
    }
    nextInner(skip, dir) {
        this.done = this.lineBreak = false;
        for (;;) {
            let last = this.nodes.length - 1;
            let top = this.nodes[last], offsetValue = this.offsets[last], offset = offsetValue >> 1;
            let size = top instanceof TextLeaf ? top.text.length : top.children.length;
            if (offset == (dir > 0 ? size : 0)) {
                if (last == 0) {
                    this.done = true;
                    this.value = "";
                    return this;
                }
                if (dir > 0)
                    this.offsets[last - 1]++;
                this.nodes.pop();
                this.offsets.pop();
            }
            else if ((offsetValue & 1) == (dir > 0 ? 0 : 1)) {
                this.offsets[last] += dir;
                if (skip == 0) {
                    this.lineBreak = true;
                    this.value = "\n";
                    return this;
                }
                skip--;
            }
            else if (top instanceof TextLeaf) {
                // Move to the next string
                let next = top.text[offset + (dir < 0 ? -1 : 0)];
                this.offsets[last] += dir;
                if (next.length > Math.max(0, skip)) {
                    this.value = skip == 0 ? next : dir > 0 ? next.slice(skip) : next.slice(0, next.length - skip);
                    return this;
                }
                skip -= next.length;
            }
            else {
                let next = top.children[offset + (dir < 0 ? -1 : 0)];
                if (skip > next.length) {
                    skip -= next.length;
                    this.offsets[last] += dir;
                }
                else {
                    if (dir < 0)
                        this.offsets[last]--;
                    this.nodes.push(next);
                    this.offsets.push(dir > 0 ? 1 : (next instanceof TextLeaf ? next.text.length : next.children.length) << 1);
                }
            }
        }
    }
    next(skip = 0) {
        if (skip < 0) {
            this.nextInner(-skip, (-this.dir));
            skip = this.value.length;
        }
        return this.nextInner(skip, this.dir);
    }
}
class PartialTextCursor {
    constructor(text, start, end) {
        this.value = "";
        this.done = false;
        this.cursor = new RawTextCursor(text, start > end ? -1 : 1);
        this.pos = start > end ? text.length : 0;
        this.from = Math.min(start, end);
        this.to = Math.max(start, end);
    }
    nextInner(skip, dir) {
        if (dir < 0 ? this.pos <= this.from : this.pos >= this.to) {
            this.value = "";
            this.done = true;
            return this;
        }
        skip += Math.max(0, dir < 0 ? this.pos - this.to : this.from - this.pos);
        let limit = dir < 0 ? this.pos - this.from : this.to - this.pos;
        if (skip > limit)
            skip = limit;
        limit -= skip;
        let { value } = this.cursor.next(skip);
        this.pos += (value.length + skip) * dir;
        this.value = value.length <= limit ? value : dir < 0 ? value.slice(value.length - limit) : value.slice(0, limit);
        this.done = !this.value;
        return this;
    }
    next(skip = 0) {
        if (skip < 0)
            skip = Math.max(skip, this.from - this.pos);
        else if (skip > 0)
            skip = Math.min(skip, this.to - this.pos);
        return this.nextInner(skip, this.cursor.dir);
    }
    get lineBreak() { return this.cursor.lineBreak && this.value != ""; }
}
class LineCursor {
    constructor(inner) {
        this.inner = inner;
        this.afterBreak = true;
        this.value = "";
        this.done = false;
    }
    next(skip = 0) {
        let { done, lineBreak, value } = this.inner.next(skip);
        if (done) {
            this.done = true;
            this.value = "";
        }
        else if (lineBreak) {
            if (this.afterBreak) {
                this.value = "";
            }
            else {
                this.afterBreak = true;
                this.next();
            }
        }
        else {
            this.value = value;
            this.afterBreak = false;
        }
        return this;
    }
    get lineBreak() { return false; }
}
if (typeof Symbol != "undefined") {
    Text.prototype[Symbol.iterator] = function () { return this.iter(); };
    RawTextCursor.prototype[Symbol.iterator] = PartialTextCursor.prototype[Symbol.iterator] =
        LineCursor.prototype[Symbol.iterator] = function () { return this; };
}
/**
This type describes a line in the document. It is created
on-demand when lines are [queried](https://codemirror.net/6/docs/ref/#state.Text.lineAt).
*/
class Line {
    /**
    @internal
    */
    constructor(
    /**
    The position of the start of the line.
    */
    from, 
    /**
    The position at the end of the line (_before_ the line break,
    or at the end of document for the last line).
    */
    to, 
    /**
    This line's line number (1-based).
    */
    number, 
    /**
    The line's content.
    */
    text) {
        this.from = from;
        this.to = to;
        this.number = number;
        this.text = text;
    }
    /**
    The length of the line (not including any line break after it).
    */
    get length() { return this.to - this.from; }
}

// Compressed representation of the Grapheme_Cluster_Break=Extend
// information from
// http://www.unicode.org/Public/13.0.0/ucd/auxiliary/GraphemeBreakProperty.txt.
// Each pair of elements represents a range, as an offet from the
// previous range and a length. Numbers are in base-36, with the empty
// string being a shorthand for 1.
let extend = /*@__PURE__*/"lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o".split(",").map(s => s ? parseInt(s, 36) : 1);
// Convert offsets into absolute values
for (let i = 1; i < extend.length; i++)
    extend[i] += extend[i - 1];
function isExtendingChar(code) {
    for (let i = 1; i < extend.length; i += 2)
        if (extend[i] > code)
            return extend[i - 1] <= code;
    return false;
}
function isRegionalIndicator(code) {
    return code >= 0x1F1E6 && code <= 0x1F1FF;
}
const ZWJ = 0x200d;
/**
Returns a next grapheme cluster break _after_ (not equal to)
`pos`, if `forward` is true, or before otherwise. Returns `pos`
itself if no further cluster break is available in the string.
Moves across surrogate pairs, extending characters (when
`includeExtending` is true), characters joined with zero-width
joiners, and flag emoji.
*/
function findClusterBreak(str, pos, forward = true, includeExtending = true) {
    return (forward ? nextClusterBreak : prevClusterBreak)(str, pos, includeExtending);
}
function nextClusterBreak(str, pos, includeExtending) {
    if (pos == str.length)
        return pos;
    // If pos is in the middle of a surrogate pair, move to its start
    if (pos && surrogateLow(str.charCodeAt(pos)) && surrogateHigh(str.charCodeAt(pos - 1)))
        pos--;
    let prev = codePointAt(str, pos);
    pos += codePointSize(prev);
    while (pos < str.length) {
        let next = codePointAt(str, pos);
        if (prev == ZWJ || next == ZWJ || includeExtending && isExtendingChar(next)) {
            pos += codePointSize(next);
            prev = next;
        }
        else if (isRegionalIndicator(next)) {
            let countBefore = 0, i = pos - 2;
            while (i >= 0 && isRegionalIndicator(codePointAt(str, i))) {
                countBefore++;
                i -= 2;
            }
            if (countBefore % 2 == 0)
                break;
            else
                pos += 2;
        }
        else {
            break;
        }
    }
    return pos;
}
function prevClusterBreak(str, pos, includeExtending) {
    while (pos > 0) {
        let found = nextClusterBreak(str, pos - 2, includeExtending);
        if (found < pos)
            return found;
        pos--;
    }
    return 0;
}
function surrogateLow(ch) { return ch >= 0xDC00 && ch < 0xE000; }
function surrogateHigh(ch) { return ch >= 0xD800 && ch < 0xDC00; }
/**
Find the code point at the given position in a string (like the
[`codePointAt`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/codePointAt)
string method).
*/
function codePointAt(str, pos) {
    let code0 = str.charCodeAt(pos);
    if (!surrogateHigh(code0) || pos + 1 == str.length)
        return code0;
    let code1 = str.charCodeAt(pos + 1);
    if (!surrogateLow(code1))
        return code0;
    return ((code0 - 0xd800) << 10) + (code1 - 0xdc00) + 0x10000;
}
/**
Given a Unicode codepoint, return the JavaScript string that
respresents it (like
[`String.fromCodePoint`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/fromCodePoint)).
*/
function fromCodePoint(code) {
    if (code <= 0xffff)
        return String.fromCharCode(code);
    code -= 0x10000;
    return String.fromCharCode((code >> 10) + 0xd800, (code & 1023) + 0xdc00);
}
/**
The amount of positions a character takes up a JavaScript string.
*/
function codePointSize(code) { return code < 0x10000 ? 1 : 2; }

const DefaultSplit = /\r\n?|\n/;
/**
Distinguishes different ways in which positions can be mapped.
*/
var MapMode = /*@__PURE__*/(function (MapMode) {
    /**
    Map a position to a valid new position, even when its context
    was deleted.
    */
    MapMode[MapMode["Simple"] = 0] = "Simple";
    /**
    Return null if deletion happens across the position.
    */
    MapMode[MapMode["TrackDel"] = 1] = "TrackDel";
    /**
    Return null if the character _before_ the position is deleted.
    */
    MapMode[MapMode["TrackBefore"] = 2] = "TrackBefore";
    /**
    Return null if the character _after_ the position is deleted.
    */
    MapMode[MapMode["TrackAfter"] = 3] = "TrackAfter";
return MapMode})(MapMode || (MapMode = {}));
/**
A change description is a variant of [change set](https://codemirror.net/6/docs/ref/#state.ChangeSet)
that doesn't store the inserted text. As such, it can't be
applied, but is cheaper to store and manipulate.
*/
class ChangeDesc {
    // Sections are encoded as pairs of integers. The first is the
    // length in the current document, and the second is -1 for
    // unaffected sections, and the length of the replacement content
    // otherwise. So an insertion would be (0, n>0), a deletion (n>0,
    // 0), and a replacement two positive numbers.
    /**
    @internal
    */
    constructor(
    /**
    @internal
    */
    sections) {
        this.sections = sections;
    }
    /**
    The length of the document before the change.
    */
    get length() {
        let result = 0;
        for (let i = 0; i < this.sections.length; i += 2)
            result += this.sections[i];
        return result;
    }
    /**
    The length of the document after the change.
    */
    get newLength() {
        let result = 0;
        for (let i = 0; i < this.sections.length; i += 2) {
            let ins = this.sections[i + 1];
            result += ins < 0 ? this.sections[i] : ins;
        }
        return result;
    }
    /**
    False when there are actual changes in this set.
    */
    get empty() { return this.sections.length == 0 || this.sections.length == 2 && this.sections[1] < 0; }
    /**
    Iterate over the unchanged parts left by these changes. `posA`
    provides the position of the range in the old document, `posB`
    the new position in the changed document.
    */
    iterGaps(f) {
        for (let i = 0, posA = 0, posB = 0; i < this.sections.length;) {
            let len = this.sections[i++], ins = this.sections[i++];
            if (ins < 0) {
                f(posA, posB, len);
                posB += len;
            }
            else {
                posB += ins;
            }
            posA += len;
        }
    }
    /**
    Iterate over the ranges changed by these changes. (See
    [`ChangeSet.iterChanges`](https://codemirror.net/6/docs/ref/#state.ChangeSet.iterChanges) for a
    variant that also provides you with the inserted text.)
    `fromA`/`toA` provides the extent of the change in the starting
    document, `fromB`/`toB` the extent of the replacement in the
    changed document.
    
    When `individual` is true, adjacent changes (which are kept
    separate for [position mapping](https://codemirror.net/6/docs/ref/#state.ChangeDesc.mapPos)) are
    reported separately.
    */
    iterChangedRanges(f, individual = false) {
        iterChanges(this, f, individual);
    }
    /**
    Get a description of the inverted form of these changes.
    */
    get invertedDesc() {
        let sections = [];
        for (let i = 0; i < this.sections.length;) {
            let len = this.sections[i++], ins = this.sections[i++];
            if (ins < 0)
                sections.push(len, ins);
            else
                sections.push(ins, len);
        }
        return new ChangeDesc(sections);
    }
    /**
    Compute the combined effect of applying another set of changes
    after this one. The length of the document after this set should
    match the length before `other`.
    */
    composeDesc(other) { return this.empty ? other : other.empty ? this : composeSets(this, other); }
    /**
    Map this description, which should start with the same document
    as `other`, over another set of changes, so that it can be
    applied after it. When `before` is true, map as if the changes
    in `other` happened before the ones in `this`.
    */
    mapDesc(other, before = false) { return other.empty ? this : mapSet(this, other, before); }
    mapPos(pos, assoc = -1, mode = MapMode.Simple) {
        let posA = 0, posB = 0;
        for (let i = 0; i < this.sections.length;) {
            let len = this.sections[i++], ins = this.sections[i++], endA = posA + len;
            if (ins < 0) {
                if (endA > pos)
                    return posB + (pos - posA);
                posB += len;
            }
            else {
                if (mode != MapMode.Simple && endA >= pos &&
                    (mode == MapMode.TrackDel && posA < pos && endA > pos ||
                        mode == MapMode.TrackBefore && posA < pos ||
                        mode == MapMode.TrackAfter && endA > pos))
                    return null;
                if (endA > pos || endA == pos && assoc < 0 && !len)
                    return pos == posA || assoc < 0 ? posB : posB + ins;
                posB += ins;
            }
            posA = endA;
        }
        if (pos > posA)
            throw new RangeError(`Position ${pos} is out of range for changeset of length ${posA}`);
        return posB;
    }
    /**
    Check whether these changes touch a given range. When one of the
    changes entirely covers the range, the string `"cover"` is
    returned.
    */
    touchesRange(from, to = from) {
        for (let i = 0, pos = 0; i < this.sections.length && pos <= to;) {
            let len = this.sections[i++], ins = this.sections[i++], end = pos + len;
            if (ins >= 0 && pos <= to && end >= from)
                return pos < from && end > to ? "cover" : true;
            pos = end;
        }
        return false;
    }
    /**
    @internal
    */
    toString() {
        let result = "";
        for (let i = 0; i < this.sections.length;) {
            let len = this.sections[i++], ins = this.sections[i++];
            result += (result ? " " : "") + len + (ins >= 0 ? ":" + ins : "");
        }
        return result;
    }
    /**
    Serialize this change desc to a JSON-representable value.
    */
    toJSON() { return this.sections; }
    /**
    Create a change desc from its JSON representation (as produced
    by [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeDesc.toJSON).
    */
    static fromJSON(json) {
        if (!Array.isArray(json) || json.length % 2 || json.some(a => typeof a != "number"))
            throw new RangeError("Invalid JSON representation of ChangeDesc");
        return new ChangeDesc(json);
    }
    /**
    @internal
    */
    static create(sections) { return new ChangeDesc(sections); }
}
/**
A change set represents a group of modifications to a document. It
stores the document length, and can only be applied to documents
with exactly that length.
*/
class ChangeSet extends ChangeDesc {
    constructor(sections, 
    /**
    @internal
    */
    inserted) {
        super(sections);
        this.inserted = inserted;
    }
    /**
    Apply the changes to a document, returning the modified
    document.
    */
    apply(doc) {
        if (this.length != doc.length)
            throw new RangeError("Applying change set to a document with the wrong length");
        iterChanges(this, (fromA, toA, fromB, _toB, text) => doc = doc.replace(fromB, fromB + (toA - fromA), text), false);
        return doc;
    }
    mapDesc(other, before = false) { return mapSet(this, other, before, true); }
    /**
    Given the document as it existed _before_ the changes, return a
    change set that represents the inverse of this set, which could
    be used to go from the document created by the changes back to
    the document as it existed before the changes.
    */
    invert(doc) {
        let sections = this.sections.slice(), inserted = [];
        for (let i = 0, pos = 0; i < sections.length; i += 2) {
            let len = sections[i], ins = sections[i + 1];
            if (ins >= 0) {
                sections[i] = ins;
                sections[i + 1] = len;
                let index = i >> 1;
                while (inserted.length < index)
                    inserted.push(Text.empty);
                inserted.push(len ? doc.slice(pos, pos + len) : Text.empty);
            }
            pos += len;
        }
        return new ChangeSet(sections, inserted);
    }
    /**
    Combine two subsequent change sets into a single set. `other`
    must start in the document produced by `this`. If `this` goes
    `docA`  `docB` and `other` represents `docB`  `docC`, the
    returned value will represent the change `docA`  `docC`.
    */
    compose(other) { return this.empty ? other : other.empty ? this : composeSets(this, other, true); }
    /**
    Given another change set starting in the same document, maps this
    change set over the other, producing a new change set that can be
    applied to the document produced by applying `other`. When
    `before` is `true`, order changes as if `this` comes before
    `other`, otherwise (the default) treat `other` as coming first.
    
    Given two changes `A` and `B`, `A.compose(B.map(A))` and
    `B.compose(A.map(B, true))` will produce the same document. This
    provides a basic form of [operational
    transformation](https://en.wikipedia.org/wiki/Operational_transformation),
    and can be used for collaborative editing.
    */
    map(other, before = false) { return other.empty ? this : mapSet(this, other, before, true); }
    /**
    Iterate over the changed ranges in the document, calling `f` for
    each, with the range in the original document (`fromA`-`toA`)
    and the range that replaces it in the new document
    (`fromB`-`toB`).
    
    When `individual` is true, adjacent changes are reported
    separately.
    */
    iterChanges(f, individual = false) {
        iterChanges(this, f, individual);
    }
    /**
    Get a [change description](https://codemirror.net/6/docs/ref/#state.ChangeDesc) for this change
    set.
    */
    get desc() { return ChangeDesc.create(this.sections); }
    /**
    @internal
    */
    filter(ranges) {
        let resultSections = [], resultInserted = [], filteredSections = [];
        let iter = new SectionIter(this);
        done: for (let i = 0, pos = 0;;) {
            let next = i == ranges.length ? 1e9 : ranges[i++];
            while (pos < next || pos == next && iter.len == 0) {
                if (iter.done)
                    break done;
                let len = Math.min(iter.len, next - pos);
                addSection(filteredSections, len, -1);
                let ins = iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0;
                addSection(resultSections, len, ins);
                if (ins > 0)
                    addInsert(resultInserted, resultSections, iter.text);
                iter.forward(len);
                pos += len;
            }
            let end = ranges[i++];
            while (pos < end) {
                if (iter.done)
                    break done;
                let len = Math.min(iter.len, end - pos);
                addSection(resultSections, len, -1);
                addSection(filteredSections, len, iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0);
                iter.forward(len);
                pos += len;
            }
        }
        return { changes: new ChangeSet(resultSections, resultInserted),
            filtered: ChangeDesc.create(filteredSections) };
    }
    /**
    Serialize this change set to a JSON-representable value.
    */
    toJSON() {
        let parts = [];
        for (let i = 0; i < this.sections.length; i += 2) {
            let len = this.sections[i], ins = this.sections[i + 1];
            if (ins < 0)
                parts.push(len);
            else if (ins == 0)
                parts.push([len]);
            else
                parts.push([len].concat(this.inserted[i >> 1].toJSON()));
        }
        return parts;
    }
    /**
    Create a change set for the given changes, for a document of the
    given length, using `lineSep` as line separator.
    */
    static of(changes, length, lineSep) {
        let sections = [], inserted = [], pos = 0;
        let total = null;
        function flush(force = false) {
            if (!force && !sections.length)
                return;
            if (pos < length)
                addSection(sections, length - pos, -1);
            let set = new ChangeSet(sections, inserted);
            total = total ? total.compose(set.map(total)) : set;
            sections = [];
            inserted = [];
            pos = 0;
        }
        function process(spec) {
            if (Array.isArray(spec)) {
                for (let sub of spec)
                    process(sub);
            }
            else if (spec instanceof ChangeSet) {
                if (spec.length != length)
                    throw new RangeError(`Mismatched change set length (got ${spec.length}, expected ${length})`);
                flush();
                total = total ? total.compose(spec.map(total)) : spec;
            }
            else {
                let { from, to = from, insert } = spec;
                if (from > to || from < 0 || to > length)
                    throw new RangeError(`Invalid change range ${from} to ${to} (in doc of length ${length})`);
                let insText = !insert ? Text.empty : typeof insert == "string" ? Text.of(insert.split(lineSep || DefaultSplit)) : insert;
                let insLen = insText.length;
                if (from == to && insLen == 0)
                    return;
                if (from < pos)
                    flush();
                if (from > pos)
                    addSection(sections, from - pos, -1);
                addSection(sections, to - from, insLen);
                addInsert(inserted, sections, insText);
                pos = to;
            }
        }
        process(changes);
        flush(!total);
        return total;
    }
    /**
    Create an empty changeset of the given length.
    */
    static empty(length) {
        return new ChangeSet(length ? [length, -1] : [], []);
    }
    /**
    Create a changeset from its JSON representation (as produced by
    [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeSet.toJSON).
    */
    static fromJSON(json) {
        if (!Array.isArray(json))
            throw new RangeError("Invalid JSON representation of ChangeSet");
        let sections = [], inserted = [];
        for (let i = 0; i < json.length; i++) {
            let part = json[i];
            if (typeof part == "number") {
                sections.push(part, -1);
            }
            else if (!Array.isArray(part) || typeof part[0] != "number" || part.some((e, i) => i && typeof e != "string")) {
                throw new RangeError("Invalid JSON representation of ChangeSet");
            }
            else if (part.length == 1) {
                sections.push(part[0], 0);
            }
            else {
                while (inserted.length < i)
                    inserted.push(Text.empty);
                inserted[i] = Text.of(part.slice(1));
                sections.push(part[0], inserted[i].length);
            }
        }
        return new ChangeSet(sections, inserted);
    }
    /**
    @internal
    */
    static createSet(sections, inserted) {
        return new ChangeSet(sections, inserted);
    }
}
function addSection(sections, len, ins, forceJoin = false) {
    if (len == 0 && ins <= 0)
        return;
    let last = sections.length - 2;
    if (last >= 0 && ins <= 0 && ins == sections[last + 1])
        sections[last] += len;
    else if (len == 0 && sections[last] == 0)
        sections[last + 1] += ins;
    else if (forceJoin) {
        sections[last] += len;
        sections[last + 1] += ins;
    }
    else
        sections.push(len, ins);
}
function addInsert(values, sections, value) {
    if (value.length == 0)
        return;
    let index = (sections.length - 2) >> 1;
    if (index < values.length) {
        values[values.length - 1] = values[values.length - 1].append(value);
    }
    else {
        while (values.length < index)
            values.push(Text.empty);
        values.push(value);
    }
}
function iterChanges(desc, f, individual) {
    let inserted = desc.inserted;
    for (let posA = 0, posB = 0, i = 0; i < desc.sections.length;) {
        let len = desc.sections[i++], ins = desc.sections[i++];
        if (ins < 0) {
            posA += len;
            posB += len;
        }
        else {
            let endA = posA, endB = posB, text = Text.empty;
            for (;;) {
                endA += len;
                endB += ins;
                if (ins && inserted)
                    text = text.append(inserted[(i - 2) >> 1]);
                if (individual || i == desc.sections.length || desc.sections[i + 1] < 0)
                    break;
                len = desc.sections[i++];
                ins = desc.sections[i++];
            }
            f(posA, endA, posB, endB, text);
            posA = endA;
            posB = endB;
        }
    }
}
function mapSet(setA, setB, before, mkSet = false) {
    // Produce a copy of setA that applies to the document after setB
    // has been applied (assuming both start at the same document).
    let sections = [], insert = mkSet ? [] : null;
    let a = new SectionIter(setA), b = new SectionIter(setB);
    // Iterate over both sets in parallel. inserted tracks, for changes
    // in A that have to be processed piece-by-piece, whether their
    // content has been inserted already, and refers to the section
    // index.
    for (let inserted = -1;;) {
        if (a.ins == -1 && b.ins == -1) {
            // Move across ranges skipped by both sets.
            let len = Math.min(a.len, b.len);
            addSection(sections, len, -1);
            a.forward(len);
            b.forward(len);
        }
        else if (b.ins >= 0 && (a.ins < 0 || inserted == a.i || a.off == 0 && (b.len < a.len || b.len == a.len && !before))) {
            // If there's a change in B that comes before the next change in
            // A (ordered by start pos, then len, then before flag), skip
            // that (and process any changes in A it covers).
            let len = b.len;
            addSection(sections, b.ins, -1);
            while (len) {
                let piece = Math.min(a.len, len);
                if (a.ins >= 0 && inserted < a.i && a.len <= piece) {
                    addSection(sections, 0, a.ins);
                    if (insert)
                        addInsert(insert, sections, a.text);
                    inserted = a.i;
                }
                a.forward(piece);
                len -= piece;
            }
            b.next();
        }
        else if (a.ins >= 0) {
            // Process the part of a change in A up to the start of the next
            // non-deletion change in B (if overlapping).
            let len = 0, left = a.len;
            while (left) {
                if (b.ins == -1) {
                    let piece = Math.min(left, b.len);
                    len += piece;
                    left -= piece;
                    b.forward(piece);
                }
                else if (b.ins == 0 && b.len < left) {
                    left -= b.len;
                    b.next();
                }
                else {
                    break;
                }
            }
            addSection(sections, len, inserted < a.i ? a.ins : 0);
            if (insert && inserted < a.i)
                addInsert(insert, sections, a.text);
            inserted = a.i;
            a.forward(a.len - left);
        }
        else if (a.done && b.done) {
            return insert ? ChangeSet.createSet(sections, insert) : ChangeDesc.create(sections);
        }
        else {
            throw new Error("Mismatched change set lengths");
        }
    }
}
function composeSets(setA, setB, mkSet = false) {
    let sections = [];
    let insert = mkSet ? [] : null;
    let a = new SectionIter(setA), b = new SectionIter(setB);
    for (let open = false;;) {
        if (a.done && b.done) {
            return insert ? ChangeSet.createSet(sections, insert) : ChangeDesc.create(sections);
        }
        else if (a.ins == 0) { // Deletion in A
            addSection(sections, a.len, 0, open);
            a.next();
        }
        else if (b.len == 0 && !b.done) { // Insertion in B
            addSection(sections, 0, b.ins, open);
            if (insert)
                addInsert(insert, sections, b.text);
            b.next();
        }
        else if (a.done || b.done) {
            throw new Error("Mismatched change set lengths");
        }
        else {
            let len = Math.min(a.len2, b.len), sectionLen = sections.length;
            if (a.ins == -1) {
                let insB = b.ins == -1 ? -1 : b.off ? 0 : b.ins;
                addSection(sections, len, insB, open);
                if (insert && insB)
                    addInsert(insert, sections, b.text);
            }
            else if (b.ins == -1) {
                addSection(sections, a.off ? 0 : a.len, len, open);
                if (insert)
                    addInsert(insert, sections, a.textBit(len));
            }
            else {
                addSection(sections, a.off ? 0 : a.len, b.off ? 0 : b.ins, open);
                if (insert && !b.off)
                    addInsert(insert, sections, b.text);
            }
            open = (a.ins > len || b.ins >= 0 && b.len > len) && (open || sections.length > sectionLen);
            a.forward2(len);
            b.forward(len);
        }
    }
}
class SectionIter {
    constructor(set) {
        this.set = set;
        this.i = 0;
        this.next();
    }
    next() {
        let { sections } = this.set;
        if (this.i < sections.length) {
            this.len = sections[this.i++];
            this.ins = sections[this.i++];
        }
        else {
            this.len = 0;
            this.ins = -2;
        }
        this.off = 0;
    }
    get done() { return this.ins == -2; }
    get len2() { return this.ins < 0 ? this.len : this.ins; }
    get text() {
        let { inserted } = this.set, index = (this.i - 2) >> 1;
        return index >= inserted.length ? Text.empty : inserted[index];
    }
    textBit(len) {
        let { inserted } = this.set, index = (this.i - 2) >> 1;
        return index >= inserted.length && !len ? Text.empty
            : inserted[index].slice(this.off, len == null ? undefined : this.off + len);
    }
    forward(len) {
        if (len == this.len)
            this.next();
        else {
            this.len -= len;
            this.off += len;
        }
    }
    forward2(len) {
        if (this.ins == -1)
            this.forward(len);
        else if (len == this.ins)
            this.next();
        else {
            this.ins -= len;
            this.off += len;
        }
    }
}

/**
A single selection range. When
[`allowMultipleSelections`](https://codemirror.net/6/docs/ref/#state.EditorState^allowMultipleSelections)
is enabled, a [selection](https://codemirror.net/6/docs/ref/#state.EditorSelection) may hold
multiple ranges. By default, selections hold exactly one range.
*/
class SelectionRange {
    constructor(
    /**
    The lower boundary of the range.
    */
    from, 
    /**
    The upper boundary of the range.
    */
    to, flags) {
        this.from = from;
        this.to = to;
        this.flags = flags;
    }
    /**
    The anchor of the rangethe side that doesn't move when you
    extend it.
    */
    get anchor() { return this.flags & 16 /* RangeFlag.Inverted */ ? this.to : this.from; }
    /**
    The head of the range, which is moved when the range is
    [extended](https://codemirror.net/6/docs/ref/#state.SelectionRange.extend).
    */
    get head() { return this.flags & 16 /* RangeFlag.Inverted */ ? this.from : this.to; }
    /**
    True when `anchor` and `head` are at the same position.
    */
    get empty() { return this.from == this.to; }
    /**
    If this is a cursor that is explicitly associated with the
    character on one of its sides, this returns the side. -1 means
    the character before its position, 1 the character after, and 0
    means no association.
    */
    get assoc() { return this.flags & 4 /* RangeFlag.AssocBefore */ ? -1 : this.flags & 8 /* RangeFlag.AssocAfter */ ? 1 : 0; }
    /**
    The bidirectional text level associated with this cursor, if
    any.
    */
    get bidiLevel() {
        let level = this.flags & 3 /* RangeFlag.BidiLevelMask */;
        return level == 3 ? null : level;
    }
    /**
    The goal column (stored vertical offset) associated with a
    cursor. This is used to preserve the vertical position when
    [moving](https://codemirror.net/6/docs/ref/#view.EditorView.moveVertically) across
    lines of different length.
    */
    get goalColumn() {
        let value = this.flags >> 5 /* RangeFlag.GoalColumnOffset */;
        return value == 33554431 /* RangeFlag.NoGoalColumn */ ? undefined : value;
    }
    /**
    Map this range through a change, producing a valid range in the
    updated document.
    */
    map(change, assoc = -1) {
        let from, to;
        if (this.empty) {
            from = to = change.mapPos(this.from, assoc);
        }
        else {
            from = change.mapPos(this.from, 1);
            to = change.mapPos(this.to, -1);
        }
        return from == this.from && to == this.to ? this : new SelectionRange(from, to, this.flags);
    }
    /**
    Extend this range to cover at least `from` to `to`.
    */
    extend(from, to = from) {
        if (from <= this.anchor && to >= this.anchor)
            return EditorSelection.range(from, to);
        let head = Math.abs(from - this.anchor) > Math.abs(to - this.anchor) ? from : to;
        return EditorSelection.range(this.anchor, head);
    }
    /**
    Compare this range to another range.
    */
    eq(other) {
        return this.anchor == other.anchor && this.head == other.head;
    }
    /**
    Return a JSON-serializable object representing the range.
    */
    toJSON() { return { anchor: this.anchor, head: this.head }; }
    /**
    Convert a JSON representation of a range to a `SelectionRange`
    instance.
    */
    static fromJSON(json) {
        if (!json || typeof json.anchor != "number" || typeof json.head != "number")
            throw new RangeError("Invalid JSON representation for SelectionRange");
        return EditorSelection.range(json.anchor, json.head);
    }
    /**
    @internal
    */
    static create(from, to, flags) {
        return new SelectionRange(from, to, flags);
    }
}
/**
An editor selection holds one or more selection ranges.
*/
class EditorSelection {
    constructor(
    /**
    The ranges in the selection, sorted by position. Ranges cannot
    overlap (but they may touch, if they aren't empty).
    */
    ranges, 
    /**
    The index of the _main_ range in the selection (which is
    usually the range that was added last).
    */
    mainIndex) {
        this.ranges = ranges;
        this.mainIndex = mainIndex;
    }
    /**
    Map a selection through a change. Used to adjust the selection
    position for changes.
    */
    map(change, assoc = -1) {
        if (change.empty)
            return this;
        return EditorSelection.create(this.ranges.map(r => r.map(change, assoc)), this.mainIndex);
    }
    /**
    Compare this selection to another selection.
    */
    eq(other) {
        if (this.ranges.length != other.ranges.length ||
            this.mainIndex != other.mainIndex)
            return false;
        for (let i = 0; i < this.ranges.length; i++)
            if (!this.ranges[i].eq(other.ranges[i]))
                return false;
        return true;
    }
    /**
    Get the primary selection range. Usually, you should make sure
    your code applies to _all_ ranges, by using methods like
    [`changeByRange`](https://codemirror.net/6/docs/ref/#state.EditorState.changeByRange).
    */
    get main() { return this.ranges[this.mainIndex]; }
    /**
    Make sure the selection only has one range. Returns a selection
    holding only the main range from this selection.
    */
    asSingle() {
        return this.ranges.length == 1 ? this : new EditorSelection([this.main], 0);
    }
    /**
    Extend this selection with an extra range.
    */
    addRange(range, main = true) {
        return EditorSelection.create([range].concat(this.ranges), main ? 0 : this.mainIndex + 1);
    }
    /**
    Replace a given range with another range, and then normalize the
    selection to merge and sort ranges if necessary.
    */
    replaceRange(range, which = this.mainIndex) {
        let ranges = this.ranges.slice();
        ranges[which] = range;
        return EditorSelection.create(ranges, this.mainIndex);
    }
    /**
    Convert this selection to an object that can be serialized to
    JSON.
    */
    toJSON() {
        return { ranges: this.ranges.map(r => r.toJSON()), main: this.mainIndex };
    }
    /**
    Create a selection from a JSON representation.
    */
    static fromJSON(json) {
        if (!json || !Array.isArray(json.ranges) || typeof json.main != "number" || json.main >= json.ranges.length)
            throw new RangeError("Invalid JSON representation for EditorSelection");
        return new EditorSelection(json.ranges.map((r) => SelectionRange.fromJSON(r)), json.main);
    }
    /**
    Create a selection holding a single range.
    */
    static single(anchor, head = anchor) {
        return new EditorSelection([EditorSelection.range(anchor, head)], 0);
    }
    /**
    Sort and merge the given set of ranges, creating a valid
    selection.
    */
    static create(ranges, mainIndex = 0) {
        if (ranges.length == 0)
            throw new RangeError("A selection needs at least one range");
        for (let pos = 0, i = 0; i < ranges.length; i++) {
            let range = ranges[i];
            if (range.empty ? range.from <= pos : range.from < pos)
                return EditorSelection.normalized(ranges.slice(), mainIndex);
            pos = range.to;
        }
        return new EditorSelection(ranges, mainIndex);
    }
    /**
    Create a cursor selection range at the given position. You can
    safely ignore the optional arguments in most situations.
    */
    static cursor(pos, assoc = 0, bidiLevel, goalColumn) {
        return SelectionRange.create(pos, pos, (assoc == 0 ? 0 : assoc < 0 ? 4 /* RangeFlag.AssocBefore */ : 8 /* RangeFlag.AssocAfter */) |
            (bidiLevel == null ? 3 : Math.min(2, bidiLevel)) |
            ((goalColumn !== null && goalColumn !== void 0 ? goalColumn : 33554431 /* RangeFlag.NoGoalColumn */) << 5 /* RangeFlag.GoalColumnOffset */));
    }
    /**
    Create a selection range.
    */
    static range(anchor, head, goalColumn) {
        let goal = (goalColumn !== null && goalColumn !== void 0 ? goalColumn : 33554431 /* RangeFlag.NoGoalColumn */) << 5 /* RangeFlag.GoalColumnOffset */;
        return head < anchor ? SelectionRange.create(head, anchor, 16 /* RangeFlag.Inverted */ | goal | 8 /* RangeFlag.AssocAfter */)
            : SelectionRange.create(anchor, head, goal | (head > anchor ? 4 /* RangeFlag.AssocBefore */ : 0));
    }
    /**
    @internal
    */
    static normalized(ranges, mainIndex = 0) {
        let main = ranges[mainIndex];
        ranges.sort((a, b) => a.from - b.from);
        mainIndex = ranges.indexOf(main);
        for (let i = 1; i < ranges.length; i++) {
            let range = ranges[i], prev = ranges[i - 1];
            if (range.empty ? range.from <= prev.to : range.from < prev.to) {
                let from = prev.from, to = Math.max(range.to, prev.to);
                if (i <= mainIndex)
                    mainIndex--;
                ranges.splice(--i, 2, range.anchor > range.head ? EditorSelection.range(to, from) : EditorSelection.range(from, to));
            }
        }
        return new EditorSelection(ranges, mainIndex);
    }
}
function checkSelection(selection, docLength) {
    for (let range of selection.ranges)
        if (range.to > docLength)
            throw new RangeError("Selection points outside of document");
}

let nextID = 0;
/**
A facet is a labeled value that is associated with an editor
state. It takes inputs from any number of extensions, and combines
those into a single output value.

Examples of uses of facets are the [tab
size](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize), [editor
attributes](https://codemirror.net/6/docs/ref/#view.EditorView^editorAttributes), and [update
listeners](https://codemirror.net/6/docs/ref/#view.EditorView^updateListener).
*/
class Facet {
    constructor(
    /**
    @internal
    */
    combine, 
    /**
    @internal
    */
    compareInput, 
    /**
    @internal
    */
    compare, isStatic, enables) {
        this.combine = combine;
        this.compareInput = compareInput;
        this.compare = compare;
        this.isStatic = isStatic;
        /**
        @internal
        */
        this.id = nextID++;
        this.default = combine([]);
        this.extensions = typeof enables == "function" ? enables(this) : enables;
    }
    /**
    Define a new facet.
    */
    static define(config = {}) {
        return new Facet(config.combine || ((a) => a), config.compareInput || ((a, b) => a === b), config.compare || (!config.combine ? sameArray : (a, b) => a === b), !!config.static, config.enables);
    }
    /**
    Returns an extension that adds the given value to this facet.
    */
    of(value) {
        return new FacetProvider([], this, 0 /* Provider.Static */, value);
    }
    /**
    Create an extension that computes a value for the facet from a
    state. You must take care to declare the parts of the state that
    this value depends on, since your function is only called again
    for a new state when one of those parts changed.
    
    In cases where your value depends only on a single field, you'll
    want to use the [`from`](https://codemirror.net/6/docs/ref/#state.Facet.from) method instead.
    */
    compute(deps, get) {
        if (this.isStatic)
            throw new Error("Can't compute a static facet");
        return new FacetProvider(deps, this, 1 /* Provider.Single */, get);
    }
    /**
    Create an extension that computes zero or more values for this
    facet from a state.
    */
    computeN(deps, get) {
        if (this.isStatic)
            throw new Error("Can't compute a static facet");
        return new FacetProvider(deps, this, 2 /* Provider.Multi */, get);
    }
    from(field, get) {
        if (!get)
            get = x => x;
        return this.compute([field], state => get(state.field(field)));
    }
}
function sameArray(a, b) {
    return a == b || a.length == b.length && a.every((e, i) => e === b[i]);
}
class FacetProvider {
    constructor(dependencies, facet, type, value) {
        this.dependencies = dependencies;
        this.facet = facet;
        this.type = type;
        this.value = value;
        this.id = nextID++;
    }
    dynamicSlot(addresses) {
        var _a;
        let getter = this.value;
        let compare = this.facet.compareInput;
        let id = this.id, idx = addresses[id] >> 1, multi = this.type == 2 /* Provider.Multi */;
        let depDoc = false, depSel = false, depAddrs = [];
        for (let dep of this.dependencies) {
            if (dep == "doc")
                depDoc = true;
            else if (dep == "selection")
                depSel = true;
            else if ((((_a = addresses[dep.id]) !== null && _a !== void 0 ? _a : 1) & 1) == 0)
                depAddrs.push(addresses[dep.id]);
        }
        return {
            create(state) {
                state.values[idx] = getter(state);
                return 1 /* SlotStatus.Changed */;
            },
            update(state, tr) {
                if ((depDoc && tr.docChanged) || (depSel && (tr.docChanged || tr.selection)) || ensureAll(state, depAddrs)) {
                    let newVal = getter(state);
                    if (multi ? !compareArray(newVal, state.values[idx], compare) : !compare(newVal, state.values[idx])) {
                        state.values[idx] = newVal;
                        return 1 /* SlotStatus.Changed */;
                    }
                }
                return 0;
            },
            reconfigure: (state, oldState) => {
                let newVal = getter(state);
                let oldAddr = oldState.config.address[id];
                if (oldAddr != null) {
                    let oldVal = getAddr(oldState, oldAddr);
                    if (this.dependencies.every(dep => {
                        return dep instanceof Facet ? oldState.facet(dep) === state.facet(dep) :
                            dep instanceof StateField ? oldState.field(dep, false) == state.field(dep, false) : true;
                    }) || (multi ? compareArray(newVal, oldVal, compare) : compare(newVal, oldVal))) {
                        state.values[idx] = oldVal;
                        return 0;
                    }
                }
                state.values[idx] = newVal;
                return 1 /* SlotStatus.Changed */;
            }
        };
    }
}
function compareArray(a, b, compare) {
    if (a.length != b.length)
        return false;
    for (let i = 0; i < a.length; i++)
        if (!compare(a[i], b[i]))
            return false;
    return true;
}
function ensureAll(state, addrs) {
    let changed = false;
    for (let addr of addrs)
        if (ensureAddr(state, addr) & 1 /* SlotStatus.Changed */)
            changed = true;
    return changed;
}
function dynamicFacetSlot(addresses, facet, providers) {
    let providerAddrs = providers.map(p => addresses[p.id]);
    let providerTypes = providers.map(p => p.type);
    let dynamic = providerAddrs.filter(p => !(p & 1));
    let idx = addresses[facet.id] >> 1;
    function get(state) {
        let values = [];
        for (let i = 0; i < providerAddrs.length; i++) {
            let value = getAddr(state, providerAddrs[i]);
            if (providerTypes[i] == 2 /* Provider.Multi */)
                for (let val of value)
                    values.push(val);
            else
                values.push(value);
        }
        return facet.combine(values);
    }
    return {
        create(state) {
            for (let addr of providerAddrs)
                ensureAddr(state, addr);
            state.values[idx] = get(state);
            return 1 /* SlotStatus.Changed */;
        },
        update(state, tr) {
            if (!ensureAll(state, dynamic))
                return 0;
            let value = get(state);
            if (facet.compare(value, state.values[idx]))
                return 0;
            state.values[idx] = value;
            return 1 /* SlotStatus.Changed */;
        },
        reconfigure(state, oldState) {
            let depChanged = ensureAll(state, providerAddrs);
            let oldProviders = oldState.config.facets[facet.id], oldValue = oldState.facet(facet);
            if (oldProviders && !depChanged && sameArray(providers, oldProviders)) {
                state.values[idx] = oldValue;
                return 0;
            }
            let value = get(state);
            if (facet.compare(value, oldValue)) {
                state.values[idx] = oldValue;
                return 0;
            }
            state.values[idx] = value;
            return 1 /* SlotStatus.Changed */;
        }
    };
}
const initField = /*@__PURE__*/Facet.define({ static: true });
/**
Fields can store additional information in an editor state, and
keep it in sync with the rest of the state.
*/
class StateField {
    constructor(
    /**
    @internal
    */
    id, createF, updateF, compareF, 
    /**
    @internal
    */
    spec) {
        this.id = id;
        this.createF = createF;
        this.updateF = updateF;
        this.compareF = compareF;
        this.spec = spec;
        /**
        @internal
        */
        this.provides = undefined;
    }
    /**
    Define a state field.
    */
    static define(config) {
        let field = new StateField(nextID++, config.create, config.update, config.compare || ((a, b) => a === b), config);
        if (config.provide)
            field.provides = config.provide(field);
        return field;
    }
    create(state) {
        let init = state.facet(initField).find(i => i.field == this);
        return ((init === null || init === void 0 ? void 0 : init.create) || this.createF)(state);
    }
    /**
    @internal
    */
    slot(addresses) {
        let idx = addresses[this.id] >> 1;
        return {
            create: (state) => {
                state.values[idx] = this.create(state);
                return 1 /* SlotStatus.Changed */;
            },
            update: (state, tr) => {
                let oldVal = state.values[idx];
                let value = this.updateF(oldVal, tr);
                if (this.compareF(oldVal, value))
                    return 0;
                state.values[idx] = value;
                return 1 /* SlotStatus.Changed */;
            },
            reconfigure: (state, oldState) => {
                if (oldState.config.address[this.id] != null) {
                    state.values[idx] = oldState.field(this);
                    return 0;
                }
                state.values[idx] = this.create(state);
                return 1 /* SlotStatus.Changed */;
            }
        };
    }
    /**
    Returns an extension that enables this field and overrides the
    way it is initialized. Can be useful when you need to provide a
    non-default starting value for the field.
    */
    init(create) {
        return [this, initField.of({ field: this, create })];
    }
    /**
    State field instances can be used as
    [`Extension`](https://codemirror.net/6/docs/ref/#state.Extension) values to enable the field in a
    given state.
    */
    get extension() { return this; }
}
const Prec_ = { lowest: 4, low: 3, default: 2, high: 1, highest: 0 };
function prec(value) {
    return (ext) => new PrecExtension(ext, value);
}
/**
By default extensions are registered in the order they are found
in the flattened form of nested array that was provided.
Individual extension values can be assigned a precedence to
override this. Extensions that do not have a precedence set get
the precedence of the nearest parent with a precedence, or
[`default`](https://codemirror.net/6/docs/ref/#state.Prec.default) if there is no such parent. The
final ordering of extensions is determined by first sorting by
precedence and then by order within each precedence.
*/
const Prec = {
    /**
    The highest precedence level, for extensions that should end up
    near the start of the precedence ordering.
    */
    highest: /*@__PURE__*/prec(Prec_.highest),
    /**
    A higher-than-default precedence, for extensions that should
    come before those with default precedence.
    */
    high: /*@__PURE__*/prec(Prec_.high),
    /**
    The default precedence, which is also used for extensions
    without an explicit precedence.
    */
    default: /*@__PURE__*/prec(Prec_.default),
    /**
    A lower-than-default precedence.
    */
    low: /*@__PURE__*/prec(Prec_.low),
    /**
    The lowest precedence level. Meant for things that should end up
    near the end of the extension order.
    */
    lowest: /*@__PURE__*/prec(Prec_.lowest)
};
class PrecExtension {
    constructor(inner, prec) {
        this.inner = inner;
        this.prec = prec;
    }
}
/**
Extension compartments can be used to make a configuration
dynamic. By [wrapping](https://codemirror.net/6/docs/ref/#state.Compartment.of) part of your
configuration in a compartment, you can later
[replace](https://codemirror.net/6/docs/ref/#state.Compartment.reconfigure) that part through a
transaction.
*/
class Compartment {
    /**
    Create an instance of this compartment to add to your [state
    configuration](https://codemirror.net/6/docs/ref/#state.EditorStateConfig.extensions).
    */
    of(ext) { return new CompartmentInstance(this, ext); }
    /**
    Create an [effect](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) that
    reconfigures this compartment.
    */
    reconfigure(content) {
        return Compartment.reconfigure.of({ compartment: this, extension: content });
    }
    /**
    Get the current content of the compartment in the state, or
    `undefined` if it isn't present.
    */
    get(state) {
        return state.config.compartments.get(this);
    }
}
class CompartmentInstance {
    constructor(compartment, inner) {
        this.compartment = compartment;
        this.inner = inner;
    }
}
class Configuration {
    constructor(base, compartments, dynamicSlots, address, staticValues, facets) {
        this.base = base;
        this.compartments = compartments;
        this.dynamicSlots = dynamicSlots;
        this.address = address;
        this.staticValues = staticValues;
        this.facets = facets;
        this.statusTemplate = [];
        while (this.statusTemplate.length < dynamicSlots.length)
            this.statusTemplate.push(0 /* SlotStatus.Unresolved */);
    }
    staticFacet(facet) {
        let addr = this.address[facet.id];
        return addr == null ? facet.default : this.staticValues[addr >> 1];
    }
    static resolve(base, compartments, oldState) {
        let fields = [];
        let facets = Object.create(null);
        let newCompartments = new Map();
        for (let ext of flatten(base, compartments, newCompartments)) {
            if (ext instanceof StateField)
                fields.push(ext);
            else
                (facets[ext.facet.id] || (facets[ext.facet.id] = [])).push(ext);
        }
        let address = Object.create(null);
        let staticValues = [];
        let dynamicSlots = [];
        for (let field of fields) {
            address[field.id] = dynamicSlots.length << 1;
            dynamicSlots.push(a => field.slot(a));
        }
        let oldFacets = oldState === null || oldState === void 0 ? void 0 : oldState.config.facets;
        for (let id in facets) {
            let providers = facets[id], facet = providers[0].facet;
            let oldProviders = oldFacets && oldFacets[id] || [];
            if (providers.every(p => p.type == 0 /* Provider.Static */)) {
                address[facet.id] = (staticValues.length << 1) | 1;
                if (sameArray(oldProviders, providers)) {
                    staticValues.push(oldState.facet(facet));
                }
                else {
                    let value = facet.combine(providers.map(p => p.value));
                    staticValues.push(oldState && facet.compare(value, oldState.facet(facet)) ? oldState.facet(facet) : value);
                }
            }
            else {
                for (let p of providers) {
                    if (p.type == 0 /* Provider.Static */) {
                        address[p.id] = (staticValues.length << 1) | 1;
                        staticValues.push(p.value);
                    }
                    else {
                        address[p.id] = dynamicSlots.length << 1;
                        dynamicSlots.push(a => p.dynamicSlot(a));
                    }
                }
                address[facet.id] = dynamicSlots.length << 1;
                dynamicSlots.push(a => dynamicFacetSlot(a, facet, providers));
            }
        }
        let dynamic = dynamicSlots.map(f => f(address));
        return new Configuration(base, newCompartments, dynamic, address, staticValues, facets);
    }
}
function flatten(extension, compartments, newCompartments) {
    let result = [[], [], [], [], []];
    let seen = new Map();
    function inner(ext, prec) {
        let known = seen.get(ext);
        if (known != null) {
            if (known <= prec)
                return;
            let found = result[known].indexOf(ext);
            if (found > -1)
                result[known].splice(found, 1);
            if (ext instanceof CompartmentInstance)
                newCompartments.delete(ext.compartment);
        }
        seen.set(ext, prec);
        if (Array.isArray(ext)) {
            for (let e of ext)
                inner(e, prec);
        }
        else if (ext instanceof CompartmentInstance) {
            if (newCompartments.has(ext.compartment))
                throw new RangeError(`Duplicate use of compartment in extensions`);
            let content = compartments.get(ext.compartment) || ext.inner;
            newCompartments.set(ext.compartment, content);
            inner(content, prec);
        }
        else if (ext instanceof PrecExtension) {
            inner(ext.inner, ext.prec);
        }
        else if (ext instanceof StateField) {
            result[prec].push(ext);
            if (ext.provides)
                inner(ext.provides, prec);
        }
        else if (ext instanceof FacetProvider) {
            result[prec].push(ext);
            if (ext.facet.extensions)
                inner(ext.facet.extensions, Prec_.default);
        }
        else {
            let content = ext.extension;
            if (!content)
                throw new Error(`Unrecognized extension value in extension set (${ext}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);
            inner(content, prec);
        }
    }
    inner(extension, Prec_.default);
    return result.reduce((a, b) => a.concat(b));
}
function ensureAddr(state, addr) {
    if (addr & 1)
        return 2 /* SlotStatus.Computed */;
    let idx = addr >> 1;
    let status = state.status[idx];
    if (status == 4 /* SlotStatus.Computing */)
        throw new Error("Cyclic dependency between fields and/or facets");
    if (status & 2 /* SlotStatus.Computed */)
        return status;
    state.status[idx] = 4 /* SlotStatus.Computing */;
    let changed = state.computeSlot(state, state.config.dynamicSlots[idx]);
    return state.status[idx] = 2 /* SlotStatus.Computed */ | changed;
}
function getAddr(state, addr) {
    return addr & 1 ? state.config.staticValues[addr >> 1] : state.values[addr >> 1];
}

const languageData = /*@__PURE__*/Facet.define();
const allowMultipleSelections = /*@__PURE__*/Facet.define({
    combine: values => values.some(v => v),
    static: true
});
const lineSeparator = /*@__PURE__*/Facet.define({
    combine: values => values.length ? values[0] : undefined,
    static: true
});
const changeFilter = /*@__PURE__*/Facet.define();
const transactionFilter = /*@__PURE__*/Facet.define();
const transactionExtender = /*@__PURE__*/Facet.define();
const readOnly = /*@__PURE__*/Facet.define({
    combine: values => values.length ? values[0] : false
});

/**
Annotations are tagged values that are used to add metadata to
transactions in an extensible way. They should be used to model
things that effect the entire transaction (such as its [time
stamp](https://codemirror.net/6/docs/ref/#state.Transaction^time) or information about its
[origin](https://codemirror.net/6/docs/ref/#state.Transaction^userEvent)). For effects that happen
_alongside_ the other changes made by the transaction, [state
effects](https://codemirror.net/6/docs/ref/#state.StateEffect) are more appropriate.
*/
class Annotation {
    /**
    @internal
    */
    constructor(
    /**
    The annotation type.
    */
    type, 
    /**
    The value of this annotation.
    */
    value) {
        this.type = type;
        this.value = value;
    }
    /**
    Define a new type of annotation.
    */
    static define() { return new AnnotationType(); }
}
/**
Marker that identifies a type of [annotation](https://codemirror.net/6/docs/ref/#state.Annotation).
*/
class AnnotationType {
    /**
    Create an instance of this annotation.
    */
    of(value) { return new Annotation(this, value); }
}
/**
Representation of a type of state effect. Defined with
[`StateEffect.define`](https://codemirror.net/6/docs/ref/#state.StateEffect^define).
*/
class StateEffectType {
    /**
    @internal
    */
    constructor(
    // The `any` types in these function types are there to work
    // around TypeScript issue #37631, where the type guard on
    // `StateEffect.is` mysteriously stops working when these properly
    // have type `Value`.
    /**
    @internal
    */
    map) {
        this.map = map;
    }
    /**
    Create a [state effect](https://codemirror.net/6/docs/ref/#state.StateEffect) instance of this
    type.
    */
    of(value) { return new StateEffect(this, value); }
}
/**
State effects can be used to represent additional effects
associated with a [transaction](https://codemirror.net/6/docs/ref/#state.Transaction.effects). They
are often useful to model changes to custom [state
fields](https://codemirror.net/6/docs/ref/#state.StateField), when those changes aren't implicit in
document or selection changes.
*/
class StateEffect {
    /**
    @internal
    */
    constructor(
    /**
    @internal
    */
    type, 
    /**
    The value of this effect.
    */
    value) {
        this.type = type;
        this.value = value;
    }
    /**
    Map this effect through a position mapping. Will return
    `undefined` when that ends up deleting the effect.
    */
    map(mapping) {
        let mapped = this.type.map(this.value, mapping);
        return mapped === undefined ? undefined : mapped == this.value ? this : new StateEffect(this.type, mapped);
    }
    /**
    Tells you whether this effect object is of a given
    [type](https://codemirror.net/6/docs/ref/#state.StateEffectType).
    */
    is(type) { return this.type == type; }
    /**
    Define a new effect type. The type parameter indicates the type
    of values that his effect holds.
    */
    static define(spec = {}) {
        return new StateEffectType(spec.map || (v => v));
    }
    /**
    Map an array of effects through a change set.
    */
    static mapEffects(effects, mapping) {
        if (!effects.length)
            return effects;
        let result = [];
        for (let effect of effects) {
            let mapped = effect.map(mapping);
            if (mapped)
                result.push(mapped);
        }
        return result;
    }
}
/**
This effect can be used to reconfigure the root extensions of
the editor. Doing this will discard any extensions
[appended](https://codemirror.net/6/docs/ref/#state.StateEffect^appendConfig), but does not reset
the content of [reconfigured](https://codemirror.net/6/docs/ref/#state.Compartment.reconfigure)
compartments.
*/
StateEffect.reconfigure = /*@__PURE__*/StateEffect.define();
/**
Append extensions to the top-level configuration of the editor.
*/
StateEffect.appendConfig = /*@__PURE__*/StateEffect.define();
/**
Changes to the editor state are grouped into transactions.
Typically, a user action creates a single transaction, which may
contain any number of document changes, may change the selection,
or have other effects. Create a transaction by calling
[`EditorState.update`](https://codemirror.net/6/docs/ref/#state.EditorState.update), or immediately
dispatch one by calling
[`EditorView.dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch).
*/
class Transaction {
    constructor(
    /**
    The state from which the transaction starts.
    */
    startState, 
    /**
    The document changes made by this transaction.
    */
    changes, 
    /**
    The selection set by this transaction, or undefined if it
    doesn't explicitly set a selection.
    */
    selection, 
    /**
    The effects added to the transaction.
    */
    effects, 
    /**
    @internal
    */
    annotations, 
    /**
    Whether the selection should be scrolled into view after this
    transaction is dispatched.
    */
    scrollIntoView) {
        this.startState = startState;
        this.changes = changes;
        this.selection = selection;
        this.effects = effects;
        this.annotations = annotations;
        this.scrollIntoView = scrollIntoView;
        /**
        @internal
        */
        this._doc = null;
        /**
        @internal
        */
        this._state = null;
        if (selection)
            checkSelection(selection, changes.newLength);
        if (!annotations.some((a) => a.type == Transaction.time))
            this.annotations = annotations.concat(Transaction.time.of(Date.now()));
    }
    /**
    @internal
    */
    static create(startState, changes, selection, effects, annotations, scrollIntoView) {
        return new Transaction(startState, changes, selection, effects, annotations, scrollIntoView);
    }
    /**
    The new document produced by the transaction. Contrary to
    [`.state`](https://codemirror.net/6/docs/ref/#state.Transaction.state)`.doc`, accessing this won't
    force the entire new state to be computed right away, so it is
    recommended that [transaction
    filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) use this getter
    when they need to look at the new document.
    */
    get newDoc() {
        return this._doc || (this._doc = this.changes.apply(this.startState.doc));
    }
    /**
    The new selection produced by the transaction. If
    [`this.selection`](https://codemirror.net/6/docs/ref/#state.Transaction.selection) is undefined,
    this will [map](https://codemirror.net/6/docs/ref/#state.EditorSelection.map) the start state's
    current selection through the changes made by the transaction.
    */
    get newSelection() {
        return this.selection || this.startState.selection.map(this.changes);
    }
    /**
    The new state created by the transaction. Computed on demand
    (but retained for subsequent access), so it is recommended not to
    access it in [transaction
    filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) when possible.
    */
    get state() {
        if (!this._state)
            this.startState.applyTransaction(this);
        return this._state;
    }
    /**
    Get the value of the given annotation type, if any.
    */
    annotation(type) {
        for (let ann of this.annotations)
            if (ann.type == type)
                return ann.value;
        return undefined;
    }
    /**
    Indicates whether the transaction changed the document.
    */
    get docChanged() { return !this.changes.empty; }
    /**
    Indicates whether this transaction reconfigures the state
    (through a [configuration compartment](https://codemirror.net/6/docs/ref/#state.Compartment) or
    with a top-level configuration
    [effect](https://codemirror.net/6/docs/ref/#state.StateEffect^reconfigure).
    */
    get reconfigured() { return this.startState.config != this.state.config; }
    /**
    Returns true if the transaction has a [user
    event](https://codemirror.net/6/docs/ref/#state.Transaction^userEvent) annotation that is equal to
    or more specific than `event`. For example, if the transaction
    has `"select.pointer"` as user event, `"select"` and
    `"select.pointer"` will match it.
    */
    isUserEvent(event) {
        let e = this.annotation(Transaction.userEvent);
        return !!(e && (e == event || e.length > event.length && e.slice(0, event.length) == event && e[event.length] == "."));
    }
}
/**
Annotation used to store transaction timestamps. Automatically
added to every transaction, holding `Date.now()`.
*/
Transaction.time = /*@__PURE__*/Annotation.define();
/**
Annotation used to associate a transaction with a user interface
event. Holds a string identifying the event, using a
dot-separated format to support attaching more specific
information. The events used by the core libraries are:

 - `"input"` when content is entered
   - `"input.type"` for typed input
     - `"input.type.compose"` for composition
   - `"input.paste"` for pasted input
   - `"input.drop"` when adding content with drag-and-drop
   - `"input.complete"` when autocompleting
 - `"delete"` when the user deletes content
   - `"delete.selection"` when deleting the selection
   - `"delete.forward"` when deleting forward from the selection
   - `"delete.backward"` when deleting backward from the selection
   - `"delete.cut"` when cutting to the clipboard
 - `"move"` when content is moved
   - `"move.drop"` when content is moved within the editor through drag-and-drop
 - `"select"` when explicitly changing the selection
   - `"select.pointer"` when selecting with a mouse or other pointing device
 - `"undo"` and `"redo"` for history actions

Use [`isUserEvent`](https://codemirror.net/6/docs/ref/#state.Transaction.isUserEvent) to check
whether the annotation matches a given event.
*/
Transaction.userEvent = /*@__PURE__*/Annotation.define();
/**
Annotation indicating whether a transaction should be added to
the undo history or not.
*/
Transaction.addToHistory = /*@__PURE__*/Annotation.define();
/**
Annotation indicating (when present and true) that a transaction
represents a change made by some other actor, not the user. This
is used, for example, to tag other people's changes in
collaborative editing.
*/
Transaction.remote = /*@__PURE__*/Annotation.define();
function joinRanges(a, b) {
    let result = [];
    for (let iA = 0, iB = 0;;) {
        let from, to;
        if (iA < a.length && (iB == b.length || b[iB] >= a[iA])) {
            from = a[iA++];
            to = a[iA++];
        }
        else if (iB < b.length) {
            from = b[iB++];
            to = b[iB++];
        }
        else
            return result;
        if (!result.length || result[result.length - 1] < from)
            result.push(from, to);
        else if (result[result.length - 1] < to)
            result[result.length - 1] = to;
    }
}
function mergeTransaction(a, b, sequential) {
    var _a;
    let mapForA, mapForB, changes;
    if (sequential) {
        mapForA = b.changes;
        mapForB = ChangeSet.empty(b.changes.length);
        changes = a.changes.compose(b.changes);
    }
    else {
        mapForA = b.changes.map(a.changes);
        mapForB = a.changes.mapDesc(b.changes, true);
        changes = a.changes.compose(mapForA);
    }
    return {
        changes,
        selection: b.selection ? b.selection.map(mapForB) : (_a = a.selection) === null || _a === void 0 ? void 0 : _a.map(mapForA),
        effects: StateEffect.mapEffects(a.effects, mapForA).concat(StateEffect.mapEffects(b.effects, mapForB)),
        annotations: a.annotations.length ? a.annotations.concat(b.annotations) : b.annotations,
        scrollIntoView: a.scrollIntoView || b.scrollIntoView
    };
}
function resolveTransactionInner(state, spec, docSize) {
    let sel = spec.selection, annotations = asArray(spec.annotations);
    if (spec.userEvent)
        annotations = annotations.concat(Transaction.userEvent.of(spec.userEvent));
    return {
        changes: spec.changes instanceof ChangeSet ? spec.changes
            : ChangeSet.of(spec.changes || [], docSize, state.facet(lineSeparator)),
        selection: sel && (sel instanceof EditorSelection ? sel : EditorSelection.single(sel.anchor, sel.head)),
        effects: asArray(spec.effects),
        annotations,
        scrollIntoView: !!spec.scrollIntoView
    };
}
function resolveTransaction(state, specs, filter) {
    let s = resolveTransactionInner(state, specs.length ? specs[0] : {}, state.doc.length);
    if (specs.length && specs[0].filter === false)
        filter = false;
    for (let i = 1; i < specs.length; i++) {
        if (specs[i].filter === false)
            filter = false;
        let seq = !!specs[i].sequential;
        s = mergeTransaction(s, resolveTransactionInner(state, specs[i], seq ? s.changes.newLength : state.doc.length), seq);
    }
    let tr = Transaction.create(state, s.changes, s.selection, s.effects, s.annotations, s.scrollIntoView);
    return extendTransaction(filter ? filterTransaction(tr) : tr);
}
// Finish a transaction by applying filters if necessary.
function filterTransaction(tr) {
    let state = tr.startState;
    // Change filters
    let result = true;
    for (let filter of state.facet(changeFilter)) {
        let value = filter(tr);
        if (value === false) {
            result = false;
            break;
        }
        if (Array.isArray(value))
            result = result === true ? value : joinRanges(result, value);
    }
    if (result !== true) {
        let changes, back;
        if (result === false) {
            back = tr.changes.invertedDesc;
            changes = ChangeSet.empty(state.doc.length);
        }
        else {
            let filtered = tr.changes.filter(result);
            changes = filtered.changes;
            back = filtered.filtered.mapDesc(filtered.changes).invertedDesc;
        }
        tr = Transaction.create(state, changes, tr.selection && tr.selection.map(back), StateEffect.mapEffects(tr.effects, back), tr.annotations, tr.scrollIntoView);
    }
    // Transaction filters
    let filters = state.facet(transactionFilter);
    for (let i = filters.length - 1; i >= 0; i--) {
        let filtered = filters[i](tr);
        if (filtered instanceof Transaction)
            tr = filtered;
        else if (Array.isArray(filtered) && filtered.length == 1 && filtered[0] instanceof Transaction)
            tr = filtered[0];
        else
            tr = resolveTransaction(state, asArray(filtered), false);
    }
    return tr;
}
function extendTransaction(tr) {
    let state = tr.startState, extenders = state.facet(transactionExtender), spec = tr;
    for (let i = extenders.length - 1; i >= 0; i--) {
        let extension = extenders[i](tr);
        if (extension && Object.keys(extension).length)
            spec = mergeTransaction(spec, resolveTransactionInner(state, extension, tr.changes.newLength), true);
    }
    return spec == tr ? tr : Transaction.create(state, tr.changes, tr.selection, spec.effects, spec.annotations, spec.scrollIntoView);
}
const none = [];
function asArray(value) {
    return value == null ? none : Array.isArray(value) ? value : [value];
}

/**
The categories produced by a [character
categorizer](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer). These are used
do things like selecting by word.
*/
var CharCategory = /*@__PURE__*/(function (CharCategory) {
    /**
    Word characters.
    */
    CharCategory[CharCategory["Word"] = 0] = "Word";
    /**
    Whitespace.
    */
    CharCategory[CharCategory["Space"] = 1] = "Space";
    /**
    Anything else.
    */
    CharCategory[CharCategory["Other"] = 2] = "Other";
return CharCategory})(CharCategory || (CharCategory = {}));
const nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
let wordChar;
try {
    wordChar = /*@__PURE__*/new RegExp("[\\p{Alphabetic}\\p{Number}_]", "u");
}
catch (_) { }
function hasWordChar(str) {
    if (wordChar)
        return wordChar.test(str);
    for (let i = 0; i < str.length; i++) {
        let ch = str[i];
        if (/\w/.test(ch) || ch > "\x80" && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch)))
            return true;
    }
    return false;
}
function makeCategorizer(wordChars) {
    return (char) => {
        if (!/\S/.test(char))
            return CharCategory.Space;
        if (hasWordChar(char))
            return CharCategory.Word;
        for (let i = 0; i < wordChars.length; i++)
            if (char.indexOf(wordChars[i]) > -1)
                return CharCategory.Word;
        return CharCategory.Other;
    };
}

/**
The editor state class is a persistent (immutable) data structure.
To update a state, you [create](https://codemirror.net/6/docs/ref/#state.EditorState.update) a
[transaction](https://codemirror.net/6/docs/ref/#state.Transaction), which produces a _new_ state
instance, without modifying the original object.

As such, _never_ mutate properties of a state directly. That'll
just break things.
*/
class EditorState {
    constructor(
    /**
    @internal
    */
    config, 
    /**
    The current document.
    */
    doc, 
    /**
    The current selection.
    */
    selection, 
    /**
    @internal
    */
    values, computeSlot, tr) {
        this.config = config;
        this.doc = doc;
        this.selection = selection;
        this.values = values;
        this.status = config.statusTemplate.slice();
        this.computeSlot = computeSlot;
        // Fill in the computed state immediately, so that further queries
        // for it made during the update return this state
        if (tr)
            tr._state = this;
        for (let i = 0; i < this.config.dynamicSlots.length; i++)
            ensureAddr(this, i << 1);
        this.computeSlot = null;
    }
    field(field, require = true) {
        let addr = this.config.address[field.id];
        if (addr == null) {
            if (require)
                throw new RangeError("Field is not present in this state");
            return undefined;
        }
        ensureAddr(this, addr);
        return getAddr(this, addr);
    }
    /**
    Create a [transaction](https://codemirror.net/6/docs/ref/#state.Transaction) that updates this
    state. Any number of [transaction specs](https://codemirror.net/6/docs/ref/#state.TransactionSpec)
    can be passed. Unless
    [`sequential`](https://codemirror.net/6/docs/ref/#state.TransactionSpec.sequential) is set, the
    [changes](https://codemirror.net/6/docs/ref/#state.TransactionSpec.changes) (if any) of each spec
    are assumed to start in the _current_ document (not the document
    produced by previous specs), and its
    [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection) and
    [effects](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) are assumed to refer
    to the document created by its _own_ changes. The resulting
    transaction contains the combined effect of all the different
    specs. For [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection), later
    specs take precedence over earlier ones.
    */
    update(...specs) {
        return resolveTransaction(this, specs, true);
    }
    /**
    @internal
    */
    applyTransaction(tr) {
        let conf = this.config, { base, compartments } = conf;
        for (let effect of tr.effects) {
            if (effect.is(Compartment.reconfigure)) {
                if (conf) {
                    compartments = new Map;
                    conf.compartments.forEach((val, key) => compartments.set(key, val));
                    conf = null;
                }
                compartments.set(effect.value.compartment, effect.value.extension);
            }
            else if (effect.is(StateEffect.reconfigure)) {
                conf = null;
                base = effect.value;
            }
            else if (effect.is(StateEffect.appendConfig)) {
                conf = null;
                base = asArray(base).concat(effect.value);
            }
        }
        let startValues;
        if (!conf) {
            conf = Configuration.resolve(base, compartments, this);
            let intermediateState = new EditorState(conf, this.doc, this.selection, conf.dynamicSlots.map(() => null), (state, slot) => slot.reconfigure(state, this), null);
            startValues = intermediateState.values;
        }
        else {
            startValues = tr.startState.values.slice();
        }
        new EditorState(conf, tr.newDoc, tr.newSelection, startValues, (state, slot) => slot.update(state, tr), tr);
    }
    /**
    Create a [transaction spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec) that
    replaces every selection range with the given content.
    */
    replaceSelection(text) {
        if (typeof text == "string")
            text = this.toText(text);
        return this.changeByRange(range => ({ changes: { from: range.from, to: range.to, insert: text },
            range: EditorSelection.cursor(range.from + text.length) }));
    }
    /**
    Create a set of changes and a new selection by running the given
    function for each range in the active selection. The function
    can return an optional set of changes (in the coordinate space
    of the start document), plus an updated range (in the coordinate
    space of the document produced by the call's own changes). This
    method will merge all the changes and ranges into a single
    changeset and selection, and return it as a [transaction
    spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec), which can be passed to
    [`update`](https://codemirror.net/6/docs/ref/#state.EditorState.update).
    */
    changeByRange(f) {
        let sel = this.selection;
        let result1 = f(sel.ranges[0]);
        let changes = this.changes(result1.changes), ranges = [result1.range];
        let effects = asArray(result1.effects);
        for (let i = 1; i < sel.ranges.length; i++) {
            let result = f(sel.ranges[i]);
            let newChanges = this.changes(result.changes), newMapped = newChanges.map(changes);
            for (let j = 0; j < i; j++)
                ranges[j] = ranges[j].map(newMapped);
            let mapBy = changes.mapDesc(newChanges, true);
            ranges.push(result.range.map(mapBy));
            changes = changes.compose(newMapped);
            effects = StateEffect.mapEffects(effects, newMapped).concat(StateEffect.mapEffects(asArray(result.effects), mapBy));
        }
        return {
            changes,
            selection: EditorSelection.create(ranges, sel.mainIndex),
            effects
        };
    }
    /**
    Create a [change set](https://codemirror.net/6/docs/ref/#state.ChangeSet) from the given change
    description, taking the state's document length and line
    separator into account.
    */
    changes(spec = []) {
        if (spec instanceof ChangeSet)
            return spec;
        return ChangeSet.of(spec, this.doc.length, this.facet(EditorState.lineSeparator));
    }
    /**
    Using the state's [line
    separator](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator), create a
    [`Text`](https://codemirror.net/6/docs/ref/#state.Text) instance from the given string.
    */
    toText(string) {
        return Text.of(string.split(this.facet(EditorState.lineSeparator) || DefaultSplit));
    }
    /**
    Return the given range of the document as a string.
    */
    sliceDoc(from = 0, to = this.doc.length) {
        return this.doc.sliceString(from, to, this.lineBreak);
    }
    /**
    Get the value of a state [facet](https://codemirror.net/6/docs/ref/#state.Facet).
    */
    facet(facet) {
        let addr = this.config.address[facet.id];
        if (addr == null)
            return facet.default;
        ensureAddr(this, addr);
        return getAddr(this, addr);
    }
    /**
    Convert this state to a JSON-serializable object. When custom
    fields should be serialized, you can pass them in as an object
    mapping property names (in the resulting object, which should
    not use `doc` or `selection`) to fields.
    */
    toJSON(fields) {
        let result = {
            doc: this.sliceDoc(),
            selection: this.selection.toJSON()
        };
        if (fields)
            for (let prop in fields) {
                let value = fields[prop];
                if (value instanceof StateField && this.config.address[value.id] != null)
                    result[prop] = value.spec.toJSON(this.field(fields[prop]), this);
            }
        return result;
    }
    /**
    Deserialize a state from its JSON representation. When custom
    fields should be deserialized, pass the same object you passed
    to [`toJSON`](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) when serializing as
    third argument.
    */
    static fromJSON(json, config = {}, fields) {
        if (!json || typeof json.doc != "string")
            throw new RangeError("Invalid JSON representation for EditorState");
        let fieldInit = [];
        if (fields)
            for (let prop in fields) {
                if (Object.prototype.hasOwnProperty.call(json, prop)) {
                    let field = fields[prop], value = json[prop];
                    fieldInit.push(field.init(state => field.spec.fromJSON(value, state)));
                }
            }
        return EditorState.create({
            doc: json.doc,
            selection: EditorSelection.fromJSON(json.selection),
            extensions: config.extensions ? fieldInit.concat([config.extensions]) : fieldInit
        });
    }
    /**
    Create a new state. You'll usually only need this when
    initializing an editorupdated states are created by applying
    transactions.
    */
    static create(config = {}) {
        let configuration = Configuration.resolve(config.extensions || [], new Map);
        let doc = config.doc instanceof Text ? config.doc
            : Text.of((config.doc || "").split(configuration.staticFacet(EditorState.lineSeparator) || DefaultSplit));
        let selection = !config.selection ? EditorSelection.single(0)
            : config.selection instanceof EditorSelection ? config.selection
                : EditorSelection.single(config.selection.anchor, config.selection.head);
        checkSelection(selection, doc.length);
        if (!configuration.staticFacet(allowMultipleSelections))
            selection = selection.asSingle();
        return new EditorState(configuration, doc, selection, configuration.dynamicSlots.map(() => null), (state, slot) => slot.create(state), null);
    }
    /**
    The size (in columns) of a tab in the document, determined by
    the [`tabSize`](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize) facet.
    */
    get tabSize() { return this.facet(EditorState.tabSize); }
    /**
    Get the proper [line-break](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator)
    string for this state.
    */
    get lineBreak() { return this.facet(EditorState.lineSeparator) || "\n"; }
    /**
    Returns true when the editor is
    [configured](https://codemirror.net/6/docs/ref/#state.EditorState^readOnly) to be read-only.
    */
    get readOnly() { return this.facet(readOnly); }
    /**
    Look up a translation for the given phrase (via the
    [`phrases`](https://codemirror.net/6/docs/ref/#state.EditorState^phrases) facet), or return the
    original string if no translation is found.
    
    If additional arguments are passed, they will be inserted in
    place of markers like `$1` (for the first value) and `$2`, etc.
    A single `$` is equivalent to `$1`, and `$$` will produce a
    literal dollar sign.
    */
    phrase(phrase, ...insert) {
        for (let map of this.facet(EditorState.phrases))
            if (Object.prototype.hasOwnProperty.call(map, phrase)) {
                phrase = map[phrase];
                break;
            }
        if (insert.length)
            phrase = phrase.replace(/\$(\$|\d*)/g, (m, i) => {
                if (i == "$")
                    return "$";
                let n = +(i || 1);
                return !n || n > insert.length ? m : insert[n - 1];
            });
        return phrase;
    }
    /**
    Find the values for a given language data field, provided by the
    the [`languageData`](https://codemirror.net/6/docs/ref/#state.EditorState^languageData) facet.
    */
    languageDataAt(name, pos, side = -1) {
        let values = [];
        for (let provider of this.facet(languageData)) {
            for (let result of provider(this, pos, side)) {
                if (Object.prototype.hasOwnProperty.call(result, name))
                    values.push(result[name]);
            }
        }
        return values;
    }
    /**
    Return a function that can categorize strings (expected to
    represent a single [grapheme cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak))
    into one of:
    
     - Word (contains an alphanumeric character or a character
       explicitly listed in the local language's `"wordChars"`
       language data, which should be a string)
     - Space (contains only whitespace)
     - Other (anything else)
    */
    charCategorizer(at) {
        return makeCategorizer(this.languageDataAt("wordChars", at).join(""));
    }
    /**
    Find the word at the given position, meaning the range
    containing all [word](https://codemirror.net/6/docs/ref/#state.CharCategory.Word) characters
    around it. If no word characters are adjacent to the position,
    this returns null.
    */
    wordAt(pos) {
        let { text, from, length } = this.doc.lineAt(pos);
        let cat = this.charCategorizer(pos);
        let start = pos - from, end = pos - from;
        while (start > 0) {
            let prev = findClusterBreak(text, start, false);
            if (cat(text.slice(prev, start)) != CharCategory.Word)
                break;
            start = prev;
        }
        while (end < length) {
            let next = findClusterBreak(text, end);
            if (cat(text.slice(end, next)) != CharCategory.Word)
                break;
            end = next;
        }
        return start == end ? null : EditorSelection.range(start + from, end + from);
    }
}
/**
A facet that, when enabled, causes the editor to allow multiple
ranges to be selected. Be careful though, because by default the
editor relies on the native DOM selection, which cannot handle
multiple selections. An extension like
[`drawSelection`](https://codemirror.net/6/docs/ref/#view.drawSelection) can be used to make
secondary selections visible to the user.
*/
EditorState.allowMultipleSelections = allowMultipleSelections;
/**
Configures the tab size to use in this state. The first
(highest-precedence) value of the facet is used. If no value is
given, this defaults to 4.
*/
EditorState.tabSize = /*@__PURE__*/Facet.define({
    combine: values => values.length ? values[0] : 4
});
/**
The line separator to use. By default, any of `"\n"`, `"\r\n"`
and `"\r"` is treated as a separator when splitting lines, and
lines are joined with `"\n"`.

When you configure a value here, only that precise separator
will be used, allowing you to round-trip documents through the
editor without normalizing line separators.
*/
EditorState.lineSeparator = lineSeparator;
/**
This facet controls the value of the
[`readOnly`](https://codemirror.net/6/docs/ref/#state.EditorState.readOnly) getter, which is
consulted by commands and extensions that implement editing
functionality to determine whether they should apply. It
defaults to false, but when its highest-precedence value is
`true`, such functionality disables itself.

Not to be confused with
[`EditorView.editable`](https://codemirror.net/6/docs/ref/#view.EditorView^editable), which
controls whether the editor's DOM is set to be editable (and
thus focusable).
*/
EditorState.readOnly = readOnly;
/**
Registers translation phrases. The
[`phrase`](https://codemirror.net/6/docs/ref/#state.EditorState.phrase) method will look through
all objects registered with this facet to find translations for
its argument.
*/
EditorState.phrases = /*@__PURE__*/Facet.define({
    compare(a, b) {
        let kA = Object.keys(a), kB = Object.keys(b);
        return kA.length == kB.length && kA.every(k => a[k] == b[k]);
    }
});
/**
A facet used to register [language
data](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt) providers.
*/
EditorState.languageData = languageData;
/**
Facet used to register change filters, which are called for each
transaction (unless explicitly
[disabled](https://codemirror.net/6/docs/ref/#state.TransactionSpec.filter)), and can suppress
part of the transaction's changes.

Such a function can return `true` to indicate that it doesn't
want to do anything, `false` to completely stop the changes in
the transaction, or a set of ranges in which changes should be
suppressed. Such ranges are represented as an array of numbers,
with each pair of two numbers indicating the start and end of a
range. So for example `[10, 20, 100, 110]` suppresses changes
between 10 and 20, and between 100 and 110.
*/
EditorState.changeFilter = changeFilter;
/**
Facet used to register a hook that gets a chance to update or
replace transaction specs before they are applied. This will
only be applied for transactions that don't have
[`filter`](https://codemirror.net/6/docs/ref/#state.TransactionSpec.filter) set to `false`. You
can either return a single transaction spec (possibly the input
transaction), or an array of specs (which will be combined in
the same way as the arguments to
[`EditorState.update`](https://codemirror.net/6/docs/ref/#state.EditorState.update)).

When possible, it is recommended to avoid accessing
[`Transaction.state`](https://codemirror.net/6/docs/ref/#state.Transaction.state) in a filter,
since it will force creation of a state that will then be
discarded again, if the transaction is actually filtered.

(This functionality should be used with care. Indiscriminately
modifying transaction is likely to break something or degrade
the user experience.)
*/
EditorState.transactionFilter = transactionFilter;
/**
This is a more limited form of
[`transactionFilter`](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter),
which can only add
[annotations](https://codemirror.net/6/docs/ref/#state.TransactionSpec.annotations) and
[effects](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects). _But_, this type
of filter runs even if the transaction has disabled regular
[filtering](https://codemirror.net/6/docs/ref/#state.TransactionSpec.filter), making it suitable
for effects that don't need to touch the changes or selection,
but do want to process every transaction.

Extenders run _after_ filters, when both are present.
*/
EditorState.transactionExtender = transactionExtender;
Compartment.reconfigure = /*@__PURE__*/StateEffect.define();

/**
Utility function for combining behaviors to fill in a config
object from an array of provided configs. `defaults` should hold
default values for all optional fields in `Config`.

The function will, by default, error
when a field gets two values that aren't `===`-equal, but you can
provide combine functions per field to do something else.
*/
function combineConfig(configs, defaults, // Should hold only the optional properties of Config, but I haven't managed to express that
combine = {}) {
    let result = {};
    for (let config of configs)
        for (let key of Object.keys(config)) {
            let value = config[key], current = result[key];
            if (current === undefined)
                result[key] = value;
            else if (current === value || value === undefined) ; // No conflict
            else if (Object.hasOwnProperty.call(combine, key))
                result[key] = combine[key](current, value);
            else
                throw new Error("Config merge conflict for field " + key);
        }
    for (let key in defaults)
        if (result[key] === undefined)
            result[key] = defaults[key];
    return result;
}

/**
Each range is associated with a value, which must inherit from
this class.
*/
class RangeValue {
    /**
    Compare this value with another value. Used when comparing
    rangesets. The default implementation compares by identity.
    Unless you are only creating a fixed number of unique instances
    of your value type, it is a good idea to implement this
    properly.
    */
    eq(other) { return this == other; }
    /**
    Create a [range](https://codemirror.net/6/docs/ref/#state.Range) with this value.
    */
    range(from, to = from) { return Range.create(from, to, this); }
}
RangeValue.prototype.startSide = RangeValue.prototype.endSide = 0;
RangeValue.prototype.point = false;
RangeValue.prototype.mapMode = MapMode.TrackDel;
/**
A range associates a value with a range of positions.
*/
class Range {
    constructor(
    /**
    The range's start position.
    */
    from, 
    /**
    Its end position.
    */
    to, 
    /**
    The value associated with this range.
    */
    value) {
        this.from = from;
        this.to = to;
        this.value = value;
    }
    /**
    @internal
    */
    static create(from, to, value) {
        return new Range(from, to, value);
    }
}
function cmpRange(a, b) {
    return a.from - b.from || a.value.startSide - b.value.startSide;
}
class Chunk {
    constructor(from, to, value, 
    // Chunks are marked with the largest point that occurs
    // in them (or -1 for no points), so that scans that are
    // only interested in points (such as the
    // heightmap-related logic) can skip range-only chunks.
    maxPoint) {
        this.from = from;
        this.to = to;
        this.value = value;
        this.maxPoint = maxPoint;
    }
    get length() { return this.to[this.to.length - 1]; }
    // Find the index of the given position and side. Use the ranges'
    // `from` pos when `end == false`, `to` when `end == true`.
    findIndex(pos, side, end, startAt = 0) {
        let arr = end ? this.to : this.from;
        for (let lo = startAt, hi = arr.length;;) {
            if (lo == hi)
                return lo;
            let mid = (lo + hi) >> 1;
            let diff = arr[mid] - pos || (end ? this.value[mid].endSide : this.value[mid].startSide) - side;
            if (mid == lo)
                return diff >= 0 ? lo : hi;
            if (diff >= 0)
                hi = mid;
            else
                lo = mid + 1;
        }
    }
    between(offset, from, to, f) {
        for (let i = this.findIndex(from, -1000000000 /* C.Far */, true), e = this.findIndex(to, 1000000000 /* C.Far */, false, i); i < e; i++)
            if (f(this.from[i] + offset, this.to[i] + offset, this.value[i]) === false)
                return false;
    }
    map(offset, changes) {
        let value = [], from = [], to = [], newPos = -1, maxPoint = -1;
        for (let i = 0; i < this.value.length; i++) {
            let val = this.value[i], curFrom = this.from[i] + offset, curTo = this.to[i] + offset, newFrom, newTo;
            if (curFrom == curTo) {
                let mapped = changes.mapPos(curFrom, val.startSide, val.mapMode);
                if (mapped == null)
                    continue;
                newFrom = newTo = mapped;
                if (val.startSide != val.endSide) {
                    newTo = changes.mapPos(curFrom, val.endSide);
                    if (newTo < newFrom)
                        continue;
                }
            }
            else {
                newFrom = changes.mapPos(curFrom, val.startSide);
                newTo = changes.mapPos(curTo, val.endSide);
                if (newFrom > newTo || newFrom == newTo && val.startSide > 0 && val.endSide <= 0)
                    continue;
            }
            if ((newTo - newFrom || val.endSide - val.startSide) < 0)
                continue;
            if (newPos < 0)
                newPos = newFrom;
            if (val.point)
                maxPoint = Math.max(maxPoint, newTo - newFrom);
            value.push(val);
            from.push(newFrom - newPos);
            to.push(newTo - newPos);
        }
        return { mapped: value.length ? new Chunk(from, to, value, maxPoint) : null, pos: newPos };
    }
}
/**
A range set stores a collection of [ranges](https://codemirror.net/6/docs/ref/#state.Range) in a
way that makes them efficient to [map](https://codemirror.net/6/docs/ref/#state.RangeSet.map) and
[update](https://codemirror.net/6/docs/ref/#state.RangeSet.update). This is an immutable data
structure.
*/
class RangeSet {
    constructor(
    /**
    @internal
    */
    chunkPos, 
    /**
    @internal
    */
    chunk, 
    /**
    @internal
    */
    nextLayer, 
    /**
    @internal
    */
    maxPoint) {
        this.chunkPos = chunkPos;
        this.chunk = chunk;
        this.nextLayer = nextLayer;
        this.maxPoint = maxPoint;
    }
    /**
    @internal
    */
    static create(chunkPos, chunk, nextLayer, maxPoint) {
        return new RangeSet(chunkPos, chunk, nextLayer, maxPoint);
    }
    /**
    @internal
    */
    get length() {
        let last = this.chunk.length - 1;
        return last < 0 ? 0 : Math.max(this.chunkEnd(last), this.nextLayer.length);
    }
    /**
    The number of ranges in the set.
    */
    get size() {
        if (this.isEmpty)
            return 0;
        let size = this.nextLayer.size;
        for (let chunk of this.chunk)
            size += chunk.value.length;
        return size;
    }
    /**
    @internal
    */
    chunkEnd(index) {
        return this.chunkPos[index] + this.chunk[index].length;
    }
    /**
    Update the range set, optionally adding new ranges or filtering
    out existing ones.
    
    (Note: The type parameter is just there as a kludge to work
    around TypeScript variance issues that prevented `RangeSet<X>`
    from being a subtype of `RangeSet<Y>` when `X` is a subtype of
    `Y`.)
    */
    update(updateSpec) {
        let { add = [], sort = false, filterFrom = 0, filterTo = this.length } = updateSpec;
        let filter = updateSpec.filter;
        if (add.length == 0 && !filter)
            return this;
        if (sort)
            add = add.slice().sort(cmpRange);
        if (this.isEmpty)
            return add.length ? RangeSet.of(add) : this;
        let cur = new LayerCursor(this, null, -1).goto(0), i = 0, spill = [];
        let builder = new RangeSetBuilder();
        while (cur.value || i < add.length) {
            if (i < add.length && (cur.from - add[i].from || cur.startSide - add[i].value.startSide) >= 0) {
                let range = add[i++];
                if (!builder.addInner(range.from, range.to, range.value))
                    spill.push(range);
            }
            else if (cur.rangeIndex == 1 && cur.chunkIndex < this.chunk.length &&
                (i == add.length || this.chunkEnd(cur.chunkIndex) < add[i].from) &&
                (!filter || filterFrom > this.chunkEnd(cur.chunkIndex) || filterTo < this.chunkPos[cur.chunkIndex]) &&
                builder.addChunk(this.chunkPos[cur.chunkIndex], this.chunk[cur.chunkIndex])) {
                cur.nextChunk();
            }
            else {
                if (!filter || filterFrom > cur.to || filterTo < cur.from || filter(cur.from, cur.to, cur.value)) {
                    if (!builder.addInner(cur.from, cur.to, cur.value))
                        spill.push(Range.create(cur.from, cur.to, cur.value));
                }
                cur.next();
            }
        }
        return builder.finishInner(this.nextLayer.isEmpty && !spill.length ? RangeSet.empty
            : this.nextLayer.update({ add: spill, filter, filterFrom, filterTo }));
    }
    /**
    Map this range set through a set of changes, return the new set.
    */
    map(changes) {
        if (changes.empty || this.isEmpty)
            return this;
        let chunks = [], chunkPos = [], maxPoint = -1;
        for (let i = 0; i < this.chunk.length; i++) {
            let start = this.chunkPos[i], chunk = this.chunk[i];
            let touch = changes.touchesRange(start, start + chunk.length);
            if (touch === false) {
                maxPoint = Math.max(maxPoint, chunk.maxPoint);
                chunks.push(chunk);
                chunkPos.push(changes.mapPos(start));
            }
            else if (touch === true) {
                let { mapped, pos } = chunk.map(start, changes);
                if (mapped) {
                    maxPoint = Math.max(maxPoint, mapped.maxPoint);
                    chunks.push(mapped);
                    chunkPos.push(pos);
                }
            }
        }
        let next = this.nextLayer.map(changes);
        return chunks.length == 0 ? next : new RangeSet(chunkPos, chunks, next || RangeSet.empty, maxPoint);
    }
    /**
    Iterate over the ranges that touch the region `from` to `to`,
    calling `f` for each. There is no guarantee that the ranges will
    be reported in any specific order. When the callback returns
    `false`, iteration stops.
    */
    between(from, to, f) {
        if (this.isEmpty)
            return;
        for (let i = 0; i < this.chunk.length; i++) {
            let start = this.chunkPos[i], chunk = this.chunk[i];
            if (to >= start && from <= start + chunk.length &&
                chunk.between(start, from - start, to - start, f) === false)
                return;
        }
        this.nextLayer.between(from, to, f);
    }
    /**
    Iterate over the ranges in this set, in order, including all
    ranges that end at or after `from`.
    */
    iter(from = 0) {
        return HeapCursor.from([this]).goto(from);
    }
    /**
    @internal
    */
    get isEmpty() { return this.nextLayer == this; }
    /**
    Iterate over the ranges in a collection of sets, in order,
    starting from `from`.
    */
    static iter(sets, from = 0) {
        return HeapCursor.from(sets).goto(from);
    }
    /**
    Iterate over two groups of sets, calling methods on `comparator`
    to notify it of possible differences.
    */
    static compare(oldSets, newSets, 
    /**
    This indicates how the underlying data changed between these
    ranges, and is needed to synchronize the iteration. `from` and
    `to` are coordinates in the _new_ space, after these changes.
    */
    textDiff, comparator, 
    /**
    Can be used to ignore all non-point ranges, and points below
    the given size. When -1, all ranges are compared.
    */
    minPointSize = -1) {
        let a = oldSets.filter(set => set.maxPoint > 0 || !set.isEmpty && set.maxPoint >= minPointSize);
        let b = newSets.filter(set => set.maxPoint > 0 || !set.isEmpty && set.maxPoint >= minPointSize);
        let sharedChunks = findSharedChunks(a, b, textDiff);
        let sideA = new SpanCursor(a, sharedChunks, minPointSize);
        let sideB = new SpanCursor(b, sharedChunks, minPointSize);
        textDiff.iterGaps((fromA, fromB, length) => compare(sideA, fromA, sideB, fromB, length, comparator));
        if (textDiff.empty && textDiff.length == 0)
            compare(sideA, 0, sideB, 0, 0, comparator);
    }
    /**
    Compare the contents of two groups of range sets, returning true
    if they are equivalent in the given range.
    */
    static eq(oldSets, newSets, from = 0, to) {
        if (to == null)
            to = 1000000000 /* C.Far */;
        let a = oldSets.filter(set => !set.isEmpty && newSets.indexOf(set) < 0);
        let b = newSets.filter(set => !set.isEmpty && oldSets.indexOf(set) < 0);
        if (a.length != b.length)
            return false;
        if (!a.length)
            return true;
        let sharedChunks = findSharedChunks(a, b);
        let sideA = new SpanCursor(a, sharedChunks, 0).goto(from), sideB = new SpanCursor(b, sharedChunks, 0).goto(from);
        for (;;) {
            if (sideA.to != sideB.to ||
                !sameValues(sideA.active, sideB.active) ||
                sideA.point && (!sideB.point || !sideA.point.eq(sideB.point)))
                return false;
            if (sideA.to > to)
                return true;
            sideA.next();
            sideB.next();
        }
    }
    /**
    Iterate over a group of range sets at the same time, notifying
    the iterator about the ranges covering every given piece of
    content. Returns the open count (see
    [`SpanIterator.span`](https://codemirror.net/6/docs/ref/#state.SpanIterator.span)) at the end
    of the iteration.
    */
    static spans(sets, from, to, iterator, 
    /**
    When given and greater than -1, only points of at least this
    size are taken into account.
    */
    minPointSize = -1) {
        let cursor = new SpanCursor(sets, null, minPointSize).goto(from), pos = from;
        let open = cursor.openStart;
        for (;;) {
            let curTo = Math.min(cursor.to, to);
            if (cursor.point) {
                iterator.point(pos, curTo, cursor.point, cursor.activeForPoint(cursor.to), open, cursor.pointRank);
                open = cursor.openEnd(curTo) + (cursor.to > curTo ? 1 : 0);
            }
            else if (curTo > pos) {
                iterator.span(pos, curTo, cursor.active, open);
                open = cursor.openEnd(curTo);
            }
            if (cursor.to > to)
                break;
            pos = cursor.to;
            cursor.next();
        }
        return open;
    }
    /**
    Create a range set for the given range or array of ranges. By
    default, this expects the ranges to be _sorted_ (by start
    position and, if two start at the same position,
    `value.startSide`). You can pass `true` as second argument to
    cause the method to sort them.
    */
    static of(ranges, sort = false) {
        let build = new RangeSetBuilder();
        for (let range of ranges instanceof Range ? [ranges] : sort ? lazySort(ranges) : ranges)
            build.add(range.from, range.to, range.value);
        return build.finish();
    }
}
/**
The empty set of ranges.
*/
RangeSet.empty = /*@__PURE__*/new RangeSet([], [], null, -1);
function lazySort(ranges) {
    if (ranges.length > 1)
        for (let prev = ranges[0], i = 1; i < ranges.length; i++) {
            let cur = ranges[i];
            if (cmpRange(prev, cur) > 0)
                return ranges.slice().sort(cmpRange);
            prev = cur;
        }
    return ranges;
}
RangeSet.empty.nextLayer = RangeSet.empty;
/**
A range set builder is a data structure that helps build up a
[range set](https://codemirror.net/6/docs/ref/#state.RangeSet) directly, without first allocating
an array of [`Range`](https://codemirror.net/6/docs/ref/#state.Range) objects.
*/
class RangeSetBuilder {
    /**
    Create an empty builder.
    */
    constructor() {
        this.chunks = [];
        this.chunkPos = [];
        this.chunkStart = -1;
        this.last = null;
        this.lastFrom = -1000000000 /* C.Far */;
        this.lastTo = -1000000000 /* C.Far */;
        this.from = [];
        this.to = [];
        this.value = [];
        this.maxPoint = -1;
        this.setMaxPoint = -1;
        this.nextLayer = null;
    }
    finishChunk(newArrays) {
        this.chunks.push(new Chunk(this.from, this.to, this.value, this.maxPoint));
        this.chunkPos.push(this.chunkStart);
        this.chunkStart = -1;
        this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint);
        this.maxPoint = -1;
        if (newArrays) {
            this.from = [];
            this.to = [];
            this.value = [];
        }
    }
    /**
    Add a range. Ranges should be added in sorted (by `from` and
    `value.startSide`) order.
    */
    add(from, to, value) {
        if (!this.addInner(from, to, value))
            (this.nextLayer || (this.nextLayer = new RangeSetBuilder)).add(from, to, value);
    }
    /**
    @internal
    */
    addInner(from, to, value) {
        let diff = from - this.lastTo || value.startSide - this.last.endSide;
        if (diff <= 0 && (from - this.lastFrom || value.startSide - this.last.startSide) < 0)
            throw new Error("Ranges must be added sorted by `from` position and `startSide`");
        if (diff < 0)
            return false;
        if (this.from.length == 250 /* C.ChunkSize */)
            this.finishChunk(true);
        if (this.chunkStart < 0)
            this.chunkStart = from;
        this.from.push(from - this.chunkStart);
        this.to.push(to - this.chunkStart);
        this.last = value;
        this.lastFrom = from;
        this.lastTo = to;
        this.value.push(value);
        if (value.point)
            this.maxPoint = Math.max(this.maxPoint, to - from);
        return true;
    }
    /**
    @internal
    */
    addChunk(from, chunk) {
        if ((from - this.lastTo || chunk.value[0].startSide - this.last.endSide) < 0)
            return false;
        if (this.from.length)
            this.finishChunk(true);
        this.setMaxPoint = Math.max(this.setMaxPoint, chunk.maxPoint);
        this.chunks.push(chunk);
        this.chunkPos.push(from);
        let last = chunk.value.length - 1;
        this.last = chunk.value[last];
        this.lastFrom = chunk.from[last] + from;
        this.lastTo = chunk.to[last] + from;
        return true;
    }
    /**
    Finish the range set. Returns the new set. The builder can't be
    used anymore after this has been called.
    */
    finish() { return this.finishInner(RangeSet.empty); }
    /**
    @internal
    */
    finishInner(next) {
        if (this.from.length)
            this.finishChunk(false);
        if (this.chunks.length == 0)
            return next;
        let result = RangeSet.create(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(next) : next, this.setMaxPoint);
        this.from = null; // Make sure further `add` calls produce errors
        return result;
    }
}
function findSharedChunks(a, b, textDiff) {
    let inA = new Map();
    for (let set of a)
        for (let i = 0; i < set.chunk.length; i++)
            if (set.chunk[i].maxPoint <= 0)
                inA.set(set.chunk[i], set.chunkPos[i]);
    let shared = new Set();
    for (let set of b)
        for (let i = 0; i < set.chunk.length; i++) {
            let known = inA.get(set.chunk[i]);
            if (known != null && (textDiff ? textDiff.mapPos(known) : known) == set.chunkPos[i] &&
                !(textDiff === null || textDiff === void 0 ? void 0 : textDiff.touchesRange(known, known + set.chunk[i].length)))
                shared.add(set.chunk[i]);
        }
    return shared;
}
class LayerCursor {
    constructor(layer, skip, minPoint, rank = 0) {
        this.layer = layer;
        this.skip = skip;
        this.minPoint = minPoint;
        this.rank = rank;
    }
    get startSide() { return this.value ? this.value.startSide : 0; }
    get endSide() { return this.value ? this.value.endSide : 0; }
    goto(pos, side = -1000000000 /* C.Far */) {
        this.chunkIndex = this.rangeIndex = 0;
        this.gotoInner(pos, side, false);
        return this;
    }
    gotoInner(pos, side, forward) {
        while (this.chunkIndex < this.layer.chunk.length) {
            let next = this.layer.chunk[this.chunkIndex];
            if (!(this.skip && this.skip.has(next) ||
                this.layer.chunkEnd(this.chunkIndex) < pos ||
                next.maxPoint < this.minPoint))
                break;
            this.chunkIndex++;
            forward = false;
        }
        if (this.chunkIndex < this.layer.chunk.length) {
            let rangeIndex = this.layer.chunk[this.chunkIndex].findIndex(pos - this.layer.chunkPos[this.chunkIndex], side, true);
            if (!forward || this.rangeIndex < rangeIndex)
                this.setRangeIndex(rangeIndex);
        }
        this.next();
    }
    forward(pos, side) {
        if ((this.to - pos || this.endSide - side) < 0)
            this.gotoInner(pos, side, true);
    }
    next() {
        for (;;) {
            if (this.chunkIndex == this.layer.chunk.length) {
                this.from = this.to = 1000000000 /* C.Far */;
                this.value = null;
                break;
            }
            else {
                let chunkPos = this.layer.chunkPos[this.chunkIndex], chunk = this.layer.chunk[this.chunkIndex];
                let from = chunkPos + chunk.from[this.rangeIndex];
                this.from = from;
                this.to = chunkPos + chunk.to[this.rangeIndex];
                this.value = chunk.value[this.rangeIndex];
                this.setRangeIndex(this.rangeIndex + 1);
                if (this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint)
                    break;
            }
        }
    }
    setRangeIndex(index) {
        if (index == this.layer.chunk[this.chunkIndex].value.length) {
            this.chunkIndex++;
            if (this.skip) {
                while (this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]))
                    this.chunkIndex++;
            }
            this.rangeIndex = 0;
        }
        else {
            this.rangeIndex = index;
        }
    }
    nextChunk() {
        this.chunkIndex++;
        this.rangeIndex = 0;
        this.next();
    }
    compare(other) {
        return this.from - other.from || this.startSide - other.startSide || this.rank - other.rank ||
            this.to - other.to || this.endSide - other.endSide;
    }
}
class HeapCursor {
    constructor(heap) {
        this.heap = heap;
    }
    static from(sets, skip = null, minPoint = -1) {
        let heap = [];
        for (let i = 0; i < sets.length; i++) {
            for (let cur = sets[i]; !cur.isEmpty; cur = cur.nextLayer) {
                if (cur.maxPoint >= minPoint)
                    heap.push(new LayerCursor(cur, skip, minPoint, i));
            }
        }
        return heap.length == 1 ? heap[0] : new HeapCursor(heap);
    }
    get startSide() { return this.value ? this.value.startSide : 0; }
    goto(pos, side = -1000000000 /* C.Far */) {
        for (let cur of this.heap)
            cur.goto(pos, side);
        for (let i = this.heap.length >> 1; i >= 0; i--)
            heapBubble(this.heap, i);
        this.next();
        return this;
    }
    forward(pos, side) {
        for (let cur of this.heap)
            cur.forward(pos, side);
        for (let i = this.heap.length >> 1; i >= 0; i--)
            heapBubble(this.heap, i);
        if ((this.to - pos || this.value.endSide - side) < 0)
            this.next();
    }
    next() {
        if (this.heap.length == 0) {
            this.from = this.to = 1000000000 /* C.Far */;
            this.value = null;
            this.rank = -1;
        }
        else {
            let top = this.heap[0];
            this.from = top.from;
            this.to = top.to;
            this.value = top.value;
            this.rank = top.rank;
            if (top.value)
                top.next();
            heapBubble(this.heap, 0);
        }
    }
}
function heapBubble(heap, index) {
    for (let cur = heap[index];;) {
        let childIndex = (index << 1) + 1;
        if (childIndex >= heap.length)
            break;
        let child = heap[childIndex];
        if (childIndex + 1 < heap.length && child.compare(heap[childIndex + 1]) >= 0) {
            child = heap[childIndex + 1];
            childIndex++;
        }
        if (cur.compare(child) < 0)
            break;
        heap[childIndex] = cur;
        heap[index] = child;
        index = childIndex;
    }
}
class SpanCursor {
    constructor(sets, skip, minPoint) {
        this.minPoint = minPoint;
        this.active = [];
        this.activeTo = [];
        this.activeRank = [];
        this.minActive = -1;
        // A currently active point range, if any
        this.point = null;
        this.pointFrom = 0;
        this.pointRank = 0;
        this.to = -1000000000 /* C.Far */;
        this.endSide = 0;
        this.openStart = -1;
        this.cursor = HeapCursor.from(sets, skip, minPoint);
    }
    goto(pos, side = -1000000000 /* C.Far */) {
        this.cursor.goto(pos, side);
        this.active.length = this.activeTo.length = this.activeRank.length = 0;
        this.minActive = -1;
        this.to = pos;
        this.endSide = side;
        this.openStart = -1;
        this.next();
        return this;
    }
    forward(pos, side) {
        while (this.minActive > -1 && (this.activeTo[this.minActive] - pos || this.active[this.minActive].endSide - side) < 0)
            this.removeActive(this.minActive);
        this.cursor.forward(pos, side);
    }
    removeActive(index) {
        remove(this.active, index);
        remove(this.activeTo, index);
        remove(this.activeRank, index);
        this.minActive = findMinIndex(this.active, this.activeTo);
    }
    addActive(trackOpen) {
        let i = 0, { value, to, rank } = this.cursor;
        while (i < this.activeRank.length && this.activeRank[i] <= rank)
            i++;
        insert(this.active, i, value);
        insert(this.activeTo, i, to);
        insert(this.activeRank, i, rank);
        if (trackOpen)
            insert(trackOpen, i, this.cursor.from);
        this.minActive = findMinIndex(this.active, this.activeTo);
    }
    // After calling this, if `this.point` != null, the next range is a
    // point. Otherwise, it's a regular range, covered by `this.active`.
    next() {
        let from = this.to, wasPoint = this.point;
        this.point = null;
        let trackOpen = this.openStart < 0 ? [] : null, trackExtra = 0;
        for (;;) {
            let a = this.minActive;
            if (a > -1 && (this.activeTo[a] - this.cursor.from || this.active[a].endSide - this.cursor.startSide) < 0) {
                if (this.activeTo[a] > from) {
                    this.to = this.activeTo[a];
                    this.endSide = this.active[a].endSide;
                    break;
                }
                this.removeActive(a);
                if (trackOpen)
                    remove(trackOpen, a);
            }
            else if (!this.cursor.value) {
                this.to = this.endSide = 1000000000 /* C.Far */;
                break;
            }
            else if (this.cursor.from > from) {
                this.to = this.cursor.from;
                this.endSide = this.cursor.startSide;
                break;
            }
            else {
                let nextVal = this.cursor.value;
                if (!nextVal.point) { // Opening a range
                    this.addActive(trackOpen);
                    if (this.cursor.from < from && this.cursor.to > from)
                        trackExtra++;
                    this.cursor.next();
                }
                else if (wasPoint && this.cursor.to == this.to && this.cursor.from < this.cursor.to) {
                    // Ignore any non-empty points that end precisely at the end of the prev point
                    this.cursor.next();
                }
                else { // New point
                    this.point = nextVal;
                    this.pointFrom = this.cursor.from;
                    this.pointRank = this.cursor.rank;
                    this.to = this.cursor.to;
                    this.endSide = nextVal.endSide;
                    if (this.cursor.from < from)
                        trackExtra = 1;
                    this.cursor.next();
                    this.forward(this.to, this.endSide);
                    break;
                }
            }
        }
        if (trackOpen) {
            let openStart = 0;
            while (openStart < trackOpen.length && trackOpen[openStart] < from)
                openStart++;
            this.openStart = openStart + trackExtra;
        }
    }
    activeForPoint(to) {
        if (!this.active.length)
            return this.active;
        let active = [];
        for (let i = this.active.length - 1; i >= 0; i--) {
            if (this.activeRank[i] < this.pointRank)
                break;
            if (this.activeTo[i] > to || this.activeTo[i] == to && this.active[i].endSide >= this.point.endSide)
                active.push(this.active[i]);
        }
        return active.reverse();
    }
    openEnd(to) {
        let open = 0;
        for (let i = this.activeTo.length - 1; i >= 0 && this.activeTo[i] > to; i--)
            open++;
        return open;
    }
}
function compare(a, startA, b, startB, length, comparator) {
    a.goto(startA);
    b.goto(startB);
    let endB = startB + length;
    let pos = startB, dPos = startB - startA;
    for (;;) {
        let diff = (a.to + dPos) - b.to || a.endSide - b.endSide;
        let end = diff < 0 ? a.to + dPos : b.to, clipEnd = Math.min(end, endB);
        if (a.point || b.point) {
            if (!(a.point && b.point && (a.point == b.point || a.point.eq(b.point)) &&
                sameValues(a.activeForPoint(a.to + dPos), b.activeForPoint(b.to))))
                comparator.comparePoint(pos, clipEnd, a.point, b.point);
        }
        else {
            if (clipEnd > pos && !sameValues(a.active, b.active))
                comparator.compareRange(pos, clipEnd, a.active, b.active);
        }
        if (end > endB)
            break;
        pos = end;
        if (diff <= 0)
            a.next();
        if (diff >= 0)
            b.next();
    }
}
function sameValues(a, b) {
    if (a.length != b.length)
        return false;
    for (let i = 0; i < a.length; i++)
        if (a[i] != b[i] && !a[i].eq(b[i]))
            return false;
    return true;
}
function remove(array, index) {
    for (let i = index, e = array.length - 1; i < e; i++)
        array[i] = array[i + 1];
    array.pop();
}
function insert(array, index, value) {
    for (let i = array.length - 1; i >= index; i--)
        array[i + 1] = array[i];
    array[index] = value;
}
function findMinIndex(value, array) {
    let found = -1, foundPos = 1000000000 /* C.Far */;
    for (let i = 0; i < array.length; i++)
        if ((array[i] - foundPos || value[i].endSide - value[found].endSide) < 0) {
            found = i;
            foundPos = array[i];
        }
    return found;
}

/**
Count the column position at the given offset into the string,
taking extending characters and tab size into account.
*/
function countColumn(string, tabSize, to = string.length) {
    let n = 0;
    for (let i = 0; i < to;) {
        if (string.charCodeAt(i) == 9) {
            n += tabSize - (n % tabSize);
            i++;
        }
        else {
            n++;
            i = findClusterBreak(string, i);
        }
    }
    return n;
}
/**
Find the offset that corresponds to the given column position in a
string, taking extending characters and tab size into account. By
default, the string length is returned when it is too short to
reach the column. Pass `strict` true to make it return -1 in that
situation.
*/
function findColumn(string, col, tabSize, strict) {
    for (let i = 0, n = 0;;) {
        if (n >= col)
            return i;
        if (i == string.length)
            break;
        n += string.charCodeAt(i) == 9 ? tabSize - (n % tabSize) : 1;
        i = findClusterBreak(string, i);
    }
    return strict === true ? -1 : string.length;
}




/***/ }),

/***/ 4512:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "p": () => (/* binding */ Decoration),
  "Nm": () => (/* binding */ Direction),
  "tk": () => (/* binding */ EditorView),
  "lg": () => (/* binding */ ViewPlugin),
  "l9": () => (/* binding */ WidgetType),
  "$f": () => (/* binding */ keymap),
  "Eu": () => (/* binding */ lineNumbers),
  "OO": () => (/* binding */ logException)
});

// UNUSED EXPORTS: BidiSpan, BlockInfo, BlockType, GutterMarker, MatchDecorator, ViewUpdate, __test, closeHoverTooltips, crosshairCursor, drawSelection, dropCursor, getPanel, getTooltip, gutter, gutterLineClass, gutters, hasHoverTooltips, highlightActiveLine, highlightActiveLineGutter, highlightSpecialChars, hoverTooltip, lineNumberMarkers, panels, placeholder, rectangularSelection, repositionTooltips, runScopeHandlers, scrollPastEnd, showPanel, showTooltip, tooltips

// EXTERNAL MODULE: ./node_modules/@codemirror/state/dist/index.js
var state_dist = __webpack_require__(802);
// EXTERNAL MODULE: ./node_modules/style-mod/src/style-mod.js
var style_mod = __webpack_require__(1609);
;// CONCATENATED MODULE: ./node_modules/w3c-keyname/index.es.js
var base = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
}

var shift = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: "\""
}

var chrome = typeof navigator != "undefined" && /Chrome\/(\d+)/.exec(navigator.userAgent)
var gecko = typeof navigator != "undefined" && /Gecko\/\d+/.test(navigator.userAgent)
var mac = typeof navigator != "undefined" && /Mac/.test(navigator.platform)
var ie = typeof navigator != "undefined" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent)
var brokenModifierNames = mac || chrome && +chrome[1] < 57

// Fill in the digit keys
for (var i = 0; i < 10; i++) base[48 + i] = base[96 + i] = String(i)

// The function keys
for (var i = 1; i <= 24; i++) base[i + 111] = "F" + i

// And the alphabetic keys
for (var i = 65; i <= 90; i++) {
  base[i] = String.fromCharCode(i + 32)
  shift[i] = String.fromCharCode(i)
}

// For each code that doesn't have a shift-equivalent, copy the base name
for (var code in base) if (!shift.hasOwnProperty(code)) shift[code] = base[code]

function keyName(event) {
  var ignoreKey = brokenModifierNames && (event.ctrlKey || event.altKey || event.metaKey) ||
    ie && event.shiftKey && event.key && event.key.length == 1 ||
    event.key == "Unidentified"
  var name = (!ignoreKey && event.key) ||
    (event.shiftKey ? shift : base)[event.keyCode] ||
    event.key || "Unidentified"
  // Edge sometimes produces wrong names (Issue #3)
  if (name == "Esc") name = "Escape"
  if (name == "Del") name = "Delete"
  // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/8860571/
  if (name == "Left") name = "ArrowLeft"
  if (name == "Up") name = "ArrowUp"
  if (name == "Right") name = "ArrowRight"
  if (name == "Down") name = "ArrowDown"
  return name
}

;// CONCATENATED MODULE: ./node_modules/@codemirror/view/dist/index.js




function getSelection(root) {
    let target;
    // Browsers differ on whether shadow roots have a getSelection
    // method. If it exists, use that, otherwise, call it on the
    // document.
    if (root.nodeType == 11) { // Shadow root
        target = root.getSelection ? root : root.ownerDocument;
    }
    else {
        target = root;
    }
    return target.getSelection();
}
function contains(dom, node) {
    return node ? dom == node || dom.contains(node.nodeType != 1 ? node.parentNode : node) : false;
}
function deepActiveElement(doc) {
    let elt = doc.activeElement;
    while (elt && elt.shadowRoot)
        elt = elt.shadowRoot.activeElement;
    return elt;
}
function hasSelection(dom, selection) {
    if (!selection.anchorNode)
        return false;
    try {
        // Firefox will raise 'permission denied' errors when accessing
        // properties of `sel.anchorNode` when it's in a generated CSS
        // element.
        return contains(dom, selection.anchorNode);
    }
    catch (_) {
        return false;
    }
}
function clientRectsFor(dom) {
    if (dom.nodeType == 3)
        return textRange(dom, 0, dom.nodeValue.length).getClientRects();
    else if (dom.nodeType == 1)
        return dom.getClientRects();
    else
        return [];
}
// Scans forward and backward through DOM positions equivalent to the
// given one to see if the two are in the same place (i.e. after a
// text node vs at the end of that text node)
function isEquivalentPosition(node, off, targetNode, targetOff) {
    return targetNode ? (scanFor(node, off, targetNode, targetOff, -1) ||
        scanFor(node, off, targetNode, targetOff, 1)) : false;
}
function domIndex(node) {
    for (var index = 0;; index++) {
        node = node.previousSibling;
        if (!node)
            return index;
    }
}
function scanFor(node, off, targetNode, targetOff, dir) {
    for (;;) {
        if (node == targetNode && off == targetOff)
            return true;
        if (off == (dir < 0 ? 0 : maxOffset(node))) {
            if (node.nodeName == "DIV")
                return false;
            let parent = node.parentNode;
            if (!parent || parent.nodeType != 1)
                return false;
            off = domIndex(node) + (dir < 0 ? 0 : 1);
            node = parent;
        }
        else if (node.nodeType == 1) {
            node = node.childNodes[off + (dir < 0 ? -1 : 0)];
            if (node.nodeType == 1 && node.contentEditable == "false")
                return false;
            off = dir < 0 ? maxOffset(node) : 0;
        }
        else {
            return false;
        }
    }
}
function maxOffset(node) {
    return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;
}
const Rect0 = { left: 0, right: 0, top: 0, bottom: 0 };
function flattenRect(rect, left) {
    let x = left ? rect.left : rect.right;
    return { left: x, right: x, top: rect.top, bottom: rect.bottom };
}
function windowRect(win) {
    return { left: 0, right: win.innerWidth,
        top: 0, bottom: win.innerHeight };
}
function scrollRectIntoView(dom, rect, side, x, y, xMargin, yMargin, ltr) {
    let doc = dom.ownerDocument, win = doc.defaultView || window;
    for (let cur = dom; cur;) {
        if (cur.nodeType == 1) { // Element
            let bounding, top = cur == doc.body;
            if (top) {
                bounding = windowRect(win);
            }
            else {
                if (cur.scrollHeight <= cur.clientHeight && cur.scrollWidth <= cur.clientWidth) {
                    cur = cur.assignedSlot || cur.parentNode;
                    continue;
                }
                let rect = cur.getBoundingClientRect();
                // Make sure scrollbar width isn't included in the rectangle
                bounding = { left: rect.left, right: rect.left + cur.clientWidth,
                    top: rect.top, bottom: rect.top + cur.clientHeight };
            }
            let moveX = 0, moveY = 0;
            if (y == "nearest") {
                if (rect.top < bounding.top) {
                    moveY = -(bounding.top - rect.top + yMargin);
                    if (side > 0 && rect.bottom > bounding.bottom + moveY)
                        moveY = rect.bottom - bounding.bottom + moveY + yMargin;
                }
                else if (rect.bottom > bounding.bottom) {
                    moveY = rect.bottom - bounding.bottom + yMargin;
                    if (side < 0 && (rect.top - moveY) < bounding.top)
                        moveY = -(bounding.top + moveY - rect.top + yMargin);
                }
            }
            else {
                let rectHeight = rect.bottom - rect.top, boundingHeight = bounding.bottom - bounding.top;
                let targetTop = y == "center" && rectHeight <= boundingHeight ? rect.top + rectHeight / 2 - boundingHeight / 2 :
                    y == "start" || y == "center" && side < 0 ? rect.top - yMargin :
                        rect.bottom - boundingHeight + yMargin;
                moveY = targetTop - bounding.top;
            }
            if (x == "nearest") {
                if (rect.left < bounding.left) {
                    moveX = -(bounding.left - rect.left + xMargin);
                    if (side > 0 && rect.right > bounding.right + moveX)
                        moveX = rect.right - bounding.right + moveX + xMargin;
                }
                else if (rect.right > bounding.right) {
                    moveX = rect.right - bounding.right + xMargin;
                    if (side < 0 && rect.left < bounding.left + moveX)
                        moveX = -(bounding.left + moveX - rect.left + xMargin);
                }
            }
            else {
                let targetLeft = x == "center" ? rect.left + (rect.right - rect.left) / 2 - (bounding.right - bounding.left) / 2 :
                    (x == "start") == ltr ? rect.left - xMargin :
                        rect.right - (bounding.right - bounding.left) + xMargin;
                moveX = targetLeft - bounding.left;
            }
            if (moveX || moveY) {
                if (top) {
                    win.scrollBy(moveX, moveY);
                }
                else {
                    let movedX = 0, movedY = 0;
                    if (moveY) {
                        let start = cur.scrollTop;
                        cur.scrollTop += moveY;
                        movedY = cur.scrollTop - start;
                    }
                    if (moveX) {
                        let start = cur.scrollLeft;
                        cur.scrollLeft += moveX;
                        movedX = cur.scrollLeft - start;
                    }
                    rect = { left: rect.left - movedX, top: rect.top - movedY,
                        right: rect.right - movedX, bottom: rect.bottom - movedY };
                    if (movedX && Math.abs(movedX - moveX) < 1)
                        x = "nearest";
                    if (movedY && Math.abs(movedY - moveY) < 1)
                        y = "nearest";
                }
            }
            if (top)
                break;
            cur = cur.assignedSlot || cur.parentNode;
        }
        else if (cur.nodeType == 11) { // A shadow root
            cur = cur.host;
        }
        else {
            break;
        }
    }
}
class DOMSelectionState {
    constructor() {
        this.anchorNode = null;
        this.anchorOffset = 0;
        this.focusNode = null;
        this.focusOffset = 0;
    }
    eq(domSel) {
        return this.anchorNode == domSel.anchorNode && this.anchorOffset == domSel.anchorOffset &&
            this.focusNode == domSel.focusNode && this.focusOffset == domSel.focusOffset;
    }
    setRange(range) {
        this.set(range.anchorNode, range.anchorOffset, range.focusNode, range.focusOffset);
    }
    set(anchorNode, anchorOffset, focusNode, focusOffset) {
        this.anchorNode = anchorNode;
        this.anchorOffset = anchorOffset;
        this.focusNode = focusNode;
        this.focusOffset = focusOffset;
    }
}
let preventScrollSupported = null;
// Feature-detects support for .focus({preventScroll: true}), and uses
// a fallback kludge when not supported.
function focusPreventScroll(dom) {
    if (dom.setActive)
        return dom.setActive(); // in IE
    if (preventScrollSupported)
        return dom.focus(preventScrollSupported);
    let stack = [];
    for (let cur = dom; cur; cur = cur.parentNode) {
        stack.push(cur, cur.scrollTop, cur.scrollLeft);
        if (cur == cur.ownerDocument)
            break;
    }
    dom.focus(preventScrollSupported == null ? {
        get preventScroll() {
            preventScrollSupported = { preventScroll: true };
            return true;
        }
    } : undefined);
    if (!preventScrollSupported) {
        preventScrollSupported = false;
        for (let i = 0; i < stack.length;) {
            let elt = stack[i++], top = stack[i++], left = stack[i++];
            if (elt.scrollTop != top)
                elt.scrollTop = top;
            if (elt.scrollLeft != left)
                elt.scrollLeft = left;
        }
    }
}
let scratchRange;
function textRange(node, from, to = from) {
    let range = scratchRange || (scratchRange = document.createRange());
    range.setEnd(node, to);
    range.setStart(node, from);
    return range;
}
function dispatchKey(elt, name, code) {
    let options = { key: name, code: name, keyCode: code, which: code, cancelable: true };
    let down = new KeyboardEvent("keydown", options);
    down.synthetic = true;
    elt.dispatchEvent(down);
    let up = new KeyboardEvent("keyup", options);
    up.synthetic = true;
    elt.dispatchEvent(up);
    return down.defaultPrevented || up.defaultPrevented;
}
function getRoot(node) {
    while (node) {
        if (node && (node.nodeType == 9 || node.nodeType == 11 && node.host))
            return node;
        node = node.assignedSlot || node.parentNode;
    }
    return null;
}
function clearAttributes(node) {
    while (node.attributes.length)
        node.removeAttributeNode(node.attributes[0]);
}
function atElementStart(doc, selection) {
    let node = selection.focusNode, offset = selection.focusOffset;
    if (!node || selection.anchorNode != node || selection.anchorOffset != offset)
        return false;
    for (;;) {
        if (offset) {
            if (node.nodeType != 1)
                return false;
            let prev = node.childNodes[offset - 1];
            if (prev.contentEditable == "false")
                offset--;
            else {
                node = prev;
                offset = maxOffset(node);
            }
        }
        else if (node == doc) {
            return true;
        }
        else {
            offset = domIndex(node);
            node = node.parentNode;
        }
    }
}

class DOMPos {
    constructor(node, offset, precise = true) {
        this.node = node;
        this.offset = offset;
        this.precise = precise;
    }
    static before(dom, precise) { return new DOMPos(dom.parentNode, domIndex(dom), precise); }
    static after(dom, precise) { return new DOMPos(dom.parentNode, domIndex(dom) + 1, precise); }
}
const noChildren = [];
class ContentView {
    constructor() {
        this.parent = null;
        this.dom = null;
        this.dirty = 2 /* Dirty.Node */;
    }
    get editorView() {
        if (!this.parent)
            throw new Error("Accessing view in orphan content view");
        return this.parent.editorView;
    }
    get overrideDOMText() { return null; }
    get posAtStart() {
        return this.parent ? this.parent.posBefore(this) : 0;
    }
    get posAtEnd() {
        return this.posAtStart + this.length;
    }
    posBefore(view) {
        let pos = this.posAtStart;
        for (let child of this.children) {
            if (child == view)
                return pos;
            pos += child.length + child.breakAfter;
        }
        throw new RangeError("Invalid child in posBefore");
    }
    posAfter(view) {
        return this.posBefore(view) + view.length;
    }
    // Will return a rectangle directly before (when side < 0), after
    // (side > 0) or directly on (when the browser supports it) the
    // given position.
    coordsAt(_pos, _side) { return null; }
    sync(track) {
        if (this.dirty & 2 /* Dirty.Node */) {
            let parent = this.dom;
            let prev = null, next;
            for (let child of this.children) {
                if (child.dirty) {
                    if (!child.dom && (next = prev ? prev.nextSibling : parent.firstChild)) {
                        let contentView = ContentView.get(next);
                        if (!contentView || !contentView.parent && contentView.canReuseDOM(child))
                            child.reuseDOM(next);
                    }
                    child.sync(track);
                    child.dirty = 0 /* Dirty.Not */;
                }
                next = prev ? prev.nextSibling : parent.firstChild;
                if (track && !track.written && track.node == parent && next != child.dom)
                    track.written = true;
                if (child.dom.parentNode == parent) {
                    while (next && next != child.dom)
                        next = rm$1(next);
                }
                else {
                    parent.insertBefore(child.dom, next);
                }
                prev = child.dom;
            }
            next = prev ? prev.nextSibling : parent.firstChild;
            if (next && track && track.node == parent)
                track.written = true;
            while (next)
                next = rm$1(next);
        }
        else if (this.dirty & 1 /* Dirty.Child */) {
            for (let child of this.children)
                if (child.dirty) {
                    child.sync(track);
                    child.dirty = 0 /* Dirty.Not */;
                }
        }
    }
    reuseDOM(_dom) { }
    localPosFromDOM(node, offset) {
        let after;
        if (node == this.dom) {
            after = this.dom.childNodes[offset];
        }
        else {
            let bias = maxOffset(node) == 0 ? 0 : offset == 0 ? -1 : 1;
            for (;;) {
                let parent = node.parentNode;
                if (parent == this.dom)
                    break;
                if (bias == 0 && parent.firstChild != parent.lastChild) {
                    if (node == parent.firstChild)
                        bias = -1;
                    else
                        bias = 1;
                }
                node = parent;
            }
            if (bias < 0)
                after = node;
            else
                after = node.nextSibling;
        }
        if (after == this.dom.firstChild)
            return 0;
        while (after && !ContentView.get(after))
            after = after.nextSibling;
        if (!after)
            return this.length;
        for (let i = 0, pos = 0;; i++) {
            let child = this.children[i];
            if (child.dom == after)
                return pos;
            pos += child.length + child.breakAfter;
        }
    }
    domBoundsAround(from, to, offset = 0) {
        let fromI = -1, fromStart = -1, toI = -1, toEnd = -1;
        for (let i = 0, pos = offset, prevEnd = offset; i < this.children.length; i++) {
            let child = this.children[i], end = pos + child.length;
            if (pos < from && end > to)
                return child.domBoundsAround(from, to, pos);
            if (end >= from && fromI == -1) {
                fromI = i;
                fromStart = pos;
            }
            if (pos > to && child.dom.parentNode == this.dom) {
                toI = i;
                toEnd = prevEnd;
                break;
            }
            prevEnd = end;
            pos = end + child.breakAfter;
        }
        return { from: fromStart, to: toEnd < 0 ? offset + this.length : toEnd,
            startDOM: (fromI ? this.children[fromI - 1].dom.nextSibling : null) || this.dom.firstChild,
            endDOM: toI < this.children.length && toI >= 0 ? this.children[toI].dom : null };
    }
    markDirty(andParent = false) {
        this.dirty |= 2 /* Dirty.Node */;
        this.markParentsDirty(andParent);
    }
    markParentsDirty(childList) {
        for (let parent = this.parent; parent; parent = parent.parent) {
            if (childList)
                parent.dirty |= 2 /* Dirty.Node */;
            if (parent.dirty & 1 /* Dirty.Child */)
                return;
            parent.dirty |= 1 /* Dirty.Child */;
            childList = false;
        }
    }
    setParent(parent) {
        if (this.parent != parent) {
            this.parent = parent;
            if (this.dirty)
                this.markParentsDirty(true);
        }
    }
    setDOM(dom) {
        if (this.dom)
            this.dom.cmView = null;
        this.dom = dom;
        dom.cmView = this;
    }
    get rootView() {
        for (let v = this;;) {
            let parent = v.parent;
            if (!parent)
                return v;
            v = parent;
        }
    }
    replaceChildren(from, to, children = noChildren) {
        this.markDirty();
        for (let i = from; i < to; i++) {
            let child = this.children[i];
            if (child.parent == this)
                child.destroy();
        }
        this.children.splice(from, to - from, ...children);
        for (let i = 0; i < children.length; i++)
            children[i].setParent(this);
    }
    ignoreMutation(_rec) { return false; }
    ignoreEvent(_event) { return false; }
    childCursor(pos = this.length) {
        return new ChildCursor(this.children, pos, this.children.length);
    }
    childPos(pos, bias = 1) {
        return this.childCursor().findPos(pos, bias);
    }
    toString() {
        let name = this.constructor.name.replace("View", "");
        return name + (this.children.length ? "(" + this.children.join() + ")" :
            this.length ? "[" + (name == "Text" ? this.text : this.length) + "]" : "") +
            (this.breakAfter ? "#" : "");
    }
    static get(node) { return node.cmView; }
    get isEditable() { return true; }
    merge(from, to, source, hasStart, openStart, openEnd) {
        return false;
    }
    become(other) { return false; }
    canReuseDOM(other) { return other.constructor == this.constructor; }
    // When this is a zero-length view with a side, this should return a
    // number <= 0 to indicate it is before its position, or a
    // number > 0 when after its position.
    getSide() { return 0; }
    destroy() {
        this.parent = null;
    }
}
ContentView.prototype.breakAfter = 0;
// Remove a DOM node and return its next sibling.
function rm$1(dom) {
    let next = dom.nextSibling;
    dom.parentNode.removeChild(dom);
    return next;
}
class ChildCursor {
    constructor(children, pos, i) {
        this.children = children;
        this.pos = pos;
        this.i = i;
        this.off = 0;
    }
    findPos(pos, bias = 1) {
        for (;;) {
            if (pos > this.pos || pos == this.pos &&
                (bias > 0 || this.i == 0 || this.children[this.i - 1].breakAfter)) {
                this.off = pos - this.pos;
                return this;
            }
            let next = this.children[--this.i];
            this.pos -= next.length + next.breakAfter;
        }
    }
}
function replaceRange(parent, fromI, fromOff, toI, toOff, insert, breakAtStart, openStart, openEnd) {
    let { children } = parent;
    let before = children.length ? children[fromI] : null;
    let last = insert.length ? insert[insert.length - 1] : null;
    let breakAtEnd = last ? last.breakAfter : breakAtStart;
    // Change within a single child
    if (fromI == toI && before && !breakAtStart && !breakAtEnd && insert.length < 2 &&
        before.merge(fromOff, toOff, insert.length ? last : null, fromOff == 0, openStart, openEnd))
        return;
    if (toI < children.length) {
        let after = children[toI];
        // Make sure the end of the child after the update is preserved in `after`
        if (after && toOff < after.length) {
            // If we're splitting a child, separate part of it to avoid that
            // being mangled when updating the child before the update.
            if (fromI == toI) {
                after = after.split(toOff);
                toOff = 0;
            }
            // If the element after the replacement should be merged with
            // the last replacing element, update `content`
            if (!breakAtEnd && last && after.merge(0, toOff, last, true, 0, openEnd)) {
                insert[insert.length - 1] = after;
            }
            else {
                // Remove the start of the after element, if necessary, and
                // add it to `content`.
                if (toOff)
                    after.merge(0, toOff, null, false, 0, openEnd);
                insert.push(after);
            }
        }
        else if (after === null || after === void 0 ? void 0 : after.breakAfter) {
            // The element at `toI` is entirely covered by this range.
            // Preserve its line break, if any.
            if (last)
                last.breakAfter = 1;
            else
                breakAtStart = 1;
        }
        // Since we've handled the next element from the current elements
        // now, make sure `toI` points after that.
        toI++;
    }
    if (before) {
        before.breakAfter = breakAtStart;
        if (fromOff > 0) {
            if (!breakAtStart && insert.length && before.merge(fromOff, before.length, insert[0], false, openStart, 0)) {
                before.breakAfter = insert.shift().breakAfter;
            }
            else if (fromOff < before.length || before.children.length && before.children[before.children.length - 1].length == 0) {
                before.merge(fromOff, before.length, null, false, openStart, 0);
            }
            fromI++;
        }
    }
    // Try to merge widgets on the boundaries of the replacement
    while (fromI < toI && insert.length) {
        if (children[toI - 1].become(insert[insert.length - 1])) {
            toI--;
            insert.pop();
            openEnd = insert.length ? 0 : openStart;
        }
        else if (children[fromI].become(insert[0])) {
            fromI++;
            insert.shift();
            openStart = insert.length ? 0 : openEnd;
        }
        else {
            break;
        }
    }
    if (!insert.length && fromI && toI < children.length && !children[fromI - 1].breakAfter &&
        children[toI].merge(0, 0, children[fromI - 1], false, openStart, openEnd))
        fromI--;
    if (fromI < toI || insert.length)
        parent.replaceChildren(fromI, toI, insert);
}
function mergeChildrenInto(parent, from, to, insert, openStart, openEnd) {
    let cur = parent.childCursor();
    let { i: toI, off: toOff } = cur.findPos(to, 1);
    let { i: fromI, off: fromOff } = cur.findPos(from, -1);
    let dLen = from - to;
    for (let view of insert)
        dLen += view.length;
    parent.length += dLen;
    replaceRange(parent, fromI, fromOff, toI, toOff, insert, 0, openStart, openEnd);
}

let nav = typeof navigator != "undefined" ? navigator : { userAgent: "", vendor: "", platform: "" };
let doc = typeof document != "undefined" ? document : { documentElement: { style: {} } };
const ie_edge = /*@__PURE__*//Edge\/(\d+)/.exec(nav.userAgent);
const ie_upto10 = /*@__PURE__*//MSIE \d/.test(nav.userAgent);
const ie_11up = /*@__PURE__*//Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(nav.userAgent);
const dist_ie = !!(ie_upto10 || ie_11up || ie_edge);
const dist_gecko = !dist_ie && /*@__PURE__*//gecko\/(\d+)/i.test(nav.userAgent);
const dist_chrome = !dist_ie && /*@__PURE__*//Chrome\/(\d+)/.exec(nav.userAgent);
const webkit = "webkitFontSmoothing" in doc.documentElement.style;
const safari = !dist_ie && /*@__PURE__*//Apple Computer/.test(nav.vendor);
const ios = safari && (/*@__PURE__*//Mobile\/\w+/.test(nav.userAgent) || nav.maxTouchPoints > 2);
var browser = {
    mac: ios || /*@__PURE__*//Mac/.test(nav.platform),
    windows: /*@__PURE__*//Win/.test(nav.platform),
    linux: /*@__PURE__*//Linux|X11/.test(nav.platform),
    ie: dist_ie,
    ie_version: ie_upto10 ? doc.documentMode || 6 : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0,
    gecko: dist_gecko,
    gecko_version: dist_gecko ? +(/*@__PURE__*//Firefox\/(\d+)/.exec(nav.userAgent) || [0, 0])[1] : 0,
    chrome: !!dist_chrome,
    chrome_version: dist_chrome ? +dist_chrome[1] : 0,
    ios,
    android: /*@__PURE__*//Android\b/.test(nav.userAgent),
    webkit,
    safari,
    webkit_version: webkit ? +(/*@__PURE__*//\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0,
    tabSize: doc.documentElement.style.tabSize != null ? "tab-size" : "-moz-tab-size"
};

const MaxJoinLen = 256;
class TextView extends ContentView {
    constructor(text) {
        super();
        this.text = text;
    }
    get length() { return this.text.length; }
    createDOM(textDOM) {
        this.setDOM(textDOM || document.createTextNode(this.text));
    }
    sync(track) {
        if (!this.dom)
            this.createDOM();
        if (this.dom.nodeValue != this.text) {
            if (track && track.node == this.dom)
                track.written = true;
            this.dom.nodeValue = this.text;
        }
    }
    reuseDOM(dom) {
        if (dom.nodeType == 3)
            this.createDOM(dom);
    }
    merge(from, to, source) {
        if (source && (!(source instanceof TextView) || this.length - (to - from) + source.length > MaxJoinLen))
            return false;
        this.text = this.text.slice(0, from) + (source ? source.text : "") + this.text.slice(to);
        this.markDirty();
        return true;
    }
    split(from) {
        let result = new TextView(this.text.slice(from));
        this.text = this.text.slice(0, from);
        this.markDirty();
        return result;
    }
    localPosFromDOM(node, offset) {
        return node == this.dom ? offset : offset ? this.text.length : 0;
    }
    domAtPos(pos) { return new DOMPos(this.dom, pos); }
    domBoundsAround(_from, _to, offset) {
        return { from: offset, to: offset + this.length, startDOM: this.dom, endDOM: this.dom.nextSibling };
    }
    coordsAt(pos, side) {
        return textCoords(this.dom, pos, side);
    }
}
class MarkView extends ContentView {
    constructor(mark, children = [], length = 0) {
        super();
        this.mark = mark;
        this.children = children;
        this.length = length;
        for (let ch of children)
            ch.setParent(this);
    }
    setAttrs(dom) {
        clearAttributes(dom);
        if (this.mark.class)
            dom.className = this.mark.class;
        if (this.mark.attrs)
            for (let name in this.mark.attrs)
                dom.setAttribute(name, this.mark.attrs[name]);
        return dom;
    }
    reuseDOM(node) {
        if (node.nodeName == this.mark.tagName.toUpperCase()) {
            this.setDOM(node);
            this.dirty |= 4 /* Dirty.Attrs */ | 2 /* Dirty.Node */;
        }
    }
    sync(track) {
        if (!this.dom)
            this.setDOM(this.setAttrs(document.createElement(this.mark.tagName)));
        else if (this.dirty & 4 /* Dirty.Attrs */)
            this.setAttrs(this.dom);
        super.sync(track);
    }
    merge(from, to, source, _hasStart, openStart, openEnd) {
        if (source && (!(source instanceof MarkView && source.mark.eq(this.mark)) ||
            (from && openStart <= 0) || (to < this.length && openEnd <= 0)))
            return false;
        mergeChildrenInto(this, from, to, source ? source.children : [], openStart - 1, openEnd - 1);
        this.markDirty();
        return true;
    }
    split(from) {
        let result = [], off = 0, detachFrom = -1, i = 0;
        for (let elt of this.children) {
            let end = off + elt.length;
            if (end > from)
                result.push(off < from ? elt.split(from - off) : elt);
            if (detachFrom < 0 && off >= from)
                detachFrom = i;
            off = end;
            i++;
        }
        let length = this.length - from;
        this.length = from;
        if (detachFrom > -1) {
            this.children.length = detachFrom;
            this.markDirty();
        }
        return new MarkView(this.mark, result, length);
    }
    domAtPos(pos) {
        return inlineDOMAtPos(this, pos);
    }
    coordsAt(pos, side) {
        return coordsInChildren(this, pos, side);
    }
}
function textCoords(text, pos, side) {
    let length = text.nodeValue.length;
    if (pos > length)
        pos = length;
    let from = pos, to = pos, flatten = 0;
    if (pos == 0 && side < 0 || pos == length && side >= 0) {
        if (!(browser.chrome || browser.gecko)) { // These browsers reliably return valid rectangles for empty ranges
            if (pos) {
                from--;
                flatten = 1;
            } // FIXME this is wrong in RTL text
            else if (to < length) {
                to++;
                flatten = -1;
            }
        }
    }
    else {
        if (side < 0)
            from--;
        else if (to < length)
            to++;
    }
    let rects = textRange(text, from, to).getClientRects();
    if (!rects.length)
        return Rect0;
    let rect = rects[(flatten ? flatten < 0 : side >= 0) ? 0 : rects.length - 1];
    if (browser.safari && !flatten && rect.width == 0)
        rect = Array.prototype.find.call(rects, r => r.width) || rect;
    return flatten ? flattenRect(rect, flatten < 0) : rect || null;
}
// Also used for collapsed ranges that don't have a placeholder widget!
class WidgetView extends ContentView {
    constructor(widget, length, side) {
        super();
        this.widget = widget;
        this.length = length;
        this.side = side;
        this.prevWidget = null;
    }
    static create(widget, length, side) {
        return new (widget.customView || WidgetView)(widget, length, side);
    }
    split(from) {
        let result = WidgetView.create(this.widget, this.length - from, this.side);
        this.length -= from;
        return result;
    }
    sync() {
        if (!this.dom || !this.widget.updateDOM(this.dom)) {
            if (this.dom && this.prevWidget)
                this.prevWidget.destroy(this.dom);
            this.prevWidget = null;
            this.setDOM(this.widget.toDOM(this.editorView));
            this.dom.contentEditable = "false";
        }
    }
    getSide() { return this.side; }
    merge(from, to, source, hasStart, openStart, openEnd) {
        if (source && (!(source instanceof WidgetView) || !this.widget.compare(source.widget) ||
            from > 0 && openStart <= 0 || to < this.length && openEnd <= 0))
            return false;
        this.length = from + (source ? source.length : 0) + (this.length - to);
        return true;
    }
    become(other) {
        if (other.length == this.length && other instanceof WidgetView && other.side == this.side) {
            if (this.widget.constructor == other.widget.constructor) {
                if (!this.widget.eq(other.widget))
                    this.markDirty(true);
                if (this.dom && !this.prevWidget)
                    this.prevWidget = this.widget;
                this.widget = other.widget;
                return true;
            }
        }
        return false;
    }
    ignoreMutation() { return true; }
    ignoreEvent(event) { return this.widget.ignoreEvent(event); }
    get overrideDOMText() {
        if (this.length == 0)
            return state_dist/* Text.empty */.xv.empty;
        let top = this;
        while (top.parent)
            top = top.parent;
        let view = top.editorView, text = view && view.state.doc, start = this.posAtStart;
        return text ? text.slice(start, start + this.length) : state_dist/* Text.empty */.xv.empty;
    }
    domAtPos(pos) {
        return pos == 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom, pos == this.length);
    }
    domBoundsAround() { return null; }
    coordsAt(pos, side) {
        let rects = this.dom.getClientRects(), rect = null;
        if (!rects.length)
            return Rect0;
        for (let i = pos > 0 ? rects.length - 1 : 0;; i += (pos > 0 ? -1 : 1)) {
            rect = rects[i];
            if (pos > 0 ? i == 0 : i == rects.length - 1 || rect.top < rect.bottom)
                break;
        }
        return (pos == 0 && side > 0 || pos == this.length && side <= 0) ? rect : flattenRect(rect, pos == 0);
    }
    get isEditable() { return false; }
    destroy() {
        super.destroy();
        if (this.dom)
            this.widget.destroy(this.dom);
    }
}
class CompositionView extends WidgetView {
    domAtPos(pos) {
        let { topView, text } = this.widget;
        if (!topView)
            return new DOMPos(text, Math.min(pos, text.nodeValue.length));
        return scanCompositionTree(pos, 0, topView, text, (v, p) => v.domAtPos(p), p => new DOMPos(text, Math.min(p, text.nodeValue.length)));
    }
    sync() { this.setDOM(this.widget.toDOM()); }
    localPosFromDOM(node, offset) {
        let { topView, text } = this.widget;
        if (!topView)
            return Math.min(offset, this.length);
        return posFromDOMInCompositionTree(node, offset, topView, text);
    }
    ignoreMutation() { return false; }
    get overrideDOMText() { return null; }
    coordsAt(pos, side) {
        let { topView, text } = this.widget;
        if (!topView)
            return textCoords(text, pos, side);
        return scanCompositionTree(pos, side, topView, text, (v, pos, side) => v.coordsAt(pos, side), (pos, side) => textCoords(text, pos, side));
    }
    destroy() {
        var _a;
        super.destroy();
        (_a = this.widget.topView) === null || _a === void 0 ? void 0 : _a.destroy();
    }
    get isEditable() { return true; }
    canReuseDOM() { return true; }
}
// Uses the old structure of a chunk of content view frozen for
// composition to try and find a reasonable DOM location for the given
// offset.
function scanCompositionTree(pos, side, view, text, enterView, fromText) {
    if (view instanceof MarkView) {
        for (let child = view.dom.firstChild; child; child = child.nextSibling) {
            let desc = ContentView.get(child);
            if (!desc)
                return fromText(pos, side);
            let hasComp = contains(child, text);
            let len = desc.length + (hasComp ? text.nodeValue.length : 0);
            if (pos < len || pos == len && desc.getSide() <= 0)
                return hasComp ? scanCompositionTree(pos, side, desc, text, enterView, fromText) : enterView(desc, pos, side);
            pos -= len;
        }
        return enterView(view, view.length, -1);
    }
    else if (view.dom == text) {
        return fromText(pos, side);
    }
    else {
        return enterView(view, pos, side);
    }
}
function posFromDOMInCompositionTree(node, offset, view, text) {
    if (view instanceof MarkView) {
        for (let child of view.children) {
            let pos = 0, hasComp = contains(child.dom, text);
            if (contains(child.dom, node))
                return pos + (hasComp ? posFromDOMInCompositionTree(node, offset, child, text) : child.localPosFromDOM(node, offset));
            pos += hasComp ? text.nodeValue.length : child.length;
        }
    }
    else if (view.dom == text) {
        return Math.min(offset, text.nodeValue.length);
    }
    return view.localPosFromDOM(node, offset);
}
// These are drawn around uneditable widgets to avoid a number of
// browser bugs that show up when the cursor is directly next to
// uneditable inline content.
class WidgetBufferView extends ContentView {
    constructor(side) {
        super();
        this.side = side;
    }
    get length() { return 0; }
    merge() { return false; }
    become(other) {
        return other instanceof WidgetBufferView && other.side == this.side;
    }
    split() { return new WidgetBufferView(this.side); }
    sync() {
        if (!this.dom) {
            let dom = document.createElement("img");
            dom.className = "cm-widgetBuffer";
            dom.setAttribute("aria-hidden", "true");
            this.setDOM(dom);
        }
    }
    getSide() { return this.side; }
    domAtPos(pos) { return DOMPos.before(this.dom); }
    localPosFromDOM() { return 0; }
    domBoundsAround() { return null; }
    coordsAt(pos) {
        let imgRect = this.dom.getBoundingClientRect();
        // Since the <img> height doesn't correspond to text height, try
        // to borrow the height from some sibling node.
        let siblingRect = inlineSiblingRect(this, this.side > 0 ? -1 : 1);
        return siblingRect && siblingRect.top < imgRect.bottom && siblingRect.bottom > imgRect.top
            ? { left: imgRect.left, right: imgRect.right, top: siblingRect.top, bottom: siblingRect.bottom } : imgRect;
    }
    get overrideDOMText() {
        return state_dist/* Text.empty */.xv.empty;
    }
}
TextView.prototype.children = WidgetView.prototype.children = WidgetBufferView.prototype.children = noChildren;
function inlineSiblingRect(view, side) {
    let parent = view.parent, index = parent ? parent.children.indexOf(view) : -1;
    while (parent && index >= 0) {
        if (side < 0 ? index > 0 : index < parent.children.length) {
            let next = parent.children[index + side];
            if (next instanceof TextView) {
                let nextRect = next.coordsAt(side < 0 ? next.length : 0, side);
                if (nextRect)
                    return nextRect;
            }
            index += side;
        }
        else if (parent instanceof MarkView && parent.parent) {
            index = parent.parent.children.indexOf(parent) + (side < 0 ? 0 : 1);
            parent = parent.parent;
        }
        else {
            let last = parent.dom.lastChild;
            if (last && last.nodeName == "BR")
                return last.getClientRects()[0];
            break;
        }
    }
    return undefined;
}
function inlineDOMAtPos(parent, pos) {
    let dom = parent.dom, { children } = parent, i = 0;
    for (let off = 0; i < children.length; i++) {
        let child = children[i], end = off + child.length;
        if (end == off && child.getSide() <= 0)
            continue;
        if (pos > off && pos < end && child.dom.parentNode == dom)
            return child.domAtPos(pos - off);
        if (pos <= off)
            break;
        off = end;
    }
    //  if (i) return DOMPos.after(children[i - 1].dom!)
    for (let j = i; j > 0; j--) {
        let prev = children[j - 1];
        if (prev.dom.parentNode == dom)
            return prev.domAtPos(prev.length);
    }
    for (let j = i; j < children.length; j++) {
        let next = children[j];
        if (next.dom.parentNode == dom)
            return next.domAtPos(0);
    }
    return new DOMPos(dom, 0);
}
// Assumes `view`, if a mark view, has precisely 1 child.
function joinInlineInto(parent, view, open) {
    let last, { children } = parent;
    if (open > 0 && view instanceof MarkView && children.length &&
        (last = children[children.length - 1]) instanceof MarkView && last.mark.eq(view.mark)) {
        joinInlineInto(last, view.children[0], open - 1);
    }
    else {
        children.push(view);
        view.setParent(parent);
    }
    parent.length += view.length;
}
function coordsInChildren(view, pos, side) {
    for (let off = 0, i = 0; i < view.children.length; i++) {
        let child = view.children[i], end = off + child.length, next;
        if ((side <= 0 || end == view.length || child.getSide() > 0 ? end >= pos : end > pos) &&
            (pos < end || i + 1 == view.children.length || (next = view.children[i + 1]).length || next.getSide() > 0)) {
            let flatten = 0;
            if (end == off) {
                if (child.getSide() <= 0)
                    continue;
                flatten = side = -child.getSide();
            }
            let rect = child.coordsAt(Math.max(0, pos - off), side);
            return flatten && rect ? flattenRect(rect, side < 0) : rect;
        }
        off = end;
    }
    let last = view.dom.lastChild;
    if (!last)
        return view.dom.getBoundingClientRect();
    let rects = clientRectsFor(last);
    return rects[rects.length - 1] || null;
}

function combineAttrs(source, target) {
    for (let name in source) {
        if (name == "class" && target.class)
            target.class += " " + source.class;
        else if (name == "style" && target.style)
            target.style += ";" + source.style;
        else
            target[name] = source[name];
    }
    return target;
}
function attrsEq(a, b) {
    if (a == b)
        return true;
    if (!a || !b)
        return false;
    let keysA = Object.keys(a), keysB = Object.keys(b);
    if (keysA.length != keysB.length)
        return false;
    for (let key of keysA) {
        if (keysB.indexOf(key) == -1 || a[key] !== b[key])
            return false;
    }
    return true;
}
function updateAttrs(dom, prev, attrs) {
    let changed = null;
    if (prev)
        for (let name in prev)
            if (!(attrs && name in attrs))
                dom.removeAttribute(changed = name);
    if (attrs)
        for (let name in attrs)
            if (!(prev && prev[name] == attrs[name]))
                dom.setAttribute(changed = name, attrs[name]);
    return !!changed;
}

/**
Widgets added to the content are described by subclasses of this
class. Using a description object like that makes it possible to
delay creating of the DOM structure for a widget until it is
needed, and to avoid redrawing widgets even if the decorations
that define them are recreated.
*/
class WidgetType {
    /**
    Compare this instance to another instance of the same type.
    (TypeScript can't express this, but only instances of the same
    specific class will be passed to this method.) This is used to
    avoid redrawing widgets when they are replaced by a new
    decoration of the same type. The default implementation just
    returns `false`, which will cause new instances of the widget to
    always be redrawn.
    */
    eq(widget) { return false; }
    /**
    Update a DOM element created by a widget of the same type (but
    different, non-`eq` content) to reflect this widget. May return
    true to indicate that it could update, false to indicate it
    couldn't (in which case the widget will be redrawn). The default
    implementation just returns false.
    */
    updateDOM(dom) { return false; }
    /**
    @internal
    */
    compare(other) {
        return this == other || this.constructor == other.constructor && this.eq(other);
    }
    /**
    The estimated height this widget will have, to be used when
    estimating the height of content that hasn't been drawn. May
    return -1 to indicate you don't know. The default implementation
    returns -1.
    */
    get estimatedHeight() { return -1; }
    /**
    Can be used to configure which kinds of events inside the widget
    should be ignored by the editor. The default is to ignore all
    events.
    */
    ignoreEvent(event) { return true; }
    /**
    @internal
    */
    get customView() { return null; }
    /**
    This is called when the an instance of the widget is removed
    from the editor view.
    */
    destroy(dom) { }
}
/**
The different types of blocks that can occur in an editor view.
*/
var BlockType = /*@__PURE__*/(function (BlockType) {
    /**
    A line of text.
    */
    BlockType[BlockType["Text"] = 0] = "Text";
    /**
    A block widget associated with the position after it.
    */
    BlockType[BlockType["WidgetBefore"] = 1] = "WidgetBefore";
    /**
    A block widget associated with the position before it.
    */
    BlockType[BlockType["WidgetAfter"] = 2] = "WidgetAfter";
    /**
    A block widget [replacing](https://codemirror.net/6/docs/ref/#view.Decoration^replace) a range of content.
    */
    BlockType[BlockType["WidgetRange"] = 3] = "WidgetRange";
return BlockType})(BlockType || (BlockType = {}));
/**
A decoration provides information on how to draw or style a piece
of content. You'll usually use it wrapped in a
[`Range`](https://codemirror.net/6/docs/ref/#state.Range), which adds a start and end position.
@nonabstract
*/
class Decoration extends state_dist/* RangeValue */.uU {
    constructor(
    /**
    @internal
    */
    startSide, 
    /**
    @internal
    */
    endSide, 
    /**
    @internal
    */
    widget, 
    /**
    The config object used to create this decoration. You can
    include additional properties in there to store metadata about
    your decoration.
    */
    spec) {
        super();
        this.startSide = startSide;
        this.endSide = endSide;
        this.widget = widget;
        this.spec = spec;
    }
    /**
    @internal
    */
    get heightRelevant() { return false; }
    /**
    Create a mark decoration, which influences the styling of the
    content in its range. Nested mark decorations will cause nested
    DOM elements to be created. Nesting order is determined by
    precedence of the [facet](https://codemirror.net/6/docs/ref/#view.EditorView^decorations), with
    the higher-precedence decorations creating the inner DOM nodes.
    Such elements are split on line boundaries and on the boundaries
    of lower-precedence decorations.
    */
    static mark(spec) {
        return new MarkDecoration(spec);
    }
    /**
    Create a widget decoration, which displays a DOM element at the
    given position.
    */
    static widget(spec) {
        let side = spec.side || 0, block = !!spec.block;
        side += block ? (side > 0 ? 300000000 /* Side.BlockAfter */ : -400000000 /* Side.BlockBefore */) : (side > 0 ? 100000000 /* Side.InlineAfter */ : -100000000 /* Side.InlineBefore */);
        return new PointDecoration(spec, side, side, block, spec.widget || null, false);
    }
    /**
    Create a replace decoration which replaces the given range with
    a widget, or simply hides it.
    */
    static replace(spec) {
        let block = !!spec.block, startSide, endSide;
        if (spec.isBlockGap) {
            startSide = -500000000 /* Side.GapStart */;
            endSide = 400000000 /* Side.GapEnd */;
        }
        else {
            let { start, end } = getInclusive(spec, block);
            startSide = (start ? (block ? -300000000 /* Side.BlockIncStart */ : -1 /* Side.InlineIncStart */) : 500000000 /* Side.NonIncStart */) - 1;
            endSide = (end ? (block ? 200000000 /* Side.BlockIncEnd */ : 1 /* Side.InlineIncEnd */) : -600000000 /* Side.NonIncEnd */) + 1;
        }
        return new PointDecoration(spec, startSide, endSide, block, spec.widget || null, true);
    }
    /**
    Create a line decoration, which can add DOM attributes to the
    line starting at the given position.
    */
    static line(spec) {
        return new LineDecoration(spec);
    }
    /**
    Build a [`DecorationSet`](https://codemirror.net/6/docs/ref/#view.DecorationSet) from the given
    decorated range or ranges. If the ranges aren't already sorted,
    pass `true` for `sort` to make the library sort them for you.
    */
    static set(of, sort = false) {
        return state_dist/* RangeSet.of */.Xs.of(of, sort);
    }
    /**
    @internal
    */
    hasHeight() { return this.widget ? this.widget.estimatedHeight > -1 : false; }
}
/**
The empty set of decorations.
*/
Decoration.none = state_dist/* RangeSet.empty */.Xs.empty;
class MarkDecoration extends Decoration {
    constructor(spec) {
        let { start, end } = getInclusive(spec);
        super(start ? -1 /* Side.InlineIncStart */ : 500000000 /* Side.NonIncStart */, end ? 1 /* Side.InlineIncEnd */ : -600000000 /* Side.NonIncEnd */, null, spec);
        this.tagName = spec.tagName || "span";
        this.class = spec.class || "";
        this.attrs = spec.attributes || null;
    }
    eq(other) {
        return this == other ||
            other instanceof MarkDecoration &&
                this.tagName == other.tagName &&
                this.class == other.class &&
                attrsEq(this.attrs, other.attrs);
    }
    range(from, to = from) {
        if (from >= to)
            throw new RangeError("Mark decorations may not be empty");
        return super.range(from, to);
    }
}
MarkDecoration.prototype.point = false;
class LineDecoration extends Decoration {
    constructor(spec) {
        super(-200000000 /* Side.Line */, -200000000 /* Side.Line */, null, spec);
    }
    eq(other) {
        return other instanceof LineDecoration && attrsEq(this.spec.attributes, other.spec.attributes);
    }
    range(from, to = from) {
        if (to != from)
            throw new RangeError("Line decoration ranges must be zero-length");
        return super.range(from, to);
    }
}
LineDecoration.prototype.mapMode = state_dist/* MapMode.TrackBefore */.gc.TrackBefore;
LineDecoration.prototype.point = true;
class PointDecoration extends Decoration {
    constructor(spec, startSide, endSide, block, widget, isReplace) {
        super(startSide, endSide, widget, spec);
        this.block = block;
        this.isReplace = isReplace;
        this.mapMode = !block ? state_dist/* MapMode.TrackDel */.gc.TrackDel : startSide <= 0 ? state_dist/* MapMode.TrackBefore */.gc.TrackBefore : state_dist/* MapMode.TrackAfter */.gc.TrackAfter;
    }
    // Only relevant when this.block == true
    get type() {
        return this.startSide < this.endSide ? BlockType.WidgetRange
            : this.startSide <= 0 ? BlockType.WidgetBefore : BlockType.WidgetAfter;
    }
    get heightRelevant() { return this.block || !!this.widget && this.widget.estimatedHeight >= 5; }
    eq(other) {
        return other instanceof PointDecoration &&
            widgetsEq(this.widget, other.widget) &&
            this.block == other.block &&
            this.startSide == other.startSide && this.endSide == other.endSide;
    }
    range(from, to = from) {
        if (this.isReplace && (from > to || (from == to && this.startSide > 0 && this.endSide <= 0)))
            throw new RangeError("Invalid range for replacement decoration");
        if (!this.isReplace && to != from)
            throw new RangeError("Widget decorations can only have zero-length ranges");
        return super.range(from, to);
    }
}
PointDecoration.prototype.point = true;
function getInclusive(spec, block = false) {
    let { inclusiveStart: start, inclusiveEnd: end } = spec;
    if (start == null)
        start = spec.inclusive;
    if (end == null)
        end = spec.inclusive;
    return { start: start !== null && start !== void 0 ? start : block, end: end !== null && end !== void 0 ? end : block };
}
function widgetsEq(a, b) {
    return a == b || !!(a && b && a.compare(b));
}
function addRange(from, to, ranges, margin = 0) {
    let last = ranges.length - 1;
    if (last >= 0 && ranges[last] + margin >= from)
        ranges[last] = Math.max(ranges[last], to);
    else
        ranges.push(from, to);
}

class LineView extends ContentView {
    constructor() {
        super(...arguments);
        this.children = [];
        this.length = 0;
        this.prevAttrs = undefined;
        this.attrs = null;
        this.breakAfter = 0;
    }
    // Consumes source
    merge(from, to, source, hasStart, openStart, openEnd) {
        if (source) {
            if (!(source instanceof LineView))
                return false;
            if (!this.dom)
                source.transferDOM(this); // Reuse source.dom when appropriate
        }
        if (hasStart)
            this.setDeco(source ? source.attrs : null);
        mergeChildrenInto(this, from, to, source ? source.children : [], openStart, openEnd);
        return true;
    }
    split(at) {
        let end = new LineView;
        end.breakAfter = this.breakAfter;
        if (this.length == 0)
            return end;
        let { i, off } = this.childPos(at);
        if (off) {
            end.append(this.children[i].split(off), 0);
            this.children[i].merge(off, this.children[i].length, null, false, 0, 0);
            i++;
        }
        for (let j = i; j < this.children.length; j++)
            end.append(this.children[j], 0);
        while (i > 0 && this.children[i - 1].length == 0)
            this.children[--i].destroy();
        this.children.length = i;
        this.markDirty();
        this.length = at;
        return end;
    }
    transferDOM(other) {
        if (!this.dom)
            return;
        this.markDirty();
        other.setDOM(this.dom);
        other.prevAttrs = this.prevAttrs === undefined ? this.attrs : this.prevAttrs;
        this.prevAttrs = undefined;
        this.dom = null;
    }
    setDeco(attrs) {
        if (!attrsEq(this.attrs, attrs)) {
            if (this.dom) {
                this.prevAttrs = this.attrs;
                this.markDirty();
            }
            this.attrs = attrs;
        }
    }
    append(child, openStart) {
        joinInlineInto(this, child, openStart);
    }
    // Only called when building a line view in ContentBuilder
    addLineDeco(deco) {
        let attrs = deco.spec.attributes, cls = deco.spec.class;
        if (attrs)
            this.attrs = combineAttrs(attrs, this.attrs || {});
        if (cls)
            this.attrs = combineAttrs({ class: cls }, this.attrs || {});
    }
    domAtPos(pos) {
        return inlineDOMAtPos(this, pos);
    }
    reuseDOM(node) {
        if (node.nodeName == "DIV") {
            this.setDOM(node);
            this.dirty |= 4 /* Dirty.Attrs */ | 2 /* Dirty.Node */;
        }
    }
    sync(track) {
        var _a;
        if (!this.dom) {
            this.setDOM(document.createElement("div"));
            this.dom.className = "cm-line";
            this.prevAttrs = this.attrs ? null : undefined;
        }
        else if (this.dirty & 4 /* Dirty.Attrs */) {
            clearAttributes(this.dom);
            this.dom.className = "cm-line";
            this.prevAttrs = this.attrs ? null : undefined;
        }
        if (this.prevAttrs !== undefined) {
            updateAttrs(this.dom, this.prevAttrs, this.attrs);
            this.dom.classList.add("cm-line");
            this.prevAttrs = undefined;
        }
        super.sync(track);
        let last = this.dom.lastChild;
        while (last && ContentView.get(last) instanceof MarkView)
            last = last.lastChild;
        if (!last || !this.length ||
            last.nodeName != "BR" && ((_a = ContentView.get(last)) === null || _a === void 0 ? void 0 : _a.isEditable) == false &&
                (!browser.ios || !this.children.some(ch => ch instanceof TextView))) {
            let hack = document.createElement("BR");
            hack.cmIgnore = true;
            this.dom.appendChild(hack);
        }
    }
    measureTextSize() {
        if (this.children.length == 0 || this.length > 20)
            return null;
        let totalWidth = 0;
        for (let child of this.children) {
            if (!(child instanceof TextView) || /[^ -~]/.test(child.text))
                return null;
            let rects = clientRectsFor(child.dom);
            if (rects.length != 1)
                return null;
            totalWidth += rects[0].width;
        }
        return !totalWidth ? null : {
            lineHeight: this.dom.getBoundingClientRect().height,
            charWidth: totalWidth / this.length
        };
    }
    coordsAt(pos, side) {
        return coordsInChildren(this, pos, side);
    }
    become(_other) { return false; }
    get type() { return BlockType.Text; }
    static find(docView, pos) {
        for (let i = 0, off = 0; i < docView.children.length; i++) {
            let block = docView.children[i], end = off + block.length;
            if (end >= pos) {
                if (block instanceof LineView)
                    return block;
                if (end > pos)
                    break;
            }
            off = end + block.breakAfter;
        }
        return null;
    }
}
class BlockWidgetView extends ContentView {
    constructor(widget, length, type) {
        super();
        this.widget = widget;
        this.length = length;
        this.type = type;
        this.breakAfter = 0;
        this.prevWidget = null;
    }
    merge(from, to, source, _takeDeco, openStart, openEnd) {
        if (source && (!(source instanceof BlockWidgetView) || !this.widget.compare(source.widget) ||
            from > 0 && openStart <= 0 || to < this.length && openEnd <= 0))
            return false;
        this.length = from + (source ? source.length : 0) + (this.length - to);
        return true;
    }
    domAtPos(pos) {
        return pos == 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom, pos == this.length);
    }
    split(at) {
        let len = this.length - at;
        this.length = at;
        let end = new BlockWidgetView(this.widget, len, this.type);
        end.breakAfter = this.breakAfter;
        return end;
    }
    get children() { return noChildren; }
    sync() {
        if (!this.dom || !this.widget.updateDOM(this.dom)) {
            if (this.dom && this.prevWidget)
                this.prevWidget.destroy(this.dom);
            this.prevWidget = null;
            this.setDOM(this.widget.toDOM(this.editorView));
            this.dom.contentEditable = "false";
        }
    }
    get overrideDOMText() {
        return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : state_dist/* Text.empty */.xv.empty;
    }
    domBoundsAround() { return null; }
    become(other) {
        if (other instanceof BlockWidgetView && other.type == this.type &&
            other.widget.constructor == this.widget.constructor) {
            if (!other.widget.eq(this.widget))
                this.markDirty(true);
            if (this.dom && !this.prevWidget)
                this.prevWidget = this.widget;
            this.widget = other.widget;
            this.length = other.length;
            this.breakAfter = other.breakAfter;
            return true;
        }
        return false;
    }
    ignoreMutation() { return true; }
    ignoreEvent(event) { return this.widget.ignoreEvent(event); }
    destroy() {
        super.destroy();
        if (this.dom)
            this.widget.destroy(this.dom);
    }
}

class ContentBuilder {
    constructor(doc, pos, end, disallowBlockEffectsFor) {
        this.doc = doc;
        this.pos = pos;
        this.end = end;
        this.disallowBlockEffectsFor = disallowBlockEffectsFor;
        this.content = [];
        this.curLine = null;
        this.breakAtStart = 0;
        this.pendingBuffer = 0 /* Buf.No */;
        // Set to false directly after a widget that covers the position after it
        this.atCursorPos = true;
        this.openStart = -1;
        this.openEnd = -1;
        this.text = "";
        this.textOff = 0;
        this.cursor = doc.iter();
        this.skip = pos;
    }
    posCovered() {
        if (this.content.length == 0)
            return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;
        let last = this.content[this.content.length - 1];
        return !last.breakAfter && !(last instanceof BlockWidgetView && last.type == BlockType.WidgetBefore);
    }
    getLine() {
        if (!this.curLine) {
            this.content.push(this.curLine = new LineView);
            this.atCursorPos = true;
        }
        return this.curLine;
    }
    flushBuffer(active) {
        if (this.pendingBuffer) {
            this.curLine.append(wrapMarks(new WidgetBufferView(-1), active), active.length);
            this.pendingBuffer = 0 /* Buf.No */;
        }
    }
    addBlockWidget(view) {
        this.flushBuffer([]);
        this.curLine = null;
        this.content.push(view);
    }
    finish(openEnd) {
        if (!openEnd)
            this.flushBuffer([]);
        else
            this.pendingBuffer = 0 /* Buf.No */;
        if (!this.posCovered())
            this.getLine();
    }
    buildText(length, active, openStart) {
        while (length > 0) {
            if (this.textOff == this.text.length) {
                let { value, lineBreak, done } = this.cursor.next(this.skip);
                this.skip = 0;
                if (done)
                    throw new Error("Ran out of text content when drawing inline views");
                if (lineBreak) {
                    if (!this.posCovered())
                        this.getLine();
                    if (this.content.length)
                        this.content[this.content.length - 1].breakAfter = 1;
                    else
                        this.breakAtStart = 1;
                    this.flushBuffer([]);
                    this.curLine = null;
                    length--;
                    continue;
                }
                else {
                    this.text = value;
                    this.textOff = 0;
                }
            }
            let take = Math.min(this.text.length - this.textOff, length, 512 /* T.Chunk */);
            this.flushBuffer(active.slice(0, openStart));
            this.getLine().append(wrapMarks(new TextView(this.text.slice(this.textOff, this.textOff + take)), active), openStart);
            this.atCursorPos = true;
            this.textOff += take;
            length -= take;
            openStart = 0;
        }
    }
    span(from, to, active, openStart) {
        this.buildText(to - from, active, openStart);
        this.pos = to;
        if (this.openStart < 0)
            this.openStart = openStart;
    }
    point(from, to, deco, active, openStart, index) {
        if (this.disallowBlockEffectsFor[index] && deco instanceof PointDecoration) {
            if (deco.block)
                throw new RangeError("Block decorations may not be specified via plugins");
            if (to > this.doc.lineAt(this.pos).to)
                throw new RangeError("Decorations that replace line breaks may not be specified via plugins");
        }
        let len = to - from;
        if (deco instanceof PointDecoration) {
            if (deco.block) {
                let { type } = deco;
                if (type == BlockType.WidgetAfter && !this.posCovered())
                    this.getLine();
                this.addBlockWidget(new BlockWidgetView(deco.widget || new NullWidget("div"), len, type));
            }
            else {
                let view = WidgetView.create(deco.widget || new NullWidget("span"), len, deco.startSide);
                let cursorBefore = this.atCursorPos && !view.isEditable && openStart <= active.length && (from < to || deco.startSide > 0);
                let cursorAfter = !view.isEditable && (from < to || deco.startSide <= 0);
                let line = this.getLine();
                if (this.pendingBuffer == 2 /* Buf.IfCursor */ && !cursorBefore)
                    this.pendingBuffer = 0 /* Buf.No */;
                this.flushBuffer(active);
                if (cursorBefore) {
                    line.append(wrapMarks(new WidgetBufferView(1), active), openStart);
                    openStart = active.length + Math.max(0, openStart - active.length);
                }
                line.append(wrapMarks(view, active), openStart);
                this.atCursorPos = cursorAfter;
                this.pendingBuffer = !cursorAfter ? 0 /* Buf.No */ : from < to ? 1 /* Buf.Yes */ : 2 /* Buf.IfCursor */;
            }
        }
        else if (this.doc.lineAt(this.pos).from == this.pos) { // Line decoration
            this.getLine().addLineDeco(deco);
        }
        if (len) {
            // Advance the iterator past the replaced content
            if (this.textOff + len <= this.text.length) {
                this.textOff += len;
            }
            else {
                this.skip += len - (this.text.length - this.textOff);
                this.text = "";
                this.textOff = 0;
            }
            this.pos = to;
        }
        if (this.openStart < 0)
            this.openStart = openStart;
    }
    static build(text, from, to, decorations, dynamicDecorationMap) {
        let builder = new ContentBuilder(text, from, to, dynamicDecorationMap);
        builder.openEnd = state_dist/* RangeSet.spans */.Xs.spans(decorations, from, to, builder);
        if (builder.openStart < 0)
            builder.openStart = builder.openEnd;
        builder.finish(builder.openEnd);
        return builder;
    }
}
function wrapMarks(view, active) {
    for (let mark of active)
        view = new MarkView(mark, [view], view.length);
    return view;
}
class NullWidget extends WidgetType {
    constructor(tag) {
        super();
        this.tag = tag;
    }
    eq(other) { return other.tag == this.tag; }
    toDOM() { return document.createElement(this.tag); }
    updateDOM(elt) { return elt.nodeName.toLowerCase() == this.tag; }
}

const clickAddsSelectionRange = /*@__PURE__*/state_dist/* Facet.define */.r$.define();
const dragMovesSelection$1 = /*@__PURE__*/state_dist/* Facet.define */.r$.define();
const mouseSelectionStyle = /*@__PURE__*/state_dist/* Facet.define */.r$.define();
const exceptionSink = /*@__PURE__*/state_dist/* Facet.define */.r$.define();
const updateListener = /*@__PURE__*/state_dist/* Facet.define */.r$.define();
const inputHandler = /*@__PURE__*/state_dist/* Facet.define */.r$.define();
const perLineTextDirection = /*@__PURE__*/state_dist/* Facet.define */.r$.define({
    combine: values => values.some(x => x)
});
class ScrollTarget {
    constructor(range, y = "nearest", x = "nearest", yMargin = 5, xMargin = 5) {
        this.range = range;
        this.y = y;
        this.x = x;
        this.yMargin = yMargin;
        this.xMargin = xMargin;
    }
    map(changes) {
        return changes.empty ? this : new ScrollTarget(this.range.map(changes), this.y, this.x, this.yMargin, this.xMargin);
    }
}
const scrollIntoView = /*@__PURE__*/state_dist/* StateEffect.define */.Py.define({ map: (t, ch) => t.map(ch) });
/**
Log or report an unhandled exception in client code. Should
probably only be used by extension code that allows client code to
provide functions, and calls those functions in a context where an
exception can't be propagated to calling code in a reasonable way
(for example when in an event handler).

Either calls a handler registered with
[`EditorView.exceptionSink`](https://codemirror.net/6/docs/ref/#view.EditorView^exceptionSink),
`window.onerror`, if defined, or `console.error` (in which case
it'll pass `context`, when given, as first argument).
*/
function logException(state, exception, context) {
    let handler = state.facet(exceptionSink);
    if (handler.length)
        handler[0](exception);
    else if (window.onerror)
        window.onerror(String(exception), context, undefined, undefined, exception);
    else if (context)
        console.error(context + ":", exception);
    else
        console.error(exception);
}
const editable = /*@__PURE__*/state_dist/* Facet.define */.r$.define({ combine: values => values.length ? values[0] : true });
let nextPluginID = 0;
const viewPlugin = /*@__PURE__*/state_dist/* Facet.define */.r$.define();
/**
View plugins associate stateful values with a view. They can
influence the way the content is drawn, and are notified of things
that happen in the view.
*/
class ViewPlugin {
    constructor(
    /**
    @internal
    */
    id, 
    /**
    @internal
    */
    create, 
    /**
    @internal
    */
    domEventHandlers, buildExtensions) {
        this.id = id;
        this.create = create;
        this.domEventHandlers = domEventHandlers;
        this.extension = buildExtensions(this);
    }
    /**
    Define a plugin from a constructor function that creates the
    plugin's value, given an editor view.
    */
    static define(create, spec) {
        const { eventHandlers, provide, decorations: deco } = spec || {};
        return new ViewPlugin(nextPluginID++, create, eventHandlers, plugin => {
            let ext = [viewPlugin.of(plugin)];
            if (deco)
                ext.push(decorations.of(view => {
                    let pluginInst = view.plugin(plugin);
                    return pluginInst ? deco(pluginInst) : Decoration.none;
                }));
            if (provide)
                ext.push(provide(plugin));
            return ext;
        });
    }
    /**
    Create a plugin for a class whose constructor takes a single
    editor view as argument.
    */
    static fromClass(cls, spec) {
        return ViewPlugin.define(view => new cls(view), spec);
    }
}
class PluginInstance {
    constructor(spec) {
        this.spec = spec;
        // When starting an update, all plugins have this field set to the
        // update object, indicating they need to be updated. When finished
        // updating, it is set to `false`. Retrieving a plugin that needs to
        // be updated with `view.plugin` forces an eager update.
        this.mustUpdate = null;
        // This is null when the plugin is initially created, but
        // initialized on the first update.
        this.value = null;
    }
    update(view) {
        if (!this.value) {
            if (this.spec) {
                try {
                    this.value = this.spec.create(view);
                }
                catch (e) {
                    logException(view.state, e, "CodeMirror plugin crashed");
                    this.deactivate();
                }
            }
        }
        else if (this.mustUpdate) {
            let update = this.mustUpdate;
            this.mustUpdate = null;
            if (this.value.update) {
                try {
                    this.value.update(update);
                }
                catch (e) {
                    logException(update.state, e, "CodeMirror plugin crashed");
                    if (this.value.destroy)
                        try {
                            this.value.destroy();
                        }
                        catch (_) { }
                    this.deactivate();
                }
            }
        }
        return this;
    }
    destroy(view) {
        var _a;
        if ((_a = this.value) === null || _a === void 0 ? void 0 : _a.destroy) {
            try {
                this.value.destroy();
            }
            catch (e) {
                logException(view.state, e, "CodeMirror plugin crashed");
            }
        }
    }
    deactivate() {
        this.spec = this.value = null;
    }
}
const editorAttributes = /*@__PURE__*/state_dist/* Facet.define */.r$.define();
const contentAttributes = /*@__PURE__*/state_dist/* Facet.define */.r$.define();
// Provide decorations
const decorations = /*@__PURE__*/state_dist/* Facet.define */.r$.define();
const atomicRanges = /*@__PURE__*/state_dist/* Facet.define */.r$.define();
const scrollMargins = /*@__PURE__*/state_dist/* Facet.define */.r$.define();
const styleModule = /*@__PURE__*/state_dist/* Facet.define */.r$.define();
class ChangedRange {
    constructor(fromA, toA, fromB, toB) {
        this.fromA = fromA;
        this.toA = toA;
        this.fromB = fromB;
        this.toB = toB;
    }
    join(other) {
        return new ChangedRange(Math.min(this.fromA, other.fromA), Math.max(this.toA, other.toA), Math.min(this.fromB, other.fromB), Math.max(this.toB, other.toB));
    }
    addToSet(set) {
        let i = set.length, me = this;
        for (; i > 0; i--) {
            let range = set[i - 1];
            if (range.fromA > me.toA)
                continue;
            if (range.toA < me.fromA)
                break;
            me = me.join(range);
            set.splice(i - 1, 1);
        }
        set.splice(i, 0, me);
        return set;
    }
    static extendWithRanges(diff, ranges) {
        if (ranges.length == 0)
            return diff;
        let result = [];
        for (let dI = 0, rI = 0, posA = 0, posB = 0;; dI++) {
            let next = dI == diff.length ? null : diff[dI], off = posA - posB;
            let end = next ? next.fromB : 1e9;
            while (rI < ranges.length && ranges[rI] < end) {
                let from = ranges[rI], to = ranges[rI + 1];
                let fromB = Math.max(posB, from), toB = Math.min(end, to);
                if (fromB <= toB)
                    new ChangedRange(fromB + off, toB + off, fromB, toB).addToSet(result);
                if (to > end)
                    break;
                else
                    rI += 2;
            }
            if (!next)
                return result;
            new ChangedRange(next.fromA, next.toA, next.fromB, next.toB).addToSet(result);
            posA = next.toA;
            posB = next.toB;
        }
    }
}
/**
View [plugins](https://codemirror.net/6/docs/ref/#view.ViewPlugin) are given instances of this
class, which describe what happened, whenever the view is updated.
*/
class ViewUpdate {
    constructor(
    /**
    The editor view that the update is associated with.
    */
    view, 
    /**
    The new editor state.
    */
    state, 
    /**
    The transactions involved in the update. May be empty.
    */
    transactions) {
        this.view = view;
        this.state = state;
        this.transactions = transactions;
        /**
        @internal
        */
        this.flags = 0;
        this.startState = view.state;
        this.changes = state_dist/* ChangeSet.empty */.as.empty(this.startState.doc.length);
        for (let tr of transactions)
            this.changes = this.changes.compose(tr.changes);
        let changedRanges = [];
        this.changes.iterChangedRanges((fromA, toA, fromB, toB) => changedRanges.push(new ChangedRange(fromA, toA, fromB, toB)));
        this.changedRanges = changedRanges;
        let focus = view.hasFocus;
        if (focus != view.inputState.notifiedFocused) {
            view.inputState.notifiedFocused = focus;
            this.flags |= 1 /* UpdateFlag.Focus */;
        }
    }
    /**
    @internal
    */
    static create(view, state, transactions) {
        return new ViewUpdate(view, state, transactions);
    }
    /**
    Tells you whether the [viewport](https://codemirror.net/6/docs/ref/#view.EditorView.viewport) or
    [visible ranges](https://codemirror.net/6/docs/ref/#view.EditorView.visibleRanges) changed in this
    update.
    */
    get viewportChanged() {
        return (this.flags & 4 /* UpdateFlag.Viewport */) > 0;
    }
    /**
    Indicates whether the height of a block element in the editor
    changed in this update.
    */
    get heightChanged() {
        return (this.flags & 2 /* UpdateFlag.Height */) > 0;
    }
    /**
    Returns true when the document was modified or the size of the
    editor, or elements within the editor, changed.
    */
    get geometryChanged() {
        return this.docChanged || (this.flags & (8 /* UpdateFlag.Geometry */ | 2 /* UpdateFlag.Height */)) > 0;
    }
    /**
    True when this update indicates a focus change.
    */
    get focusChanged() {
        return (this.flags & 1 /* UpdateFlag.Focus */) > 0;
    }
    /**
    Whether the document changed in this update.
    */
    get docChanged() {
        return !this.changes.empty;
    }
    /**
    Whether the selection was explicitly set in this update.
    */
    get selectionSet() {
        return this.transactions.some(tr => tr.selection);
    }
    /**
    @internal
    */
    get empty() { return this.flags == 0 && this.transactions.length == 0; }
}

/**
Used to indicate [text direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection).
*/
var Direction = /*@__PURE__*/(function (Direction) {
    // (These are chosen to match the base levels, in bidi algorithm
    // terms, of spans in that direction.)
    /**
    Left-to-right.
    */
    Direction[Direction["LTR"] = 0] = "LTR";
    /**
    Right-to-left.
    */
    Direction[Direction["RTL"] = 1] = "RTL";
return Direction})(Direction || (Direction = {}));
const LTR = Direction.LTR, RTL = Direction.RTL;
// Decode a string with each type encoded as log2(type)
function dec(str) {
    let result = [];
    for (let i = 0; i < str.length; i++)
        result.push(1 << +str[i]);
    return result;
}
// Character types for codepoints 0 to 0xf8
const LowTypes = /*@__PURE__*/dec("88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008");
// Character types for codepoints 0x600 to 0x6f9
const ArabicTypes = /*@__PURE__*/dec("4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333");
const Brackets = /*@__PURE__*/Object.create(null), BracketStack = [];
// There's a lot more in
// https://www.unicode.org/Public/UCD/latest/ucd/BidiBrackets.txt,
// which are left out to keep code size down.
for (let p of ["()", "[]", "{}"]) {
    let l = /*@__PURE__*/p.charCodeAt(0), r = /*@__PURE__*/p.charCodeAt(1);
    Brackets[l] = r;
    Brackets[r] = -l;
}
function charType(ch) {
    return ch <= 0xf7 ? LowTypes[ch] :
        0x590 <= ch && ch <= 0x5f4 ? 2 /* T.R */ :
            0x600 <= ch && ch <= 0x6f9 ? ArabicTypes[ch - 0x600] :
                0x6ee <= ch && ch <= 0x8ac ? 4 /* T.AL */ :
                    0x2000 <= ch && ch <= 0x200b ? 256 /* T.NI */ :
                        0xfb50 <= ch && ch <= 0xfdff ? 4 /* T.AL */ :
                            ch == 0x200c ? 256 /* T.NI */ : 1 /* T.L */;
}
const BidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/;
/**
Represents a contiguous range of text that has a single direction
(as in left-to-right or right-to-left).
*/
class BidiSpan {
    /**
    @internal
    */
    constructor(
    /**
    The start of the span (relative to the start of the line).
    */
    from, 
    /**
    The end of the span.
    */
    to, 
    /**
    The ["bidi
    level"](https://unicode.org/reports/tr9/#Basic_Display_Algorithm)
    of the span (in this context, 0 means
    left-to-right, 1 means right-to-left, 2 means left-to-right
    number inside right-to-left text).
    */
    level) {
        this.from = from;
        this.to = to;
        this.level = level;
    }
    /**
    The direction of this span.
    */
    get dir() { return this.level % 2 ? RTL : LTR; }
    /**
    @internal
    */
    side(end, dir) { return (this.dir == dir) == end ? this.to : this.from; }
    /**
    @internal
    */
    static find(order, index, level, assoc) {
        let maybe = -1;
        for (let i = 0; i < order.length; i++) {
            let span = order[i];
            if (span.from <= index && span.to >= index) {
                if (span.level == level)
                    return i;
                // When multiple spans match, if assoc != 0, take the one that
                // covers that side, otherwise take the one with the minimum
                // level.
                if (maybe < 0 || (assoc != 0 ? (assoc < 0 ? span.from < index : span.to > index) : order[maybe].level > span.level))
                    maybe = i;
            }
        }
        if (maybe < 0)
            throw new RangeError("Index out of range");
        return maybe;
    }
}
// Reused array of character types
const types = [];
function computeOrder(line, direction) {
    let len = line.length, outerType = direction == LTR ? 1 /* T.L */ : 2 /* T.R */, oppositeType = direction == LTR ? 2 /* T.R */ : 1 /* T.L */;
    if (!line || outerType == 1 /* T.L */ && !BidiRE.test(line))
        return trivialOrder(len);
    // W1. Examine each non-spacing mark (NSM) in the level run, and
    // change the type of the NSM to the type of the previous
    // character. If the NSM is at the start of the level run, it will
    // get the type of sor.
    // W2. Search backwards from each instance of a European number
    // until the first strong type (R, L, AL, or sor) is found. If an
    // AL is found, change the type of the European number to Arabic
    // number.
    // W3. Change all ALs to R.
    // (Left after this: L, R, EN, AN, ET, CS, NI)
    for (let i = 0, prev = outerType, prevStrong = outerType; i < len; i++) {
        let type = charType(line.charCodeAt(i));
        if (type == 512 /* T.NSM */)
            type = prev;
        else if (type == 8 /* T.EN */ && prevStrong == 4 /* T.AL */)
            type = 16 /* T.AN */;
        types[i] = type == 4 /* T.AL */ ? 2 /* T.R */ : type;
        if (type & 7 /* T.Strong */)
            prevStrong = type;
        prev = type;
    }
    // W5. A sequence of European terminators adjacent to European
    // numbers changes to all European numbers.
    // W6. Otherwise, separators and terminators change to Other
    // Neutral.
    // W7. Search backwards from each instance of a European number
    // until the first strong type (R, L, or sor) is found. If an L is
    // found, then change the type of the European number to L.
    // (Left after this: L, R, EN+AN, NI)
    for (let i = 0, prev = outerType, prevStrong = outerType; i < len; i++) {
        let type = types[i];
        if (type == 128 /* T.CS */) {
            if (i < len - 1 && prev == types[i + 1] && (prev & 24 /* T.Num */))
                type = types[i] = prev;
            else
                types[i] = 256 /* T.NI */;
        }
        else if (type == 64 /* T.ET */) {
            let end = i + 1;
            while (end < len && types[end] == 64 /* T.ET */)
                end++;
            let replace = (i && prev == 8 /* T.EN */) || (end < len && types[end] == 8 /* T.EN */) ? (prevStrong == 1 /* T.L */ ? 1 /* T.L */ : 8 /* T.EN */) : 256 /* T.NI */;
            for (let j = i; j < end; j++)
                types[j] = replace;
            i = end - 1;
        }
        else if (type == 8 /* T.EN */ && prevStrong == 1 /* T.L */) {
            types[i] = 1 /* T.L */;
        }
        prev = type;
        if (type & 7 /* T.Strong */)
            prevStrong = type;
    }
    // N0. Process bracket pairs in an isolating run sequence
    // sequentially in the logical order of the text positions of the
    // opening paired brackets using the logic given below. Within this
    // scope, bidirectional types EN and AN are treated as R.
    for (let i = 0, sI = 0, context = 0, ch, br, type; i < len; i++) {
        // Keeps [startIndex, type, strongSeen] triples for each open
        // bracket on BracketStack.
        if (br = Brackets[ch = line.charCodeAt(i)]) {
            if (br < 0) { // Closing bracket
                for (let sJ = sI - 3; sJ >= 0; sJ -= 3) {
                    if (BracketStack[sJ + 1] == -br) {
                        let flags = BracketStack[sJ + 2];
                        let type = (flags & 2 /* Bracketed.EmbedInside */) ? outerType :
                            !(flags & 4 /* Bracketed.OppositeInside */) ? 0 :
                                (flags & 1 /* Bracketed.OppositeBefore */) ? oppositeType : outerType;
                        if (type)
                            types[i] = types[BracketStack[sJ]] = type;
                        sI = sJ;
                        break;
                    }
                }
            }
            else if (BracketStack.length == 189 /* Bracketed.MaxDepth */) {
                break;
            }
            else {
                BracketStack[sI++] = i;
                BracketStack[sI++] = ch;
                BracketStack[sI++] = context;
            }
        }
        else if ((type = types[i]) == 2 /* T.R */ || type == 1 /* T.L */) {
            let embed = type == outerType;
            context = embed ? 0 : 1 /* Bracketed.OppositeBefore */;
            for (let sJ = sI - 3; sJ >= 0; sJ -= 3) {
                let cur = BracketStack[sJ + 2];
                if (cur & 2 /* Bracketed.EmbedInside */)
                    break;
                if (embed) {
                    BracketStack[sJ + 2] |= 2 /* Bracketed.EmbedInside */;
                }
                else {
                    if (cur & 4 /* Bracketed.OppositeInside */)
                        break;
                    BracketStack[sJ + 2] |= 4 /* Bracketed.OppositeInside */;
                }
            }
        }
    }
    // N1. A sequence of neutrals takes the direction of the
    // surrounding strong text if the text on both sides has the same
    // direction. European and Arabic numbers act as if they were R in
    // terms of their influence on neutrals. Start-of-level-run (sor)
    // and end-of-level-run (eor) are used at level run boundaries.
    // N2. Any remaining neutrals take the embedding direction.
    // (Left after this: L, R, EN+AN)
    for (let i = 0; i < len; i++) {
        if (types[i] == 256 /* T.NI */) {
            let end = i + 1;
            while (end < len && types[end] == 256 /* T.NI */)
                end++;
            let beforeL = (i ? types[i - 1] : outerType) == 1 /* T.L */;
            let afterL = (end < len ? types[end] : outerType) == 1 /* T.L */;
            let replace = beforeL == afterL ? (beforeL ? 1 /* T.L */ : 2 /* T.R */) : outerType;
            for (let j = i; j < end; j++)
                types[j] = replace;
            i = end - 1;
        }
    }
    // Here we depart from the documented algorithm, in order to avoid
    // building up an actual levels array. Since there are only three
    // levels (0, 1, 2) in an implementation that doesn't take
    // explicit embedding into account, we can build up the order on
    // the fly, without following the level-based algorithm.
    let order = [];
    if (outerType == 1 /* T.L */) {
        for (let i = 0; i < len;) {
            let start = i, rtl = types[i++] != 1 /* T.L */;
            while (i < len && rtl == (types[i] != 1 /* T.L */))
                i++;
            if (rtl) {
                for (let j = i; j > start;) {
                    let end = j, l = types[--j] != 2 /* T.R */;
                    while (j > start && l == (types[j - 1] != 2 /* T.R */))
                        j--;
                    order.push(new BidiSpan(j, end, l ? 2 : 1));
                }
            }
            else {
                order.push(new BidiSpan(start, i, 0));
            }
        }
    }
    else {
        for (let i = 0; i < len;) {
            let start = i, rtl = types[i++] == 2 /* T.R */;
            while (i < len && rtl == (types[i] == 2 /* T.R */))
                i++;
            order.push(new BidiSpan(start, i, rtl ? 1 : 2));
        }
    }
    return order;
}
function trivialOrder(length) {
    return [new BidiSpan(0, length, 0)];
}
let movedOver = "";
function moveVisually(line, order, dir, start, forward) {
    var _a;
    let startIndex = start.head - line.from, spanI = -1;
    if (startIndex == 0) {
        if (!forward || !line.length)
            return null;
        if (order[0].level != dir) {
            startIndex = order[0].side(false, dir);
            spanI = 0;
        }
    }
    else if (startIndex == line.length) {
        if (forward)
            return null;
        let last = order[order.length - 1];
        if (last.level != dir) {
            startIndex = last.side(true, dir);
            spanI = order.length - 1;
        }
    }
    if (spanI < 0)
        spanI = BidiSpan.find(order, startIndex, (_a = start.bidiLevel) !== null && _a !== void 0 ? _a : -1, start.assoc);
    let span = order[spanI];
    // End of span. (But not end of line--that was checked for above.)
    if (startIndex == span.side(forward, dir)) {
        span = order[spanI += forward ? 1 : -1];
        startIndex = span.side(!forward, dir);
    }
    let indexForward = forward == (span.dir == dir);
    let nextIndex = (0,state_dist/* findClusterBreak */.cp)(line.text, startIndex, indexForward);
    movedOver = line.text.slice(Math.min(startIndex, nextIndex), Math.max(startIndex, nextIndex));
    if (nextIndex != span.side(forward, dir))
        return state_dist/* EditorSelection.cursor */.jT.cursor(nextIndex + line.from, indexForward ? -1 : 1, span.level);
    let nextSpan = spanI == (forward ? order.length - 1 : 0) ? null : order[spanI + (forward ? 1 : -1)];
    if (!nextSpan && span.level != dir)
        return state_dist/* EditorSelection.cursor */.jT.cursor(forward ? line.to : line.from, forward ? -1 : 1, dir);
    if (nextSpan && nextSpan.level < span.level)
        return state_dist/* EditorSelection.cursor */.jT.cursor(nextSpan.side(!forward, dir) + line.from, forward ? 1 : -1, nextSpan.level);
    return state_dist/* EditorSelection.cursor */.jT.cursor(nextIndex + line.from, forward ? -1 : 1, span.level);
}

const LineBreakPlaceholder = "\uffff";
class DOMReader {
    constructor(points, state) {
        this.points = points;
        this.text = "";
        this.lineSeparator = state.facet(state_dist/* EditorState.lineSeparator */.yy.lineSeparator);
    }
    append(text) {
        this.text += text;
    }
    lineBreak() {
        this.text += LineBreakPlaceholder;
    }
    readRange(start, end) {
        if (!start)
            return this;
        let parent = start.parentNode;
        for (let cur = start;;) {
            this.findPointBefore(parent, cur);
            this.readNode(cur);
            let next = cur.nextSibling;
            if (next == end)
                break;
            let view = ContentView.get(cur), nextView = ContentView.get(next);
            if (view && nextView ? view.breakAfter :
                (view ? view.breakAfter : isBlockElement(cur)) ||
                    (isBlockElement(next) && (cur.nodeName != "BR" || cur.cmIgnore)))
                this.lineBreak();
            cur = next;
        }
        this.findPointBefore(parent, end);
        return this;
    }
    readTextNode(node) {
        let text = node.nodeValue;
        for (let point of this.points)
            if (point.node == node)
                point.pos = this.text.length + Math.min(point.offset, text.length);
        for (let off = 0, re = this.lineSeparator ? null : /\r\n?|\n/g;;) {
            let nextBreak = -1, breakSize = 1, m;
            if (this.lineSeparator) {
                nextBreak = text.indexOf(this.lineSeparator, off);
                breakSize = this.lineSeparator.length;
            }
            else if (m = re.exec(text)) {
                nextBreak = m.index;
                breakSize = m[0].length;
            }
            this.append(text.slice(off, nextBreak < 0 ? text.length : nextBreak));
            if (nextBreak < 0)
                break;
            this.lineBreak();
            if (breakSize > 1)
                for (let point of this.points)
                    if (point.node == node && point.pos > this.text.length)
                        point.pos -= breakSize - 1;
            off = nextBreak + breakSize;
        }
    }
    readNode(node) {
        if (node.cmIgnore)
            return;
        let view = ContentView.get(node);
        let fromView = view && view.overrideDOMText;
        if (fromView != null) {
            this.findPointInside(node, fromView.length);
            for (let i = fromView.iter(); !i.next().done;) {
                if (i.lineBreak)
                    this.lineBreak();
                else
                    this.append(i.value);
            }
        }
        else if (node.nodeType == 3) {
            this.readTextNode(node);
        }
        else if (node.nodeName == "BR") {
            if (node.nextSibling)
                this.lineBreak();
        }
        else if (node.nodeType == 1) {
            this.readRange(node.firstChild, null);
        }
    }
    findPointBefore(node, next) {
        for (let point of this.points)
            if (point.node == node && node.childNodes[point.offset] == next)
                point.pos = this.text.length;
    }
    findPointInside(node, maxLen) {
        for (let point of this.points)
            if (node.nodeType == 3 ? point.node == node : node.contains(point.node))
                point.pos = this.text.length + Math.min(maxLen, point.offset);
    }
}
function isBlockElement(node) {
    return node.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(node.nodeName);
}
class DOMPoint {
    constructor(node, offset) {
        this.node = node;
        this.offset = offset;
        this.pos = -1;
    }
}

class DocView extends ContentView {
    constructor(view) {
        super();
        this.view = view;
        this.compositionDeco = Decoration.none;
        this.decorations = [];
        this.dynamicDecorationMap = [];
        // Track a minimum width for the editor. When measuring sizes in
        // measureVisibleLineHeights, this is updated to point at the width
        // of a given element and its extent in the document. When a change
        // happens in that range, these are reset. That way, once we've seen
        // a line/element of a given length, we keep the editor wide enough
        // to fit at least that element, until it is changed, at which point
        // we forget it again.
        this.minWidth = 0;
        this.minWidthFrom = 0;
        this.minWidthTo = 0;
        // Track whether the DOM selection was set in a lossy way, so that
        // we don't mess it up when reading it back it
        this.impreciseAnchor = null;
        this.impreciseHead = null;
        this.forceSelection = false;
        // Used by the resize observer to ignore resizes that we caused
        // ourselves
        this.lastUpdate = Date.now();
        this.setDOM(view.contentDOM);
        this.children = [new LineView];
        this.children[0].setParent(this);
        this.updateDeco();
        this.updateInner([new ChangedRange(0, 0, 0, view.state.doc.length)], 0);
    }
    get editorView() { return this.view; }
    get length() { return this.view.state.doc.length; }
    // Update the document view to a given state. scrollIntoView can be
    // used as a hint to compute a new viewport that includes that
    // position, if we know the editor is going to scroll that position
    // into view.
    update(update) {
        let changedRanges = update.changedRanges;
        if (this.minWidth > 0 && changedRanges.length) {
            if (!changedRanges.every(({ fromA, toA }) => toA < this.minWidthFrom || fromA > this.minWidthTo)) {
                this.minWidth = this.minWidthFrom = this.minWidthTo = 0;
            }
            else {
                this.minWidthFrom = update.changes.mapPos(this.minWidthFrom, 1);
                this.minWidthTo = update.changes.mapPos(this.minWidthTo, 1);
            }
        }
        if (this.view.inputState.composing < 0)
            this.compositionDeco = Decoration.none;
        else if (update.transactions.length || this.dirty)
            this.compositionDeco = computeCompositionDeco(this.view, update.changes);
        // When the DOM nodes around the selection are moved to another
        // parent, Chrome sometimes reports a different selection through
        // getSelection than the one that it actually shows to the user.
        // This forces a selection update when lines are joined to work
        // around that. Issue #54
        if ((browser.ie || browser.chrome) && !this.compositionDeco.size && update &&
            update.state.doc.lines != update.startState.doc.lines)
            this.forceSelection = true;
        let prevDeco = this.decorations, deco = this.updateDeco();
        let decoDiff = findChangedDeco(prevDeco, deco, update.changes);
        changedRanges = ChangedRange.extendWithRanges(changedRanges, decoDiff);
        if (this.dirty == 0 /* Dirty.Not */ && changedRanges.length == 0) {
            return false;
        }
        else {
            this.updateInner(changedRanges, update.startState.doc.length);
            if (update.transactions.length)
                this.lastUpdate = Date.now();
            return true;
        }
    }
    // Used by update and the constructor do perform the actual DOM
    // update
    updateInner(changes, oldLength) {
        this.view.viewState.mustMeasureContent = true;
        this.updateChildren(changes, oldLength);
        let { observer } = this.view;
        observer.ignore(() => {
            // Lock the height during redrawing, since Chrome sometimes
            // messes with the scroll position during DOM mutation (though
            // no relayout is triggered and I cannot imagine how it can
            // recompute the scroll position without a layout)
            this.dom.style.height = this.view.viewState.contentHeight + "px";
            this.dom.style.flexBasis = this.minWidth ? this.minWidth + "px" : "";
            // Chrome will sometimes, when DOM mutations occur directly
            // around the selection, get confused and report a different
            // selection from the one it displays (issue #218). This tries
            // to detect that situation.
            let track = browser.chrome || browser.ios ? { node: observer.selectionRange.focusNode, written: false } : undefined;
            this.sync(track);
            this.dirty = 0 /* Dirty.Not */;
            if (track && (track.written || observer.selectionRange.focusNode != track.node))
                this.forceSelection = true;
            this.dom.style.height = "";
        });
        let gaps = [];
        if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length)
            for (let child of this.children)
                if (child instanceof BlockWidgetView && child.widget instanceof BlockGapWidget)
                    gaps.push(child.dom);
        observer.updateGaps(gaps);
    }
    updateChildren(changes, oldLength) {
        let cursor = this.childCursor(oldLength);
        for (let i = changes.length - 1;; i--) {
            let next = i >= 0 ? changes[i] : null;
            if (!next)
                break;
            let { fromA, toA, fromB, toB } = next;
            let { content, breakAtStart, openStart, openEnd } = ContentBuilder.build(this.view.state.doc, fromB, toB, this.decorations, this.dynamicDecorationMap);
            let { i: toI, off: toOff } = cursor.findPos(toA, 1);
            let { i: fromI, off: fromOff } = cursor.findPos(fromA, -1);
            replaceRange(this, fromI, fromOff, toI, toOff, content, breakAtStart, openStart, openEnd);
        }
    }
    // Sync the DOM selection to this.state.selection
    updateSelection(mustRead = false, fromPointer = false) {
        if (mustRead || !this.view.observer.selectionRange.focusNode)
            this.view.observer.readSelectionRange();
        if (!(fromPointer || this.mayControlSelection()))
            return;
        let force = this.forceSelection;
        this.forceSelection = false;
        let main = this.view.state.selection.main;
        // FIXME need to handle the case where the selection falls inside a block range
        let anchor = this.domAtPos(main.anchor);
        let head = main.empty ? anchor : this.domAtPos(main.head);
        // Always reset on Firefox when next to an uneditable node to
        // avoid invisible cursor bugs (#111)
        if (browser.gecko && main.empty && betweenUneditable(anchor)) {
            let dummy = document.createTextNode("");
            this.view.observer.ignore(() => anchor.node.insertBefore(dummy, anchor.node.childNodes[anchor.offset] || null));
            anchor = head = new DOMPos(dummy, 0);
            force = true;
        }
        let domSel = this.view.observer.selectionRange;
        // If the selection is already here, or in an equivalent position, don't touch it
        if (force || !domSel.focusNode ||
            !isEquivalentPosition(anchor.node, anchor.offset, domSel.anchorNode, domSel.anchorOffset) ||
            !isEquivalentPosition(head.node, head.offset, domSel.focusNode, domSel.focusOffset)) {
            this.view.observer.ignore(() => {
                // Chrome Android will hide the virtual keyboard when tapping
                // inside an uneditable node, and not bring it back when we
                // move the cursor to its proper position. This tries to
                // restore the keyboard by cycling focus.
                if (browser.android && browser.chrome && this.dom.contains(domSel.focusNode) &&
                    inUneditable(domSel.focusNode, this.dom)) {
                    this.dom.blur();
                    this.dom.focus({ preventScroll: true });
                }
                let rawSel = getSelection(this.view.root);
                if (!rawSel) ;
                else if (main.empty) {
                    // Work around https://bugzilla.mozilla.org/show_bug.cgi?id=1612076
                    if (browser.gecko) {
                        let nextTo = nextToUneditable(anchor.node, anchor.offset);
                        if (nextTo && nextTo != (1 /* NextTo.Before */ | 2 /* NextTo.After */)) {
                            let text = nearbyTextNode(anchor.node, anchor.offset, nextTo == 1 /* NextTo.Before */ ? 1 : -1);
                            if (text)
                                anchor = new DOMPos(text, nextTo == 1 /* NextTo.Before */ ? 0 : text.nodeValue.length);
                        }
                    }
                    rawSel.collapse(anchor.node, anchor.offset);
                    if (main.bidiLevel != null && domSel.cursorBidiLevel != null)
                        domSel.cursorBidiLevel = main.bidiLevel;
                }
                else if (rawSel.extend) {
                    // Selection.extend can be used to create an 'inverted' selection
                    // (one where the focus is before the anchor), but not all
                    // browsers support it yet.
                    rawSel.collapse(anchor.node, anchor.offset);
                    // Safari will ignore the call above when the editor is
                    // hidden, and then raise an error on the call to extend
                    // (#940).
                    try {
                        rawSel.extend(head.node, head.offset);
                    }
                    catch (_) { }
                }
                else {
                    // Primitive (IE) way
                    let range = document.createRange();
                    if (main.anchor > main.head)
                        [anchor, head] = [head, anchor];
                    range.setEnd(head.node, head.offset);
                    range.setStart(anchor.node, anchor.offset);
                    rawSel.removeAllRanges();
                    rawSel.addRange(range);
                }
            });
            this.view.observer.setSelectionRange(anchor, head);
        }
        this.impreciseAnchor = anchor.precise ? null : new DOMPos(domSel.anchorNode, domSel.anchorOffset);
        this.impreciseHead = head.precise ? null : new DOMPos(domSel.focusNode, domSel.focusOffset);
    }
    enforceCursorAssoc() {
        if (this.compositionDeco.size)
            return;
        let cursor = this.view.state.selection.main;
        let sel = getSelection(this.view.root);
        if (!sel || !cursor.empty || !cursor.assoc || !sel.modify)
            return;
        let line = LineView.find(this, cursor.head);
        if (!line)
            return;
        let lineStart = line.posAtStart;
        if (cursor.head == lineStart || cursor.head == lineStart + line.length)
            return;
        let before = this.coordsAt(cursor.head, -1), after = this.coordsAt(cursor.head, 1);
        if (!before || !after || before.bottom > after.top)
            return;
        let dom = this.domAtPos(cursor.head + cursor.assoc);
        sel.collapse(dom.node, dom.offset);
        sel.modify("move", cursor.assoc < 0 ? "forward" : "backward", "lineboundary");
    }
    mayControlSelection() {
        let active = this.view.root.activeElement;
        return active == this.dom ||
            hasSelection(this.dom, this.view.observer.selectionRange) && !(active && this.dom.contains(active));
    }
    nearest(dom) {
        for (let cur = dom; cur;) {
            let domView = ContentView.get(cur);
            if (domView && domView.rootView == this)
                return domView;
            cur = cur.parentNode;
        }
        return null;
    }
    posFromDOM(node, offset) {
        let view = this.nearest(node);
        if (!view)
            throw new RangeError("Trying to find position for a DOM position outside of the document");
        return view.localPosFromDOM(node, offset) + view.posAtStart;
    }
    domAtPos(pos) {
        let { i, off } = this.childCursor().findPos(pos, -1);
        for (; i < this.children.length - 1;) {
            let child = this.children[i];
            if (off < child.length || child instanceof LineView)
                break;
            i++;
            off = 0;
        }
        return this.children[i].domAtPos(off);
    }
    coordsAt(pos, side) {
        for (let off = this.length, i = this.children.length - 1;; i--) {
            let child = this.children[i], start = off - child.breakAfter - child.length;
            if (pos > start ||
                (pos == start && child.type != BlockType.WidgetBefore && child.type != BlockType.WidgetAfter &&
                    (!i || side == 2 || this.children[i - 1].breakAfter ||
                        (this.children[i - 1].type == BlockType.WidgetBefore && side > -2))))
                return child.coordsAt(pos - start, side);
            off = start;
        }
    }
    measureVisibleLineHeights(viewport) {
        let result = [], { from, to } = viewport;
        let contentWidth = this.view.contentDOM.clientWidth;
        let isWider = contentWidth > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1;
        let widest = -1, ltr = this.view.textDirection == Direction.LTR;
        for (let pos = 0, i = 0; i < this.children.length; i++) {
            let child = this.children[i], end = pos + child.length;
            if (end > to)
                break;
            if (pos >= from) {
                let childRect = child.dom.getBoundingClientRect();
                result.push(childRect.height);
                if (isWider) {
                    let last = child.dom.lastChild;
                    let rects = last ? clientRectsFor(last) : [];
                    if (rects.length) {
                        let rect = rects[rects.length - 1];
                        let width = ltr ? rect.right - childRect.left : childRect.right - rect.left;
                        if (width > widest) {
                            widest = width;
                            this.minWidth = contentWidth;
                            this.minWidthFrom = pos;
                            this.minWidthTo = end;
                        }
                    }
                }
            }
            pos = end + child.breakAfter;
        }
        return result;
    }
    textDirectionAt(pos) {
        let { i } = this.childPos(pos, 1);
        return getComputedStyle(this.children[i].dom).direction == "rtl" ? Direction.RTL : Direction.LTR;
    }
    measureTextSize() {
        for (let child of this.children) {
            if (child instanceof LineView) {
                let measure = child.measureTextSize();
                if (measure)
                    return measure;
            }
        }
        // If no workable line exists, force a layout of a measurable element
        let dummy = document.createElement("div"), lineHeight, charWidth;
        dummy.className = "cm-line";
        dummy.style.width = "99999px";
        dummy.textContent = "abc def ghi jkl mno pqr stu";
        this.view.observer.ignore(() => {
            this.dom.appendChild(dummy);
            let rect = clientRectsFor(dummy.firstChild)[0];
            lineHeight = dummy.getBoundingClientRect().height;
            charWidth = rect ? rect.width / 27 : 7;
            dummy.remove();
        });
        return { lineHeight, charWidth };
    }
    childCursor(pos = this.length) {
        // Move back to start of last element when possible, so that
        // `ChildCursor.findPos` doesn't have to deal with the edge case
        // of being after the last element.
        let i = this.children.length;
        if (i)
            pos -= this.children[--i].length;
        return new ChildCursor(this.children, pos, i);
    }
    computeBlockGapDeco() {
        let deco = [], vs = this.view.viewState;
        for (let pos = 0, i = 0;; i++) {
            let next = i == vs.viewports.length ? null : vs.viewports[i];
            let end = next ? next.from - 1 : this.length;
            if (end > pos) {
                let height = vs.lineBlockAt(end).bottom - vs.lineBlockAt(pos).top;
                deco.push(Decoration.replace({
                    widget: new BlockGapWidget(height),
                    block: true,
                    inclusive: true,
                    isBlockGap: true,
                }).range(pos, end));
            }
            if (!next)
                break;
            pos = next.to + 1;
        }
        return Decoration.set(deco);
    }
    updateDeco() {
        let allDeco = this.view.state.facet(decorations).map((d, i) => {
            let dynamic = this.dynamicDecorationMap[i] = typeof d == "function";
            return dynamic ? d(this.view) : d;
        });
        for (let i = allDeco.length; i < allDeco.length + 3; i++)
            this.dynamicDecorationMap[i] = false;
        return this.decorations = [
            ...allDeco,
            this.compositionDeco,
            this.computeBlockGapDeco(),
            this.view.viewState.lineGapDeco
        ];
    }
    scrollIntoView(target) {
        let { range } = target;
        let rect = this.coordsAt(range.head, range.empty ? range.assoc : range.head > range.anchor ? -1 : 1), other;
        if (!rect)
            return;
        if (!range.empty && (other = this.coordsAt(range.anchor, range.anchor > range.head ? -1 : 1)))
            rect = { left: Math.min(rect.left, other.left), top: Math.min(rect.top, other.top),
                right: Math.max(rect.right, other.right), bottom: Math.max(rect.bottom, other.bottom) };
        let mLeft = 0, mRight = 0, mTop = 0, mBottom = 0;
        for (let margins of this.view.state.facet(scrollMargins).map(f => f(this.view)))
            if (margins) {
                let { left, right, top, bottom } = margins;
                if (left != null)
                    mLeft = Math.max(mLeft, left);
                if (right != null)
                    mRight = Math.max(mRight, right);
                if (top != null)
                    mTop = Math.max(mTop, top);
                if (bottom != null)
                    mBottom = Math.max(mBottom, bottom);
            }
        let targetRect = {
            left: rect.left - mLeft, top: rect.top - mTop,
            right: rect.right + mRight, bottom: rect.bottom + mBottom
        };
        scrollRectIntoView(this.view.scrollDOM, targetRect, range.head < range.anchor ? -1 : 1, target.x, target.y, target.xMargin, target.yMargin, this.view.textDirection == Direction.LTR);
    }
}
function betweenUneditable(pos) {
    return pos.node.nodeType == 1 && pos.node.firstChild &&
        (pos.offset == 0 || pos.node.childNodes[pos.offset - 1].contentEditable == "false") &&
        (pos.offset == pos.node.childNodes.length || pos.node.childNodes[pos.offset].contentEditable == "false");
}
class BlockGapWidget extends WidgetType {
    constructor(height) {
        super();
        this.height = height;
    }
    toDOM() {
        let elt = document.createElement("div");
        this.updateDOM(elt);
        return elt;
    }
    eq(other) { return other.height == this.height; }
    updateDOM(elt) {
        elt.style.height = this.height + "px";
        return true;
    }
    get estimatedHeight() { return this.height; }
}
function compositionSurroundingNode(view) {
    let sel = view.observer.selectionRange;
    let textNode = sel.focusNode && nearbyTextNode(sel.focusNode, sel.focusOffset, 0);
    if (!textNode)
        return null;
    let cView = view.docView.nearest(textNode);
    if (!cView)
        return null;
    if (cView instanceof LineView) {
        let topNode = textNode;
        while (topNode.parentNode != cView.dom)
            topNode = topNode.parentNode;
        let prev = topNode.previousSibling;
        while (prev && !ContentView.get(prev))
            prev = prev.previousSibling;
        let pos = prev ? ContentView.get(prev).posAtEnd : cView.posAtStart;
        return { from: pos, to: pos, node: topNode, text: textNode };
    }
    else {
        for (;;) {
            let { parent } = cView;
            if (!parent)
                return null;
            if (parent instanceof LineView)
                break;
            cView = parent;
        }
        let from = cView.posAtStart;
        return { from, to: from + cView.length, node: cView.dom, text: textNode };
    }
}
function computeCompositionDeco(view, changes) {
    let surrounding = compositionSurroundingNode(view);
    if (!surrounding)
        return Decoration.none;
    let { from, to, node, text: textNode } = surrounding;
    let newFrom = changes.mapPos(from, 1), newTo = Math.max(newFrom, changes.mapPos(to, -1));
    let { state } = view, text = node.nodeType == 3 ? node.nodeValue :
        new DOMReader([], state).readRange(node.firstChild, null).text;
    if (newTo - newFrom < text.length) {
        if (state.doc.sliceString(newFrom, Math.min(state.doc.length, newFrom + text.length), LineBreakPlaceholder) == text)
            newTo = newFrom + text.length;
        else if (state.doc.sliceString(Math.max(0, newTo - text.length), newTo, LineBreakPlaceholder) == text)
            newFrom = newTo - text.length;
        else
            return Decoration.none;
    }
    else if (state.doc.sliceString(newFrom, newTo, LineBreakPlaceholder) != text) {
        return Decoration.none;
    }
    let topView = ContentView.get(node);
    if (topView instanceof CompositionView)
        topView = topView.widget.topView;
    else if (topView)
        topView.parent = null;
    return Decoration.set(Decoration.replace({ widget: new CompositionWidget(node, textNode, topView), inclusive: true })
        .range(newFrom, newTo));
}
class CompositionWidget extends WidgetType {
    constructor(top, text, topView) {
        super();
        this.top = top;
        this.text = text;
        this.topView = topView;
    }
    eq(other) { return this.top == other.top && this.text == other.text; }
    toDOM() { return this.top; }
    ignoreEvent() { return false; }
    get customView() { return CompositionView; }
}
function nearbyTextNode(node, offset, side) {
    for (;;) {
        if (node.nodeType == 3)
            return node;
        if (node.nodeType == 1 && offset > 0 && side <= 0) {
            node = node.childNodes[offset - 1];
            offset = maxOffset(node);
        }
        else if (node.nodeType == 1 && offset < node.childNodes.length && side >= 0) {
            node = node.childNodes[offset];
            offset = 0;
        }
        else {
            return null;
        }
    }
}
function nextToUneditable(node, offset) {
    if (node.nodeType != 1)
        return 0;
    return (offset && node.childNodes[offset - 1].contentEditable == "false" ? 1 /* NextTo.Before */ : 0) |
        (offset < node.childNodes.length && node.childNodes[offset].contentEditable == "false" ? 2 /* NextTo.After */ : 0);
}
class DecorationComparator$1 {
    constructor() {
        this.changes = [];
    }
    compareRange(from, to) { addRange(from, to, this.changes); }
    comparePoint(from, to) { addRange(from, to, this.changes); }
}
function findChangedDeco(a, b, diff) {
    let comp = new DecorationComparator$1;
    state_dist/* RangeSet.compare */.Xs.compare(a, b, diff, comp);
    return comp.changes;
}
function inUneditable(node, inside) {
    for (let cur = node; cur && cur != inside; cur = cur.assignedSlot || cur.parentNode) {
        if (cur.nodeType == 1 && cur.contentEditable == 'false') {
            return true;
        }
    }
    return false;
}

function groupAt(state, pos, bias = 1) {
    let categorize = state.charCategorizer(pos);
    let line = state.doc.lineAt(pos), linePos = pos - line.from;
    if (line.length == 0)
        return state_dist/* EditorSelection.cursor */.jT.cursor(pos);
    if (linePos == 0)
        bias = 1;
    else if (linePos == line.length)
        bias = -1;
    let from = linePos, to = linePos;
    if (bias < 0)
        from = (0,state_dist/* findClusterBreak */.cp)(line.text, linePos, false);
    else
        to = (0,state_dist/* findClusterBreak */.cp)(line.text, linePos);
    let cat = categorize(line.text.slice(from, to));
    while (from > 0) {
        let prev = (0,state_dist/* findClusterBreak */.cp)(line.text, from, false);
        if (categorize(line.text.slice(prev, from)) != cat)
            break;
        from = prev;
    }
    while (to < line.length) {
        let next = (0,state_dist/* findClusterBreak */.cp)(line.text, to);
        if (categorize(line.text.slice(to, next)) != cat)
            break;
        to = next;
    }
    return state_dist/* EditorSelection.range */.jT.range(from + line.from, to + line.from);
}
// Search the DOM for the {node, offset} position closest to the given
// coordinates. Very inefficient and crude, but can usually be avoided
// by calling caret(Position|Range)FromPoint instead.
function getdx(x, rect) {
    return rect.left > x ? rect.left - x : Math.max(0, x - rect.right);
}
function getdy(y, rect) {
    return rect.top > y ? rect.top - y : Math.max(0, y - rect.bottom);
}
function yOverlap(a, b) {
    return a.top < b.bottom - 1 && a.bottom > b.top + 1;
}
function upTop(rect, top) {
    return top < rect.top ? { top, left: rect.left, right: rect.right, bottom: rect.bottom } : rect;
}
function upBot(rect, bottom) {
    return bottom > rect.bottom ? { top: rect.top, left: rect.left, right: rect.right, bottom } : rect;
}
function domPosAtCoords(parent, x, y) {
    let closest, closestRect, closestX, closestY, closestOverlap = false;
    let above, below, aboveRect, belowRect;
    for (let child = parent.firstChild; child; child = child.nextSibling) {
        let rects = clientRectsFor(child);
        for (let i = 0; i < rects.length; i++) {
            let rect = rects[i];
            if (closestRect && yOverlap(closestRect, rect))
                rect = upTop(upBot(rect, closestRect.bottom), closestRect.top);
            let dx = getdx(x, rect), dy = getdy(y, rect);
            if (dx == 0 && dy == 0)
                return child.nodeType == 3 ? domPosInText(child, x, y) : domPosAtCoords(child, x, y);
            if (!closest || closestY > dy || closestY == dy && closestX > dx) {
                closest = child;
                closestRect = rect;
                closestX = dx;
                closestY = dy;
                closestOverlap = !dx || (dx > 0 ? i < rects.length - 1 : i > 0);
            }
            if (dx == 0) {
                if (y > rect.bottom && (!aboveRect || aboveRect.bottom < rect.bottom)) {
                    above = child;
                    aboveRect = rect;
                }
                else if (y < rect.top && (!belowRect || belowRect.top > rect.top)) {
                    below = child;
                    belowRect = rect;
                }
            }
            else if (aboveRect && yOverlap(aboveRect, rect)) {
                aboveRect = upBot(aboveRect, rect.bottom);
            }
            else if (belowRect && yOverlap(belowRect, rect)) {
                belowRect = upTop(belowRect, rect.top);
            }
        }
    }
    if (aboveRect && aboveRect.bottom >= y) {
        closest = above;
        closestRect = aboveRect;
    }
    else if (belowRect && belowRect.top <= y) {
        closest = below;
        closestRect = belowRect;
    }
    if (!closest)
        return { node: parent, offset: 0 };
    let clipX = Math.max(closestRect.left, Math.min(closestRect.right, x));
    if (closest.nodeType == 3)
        return domPosInText(closest, clipX, y);
    if (closestOverlap && closest.contentEditable != "false")
        return domPosAtCoords(closest, clipX, y);
    let offset = Array.prototype.indexOf.call(parent.childNodes, closest) +
        (x >= (closestRect.left + closestRect.right) / 2 ? 1 : 0);
    return { node: parent, offset };
}
function domPosInText(node, x, y) {
    let len = node.nodeValue.length;
    let closestOffset = -1, closestDY = 1e9, generalSide = 0;
    for (let i = 0; i < len; i++) {
        let rects = textRange(node, i, i + 1).getClientRects();
        for (let j = 0; j < rects.length; j++) {
            let rect = rects[j];
            if (rect.top == rect.bottom)
                continue;
            if (!generalSide)
                generalSide = x - rect.left;
            let dy = (rect.top > y ? rect.top - y : y - rect.bottom) - 1;
            if (rect.left - 1 <= x && rect.right + 1 >= x && dy < closestDY) {
                let right = x >= (rect.left + rect.right) / 2, after = right;
                if (browser.chrome || browser.gecko) {
                    // Check for RTL on browsers that support getting client
                    // rects for empty ranges.
                    let rectBefore = textRange(node, i).getBoundingClientRect();
                    if (rectBefore.left == rect.right)
                        after = !right;
                }
                if (dy <= 0)
                    return { node, offset: i + (after ? 1 : 0) };
                closestOffset = i + (after ? 1 : 0);
                closestDY = dy;
            }
        }
    }
    return { node, offset: closestOffset > -1 ? closestOffset : generalSide > 0 ? node.nodeValue.length : 0 };
}
function posAtCoords(view, { x, y }, precise, bias = -1) {
    var _a;
    let content = view.contentDOM.getBoundingClientRect(), docTop = content.top + view.viewState.paddingTop;
    let block, { docHeight } = view.viewState;
    let yOffset = y - docTop;
    if (yOffset < 0)
        return 0;
    if (yOffset > docHeight)
        return view.state.doc.length;
    // Scan for a text block near the queried y position
    for (let halfLine = view.defaultLineHeight / 2, bounced = false;;) {
        block = view.elementAtHeight(yOffset);
        if (block.type == BlockType.Text)
            break;
        for (;;) {
            // Move the y position out of this block
            yOffset = bias > 0 ? block.bottom + halfLine : block.top - halfLine;
            if (yOffset >= 0 && yOffset <= docHeight)
                break;
            // If the document consists entirely of replaced widgets, we
            // won't find a text block, so return 0
            if (bounced)
                return precise ? null : 0;
            bounced = true;
            bias = -bias;
        }
    }
    y = docTop + yOffset;
    let lineStart = block.from;
    // If this is outside of the rendered viewport, we can't determine a position
    if (lineStart < view.viewport.from)
        return view.viewport.from == 0 ? 0 : precise ? null : posAtCoordsImprecise(view, content, block, x, y);
    if (lineStart > view.viewport.to)
        return view.viewport.to == view.state.doc.length ? view.state.doc.length :
            precise ? null : posAtCoordsImprecise(view, content, block, x, y);
    // Prefer ShadowRootOrDocument.elementFromPoint if present, fall back to document if not
    let doc = view.dom.ownerDocument;
    let root = view.root.elementFromPoint ? view.root : doc;
    let element = root.elementFromPoint(x, y);
    if (element && !view.contentDOM.contains(element))
        element = null;
    // If the element is unexpected, clip x at the sides of the content area and try again
    if (!element) {
        x = Math.max(content.left + 1, Math.min(content.right - 1, x));
        element = root.elementFromPoint(x, y);
        if (element && !view.contentDOM.contains(element))
            element = null;
    }
    // There's visible editor content under the point, so we can try
    // using caret(Position|Range)FromPoint as a shortcut
    let node, offset = -1;
    if (element && ((_a = view.docView.nearest(element)) === null || _a === void 0 ? void 0 : _a.isEditable) != false) {
        if (doc.caretPositionFromPoint) {
            let pos = doc.caretPositionFromPoint(x, y);
            if (pos)
                ({ offsetNode: node, offset } = pos);
        }
        else if (doc.caretRangeFromPoint) {
            let range = doc.caretRangeFromPoint(x, y);
            if (range) {
                ({ startContainer: node, startOffset: offset } = range);
                if (!view.contentDOM.contains(node) ||
                    browser.safari && isSuspiciousSafariCaretResult(node, offset, x) ||
                    browser.chrome && isSuspiciousChromeCaretResult(node, offset, x))
                    node = undefined;
            }
        }
    }
    // No luck, do our own (potentially expensive) search
    if (!node || !view.docView.dom.contains(node)) {
        let line = LineView.find(view.docView, lineStart);
        if (!line)
            return yOffset > block.top + block.height / 2 ? block.to : block.from;
        ({ node, offset } = domPosAtCoords(line.dom, x, y));
    }
    return view.docView.posFromDOM(node, offset);
}
function posAtCoordsImprecise(view, contentRect, block, x, y) {
    let into = Math.round((x - contentRect.left) * view.defaultCharacterWidth);
    if (view.lineWrapping && block.height > view.defaultLineHeight * 1.5) {
        let line = Math.floor((y - block.top) / view.defaultLineHeight);
        into += line * view.viewState.heightOracle.lineLength;
    }
    let content = view.state.sliceDoc(block.from, block.to);
    return block.from + (0,state_dist/* findColumn */.Gz)(content, into, view.state.tabSize);
}
// In case of a high line height, Safari's caretRangeFromPoint treats
// the space between lines as belonging to the last character of the
// line before. This is used to detect such a result so that it can be
// ignored (issue #401).
function isSuspiciousSafariCaretResult(node, offset, x) {
    let len;
    if (node.nodeType != 3 || offset != (len = node.nodeValue.length))
        return false;
    for (let next = node.nextSibling; next; next = next.nextSibling)
        if (next.nodeType != 1 || next.nodeName != "BR")
            return false;
    return textRange(node, len - 1, len).getBoundingClientRect().left > x;
}
// Chrome will move positions between lines to the start of the next line
function isSuspiciousChromeCaretResult(node, offset, x) {
    if (offset != 0)
        return false;
    for (let cur = node;;) {
        let parent = cur.parentNode;
        if (!parent || parent.nodeType != 1 || parent.firstChild != cur)
            return false;
        if (parent.classList.contains("cm-line"))
            break;
        cur = parent;
    }
    let rect = node.nodeType == 1 ? node.getBoundingClientRect()
        : textRange(node, 0, Math.max(node.nodeValue.length, 1)).getBoundingClientRect();
    return x - rect.left > 5;
}
function moveToLineBoundary(view, start, forward, includeWrap) {
    let line = view.state.doc.lineAt(start.head);
    let coords = !includeWrap || !view.lineWrapping ? null
        : view.coordsAtPos(start.assoc < 0 && start.head > line.from ? start.head - 1 : start.head);
    if (coords) {
        let editorRect = view.dom.getBoundingClientRect();
        let direction = view.textDirectionAt(line.from);
        let pos = view.posAtCoords({ x: forward == (direction == Direction.LTR) ? editorRect.right - 1 : editorRect.left + 1,
            y: (coords.top + coords.bottom) / 2 });
        if (pos != null)
            return state_dist/* EditorSelection.cursor */.jT.cursor(pos, forward ? -1 : 1);
    }
    let lineView = LineView.find(view.docView, start.head);
    let end = lineView ? (forward ? lineView.posAtEnd : lineView.posAtStart) : (forward ? line.to : line.from);
    return state_dist/* EditorSelection.cursor */.jT.cursor(end, forward ? -1 : 1);
}
function moveByChar(view, start, forward, by) {
    let line = view.state.doc.lineAt(start.head), spans = view.bidiSpans(line);
    let direction = view.textDirectionAt(line.from);
    for (let cur = start, check = null;;) {
        let next = moveVisually(line, spans, direction, cur, forward), char = movedOver;
        if (!next) {
            if (line.number == (forward ? view.state.doc.lines : 1))
                return cur;
            char = "\n";
            line = view.state.doc.line(line.number + (forward ? 1 : -1));
            spans = view.bidiSpans(line);
            next = state_dist/* EditorSelection.cursor */.jT.cursor(forward ? line.from : line.to);
        }
        if (!check) {
            if (!by)
                return next;
            check = by(char);
        }
        else if (!check(char)) {
            return cur;
        }
        cur = next;
    }
}
function byGroup(view, pos, start) {
    let categorize = view.state.charCategorizer(pos);
    let cat = categorize(start);
    return (next) => {
        let nextCat = categorize(next);
        if (cat == state_dist/* CharCategory.Space */.D0.Space)
            cat = nextCat;
        return cat == nextCat;
    };
}
function moveVertically(view, start, forward, distance) {
    let startPos = start.head, dir = forward ? 1 : -1;
    if (startPos == (forward ? view.state.doc.length : 0))
        return state_dist/* EditorSelection.cursor */.jT.cursor(startPos, start.assoc);
    let goal = start.goalColumn, startY;
    let rect = view.contentDOM.getBoundingClientRect();
    let startCoords = view.coordsAtPos(startPos), docTop = view.documentTop;
    if (startCoords) {
        if (goal == null)
            goal = startCoords.left - rect.left;
        startY = dir < 0 ? startCoords.top : startCoords.bottom;
    }
    else {
        let line = view.viewState.lineBlockAt(startPos);
        if (goal == null)
            goal = Math.min(rect.right - rect.left, view.defaultCharacterWidth * (startPos - line.from));
        startY = (dir < 0 ? line.top : line.bottom) + docTop;
    }
    let resolvedGoal = rect.left + goal;
    let dist = distance !== null && distance !== void 0 ? distance : (view.defaultLineHeight >> 1);
    for (let extra = 0;; extra += 10) {
        let curY = startY + (dist + extra) * dir;
        let pos = posAtCoords(view, { x: resolvedGoal, y: curY }, false, dir);
        if (curY < rect.top || curY > rect.bottom || (dir < 0 ? pos < startPos : pos > startPos))
            return state_dist/* EditorSelection.cursor */.jT.cursor(pos, start.assoc, undefined, goal);
    }
}
function skipAtoms(view, oldPos, pos) {
    let atoms = view.state.facet(atomicRanges).map(f => f(view));
    for (;;) {
        let moved = false;
        for (let set of atoms) {
            set.between(pos.from - 1, pos.from + 1, (from, to, value) => {
                if (pos.from > from && pos.from < to) {
                    pos = oldPos.head > pos.from ? state_dist/* EditorSelection.cursor */.jT.cursor(from, 1) : state_dist/* EditorSelection.cursor */.jT.cursor(to, -1);
                    moved = true;
                }
            });
        }
        if (!moved)
            return pos;
    }
}

// This will also be where dragging info and such goes
class InputState {
    constructor(view) {
        this.lastKeyCode = 0;
        this.lastKeyTime = 0;
        this.lastTouchTime = 0;
        this.lastFocusTime = 0;
        this.lastScrollTop = 0;
        this.lastScrollLeft = 0;
        this.chromeScrollHack = -1;
        // On iOS, some keys need to have their default behavior happen
        // (after which we retroactively handle them and reset the DOM) to
        // avoid messing up the virtual keyboard state.
        this.pendingIOSKey = undefined;
        this.lastSelectionOrigin = null;
        this.lastSelectionTime = 0;
        this.lastEscPress = 0;
        this.lastContextMenu = 0;
        this.scrollHandlers = [];
        this.registeredEvents = [];
        this.customHandlers = [];
        // -1 means not in a composition. Otherwise, this counts the number
        // of changes made during the composition. The count is used to
        // avoid treating the start state of the composition, before any
        // changes have been made, as part of the composition.
        this.composing = -1;
        // Tracks whether the next change should be marked as starting the
        // composition (null means no composition, true means next is the
        // first, false means first has already been marked for this
        // composition)
        this.compositionFirstChange = null;
        this.compositionEndedAt = 0;
        this.mouseSelection = null;
        for (let type in handlers) {
            let handler = handlers[type];
            view.contentDOM.addEventListener(type, (event) => {
                if (!eventBelongsToEditor(view, event) || this.ignoreDuringComposition(event))
                    return;
                if (type == "keydown" && this.keydown(view, event))
                    return;
                if (this.mustFlushObserver(event))
                    view.observer.forceFlush();
                if (this.runCustomHandlers(type, view, event))
                    event.preventDefault();
                else
                    handler(view, event);
            }, handlerOptions[type]);
            this.registeredEvents.push(type);
        }
        if (browser.chrome && browser.chrome_version == 102) { // FIXME remove at some point
            // On Chrome 102, viewport updates somehow stop wheel-based
            // scrolling. Turning off pointer events during the scroll seems
            // to avoid the issue.
            view.scrollDOM.addEventListener("wheel", () => {
                if (this.chromeScrollHack < 0)
                    view.contentDOM.style.pointerEvents = "none";
                else
                    window.clearTimeout(this.chromeScrollHack);
                this.chromeScrollHack = setTimeout(() => {
                    this.chromeScrollHack = -1;
                    view.contentDOM.style.pointerEvents = "";
                }, 100);
            }, { passive: true });
        }
        this.notifiedFocused = view.hasFocus;
        // On Safari adding an input event handler somehow prevents an
        // issue where the composition vanishes when you press enter.
        if (browser.safari)
            view.contentDOM.addEventListener("input", () => null);
    }
    setSelectionOrigin(origin) {
        this.lastSelectionOrigin = origin;
        this.lastSelectionTime = Date.now();
    }
    ensureHandlers(view, plugins) {
        var _a;
        let handlers;
        this.customHandlers = [];
        for (let plugin of plugins)
            if (handlers = (_a = plugin.update(view).spec) === null || _a === void 0 ? void 0 : _a.domEventHandlers) {
                this.customHandlers.push({ plugin: plugin.value, handlers });
                for (let type in handlers)
                    if (this.registeredEvents.indexOf(type) < 0 && type != "scroll") {
                        this.registeredEvents.push(type);
                        view.contentDOM.addEventListener(type, (event) => {
                            if (!eventBelongsToEditor(view, event))
                                return;
                            if (this.runCustomHandlers(type, view, event))
                                event.preventDefault();
                        });
                    }
            }
    }
    runCustomHandlers(type, view, event) {
        for (let set of this.customHandlers) {
            let handler = set.handlers[type];
            if (handler) {
                try {
                    if (handler.call(set.plugin, event, view) || event.defaultPrevented)
                        return true;
                }
                catch (e) {
                    logException(view.state, e);
                }
            }
        }
        return false;
    }
    runScrollHandlers(view, event) {
        this.lastScrollTop = view.scrollDOM.scrollTop;
        this.lastScrollLeft = view.scrollDOM.scrollLeft;
        for (let set of this.customHandlers) {
            let handler = set.handlers.scroll;
            if (handler) {
                try {
                    handler.call(set.plugin, event, view);
                }
                catch (e) {
                    logException(view.state, e);
                }
            }
        }
    }
    keydown(view, event) {
        // Must always run, even if a custom handler handled the event
        this.lastKeyCode = event.keyCode;
        this.lastKeyTime = Date.now();
        if (event.keyCode == 9 && Date.now() < this.lastEscPress + 2000)
            return true;
        // Chrome for Android usually doesn't fire proper key events, but
        // occasionally does, usually surrounded by a bunch of complicated
        // composition changes. When an enter or backspace key event is
        // seen, hold off on handling DOM events for a bit, and then
        // dispatch it.
        if (browser.android && browser.chrome && !event.synthetic &&
            (event.keyCode == 13 || event.keyCode == 8)) {
            view.observer.delayAndroidKey(event.key, event.keyCode);
            return true;
        }
        // Prevent the default behavior of Enter on iOS makes the
        // virtual keyboard get stuck in the wrong (lowercase)
        // state. So we let it go through, and then, in
        // applyDOMChange, notify key handlers of it and reset to
        // the state they produce.
        let pending;
        if (browser.ios && !event.synthetic && !event.altKey && !event.metaKey &&
            ((pending = PendingKeys.find(key => key.keyCode == event.keyCode)) && !event.ctrlKey ||
                EmacsyPendingKeys.indexOf(event.key) > -1 && event.ctrlKey && !event.shiftKey)) {
            this.pendingIOSKey = pending || event;
            setTimeout(() => this.flushIOSKey(view), 250);
            return true;
        }
        return false;
    }
    flushIOSKey(view) {
        let key = this.pendingIOSKey;
        if (!key)
            return false;
        this.pendingIOSKey = undefined;
        return dispatchKey(view.contentDOM, key.key, key.keyCode);
    }
    ignoreDuringComposition(event) {
        if (!/^key/.test(event.type))
            return false;
        if (this.composing > 0)
            return true;
        // See https://www.stum.de/2016/06/24/handling-ime-events-in-javascript/.
        // On some input method editors (IMEs), the Enter key is used to
        // confirm character selection. On Safari, when Enter is pressed,
        // compositionend and keydown events are sometimes emitted in the
        // wrong order. The key event should still be ignored, even when
        // it happens after the compositionend event.
        if (browser.safari && !browser.ios && Date.now() - this.compositionEndedAt < 100) {
            this.compositionEndedAt = 0;
            return true;
        }
        return false;
    }
    mustFlushObserver(event) {
        return event.type == "keydown" && event.keyCode != 229;
    }
    startMouseSelection(mouseSelection) {
        if (this.mouseSelection)
            this.mouseSelection.destroy();
        this.mouseSelection = mouseSelection;
    }
    update(update) {
        if (this.mouseSelection)
            this.mouseSelection.update(update);
        if (update.transactions.length)
            this.lastKeyCode = this.lastSelectionTime = 0;
    }
    destroy() {
        if (this.mouseSelection)
            this.mouseSelection.destroy();
    }
}
const PendingKeys = [
    { key: "Backspace", keyCode: 8, inputType: "deleteContentBackward" },
    { key: "Enter", keyCode: 13, inputType: "insertParagraph" },
    { key: "Delete", keyCode: 46, inputType: "deleteContentForward" }
];
const EmacsyPendingKeys = "dthko";
// Key codes for modifier keys
const modifierCodes = [16, 17, 18, 20, 91, 92, 224, 225];
class MouseSelection {
    constructor(view, startEvent, style, mustSelect) {
        this.view = view;
        this.style = style;
        this.mustSelect = mustSelect;
        this.lastEvent = startEvent;
        let doc = view.contentDOM.ownerDocument;
        doc.addEventListener("mousemove", this.move = this.move.bind(this));
        doc.addEventListener("mouseup", this.up = this.up.bind(this));
        this.extend = startEvent.shiftKey;
        this.multiple = view.state.facet(state_dist/* EditorState.allowMultipleSelections */.yy.allowMultipleSelections) && addsSelectionRange(view, startEvent);
        this.dragMove = dragMovesSelection(view, startEvent);
        this.dragging = isInPrimarySelection(view, startEvent) && getClickType(startEvent) == 1 ? null : false;
        // When clicking outside of the selection, immediately apply the
        // effect of starting the selection
        if (this.dragging === false) {
            startEvent.preventDefault();
            this.select(startEvent);
        }
    }
    move(event) {
        if (event.buttons == 0)
            return this.destroy();
        if (this.dragging !== false)
            return;
        this.select(this.lastEvent = event);
    }
    up(event) {
        if (this.dragging == null)
            this.select(this.lastEvent);
        if (!this.dragging)
            event.preventDefault();
        this.destroy();
    }
    destroy() {
        let doc = this.view.contentDOM.ownerDocument;
        doc.removeEventListener("mousemove", this.move);
        doc.removeEventListener("mouseup", this.up);
        this.view.inputState.mouseSelection = null;
    }
    select(event) {
        let selection = this.style.get(event, this.extend, this.multiple);
        if (this.mustSelect || !selection.eq(this.view.state.selection) ||
            selection.main.assoc != this.view.state.selection.main.assoc)
            this.view.dispatch({
                selection,
                userEvent: "select.pointer",
                scrollIntoView: true
            });
        this.mustSelect = false;
    }
    update(update) {
        if (update.docChanged && this.dragging)
            this.dragging = this.dragging.map(update.changes);
        if (this.style.update(update))
            setTimeout(() => this.select(this.lastEvent), 20);
    }
}
function addsSelectionRange(view, event) {
    let facet = view.state.facet(clickAddsSelectionRange);
    return facet.length ? facet[0](event) : browser.mac ? event.metaKey : event.ctrlKey;
}
function dragMovesSelection(view, event) {
    let facet = view.state.facet(dragMovesSelection$1);
    return facet.length ? facet[0](event) : browser.mac ? !event.altKey : !event.ctrlKey;
}
function isInPrimarySelection(view, event) {
    let { main } = view.state.selection;
    if (main.empty)
        return false;
    // On boundary clicks, check whether the coordinates are inside the
    // selection's client rectangles
    let sel = getSelection(view.root);
    if (!sel || sel.rangeCount == 0)
        return true;
    let rects = sel.getRangeAt(0).getClientRects();
    for (let i = 0; i < rects.length; i++) {
        let rect = rects[i];
        if (rect.left <= event.clientX && rect.right >= event.clientX &&
            rect.top <= event.clientY && rect.bottom >= event.clientY)
            return true;
    }
    return false;
}
function eventBelongsToEditor(view, event) {
    if (!event.bubbles)
        return true;
    if (event.defaultPrevented)
        return false;
    for (let node = event.target, cView; node != view.contentDOM; node = node.parentNode)
        if (!node || node.nodeType == 11 || ((cView = ContentView.get(node)) && cView.ignoreEvent(event)))
            return false;
    return true;
}
const handlers = /*@__PURE__*/Object.create(null);
const handlerOptions = /*@__PURE__*/Object.create(null);
// This is very crude, but unfortunately both these browsers _pretend_
// that they have a clipboard APIall the objects and methods are
// there, they just don't work, and they are hard to test.
const brokenClipboardAPI = (browser.ie && browser.ie_version < 15) ||
    (browser.ios && browser.webkit_version < 604);
function capturePaste(view) {
    let parent = view.dom.parentNode;
    if (!parent)
        return;
    let target = parent.appendChild(document.createElement("textarea"));
    target.style.cssText = "position: fixed; left: -10000px; top: 10px";
    target.focus();
    setTimeout(() => {
        view.focus();
        target.remove();
        doPaste(view, target.value);
    }, 50);
}
function doPaste(view, input) {
    let { state } = view, changes, i = 1, text = state.toText(input);
    let byLine = text.lines == state.selection.ranges.length;
    let linewise = lastLinewiseCopy != null && state.selection.ranges.every(r => r.empty) && lastLinewiseCopy == text.toString();
    if (linewise) {
        let lastLine = -1;
        changes = state.changeByRange(range => {
            let line = state.doc.lineAt(range.from);
            if (line.from == lastLine)
                return { range };
            lastLine = line.from;
            let insert = state.toText((byLine ? text.line(i++).text : input) + state.lineBreak);
            return { changes: { from: line.from, insert },
                range: state_dist/* EditorSelection.cursor */.jT.cursor(range.from + insert.length) };
        });
    }
    else if (byLine) {
        changes = state.changeByRange(range => {
            let line = text.line(i++);
            return { changes: { from: range.from, to: range.to, insert: line.text },
                range: state_dist/* EditorSelection.cursor */.jT.cursor(range.from + line.length) };
        });
    }
    else {
        changes = state.replaceSelection(text);
    }
    view.dispatch(changes, {
        userEvent: "input.paste",
        scrollIntoView: true
    });
}
handlers.keydown = (view, event) => {
    view.inputState.setSelectionOrigin("select");
    if (event.keyCode == 27)
        view.inputState.lastEscPress = Date.now();
    else if (modifierCodes.indexOf(event.keyCode) < 0)
        view.inputState.lastEscPress = 0;
};
handlers.touchstart = (view, e) => {
    view.inputState.lastTouchTime = Date.now();
    view.inputState.setSelectionOrigin("select.pointer");
};
handlers.touchmove = view => {
    view.inputState.setSelectionOrigin("select.pointer");
};
handlerOptions.touchstart = handlerOptions.touchmove = { passive: true };
handlers.mousedown = (view, event) => {
    view.observer.flush();
    if (view.inputState.lastTouchTime > Date.now() - 2000)
        return; // Ignore touch interaction
    let style = null;
    for (let makeStyle of view.state.facet(mouseSelectionStyle)) {
        style = makeStyle(view, event);
        if (style)
            break;
    }
    if (!style && event.button == 0)
        style = basicMouseSelection(view, event);
    if (style) {
        let mustFocus = view.root.activeElement != view.contentDOM;
        if (mustFocus)
            view.observer.ignore(() => focusPreventScroll(view.contentDOM));
        view.inputState.startMouseSelection(new MouseSelection(view, event, style, mustFocus));
    }
};
function rangeForClick(view, pos, bias, type) {
    if (type == 1) { // Single click
        return state_dist/* EditorSelection.cursor */.jT.cursor(pos, bias);
    }
    else if (type == 2) { // Double click
        return groupAt(view.state, pos, bias);
    }
    else { // Triple click
        let visual = LineView.find(view.docView, pos), line = view.state.doc.lineAt(visual ? visual.posAtEnd : pos);
        let from = visual ? visual.posAtStart : line.from, to = visual ? visual.posAtEnd : line.to;
        if (to < view.state.doc.length && to == line.to)
            to++;
        return state_dist/* EditorSelection.range */.jT.range(from, to);
    }
}
let insideY = (y, rect) => y >= rect.top && y <= rect.bottom;
let inside = (x, y, rect) => insideY(y, rect) && x >= rect.left && x <= rect.right;
// Try to determine, for the given coordinates, associated with the
// given position, whether they are related to the element before or
// the element after the position.
function findPositionSide(view, pos, x, y) {
    let line = LineView.find(view.docView, pos);
    if (!line)
        return 1;
    let off = pos - line.posAtStart;
    // Line boundaries point into the line
    if (off == 0)
        return 1;
    if (off == line.length)
        return -1;
    // Positions on top of an element point at that element
    let before = line.coordsAt(off, -1);
    if (before && inside(x, y, before))
        return -1;
    let after = line.coordsAt(off, 1);
    if (after && inside(x, y, after))
        return 1;
    // This is probably a line wrap point. Pick before if the point is
    // beside it.
    return before && insideY(y, before) ? -1 : 1;
}
function queryPos(view, event) {
    let pos = view.posAtCoords({ x: event.clientX, y: event.clientY }, false);
    return { pos, bias: findPositionSide(view, pos, event.clientX, event.clientY) };
}
const BadMouseDetail = browser.ie && browser.ie_version <= 11;
let lastMouseDown = null, lastMouseDownCount = 0, lastMouseDownTime = 0;
function getClickType(event) {
    if (!BadMouseDetail)
        return event.detail;
    let last = lastMouseDown, lastTime = lastMouseDownTime;
    lastMouseDown = event;
    lastMouseDownTime = Date.now();
    return lastMouseDownCount = !last || (lastTime > Date.now() - 400 && Math.abs(last.clientX - event.clientX) < 2 &&
        Math.abs(last.clientY - event.clientY) < 2) ? (lastMouseDownCount + 1) % 3 : 1;
}
function basicMouseSelection(view, event) {
    let start = queryPos(view, event), type = getClickType(event);
    let startSel = view.state.selection;
    let last = start, lastEvent = event;
    return {
        update(update) {
            if (update.docChanged) {
                start.pos = update.changes.mapPos(start.pos);
                startSel = startSel.map(update.changes);
                lastEvent = null;
            }
        },
        get(event, extend, multiple) {
            let cur;
            if (lastEvent && event.clientX == lastEvent.clientX && event.clientY == lastEvent.clientY)
                cur = last;
            else {
                cur = last = queryPos(view, event);
                lastEvent = event;
            }
            let range = rangeForClick(view, cur.pos, cur.bias, type);
            if (start.pos != cur.pos && !extend) {
                let startRange = rangeForClick(view, start.pos, start.bias, type);
                let from = Math.min(startRange.from, range.from), to = Math.max(startRange.to, range.to);
                range = from < range.from ? state_dist/* EditorSelection.range */.jT.range(from, to) : state_dist/* EditorSelection.range */.jT.range(to, from);
            }
            if (extend)
                return startSel.replaceRange(startSel.main.extend(range.from, range.to));
            else if (multiple && startSel.ranges.length > 1 && startSel.ranges.some(r => r.eq(range)))
                return removeRange(startSel, range);
            else if (multiple)
                return startSel.addRange(range);
            else
                return state_dist/* EditorSelection.create */.jT.create([range]);
        }
    };
}
function removeRange(sel, range) {
    for (let i = 0;; i++) {
        if (sel.ranges[i].eq(range))
            return state_dist/* EditorSelection.create */.jT.create(sel.ranges.slice(0, i).concat(sel.ranges.slice(i + 1)), sel.mainIndex == i ? 0 : sel.mainIndex - (sel.mainIndex > i ? 1 : 0));
    }
}
handlers.dragstart = (view, event) => {
    let { selection: { main } } = view.state;
    let { mouseSelection } = view.inputState;
    if (mouseSelection)
        mouseSelection.dragging = main;
    if (event.dataTransfer) {
        event.dataTransfer.setData("Text", view.state.sliceDoc(main.from, main.to));
        event.dataTransfer.effectAllowed = "copyMove";
    }
};
function dropText(view, event, text, direct) {
    if (!text)
        return;
    let dropPos = view.posAtCoords({ x: event.clientX, y: event.clientY }, false);
    event.preventDefault();
    let { mouseSelection } = view.inputState;
    let del = direct && mouseSelection && mouseSelection.dragging && mouseSelection.dragMove ?
        { from: mouseSelection.dragging.from, to: mouseSelection.dragging.to } : null;
    let ins = { from: dropPos, insert: text };
    let changes = view.state.changes(del ? [del, ins] : ins);
    view.focus();
    view.dispatch({
        changes,
        selection: { anchor: changes.mapPos(dropPos, -1), head: changes.mapPos(dropPos, 1) },
        userEvent: del ? "move.drop" : "input.drop"
    });
}
handlers.drop = (view, event) => {
    if (!event.dataTransfer)
        return;
    if (view.state.readOnly)
        return event.preventDefault();
    let files = event.dataTransfer.files;
    if (files && files.length) { // For a file drop, read the file's text.
        event.preventDefault();
        let text = Array(files.length), read = 0;
        let finishFile = () => {
            if (++read == files.length)
                dropText(view, event, text.filter(s => s != null).join(view.state.lineBreak), false);
        };
        for (let i = 0; i < files.length; i++) {
            let reader = new FileReader;
            reader.onerror = finishFile;
            reader.onload = () => {
                if (!/[\x00-\x08\x0e-\x1f]{2}/.test(reader.result))
                    text[i] = reader.result;
                finishFile();
            };
            reader.readAsText(files[i]);
        }
    }
    else {
        dropText(view, event, event.dataTransfer.getData("Text"), true);
    }
};
handlers.paste = (view, event) => {
    if (view.state.readOnly)
        return event.preventDefault();
    view.observer.flush();
    let data = brokenClipboardAPI ? null : event.clipboardData;
    if (data) {
        doPaste(view, data.getData("text/plain"));
        event.preventDefault();
    }
    else {
        capturePaste(view);
    }
};
function captureCopy(view, text) {
    // The extra wrapper is somehow necessary on IE/Edge to prevent the
    // content from being mangled when it is put onto the clipboard
    let parent = view.dom.parentNode;
    if (!parent)
        return;
    let target = parent.appendChild(document.createElement("textarea"));
    target.style.cssText = "position: fixed; left: -10000px; top: 10px";
    target.value = text;
    target.focus();
    target.selectionEnd = text.length;
    target.selectionStart = 0;
    setTimeout(() => {
        target.remove();
        view.focus();
    }, 50);
}
function copiedRange(state) {
    let content = [], ranges = [], linewise = false;
    for (let range of state.selection.ranges)
        if (!range.empty) {
            content.push(state.sliceDoc(range.from, range.to));
            ranges.push(range);
        }
    if (!content.length) {
        // Nothing selected, do a line-wise copy
        let upto = -1;
        for (let { from } of state.selection.ranges) {
            let line = state.doc.lineAt(from);
            if (line.number > upto) {
                content.push(line.text);
                ranges.push({ from: line.from, to: Math.min(state.doc.length, line.to + 1) });
            }
            upto = line.number;
        }
        linewise = true;
    }
    return { text: content.join(state.lineBreak), ranges, linewise };
}
let lastLinewiseCopy = null;
handlers.copy = handlers.cut = (view, event) => {
    let { text, ranges, linewise } = copiedRange(view.state);
    if (!text && !linewise)
        return;
    lastLinewiseCopy = linewise ? text : null;
    let data = brokenClipboardAPI ? null : event.clipboardData;
    if (data) {
        event.preventDefault();
        data.clearData();
        data.setData("text/plain", text);
    }
    else {
        captureCopy(view, text);
    }
    if (event.type == "cut" && !view.state.readOnly)
        view.dispatch({
            changes: ranges,
            scrollIntoView: true,
            userEvent: "delete.cut"
        });
};
function updateForFocusChange(view) {
    setTimeout(() => {
        if (view.hasFocus != view.inputState.notifiedFocused)
            view.update([]);
    }, 10);
}
handlers.focus = view => {
    view.inputState.lastFocusTime = Date.now();
    // When focusing reset the scroll position, move it back to where it was
    if (!view.scrollDOM.scrollTop && (view.inputState.lastScrollTop || view.inputState.lastScrollLeft)) {
        view.scrollDOM.scrollTop = view.inputState.lastScrollTop;
        view.scrollDOM.scrollLeft = view.inputState.lastScrollLeft;
    }
    updateForFocusChange(view);
};
handlers.blur = view => {
    view.observer.clearSelectionRange();
    updateForFocusChange(view);
};
handlers.compositionstart = handlers.compositionupdate = view => {
    if (view.inputState.compositionFirstChange == null)
        view.inputState.compositionFirstChange = true;
    if (view.inputState.composing < 0) {
        // FIXME possibly set a timeout to clear it again on Android
        view.inputState.composing = 0;
    }
};
handlers.compositionend = view => {
    view.inputState.composing = -1;
    view.inputState.compositionEndedAt = Date.now();
    view.inputState.compositionFirstChange = null;
    if (browser.chrome && browser.android)
        view.observer.flushSoon();
    setTimeout(() => {
        // Force the composition state to be cleared if it hasn't already been
        if (view.inputState.composing < 0 && view.docView.compositionDeco.size)
            view.update([]);
    }, 50);
};
handlers.contextmenu = view => {
    view.inputState.lastContextMenu = Date.now();
};
handlers.beforeinput = (view, event) => {
    var _a;
    // Because Chrome Android doesn't fire useful key events, use
    // beforeinput to detect backspace (and possibly enter and delete,
    // but those usually don't even seem to fire beforeinput events at
    // the moment) and fake a key event for it.
    //
    // (preventDefault on beforeinput, though supported in the spec,
    // seems to do nothing at all on Chrome).
    let pending;
    if (browser.chrome && browser.android && (pending = PendingKeys.find(key => key.inputType == event.inputType))) {
        view.observer.delayAndroidKey(pending.key, pending.keyCode);
        if (pending.key == "Backspace" || pending.key == "Delete") {
            let startViewHeight = ((_a = window.visualViewport) === null || _a === void 0 ? void 0 : _a.height) || 0;
            setTimeout(() => {
                var _a;
                // Backspacing near uneditable nodes on Chrome Android sometimes
                // closes the virtual keyboard. This tries to crudely detect
                // that and refocus to get it back.
                if ((((_a = window.visualViewport) === null || _a === void 0 ? void 0 : _a.height) || 0) > startViewHeight + 10 && view.hasFocus) {
                    view.contentDOM.blur();
                    view.focus();
                }
            }, 100);
        }
    }
};

const wrappingWhiteSpace = ["pre-wrap", "normal", "pre-line", "break-spaces"];
class HeightOracle {
    constructor() {
        this.doc = state_dist/* Text.empty */.xv.empty;
        this.lineWrapping = false;
        this.heightSamples = {};
        this.lineHeight = 14;
        this.charWidth = 7;
        this.lineLength = 30;
        // Used to track, during updateHeight, if any actual heights changed
        this.heightChanged = false;
    }
    heightForGap(from, to) {
        let lines = this.doc.lineAt(to).number - this.doc.lineAt(from).number + 1;
        if (this.lineWrapping)
            lines += Math.ceil(((to - from) - (lines * this.lineLength * 0.5)) / this.lineLength);
        return this.lineHeight * lines;
    }
    heightForLine(length) {
        if (!this.lineWrapping)
            return this.lineHeight;
        let lines = 1 + Math.max(0, Math.ceil((length - this.lineLength) / (this.lineLength - 5)));
        return lines * this.lineHeight;
    }
    setDoc(doc) { this.doc = doc; return this; }
    mustRefreshForWrapping(whiteSpace) {
        return (wrappingWhiteSpace.indexOf(whiteSpace) > -1) != this.lineWrapping;
    }
    mustRefreshForHeights(lineHeights) {
        let newHeight = false;
        for (let i = 0; i < lineHeights.length; i++) {
            let h = lineHeights[i];
            if (h < 0) {
                i++;
            }
            else if (!this.heightSamples[Math.floor(h * 10)]) { // Round to .1 pixels
                newHeight = true;
                this.heightSamples[Math.floor(h * 10)] = true;
            }
        }
        return newHeight;
    }
    refresh(whiteSpace, lineHeight, charWidth, lineLength, knownHeights) {
        let lineWrapping = wrappingWhiteSpace.indexOf(whiteSpace) > -1;
        let changed = Math.round(lineHeight) != Math.round(this.lineHeight) || this.lineWrapping != lineWrapping;
        this.lineWrapping = lineWrapping;
        this.lineHeight = lineHeight;
        this.charWidth = charWidth;
        this.lineLength = lineLength;
        if (changed) {
            this.heightSamples = {};
            for (let i = 0; i < knownHeights.length; i++) {
                let h = knownHeights[i];
                if (h < 0)
                    i++;
                else
                    this.heightSamples[Math.floor(h * 10)] = true;
            }
        }
        return changed;
    }
}
// This object is used by `updateHeight` to make DOM measurements
// arrive at the right nides. The `heights` array is a sequence of
// block heights, starting from position `from`.
class MeasuredHeights {
    constructor(from, heights) {
        this.from = from;
        this.heights = heights;
        this.index = 0;
    }
    get more() { return this.index < this.heights.length; }
}
/**
Record used to represent information about a block-level element
in the editor view.
*/
class BlockInfo {
    /**
    @internal
    */
    constructor(
    /**
    The start of the element in the document.
    */
    from, 
    /**
    The length of the element.
    */
    length, 
    /**
    The top position of the element (relative to the top of the
    document).
    */
    top, 
    /**
    Its height.
    */
    height, 
    /**
    The type of element this is. When querying lines, this may be
    an array of all the blocks that make up the line.
    */
    type) {
        this.from = from;
        this.length = length;
        this.top = top;
        this.height = height;
        this.type = type;
    }
    /**
    The end of the element as a document position.
    */
    get to() { return this.from + this.length; }
    /**
    The bottom position of the element.
    */
    get bottom() { return this.top + this.height; }
    /**
    @internal
    */
    join(other) {
        let detail = (Array.isArray(this.type) ? this.type : [this])
            .concat(Array.isArray(other.type) ? other.type : [other]);
        return new BlockInfo(this.from, this.length + other.length, this.top, this.height + other.height, detail);
    }
}
var QueryType = /*@__PURE__*/(function (QueryType) {
    QueryType[QueryType["ByPos"] = 0] = "ByPos";
    QueryType[QueryType["ByHeight"] = 1] = "ByHeight";
    QueryType[QueryType["ByPosNoHeight"] = 2] = "ByPosNoHeight";
return QueryType})(QueryType || (QueryType = {}));
const Epsilon = 1e-3;
class HeightMap {
    constructor(length, // The number of characters covered
    height, // Height of this part of the document
    flags = 2 /* Flag.Outdated */) {
        this.length = length;
        this.height = height;
        this.flags = flags;
    }
    get outdated() { return (this.flags & 2 /* Flag.Outdated */) > 0; }
    set outdated(value) { this.flags = (value ? 2 /* Flag.Outdated */ : 0) | (this.flags & ~2 /* Flag.Outdated */); }
    setHeight(oracle, height) {
        if (this.height != height) {
            if (Math.abs(this.height - height) > Epsilon)
                oracle.heightChanged = true;
            this.height = height;
        }
    }
    // Base case is to replace a leaf node, which simply builds a tree
    // from the new nodes and returns that (HeightMapBranch and
    // HeightMapGap override this to actually use from/to)
    replace(_from, _to, nodes) {
        return HeightMap.of(nodes);
    }
    // Again, these are base cases, and are overridden for branch and gap nodes.
    decomposeLeft(_to, result) { result.push(this); }
    decomposeRight(_from, result) { result.push(this); }
    applyChanges(decorations, oldDoc, oracle, changes) {
        let me = this;
        for (let i = changes.length - 1; i >= 0; i--) {
            let { fromA, toA, fromB, toB } = changes[i];
            let start = me.lineAt(fromA, QueryType.ByPosNoHeight, oldDoc, 0, 0);
            let end = start.to >= toA ? start : me.lineAt(toA, QueryType.ByPosNoHeight, oldDoc, 0, 0);
            toB += end.to - toA;
            toA = end.to;
            while (i > 0 && start.from <= changes[i - 1].toA) {
                fromA = changes[i - 1].fromA;
                fromB = changes[i - 1].fromB;
                i--;
                if (fromA < start.from)
                    start = me.lineAt(fromA, QueryType.ByPosNoHeight, oldDoc, 0, 0);
            }
            fromB += start.from - fromA;
            fromA = start.from;
            let nodes = NodeBuilder.build(oracle, decorations, fromB, toB);
            me = me.replace(fromA, toA, nodes);
        }
        return me.updateHeight(oracle, 0);
    }
    static empty() { return new HeightMapText(0, 0); }
    // nodes uses null values to indicate the position of line breaks.
    // There are never line breaks at the start or end of the array, or
    // two line breaks next to each other, and the array isn't allowed
    // to be empty (same restrictions as return value from the builder).
    static of(nodes) {
        if (nodes.length == 1)
            return nodes[0];
        let i = 0, j = nodes.length, before = 0, after = 0;
        for (;;) {
            if (i == j) {
                if (before > after * 2) {
                    let split = nodes[i - 1];
                    if (split.break)
                        nodes.splice(--i, 1, split.left, null, split.right);
                    else
                        nodes.splice(--i, 1, split.left, split.right);
                    j += 1 + split.break;
                    before -= split.size;
                }
                else if (after > before * 2) {
                    let split = nodes[j];
                    if (split.break)
                        nodes.splice(j, 1, split.left, null, split.right);
                    else
                        nodes.splice(j, 1, split.left, split.right);
                    j += 2 + split.break;
                    after -= split.size;
                }
                else {
                    break;
                }
            }
            else if (before < after) {
                let next = nodes[i++];
                if (next)
                    before += next.size;
            }
            else {
                let next = nodes[--j];
                if (next)
                    after += next.size;
            }
        }
        let brk = 0;
        if (nodes[i - 1] == null) {
            brk = 1;
            i--;
        }
        else if (nodes[i] == null) {
            brk = 1;
            j++;
        }
        return new HeightMapBranch(HeightMap.of(nodes.slice(0, i)), brk, HeightMap.of(nodes.slice(j)));
    }
}
HeightMap.prototype.size = 1;
class HeightMapBlock extends HeightMap {
    constructor(length, height, type) {
        super(length, height);
        this.type = type;
    }
    blockAt(_height, _doc, top, offset) {
        return new BlockInfo(offset, this.length, top, this.height, this.type);
    }
    lineAt(_value, _type, doc, top, offset) {
        return this.blockAt(0, doc, top, offset);
    }
    forEachLine(from, to, doc, top, offset, f) {
        if (from <= offset + this.length && to >= offset)
            f(this.blockAt(0, doc, top, offset));
    }
    updateHeight(oracle, offset = 0, _force = false, measured) {
        if (measured && measured.from <= offset && measured.more)
            this.setHeight(oracle, measured.heights[measured.index++]);
        this.outdated = false;
        return this;
    }
    toString() { return `block(${this.length})`; }
}
class HeightMapText extends HeightMapBlock {
    constructor(length, height) {
        super(length, height, BlockType.Text);
        this.collapsed = 0; // Amount of collapsed content in the line
        this.widgetHeight = 0; // Maximum inline widget height
    }
    replace(_from, _to, nodes) {
        let node = nodes[0];
        if (nodes.length == 1 && (node instanceof HeightMapText || node instanceof HeightMapGap && (node.flags & 4 /* Flag.SingleLine */)) &&
            Math.abs(this.length - node.length) < 10) {
            if (node instanceof HeightMapGap)
                node = new HeightMapText(node.length, this.height);
            else
                node.height = this.height;
            if (!this.outdated)
                node.outdated = false;
            return node;
        }
        else {
            return HeightMap.of(nodes);
        }
    }
    updateHeight(oracle, offset = 0, force = false, measured) {
        if (measured && measured.from <= offset && measured.more)
            this.setHeight(oracle, measured.heights[measured.index++]);
        else if (force || this.outdated)
            this.setHeight(oracle, Math.max(this.widgetHeight, oracle.heightForLine(this.length - this.collapsed)));
        this.outdated = false;
        return this;
    }
    toString() {
        return `line(${this.length}${this.collapsed ? -this.collapsed : ""}${this.widgetHeight ? ":" + this.widgetHeight : ""})`;
    }
}
class HeightMapGap extends HeightMap {
    constructor(length) { super(length, 0); }
    lines(doc, offset) {
        let firstLine = doc.lineAt(offset).number, lastLine = doc.lineAt(offset + this.length).number;
        return { firstLine, lastLine, lineHeight: this.height / (lastLine - firstLine + 1) };
    }
    blockAt(height, doc, top, offset) {
        let { firstLine, lastLine, lineHeight } = this.lines(doc, offset);
        let line = Math.max(0, Math.min(lastLine - firstLine, Math.floor((height - top) / lineHeight)));
        let { from, length } = doc.line(firstLine + line);
        return new BlockInfo(from, length, top + lineHeight * line, lineHeight, BlockType.Text);
    }
    lineAt(value, type, doc, top, offset) {
        if (type == QueryType.ByHeight)
            return this.blockAt(value, doc, top, offset);
        if (type == QueryType.ByPosNoHeight) {
            let { from, to } = doc.lineAt(value);
            return new BlockInfo(from, to - from, 0, 0, BlockType.Text);
        }
        let { firstLine, lineHeight } = this.lines(doc, offset);
        let { from, length, number } = doc.lineAt(value);
        return new BlockInfo(from, length, top + lineHeight * (number - firstLine), lineHeight, BlockType.Text);
    }
    forEachLine(from, to, doc, top, offset, f) {
        let { firstLine, lineHeight } = this.lines(doc, offset);
        for (let pos = Math.max(from, offset), end = Math.min(offset + this.length, to); pos <= end;) {
            let line = doc.lineAt(pos);
            if (pos == from)
                top += lineHeight * (line.number - firstLine);
            f(new BlockInfo(line.from, line.length, top, lineHeight, BlockType.Text));
            top += lineHeight;
            pos = line.to + 1;
        }
    }
    replace(from, to, nodes) {
        let after = this.length - to;
        if (after > 0) {
            let last = nodes[nodes.length - 1];
            if (last instanceof HeightMapGap)
                nodes[nodes.length - 1] = new HeightMapGap(last.length + after);
            else
                nodes.push(null, new HeightMapGap(after - 1));
        }
        if (from > 0) {
            let first = nodes[0];
            if (first instanceof HeightMapGap)
                nodes[0] = new HeightMapGap(from + first.length);
            else
                nodes.unshift(new HeightMapGap(from - 1), null);
        }
        return HeightMap.of(nodes);
    }
    decomposeLeft(to, result) {
        result.push(new HeightMapGap(to - 1), null);
    }
    decomposeRight(from, result) {
        result.push(null, new HeightMapGap(this.length - from - 1));
    }
    updateHeight(oracle, offset = 0, force = false, measured) {
        let end = offset + this.length;
        if (measured && measured.from <= offset + this.length && measured.more) {
            // Fill in part of this gap with measured lines. We know there
            // can't be widgets or collapsed ranges in those lines, because
            // they would already have been added to the heightmap (gaps
            // only contain plain text).
            let nodes = [], pos = Math.max(offset, measured.from), singleHeight = -1;
            let wasChanged = oracle.heightChanged;
            if (measured.from > offset)
                nodes.push(new HeightMapGap(measured.from - offset - 1).updateHeight(oracle, offset));
            while (pos <= end && measured.more) {
                let len = oracle.doc.lineAt(pos).length;
                if (nodes.length)
                    nodes.push(null);
                let height = measured.heights[measured.index++];
                if (singleHeight == -1)
                    singleHeight = height;
                else if (Math.abs(height - singleHeight) >= Epsilon)
                    singleHeight = -2;
                let line = new HeightMapText(len, height);
                line.outdated = false;
                nodes.push(line);
                pos += len + 1;
            }
            if (pos <= end)
                nodes.push(null, new HeightMapGap(end - pos).updateHeight(oracle, pos));
            let result = HeightMap.of(nodes);
            oracle.heightChanged = wasChanged || singleHeight < 0 || Math.abs(result.height - this.height) >= Epsilon ||
                Math.abs(singleHeight - this.lines(oracle.doc, offset).lineHeight) >= Epsilon;
            return result;
        }
        else if (force || this.outdated) {
            this.setHeight(oracle, oracle.heightForGap(offset, offset + this.length));
            this.outdated = false;
        }
        return this;
    }
    toString() { return `gap(${this.length})`; }
}
class HeightMapBranch extends HeightMap {
    constructor(left, brk, right) {
        super(left.length + brk + right.length, left.height + right.height, brk | (left.outdated || right.outdated ? 2 /* Flag.Outdated */ : 0));
        this.left = left;
        this.right = right;
        this.size = left.size + right.size;
    }
    get break() { return this.flags & 1 /* Flag.Break */; }
    blockAt(height, doc, top, offset) {
        let mid = top + this.left.height;
        return height < mid ? this.left.blockAt(height, doc, top, offset)
            : this.right.blockAt(height, doc, mid, offset + this.left.length + this.break);
    }
    lineAt(value, type, doc, top, offset) {
        let rightTop = top + this.left.height, rightOffset = offset + this.left.length + this.break;
        let left = type == QueryType.ByHeight ? value < rightTop : value < rightOffset;
        let base = left ? this.left.lineAt(value, type, doc, top, offset)
            : this.right.lineAt(value, type, doc, rightTop, rightOffset);
        if (this.break || (left ? base.to < rightOffset : base.from > rightOffset))
            return base;
        let subQuery = type == QueryType.ByPosNoHeight ? QueryType.ByPosNoHeight : QueryType.ByPos;
        if (left)
            return base.join(this.right.lineAt(rightOffset, subQuery, doc, rightTop, rightOffset));
        else
            return this.left.lineAt(rightOffset, subQuery, doc, top, offset).join(base);
    }
    forEachLine(from, to, doc, top, offset, f) {
        let rightTop = top + this.left.height, rightOffset = offset + this.left.length + this.break;
        if (this.break) {
            if (from < rightOffset)
                this.left.forEachLine(from, to, doc, top, offset, f);
            if (to >= rightOffset)
                this.right.forEachLine(from, to, doc, rightTop, rightOffset, f);
        }
        else {
            let mid = this.lineAt(rightOffset, QueryType.ByPos, doc, top, offset);
            if (from < mid.from)
                this.left.forEachLine(from, mid.from - 1, doc, top, offset, f);
            if (mid.to >= from && mid.from <= to)
                f(mid);
            if (to > mid.to)
                this.right.forEachLine(mid.to + 1, to, doc, rightTop, rightOffset, f);
        }
    }
    replace(from, to, nodes) {
        let rightStart = this.left.length + this.break;
        if (to < rightStart)
            return this.balanced(this.left.replace(from, to, nodes), this.right);
        if (from > this.left.length)
            return this.balanced(this.left, this.right.replace(from - rightStart, to - rightStart, nodes));
        let result = [];
        if (from > 0)
            this.decomposeLeft(from, result);
        let left = result.length;
        for (let node of nodes)
            result.push(node);
        if (from > 0)
            mergeGaps(result, left - 1);
        if (to < this.length) {
            let right = result.length;
            this.decomposeRight(to, result);
            mergeGaps(result, right);
        }
        return HeightMap.of(result);
    }
    decomposeLeft(to, result) {
        let left = this.left.length;
        if (to <= left)
            return this.left.decomposeLeft(to, result);
        result.push(this.left);
        if (this.break) {
            left++;
            if (to >= left)
                result.push(null);
        }
        if (to > left)
            this.right.decomposeLeft(to - left, result);
    }
    decomposeRight(from, result) {
        let left = this.left.length, right = left + this.break;
        if (from >= right)
            return this.right.decomposeRight(from - right, result);
        if (from < left)
            this.left.decomposeRight(from, result);
        if (this.break && from < right)
            result.push(null);
        result.push(this.right);
    }
    balanced(left, right) {
        if (left.size > 2 * right.size || right.size > 2 * left.size)
            return HeightMap.of(this.break ? [left, null, right] : [left, right]);
        this.left = left;
        this.right = right;
        this.height = left.height + right.height;
        this.outdated = left.outdated || right.outdated;
        this.size = left.size + right.size;
        this.length = left.length + this.break + right.length;
        return this;
    }
    updateHeight(oracle, offset = 0, force = false, measured) {
        let { left, right } = this, rightStart = offset + left.length + this.break, rebalance = null;
        if (measured && measured.from <= offset + left.length && measured.more)
            rebalance = left = left.updateHeight(oracle, offset, force, measured);
        else
            left.updateHeight(oracle, offset, force);
        if (measured && measured.from <= rightStart + right.length && measured.more)
            rebalance = right = right.updateHeight(oracle, rightStart, force, measured);
        else
            right.updateHeight(oracle, rightStart, force);
        if (rebalance)
            return this.balanced(left, right);
        this.height = this.left.height + this.right.height;
        this.outdated = false;
        return this;
    }
    toString() { return this.left + (this.break ? " " : "-") + this.right; }
}
function mergeGaps(nodes, around) {
    let before, after;
    if (nodes[around] == null &&
        (before = nodes[around - 1]) instanceof HeightMapGap &&
        (after = nodes[around + 1]) instanceof HeightMapGap)
        nodes.splice(around - 1, 3, new HeightMapGap(before.length + 1 + after.length));
}
const relevantWidgetHeight = 5;
class NodeBuilder {
    constructor(pos, oracle) {
        this.pos = pos;
        this.oracle = oracle;
        this.nodes = [];
        this.lineStart = -1;
        this.lineEnd = -1;
        this.covering = null;
        this.writtenTo = pos;
    }
    get isCovered() {
        return this.covering && this.nodes[this.nodes.length - 1] == this.covering;
    }
    span(_from, to) {
        if (this.lineStart > -1) {
            let end = Math.min(to, this.lineEnd), last = this.nodes[this.nodes.length - 1];
            if (last instanceof HeightMapText)
                last.length += end - this.pos;
            else if (end > this.pos || !this.isCovered)
                this.nodes.push(new HeightMapText(end - this.pos, -1));
            this.writtenTo = end;
            if (to > end) {
                this.nodes.push(null);
                this.writtenTo++;
                this.lineStart = -1;
            }
        }
        this.pos = to;
    }
    point(from, to, deco) {
        if (from < to || deco.heightRelevant) {
            let height = deco.widget ? deco.widget.estimatedHeight : 0;
            if (height < 0)
                height = this.oracle.lineHeight;
            let len = to - from;
            if (deco.block) {
                this.addBlock(new HeightMapBlock(len, height, deco.type));
            }
            else if (len || height >= relevantWidgetHeight) {
                this.addLineDeco(height, len);
            }
        }
        else if (to > from) {
            this.span(from, to);
        }
        if (this.lineEnd > -1 && this.lineEnd < this.pos)
            this.lineEnd = this.oracle.doc.lineAt(this.pos).to;
    }
    enterLine() {
        if (this.lineStart > -1)
            return;
        let { from, to } = this.oracle.doc.lineAt(this.pos);
        this.lineStart = from;
        this.lineEnd = to;
        if (this.writtenTo < from) {
            if (this.writtenTo < from - 1 || this.nodes[this.nodes.length - 1] == null)
                this.nodes.push(this.blankContent(this.writtenTo, from - 1));
            this.nodes.push(null);
        }
        if (this.pos > from)
            this.nodes.push(new HeightMapText(this.pos - from, -1));
        this.writtenTo = this.pos;
    }
    blankContent(from, to) {
        let gap = new HeightMapGap(to - from);
        if (this.oracle.doc.lineAt(from).to == to)
            gap.flags |= 4 /* Flag.SingleLine */;
        return gap;
    }
    ensureLine() {
        this.enterLine();
        let last = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;
        if (last instanceof HeightMapText)
            return last;
        let line = new HeightMapText(0, -1);
        this.nodes.push(line);
        return line;
    }
    addBlock(block) {
        this.enterLine();
        if (block.type == BlockType.WidgetAfter && !this.isCovered)
            this.ensureLine();
        this.nodes.push(block);
        this.writtenTo = this.pos = this.pos + block.length;
        if (block.type != BlockType.WidgetBefore)
            this.covering = block;
    }
    addLineDeco(height, length) {
        let line = this.ensureLine();
        line.length += length;
        line.collapsed += length;
        line.widgetHeight = Math.max(line.widgetHeight, height);
        this.writtenTo = this.pos = this.pos + length;
    }
    finish(from) {
        let last = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];
        if (this.lineStart > -1 && !(last instanceof HeightMapText) && !this.isCovered)
            this.nodes.push(new HeightMapText(0, -1));
        else if (this.writtenTo < this.pos || last == null)
            this.nodes.push(this.blankContent(this.writtenTo, this.pos));
        let pos = from;
        for (let node of this.nodes) {
            if (node instanceof HeightMapText)
                node.updateHeight(this.oracle, pos);
            pos += node ? node.length : 1;
        }
        return this.nodes;
    }
    // Always called with a region that on both sides either stretches
    // to a line break or the end of the document.
    // The returned array uses null to indicate line breaks, but never
    // starts or ends in a line break, or has multiple line breaks next
    // to each other.
    static build(oracle, decorations, from, to) {
        let builder = new NodeBuilder(from, oracle);
        state_dist/* RangeSet.spans */.Xs.spans(decorations, from, to, builder, 0);
        return builder.finish(from);
    }
}
function heightRelevantDecoChanges(a, b, diff) {
    let comp = new DecorationComparator;
    state_dist/* RangeSet.compare */.Xs.compare(a, b, diff, comp, 0);
    return comp.changes;
}
class DecorationComparator {
    constructor() {
        this.changes = [];
    }
    compareRange() { }
    comparePoint(from, to, a, b) {
        if (from < to || a && a.heightRelevant || b && b.heightRelevant)
            addRange(from, to, this.changes, 5);
    }
}

function visiblePixelRange(dom, paddingTop) {
    let rect = dom.getBoundingClientRect();
    let doc = dom.ownerDocument, win = doc.defaultView || window;
    let left = Math.max(0, rect.left), right = Math.min(win.innerWidth, rect.right);
    let top = Math.max(0, rect.top), bottom = Math.min(win.innerHeight, rect.bottom);
    for (let parent = dom.parentNode; parent && parent != doc.body;) {
        if (parent.nodeType == 1) {
            let elt = parent;
            let style = window.getComputedStyle(elt);
            if ((elt.scrollHeight > elt.clientHeight || elt.scrollWidth > elt.clientWidth) &&
                style.overflow != "visible") {
                let parentRect = elt.getBoundingClientRect();
                left = Math.max(left, parentRect.left);
                right = Math.min(right, parentRect.right);
                top = Math.max(top, parentRect.top);
                bottom = parent == dom.parentNode ? parentRect.bottom : Math.min(bottom, parentRect.bottom);
            }
            parent = style.position == "absolute" || style.position == "fixed" ? elt.offsetParent : elt.parentNode;
        }
        else if (parent.nodeType == 11) { // Shadow root
            parent = parent.host;
        }
        else {
            break;
        }
    }
    return { left: left - rect.left, right: Math.max(left, right) - rect.left,
        top: top - (rect.top + paddingTop), bottom: Math.max(top, bottom) - (rect.top + paddingTop) };
}
function fullPixelRange(dom, paddingTop) {
    let rect = dom.getBoundingClientRect();
    return { left: 0, right: rect.right - rect.left,
        top: paddingTop, bottom: rect.bottom - (rect.top + paddingTop) };
}
// Line gaps are placeholder widgets used to hide pieces of overlong
// lines within the viewport, as a kludge to keep the editor
// responsive when a ridiculously long line is loaded into it.
class LineGap {
    constructor(from, to, size) {
        this.from = from;
        this.to = to;
        this.size = size;
    }
    static same(a, b) {
        if (a.length != b.length)
            return false;
        for (let i = 0; i < a.length; i++) {
            let gA = a[i], gB = b[i];
            if (gA.from != gB.from || gA.to != gB.to || gA.size != gB.size)
                return false;
        }
        return true;
    }
    draw(wrapping) {
        return Decoration.replace({ widget: new LineGapWidget(this.size, wrapping) }).range(this.from, this.to);
    }
}
class LineGapWidget extends WidgetType {
    constructor(size, vertical) {
        super();
        this.size = size;
        this.vertical = vertical;
    }
    eq(other) { return other.size == this.size && other.vertical == this.vertical; }
    toDOM() {
        let elt = document.createElement("div");
        if (this.vertical) {
            elt.style.height = this.size + "px";
        }
        else {
            elt.style.width = this.size + "px";
            elt.style.height = "2px";
            elt.style.display = "inline-block";
        }
        return elt;
    }
    get estimatedHeight() { return this.vertical ? this.size : -1; }
}
class ViewState {
    constructor(state) {
        this.state = state;
        // These are contentDOM-local coordinates
        this.pixelViewport = { left: 0, right: window.innerWidth, top: 0, bottom: 0 };
        this.inView = true;
        this.paddingTop = 0;
        this.paddingBottom = 0;
        this.contentDOMWidth = 0;
        this.contentDOMHeight = 0;
        this.editorHeight = 0;
        this.editorWidth = 0;
        this.heightOracle = new HeightOracle;
        // See VP.MaxDOMHeight
        this.scaler = IdScaler;
        this.scrollTarget = null;
        // Briefly set to true when printing, to disable viewport limiting
        this.printing = false;
        // Flag set when editor content was redrawn, so that the next
        // measure stage knows it must read DOM layout
        this.mustMeasureContent = true;
        this.defaultTextDirection = Direction.RTL;
        this.visibleRanges = [];
        // Cursor 'assoc' is only significant when the cursor is on a line
        // wrap point, where it must stick to the character that it is
        // associated with. Since browsers don't provide a reasonable
        // interface to set or query this, when a selection is set that
        // might cause this to be significant, this flag is set. The next
        // measure phase will check whether the cursor is on a line-wrapping
        // boundary and, if so, reset it to make sure it is positioned in
        // the right place.
        this.mustEnforceCursorAssoc = false;
        this.stateDeco = state.facet(decorations).filter(d => typeof d != "function");
        this.heightMap = HeightMap.empty().applyChanges(this.stateDeco, state_dist/* Text.empty */.xv.empty, this.heightOracle.setDoc(state.doc), [new ChangedRange(0, 0, 0, state.doc.length)]);
        this.viewport = this.getViewport(0, null);
        this.updateViewportLines();
        this.updateForViewport();
        this.lineGaps = this.ensureLineGaps([]);
        this.lineGapDeco = Decoration.set(this.lineGaps.map(gap => gap.draw(false)));
        this.computeVisibleRanges();
    }
    updateForViewport() {
        let viewports = [this.viewport], { main } = this.state.selection;
        for (let i = 0; i <= 1; i++) {
            let pos = i ? main.head : main.anchor;
            if (!viewports.some(({ from, to }) => pos >= from && pos <= to)) {
                let { from, to } = this.lineBlockAt(pos);
                viewports.push(new Viewport(from, to));
            }
        }
        this.viewports = viewports.sort((a, b) => a.from - b.from);
        this.scaler = this.heightMap.height <= 7000000 /* VP.MaxDOMHeight */ ? IdScaler :
            new BigScaler(this.heightOracle.doc, this.heightMap, this.viewports);
    }
    updateViewportLines() {
        this.viewportLines = [];
        this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.state.doc, 0, 0, block => {
            this.viewportLines.push(this.scaler.scale == 1 ? block : scaleBlock(block, this.scaler));
        });
    }
    update(update, scrollTarget = null) {
        this.state = update.state;
        let prevDeco = this.stateDeco;
        this.stateDeco = this.state.facet(decorations).filter(d => typeof d != "function");
        let contentChanges = update.changedRanges;
        let heightChanges = ChangedRange.extendWithRanges(contentChanges, heightRelevantDecoChanges(prevDeco, this.stateDeco, update ? update.changes : state_dist/* ChangeSet.empty */.as.empty(this.state.doc.length)));
        let prevHeight = this.heightMap.height;
        this.heightMap = this.heightMap.applyChanges(this.stateDeco, update.startState.doc, this.heightOracle.setDoc(this.state.doc), heightChanges);
        if (this.heightMap.height != prevHeight)
            update.flags |= 2 /* UpdateFlag.Height */;
        let viewport = heightChanges.length ? this.mapViewport(this.viewport, update.changes) : this.viewport;
        if (scrollTarget && (scrollTarget.range.head < viewport.from || scrollTarget.range.head > viewport.to) ||
            !this.viewportIsAppropriate(viewport))
            viewport = this.getViewport(0, scrollTarget);
        let updateLines = !update.changes.empty || (update.flags & 2 /* UpdateFlag.Height */) ||
            viewport.from != this.viewport.from || viewport.to != this.viewport.to;
        this.viewport = viewport;
        this.updateForViewport();
        if (updateLines)
            this.updateViewportLines();
        if (this.lineGaps.length || this.viewport.to - this.viewport.from > (2000 /* LG.Margin */ << 1))
            this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, update.changes)));
        update.flags |= this.computeVisibleRanges();
        if (scrollTarget)
            this.scrollTarget = scrollTarget;
        if (!this.mustEnforceCursorAssoc && update.selectionSet && update.view.lineWrapping &&
            update.state.selection.main.empty && update.state.selection.main.assoc)
            this.mustEnforceCursorAssoc = true;
    }
    measure(view) {
        let dom = view.contentDOM, style = window.getComputedStyle(dom);
        let oracle = this.heightOracle;
        let whiteSpace = style.whiteSpace;
        this.defaultTextDirection = style.direction == "rtl" ? Direction.RTL : Direction.LTR;
        let refresh = this.heightOracle.mustRefreshForWrapping(whiteSpace);
        let measureContent = refresh || this.mustMeasureContent || this.contentDOMHeight != dom.clientHeight;
        this.contentDOMHeight = dom.clientHeight;
        this.mustMeasureContent = false;
        let result = 0, bias = 0;
        // Vertical padding
        let paddingTop = parseInt(style.paddingTop) || 0, paddingBottom = parseInt(style.paddingBottom) || 0;
        if (this.paddingTop != paddingTop || this.paddingBottom != paddingBottom) {
            this.paddingTop = paddingTop;
            this.paddingBottom = paddingBottom;
            result |= 8 /* UpdateFlag.Geometry */ | 2 /* UpdateFlag.Height */;
        }
        if (this.editorWidth != view.scrollDOM.clientWidth) {
            if (oracle.lineWrapping)
                measureContent = true;
            this.editorWidth = view.scrollDOM.clientWidth;
            result |= 8 /* UpdateFlag.Geometry */;
        }
        // Pixel viewport
        let pixelViewport = (this.printing ? fullPixelRange : visiblePixelRange)(dom, this.paddingTop);
        let dTop = pixelViewport.top - this.pixelViewport.top, dBottom = pixelViewport.bottom - this.pixelViewport.bottom;
        this.pixelViewport = pixelViewport;
        let inView = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;
        if (inView != this.inView) {
            this.inView = inView;
            if (inView)
                measureContent = true;
        }
        if (!this.inView && !this.scrollTarget)
            return 0;
        let contentWidth = dom.clientWidth;
        if (this.contentDOMWidth != contentWidth || this.editorHeight != view.scrollDOM.clientHeight) {
            this.contentDOMWidth = contentWidth;
            this.editorHeight = view.scrollDOM.clientHeight;
            result |= 8 /* UpdateFlag.Geometry */;
        }
        if (measureContent) {
            let lineHeights = view.docView.measureVisibleLineHeights(this.viewport);
            if (oracle.mustRefreshForHeights(lineHeights))
                refresh = true;
            if (refresh || oracle.lineWrapping && Math.abs(contentWidth - this.contentDOMWidth) > oracle.charWidth) {
                let { lineHeight, charWidth } = view.docView.measureTextSize();
                refresh = oracle.refresh(whiteSpace, lineHeight, charWidth, contentWidth / charWidth, lineHeights);
                if (refresh) {
                    view.docView.minWidth = 0;
                    result |= 8 /* UpdateFlag.Geometry */;
                }
            }
            if (dTop > 0 && dBottom > 0)
                bias = Math.max(dTop, dBottom);
            else if (dTop < 0 && dBottom < 0)
                bias = Math.min(dTop, dBottom);
            oracle.heightChanged = false;
            for (let vp of this.viewports) {
                let heights = vp.from == this.viewport.from ? lineHeights : view.docView.measureVisibleLineHeights(vp);
                this.heightMap = this.heightMap.updateHeight(oracle, 0, refresh, new MeasuredHeights(vp.from, heights));
            }
            if (oracle.heightChanged)
                result |= 2 /* UpdateFlag.Height */;
        }
        let viewportChange = !this.viewportIsAppropriate(this.viewport, bias) ||
            this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from || this.scrollTarget.range.head > this.viewport.to);
        if (viewportChange)
            this.viewport = this.getViewport(bias, this.scrollTarget);
        this.updateForViewport();
        if ((result & 2 /* UpdateFlag.Height */) || viewportChange)
            this.updateViewportLines();
        if (this.lineGaps.length || this.viewport.to - this.viewport.from > (2000 /* LG.Margin */ << 1))
            this.updateLineGaps(this.ensureLineGaps(refresh ? [] : this.lineGaps, view));
        result |= this.computeVisibleRanges();
        if (this.mustEnforceCursorAssoc) {
            this.mustEnforceCursorAssoc = false;
            // This is done in the read stage, because moving the selection
            // to a line end is going to trigger a layout anyway, so it
            // can't be a pure write. It should be rare that it does any
            // writing.
            view.docView.enforceCursorAssoc();
        }
        return result;
    }
    get visibleTop() { return this.scaler.fromDOM(this.pixelViewport.top); }
    get visibleBottom() { return this.scaler.fromDOM(this.pixelViewport.bottom); }
    getViewport(bias, scrollTarget) {
        // This will divide VP.Margin between the top and the
        // bottom, depending on the bias (the change in viewport position
        // since the last update). It'll hold a number between 0 and 1
        let marginTop = 0.5 - Math.max(-0.5, Math.min(0.5, bias / 1000 /* VP.Margin */ / 2));
        let map = this.heightMap, doc = this.state.doc, { visibleTop, visibleBottom } = this;
        let viewport = new Viewport(map.lineAt(visibleTop - marginTop * 1000 /* VP.Margin */, QueryType.ByHeight, doc, 0, 0).from, map.lineAt(visibleBottom + (1 - marginTop) * 1000 /* VP.Margin */, QueryType.ByHeight, doc, 0, 0).to);
        // If scrollTarget is given, make sure the viewport includes that position
        if (scrollTarget) {
            let { head } = scrollTarget.range;
            if (head < viewport.from || head > viewport.to) {
                let viewHeight = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top);
                let block = map.lineAt(head, QueryType.ByPos, doc, 0, 0), topPos;
                if (scrollTarget.y == "center")
                    topPos = (block.top + block.bottom) / 2 - viewHeight / 2;
                else if (scrollTarget.y == "start" || scrollTarget.y == "nearest" && head < viewport.from)
                    topPos = block.top;
                else
                    topPos = block.bottom - viewHeight;
                viewport = new Viewport(map.lineAt(topPos - 1000 /* VP.Margin */ / 2, QueryType.ByHeight, doc, 0, 0).from, map.lineAt(topPos + viewHeight + 1000 /* VP.Margin */ / 2, QueryType.ByHeight, doc, 0, 0).to);
            }
        }
        return viewport;
    }
    mapViewport(viewport, changes) {
        let from = changes.mapPos(viewport.from, -1), to = changes.mapPos(viewport.to, 1);
        return new Viewport(this.heightMap.lineAt(from, QueryType.ByPos, this.state.doc, 0, 0).from, this.heightMap.lineAt(to, QueryType.ByPos, this.state.doc, 0, 0).to);
    }
    // Checks if a given viewport covers the visible part of the
    // document and not too much beyond that.
    viewportIsAppropriate({ from, to }, bias = 0) {
        if (!this.inView)
            return true;
        let { top } = this.heightMap.lineAt(from, QueryType.ByPos, this.state.doc, 0, 0);
        let { bottom } = this.heightMap.lineAt(to, QueryType.ByPos, this.state.doc, 0, 0);
        let { visibleTop, visibleBottom } = this;
        return (from == 0 || top <= visibleTop - Math.max(10 /* VP.MinCoverMargin */, Math.min(-bias, 250 /* VP.MaxCoverMargin */))) &&
            (to == this.state.doc.length ||
                bottom >= visibleBottom + Math.max(10 /* VP.MinCoverMargin */, Math.min(bias, 250 /* VP.MaxCoverMargin */))) &&
            (top > visibleTop - 2 * 1000 /* VP.Margin */ && bottom < visibleBottom + 2 * 1000 /* VP.Margin */);
    }
    mapLineGaps(gaps, changes) {
        if (!gaps.length || changes.empty)
            return gaps;
        let mapped = [];
        for (let gap of gaps)
            if (!changes.touchesRange(gap.from, gap.to))
                mapped.push(new LineGap(changes.mapPos(gap.from), changes.mapPos(gap.to), gap.size));
        return mapped;
    }
    // Computes positions in the viewport where the start or end of a
    // line should be hidden, trying to reuse existing line gaps when
    // appropriate to avoid unneccesary redraws.
    // Uses crude character-counting for the positioning and sizing,
    // since actual DOM coordinates aren't always available and
    // predictable. Relies on generous margins (see LG.Margin) to hide
    // the artifacts this might produce from the user.
    ensureLineGaps(current, mayMeasure) {
        let wrapping = this.heightOracle.lineWrapping;
        let margin = wrapping ? 10000 /* LG.MarginWrap */ : 2000 /* LG.Margin */, halfMargin = margin >> 1, doubleMargin = margin << 1;
        // The non-wrapping logic won't work at all in predominantly right-to-left text.
        if (this.defaultTextDirection != Direction.LTR && !wrapping)
            return [];
        let gaps = [];
        let addGap = (from, to, line, structure) => {
            if (to - from < halfMargin)
                return;
            let sel = this.state.selection.main, avoid = [sel.from];
            if (!sel.empty)
                avoid.push(sel.to);
            for (let pos of avoid) {
                if (pos > from && pos < to) {
                    addGap(from, pos - 10 /* LG.SelectionMargin */, line, structure);
                    addGap(pos + 10 /* LG.SelectionMargin */, to, line, structure);
                    return;
                }
            }
            let gap = find(current, gap => gap.from >= line.from && gap.to <= line.to &&
                Math.abs(gap.from - from) < halfMargin && Math.abs(gap.to - to) < halfMargin &&
                !avoid.some(pos => gap.from < pos && gap.to > pos));
            if (!gap) {
                // When scrolling down, snap gap ends to line starts to avoid shifts in wrapping
                if (to < line.to && mayMeasure && wrapping &&
                    mayMeasure.visibleRanges.some(r => r.from <= to && r.to >= to)) {
                    let lineStart = mayMeasure.moveToLineBoundary(state_dist/* EditorSelection.cursor */.jT.cursor(to), false, true).head;
                    if (lineStart > from)
                        to = lineStart;
                }
                gap = new LineGap(from, to, this.gapSize(line, from, to, structure));
            }
            gaps.push(gap);
        };
        for (let line of this.viewportLines) {
            if (line.length < doubleMargin)
                continue;
            let structure = lineStructure(line.from, line.to, this.stateDeco);
            if (structure.total < doubleMargin)
                continue;
            let target = this.scrollTarget ? this.scrollTarget.range.head : null;
            let viewFrom, viewTo;
            if (wrapping) {
                let marginHeight = (margin / this.heightOracle.lineLength) * this.heightOracle.lineHeight;
                let top, bot;
                if (target != null) {
                    top = Math.max(line.from, target - margin);
                    bot = Math.min(line.to, target + margin);
                }
                else {
                    top = (this.visibleTop - line.top - marginHeight) / line.height;
                    bot = (this.visibleBottom - line.top + marginHeight) / line.height;
                }
                viewFrom = findPosition(structure, top);
                viewTo = findPosition(structure, bot);
            }
            else {
                let left, right;
                if (target != null) {
                    left = Math.max(line.from, target - doubleMargin);
                    right = Math.min(line.to, target + doubleMargin);
                }
                else {
                    let totalWidth = structure.total * this.heightOracle.charWidth;
                    let marginWidth = margin * this.heightOracle.charWidth;
                    left = (this.pixelViewport.left - marginWidth) / totalWidth;
                    right = (this.pixelViewport.right + marginWidth) / totalWidth;
                }
                viewFrom = findPosition(structure, left);
                viewTo = findPosition(structure, right);
            }
            if (viewFrom > line.from)
                addGap(line.from, viewFrom, line, structure);
            if (viewTo < line.to)
                addGap(viewTo, line.to, line, structure);
        }
        return gaps;
    }
    gapSize(line, from, to, structure) {
        let fraction = findFraction(structure, to) - findFraction(structure, from);
        if (this.heightOracle.lineWrapping) {
            return line.height * fraction;
        }
        else {
            return structure.total * this.heightOracle.charWidth * fraction;
        }
    }
    updateLineGaps(gaps) {
        if (!LineGap.same(gaps, this.lineGaps)) {
            this.lineGaps = gaps;
            this.lineGapDeco = Decoration.set(gaps.map(gap => gap.draw(this.heightOracle.lineWrapping)));
        }
    }
    computeVisibleRanges() {
        let deco = this.stateDeco;
        if (this.lineGaps.length)
            deco = deco.concat(this.lineGapDeco);
        let ranges = [];
        state_dist/* RangeSet.spans */.Xs.spans(deco, this.viewport.from, this.viewport.to, {
            span(from, to) { ranges.push({ from, to }); },
            point() { }
        }, 20);
        let changed = ranges.length != this.visibleRanges.length ||
            this.visibleRanges.some((r, i) => r.from != ranges[i].from || r.to != ranges[i].to);
        this.visibleRanges = ranges;
        return changed ? 4 /* UpdateFlag.Viewport */ : 0;
    }
    lineBlockAt(pos) {
        return (pos >= this.viewport.from && pos <= this.viewport.to && this.viewportLines.find(b => b.from <= pos && b.to >= pos)) ||
            scaleBlock(this.heightMap.lineAt(pos, QueryType.ByPos, this.state.doc, 0, 0), this.scaler);
    }
    lineBlockAtHeight(height) {
        return scaleBlock(this.heightMap.lineAt(this.scaler.fromDOM(height), QueryType.ByHeight, this.state.doc, 0, 0), this.scaler);
    }
    elementAtHeight(height) {
        return scaleBlock(this.heightMap.blockAt(this.scaler.fromDOM(height), this.state.doc, 0, 0), this.scaler);
    }
    get docHeight() {
        return this.scaler.toDOM(this.heightMap.height);
    }
    get contentHeight() {
        return this.docHeight + this.paddingTop + this.paddingBottom;
    }
}
class Viewport {
    constructor(from, to) {
        this.from = from;
        this.to = to;
    }
}
function lineStructure(from, to, stateDeco) {
    let ranges = [], pos = from, total = 0;
    state_dist/* RangeSet.spans */.Xs.spans(stateDeco, from, to, {
        span() { },
        point(from, to) {
            if (from > pos) {
                ranges.push({ from: pos, to: from });
                total += from - pos;
            }
            pos = to;
        }
    }, 20); // We're only interested in collapsed ranges of a significant size
    if (pos < to) {
        ranges.push({ from: pos, to });
        total += to - pos;
    }
    return { total, ranges };
}
function findPosition({ total, ranges }, ratio) {
    if (ratio <= 0)
        return ranges[0].from;
    if (ratio >= 1)
        return ranges[ranges.length - 1].to;
    let dist = Math.floor(total * ratio);
    for (let i = 0;; i++) {
        let { from, to } = ranges[i], size = to - from;
        if (dist <= size)
            return from + dist;
        dist -= size;
    }
}
function findFraction(structure, pos) {
    let counted = 0;
    for (let { from, to } of structure.ranges) {
        if (pos <= to) {
            counted += pos - from;
            break;
        }
        counted += to - from;
    }
    return counted / structure.total;
}
function find(array, f) {
    for (let val of array)
        if (f(val))
            return val;
    return undefined;
}
// Don't scale when the document height is within the range of what
// the DOM can handle.
const IdScaler = {
    toDOM(n) { return n; },
    fromDOM(n) { return n; },
    scale: 1
};
// When the height is too big (> VP.MaxDOMHeight), scale down the
// regions outside the viewports so that the total height is
// VP.MaxDOMHeight.
class BigScaler {
    constructor(doc, heightMap, viewports) {
        let vpHeight = 0, base = 0, domBase = 0;
        this.viewports = viewports.map(({ from, to }) => {
            let top = heightMap.lineAt(from, QueryType.ByPos, doc, 0, 0).top;
            let bottom = heightMap.lineAt(to, QueryType.ByPos, doc, 0, 0).bottom;
            vpHeight += bottom - top;
            return { from, to, top, bottom, domTop: 0, domBottom: 0 };
        });
        this.scale = (7000000 /* VP.MaxDOMHeight */ - vpHeight) / (heightMap.height - vpHeight);
        for (let obj of this.viewports) {
            obj.domTop = domBase + (obj.top - base) * this.scale;
            domBase = obj.domBottom = obj.domTop + (obj.bottom - obj.top);
            base = obj.bottom;
        }
    }
    toDOM(n) {
        for (let i = 0, base = 0, domBase = 0;; i++) {
            let vp = i < this.viewports.length ? this.viewports[i] : null;
            if (!vp || n < vp.top)
                return domBase + (n - base) * this.scale;
            if (n <= vp.bottom)
                return vp.domTop + (n - vp.top);
            base = vp.bottom;
            domBase = vp.domBottom;
        }
    }
    fromDOM(n) {
        for (let i = 0, base = 0, domBase = 0;; i++) {
            let vp = i < this.viewports.length ? this.viewports[i] : null;
            if (!vp || n < vp.domTop)
                return base + (n - domBase) / this.scale;
            if (n <= vp.domBottom)
                return vp.top + (n - vp.domTop);
            base = vp.bottom;
            domBase = vp.domBottom;
        }
    }
}
function scaleBlock(block, scaler) {
    if (scaler.scale == 1)
        return block;
    let bTop = scaler.toDOM(block.top), bBottom = scaler.toDOM(block.bottom);
    return new BlockInfo(block.from, block.length, bTop, bBottom - bTop, Array.isArray(block.type) ? block.type.map(b => scaleBlock(b, scaler)) : block.type);
}

const theme = /*@__PURE__*/state_dist/* Facet.define */.r$.define({ combine: strs => strs.join(" ") });
const darkTheme = /*@__PURE__*/state_dist/* Facet.define */.r$.define({ combine: values => values.indexOf(true) > -1 });
const baseThemeID = /*@__PURE__*/style_mod/* StyleModule.newName */.V.newName(), baseLightID = /*@__PURE__*/style_mod/* StyleModule.newName */.V.newName(), baseDarkID = /*@__PURE__*/style_mod/* StyleModule.newName */.V.newName();
const lightDarkIDs = { "&light": "." + baseLightID, "&dark": "." + baseDarkID };
function buildTheme(main, spec, scopes) {
    return new style_mod/* StyleModule */.V(spec, {
        finish(sel) {
            return /&/.test(sel) ? sel.replace(/&\w*/, m => {
                if (m == "&")
                    return main;
                if (!scopes || !scopes[m])
                    throw new RangeError(`Unsupported selector: ${m}`);
                return scopes[m];
            }) : main + " " + sel;
        }
    });
}
const baseTheme$1 = /*@__PURE__*/buildTheme("." + baseThemeID, {
    "&.cm-editor": {
        position: "relative !important",
        boxSizing: "border-box",
        "&.cm-focused": {
            // Provide a simple default outline to make sure a focused
            // editor is visually distinct. Can't leave the default behavior
            // because that will apply to the content element, which is
            // inside the scrollable container and doesn't include the
            // gutters. We also can't use an 'auto' outline, since those
            // are, for some reason, drawn behind the element content, which
            // will cause things like the active line background to cover
            // the outline (#297).
            outline: "1px dotted #212121"
        },
        display: "flex !important",
        flexDirection: "column"
    },
    ".cm-scroller": {
        display: "flex !important",
        alignItems: "flex-start !important",
        fontFamily: "monospace",
        lineHeight: 1.4,
        height: "100%",
        overflowX: "auto",
        position: "relative",
        zIndex: 0
    },
    ".cm-content": {
        margin: 0,
        flexGrow: 2,
        flexShrink: 0,
        minHeight: "100%",
        display: "block",
        whiteSpace: "pre",
        wordWrap: "normal",
        boxSizing: "border-box",
        padding: "4px 0",
        outline: "none",
        "&[contenteditable=true]": {
            WebkitUserModify: "read-write-plaintext-only",
        }
    },
    ".cm-lineWrapping": {
        whiteSpace_fallback: "pre-wrap",
        whiteSpace: "break-spaces",
        wordBreak: "break-word",
        overflowWrap: "anywhere",
        flexShrink: 1
    },
    "&light .cm-content": { caretColor: "black" },
    "&dark .cm-content": { caretColor: "white" },
    ".cm-line": {
        display: "block",
        padding: "0 2px 0 4px"
    },
    ".cm-selectionLayer": {
        zIndex: -1,
        contain: "size style"
    },
    ".cm-selectionBackground": {
        position: "absolute",
    },
    "&light .cm-selectionBackground": {
        background: "#d9d9d9"
    },
    "&dark .cm-selectionBackground": {
        background: "#222"
    },
    "&light.cm-focused .cm-selectionBackground": {
        background: "#d7d4f0"
    },
    "&dark.cm-focused .cm-selectionBackground": {
        background: "#233"
    },
    ".cm-cursorLayer": {
        zIndex: 100,
        contain: "size style",
        pointerEvents: "none"
    },
    "&.cm-focused .cm-cursorLayer": {
        animation: "steps(1) cm-blink 1.2s infinite"
    },
    // Two animations defined so that we can switch between them to
    // restart the animation without forcing another style
    // recomputation.
    "@keyframes cm-blink": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
    "@keyframes cm-blink2": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
    ".cm-cursor, .cm-dropCursor": {
        position: "absolute",
        borderLeft: "1.2px solid black",
        marginLeft: "-0.6px",
        pointerEvents: "none",
    },
    ".cm-cursor": {
        display: "none"
    },
    "&dark .cm-cursor": {
        borderLeftColor: "#444"
    },
    "&.cm-focused .cm-cursor": {
        display: "block"
    },
    "&light .cm-activeLine": { backgroundColor: "#cceeff44" },
    "&dark .cm-activeLine": { backgroundColor: "#99eeff33" },
    "&light .cm-specialChar": { color: "red" },
    "&dark .cm-specialChar": { color: "#f78" },
    ".cm-gutters": {
        flexShrink: 0,
        display: "flex",
        height: "100%",
        boxSizing: "border-box",
        left: 0,
        zIndex: 200
    },
    "&light .cm-gutters": {
        backgroundColor: "#f5f5f5",
        color: "#6c6c6c",
        borderRight: "1px solid #ddd"
    },
    "&dark .cm-gutters": {
        backgroundColor: "#333338",
        color: "#ccc"
    },
    ".cm-gutter": {
        display: "flex !important",
        flexDirection: "column",
        flexShrink: 0,
        boxSizing: "border-box",
        minHeight: "100%",
        overflow: "hidden"
    },
    ".cm-gutterElement": {
        boxSizing: "border-box"
    },
    ".cm-lineNumbers .cm-gutterElement": {
        padding: "0 3px 0 5px",
        minWidth: "20px",
        textAlign: "right",
        whiteSpace: "nowrap"
    },
    "&light .cm-activeLineGutter": {
        backgroundColor: "#e2f2ff"
    },
    "&dark .cm-activeLineGutter": {
        backgroundColor: "#222227"
    },
    ".cm-panels": {
        boxSizing: "border-box",
        position: "sticky",
        left: 0,
        right: 0
    },
    "&light .cm-panels": {
        backgroundColor: "#f5f5f5",
        color: "black"
    },
    "&light .cm-panels-top": {
        borderBottom: "1px solid #ddd"
    },
    "&light .cm-panels-bottom": {
        borderTop: "1px solid #ddd"
    },
    "&dark .cm-panels": {
        backgroundColor: "#333338",
        color: "white"
    },
    ".cm-tab": {
        display: "inline-block",
        overflow: "hidden",
        verticalAlign: "bottom"
    },
    ".cm-widgetBuffer": {
        verticalAlign: "text-top",
        height: "1em",
        width: 0,
        display: "inline"
    },
    ".cm-placeholder": {
        color: "#888",
        display: "inline-block",
        verticalAlign: "top",
    },
    ".cm-button": {
        verticalAlign: "middle",
        color: "inherit",
        fontSize: "70%",
        padding: ".2em 1em",
        borderRadius: "1px"
    },
    "&light .cm-button": {
        backgroundImage: "linear-gradient(#eff1f5, #d9d9df)",
        border: "1px solid #888",
        "&:active": {
            backgroundImage: "linear-gradient(#b4b4b4, #d0d3d6)"
        }
    },
    "&dark .cm-button": {
        backgroundImage: "linear-gradient(#393939, #111)",
        border: "1px solid #888",
        "&:active": {
            backgroundImage: "linear-gradient(#111, #333)"
        }
    },
    ".cm-textfield": {
        verticalAlign: "middle",
        color: "inherit",
        fontSize: "70%",
        border: "1px solid silver",
        padding: ".2em .5em"
    },
    "&light .cm-textfield": {
        backgroundColor: "white"
    },
    "&dark .cm-textfield": {
        border: "1px solid #555",
        backgroundColor: "inherit"
    }
}, lightDarkIDs);

const observeOptions = {
    childList: true,
    characterData: true,
    subtree: true,
    attributes: true,
    characterDataOldValue: true
};
// IE11 has very broken mutation observers, so we also listen to
// DOMCharacterDataModified there
const useCharData = browser.ie && browser.ie_version <= 11;
class DOMObserver {
    constructor(view, onChange, onScrollChanged) {
        this.view = view;
        this.onChange = onChange;
        this.onScrollChanged = onScrollChanged;
        this.active = false;
        // The known selection. Kept in our own object, as opposed to just
        // directly accessing the selection because:
        //  - Safari doesn't report the right selection in shadow DOM
        //  - Reading from the selection forces a DOM layout
        //  - This way, we can ignore selectionchange events if we have
        //    already seen the 'new' selection
        this.selectionRange = new DOMSelectionState;
        // Set when a selection change is detected, cleared on flush
        this.selectionChanged = false;
        this.delayedFlush = -1;
        this.resizeTimeout = -1;
        this.queue = [];
        this.delayedAndroidKey = null;
        this.lastChange = 0;
        this.scrollTargets = [];
        this.intersection = null;
        this.resize = null;
        this.intersecting = false;
        this.gapIntersection = null;
        this.gaps = [];
        // Timeout for scheduling check of the parents that need scroll handlers
        this.parentCheck = -1;
        this.dom = view.contentDOM;
        this.observer = new MutationObserver(mutations => {
            for (let mut of mutations)
                this.queue.push(mut);
            // IE11 will sometimes (on typing over a selection or
            // backspacing out a single character text node) call the
            // observer callback before actually updating the DOM.
            //
            // Unrelatedly, iOS Safari will, when ending a composition,
            // sometimes first clear it, deliver the mutations, and then
            // reinsert the finished text. CodeMirror's handling of the
            // deletion will prevent the reinsertion from happening,
            // breaking composition.
            if ((browser.ie && browser.ie_version <= 11 || browser.ios && view.composing) &&
                mutations.some(m => m.type == "childList" && m.removedNodes.length ||
                    m.type == "characterData" && m.oldValue.length > m.target.nodeValue.length))
                this.flushSoon();
            else
                this.flush();
        });
        if (useCharData)
            this.onCharData = (event) => {
                this.queue.push({ target: event.target,
                    type: "characterData",
                    oldValue: event.prevValue });
                this.flushSoon();
            };
        this.onSelectionChange = this.onSelectionChange.bind(this);
        this.onResize = this.onResize.bind(this);
        this.onPrint = this.onPrint.bind(this);
        this.onScroll = this.onScroll.bind(this);
        if (typeof ResizeObserver == "function") {
            this.resize = new ResizeObserver(() => {
                if (this.view.docView.lastUpdate < Date.now() - 75)
                    this.onResize();
            });
            this.resize.observe(view.scrollDOM);
        }
        this.addWindowListeners(this.win = view.win);
        this.start();
        if (typeof IntersectionObserver == "function") {
            this.intersection = new IntersectionObserver(entries => {
                if (this.parentCheck < 0)
                    this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1000);
                if (entries.length > 0 && (entries[entries.length - 1].intersectionRatio > 0) != this.intersecting) {
                    this.intersecting = !this.intersecting;
                    if (this.intersecting != this.view.inView)
                        this.onScrollChanged(document.createEvent("Event"));
                }
            }, {});
            this.intersection.observe(this.dom);
            this.gapIntersection = new IntersectionObserver(entries => {
                if (entries.length > 0 && entries[entries.length - 1].intersectionRatio > 0)
                    this.onScrollChanged(document.createEvent("Event"));
            }, {});
        }
        this.listenForScroll();
        this.readSelectionRange();
    }
    onScroll(e) {
        if (this.intersecting)
            this.flush(false);
        this.onScrollChanged(e);
    }
    onResize() {
        if (this.resizeTimeout < 0)
            this.resizeTimeout = setTimeout(() => {
                this.resizeTimeout = -1;
                this.view.requestMeasure();
            }, 50);
    }
    onPrint() {
        this.view.viewState.printing = true;
        this.view.measure();
        setTimeout(() => {
            this.view.viewState.printing = false;
            this.view.requestMeasure();
        }, 500);
    }
    updateGaps(gaps) {
        if (this.gapIntersection && (gaps.length != this.gaps.length || this.gaps.some((g, i) => g != gaps[i]))) {
            this.gapIntersection.disconnect();
            for (let gap of gaps)
                this.gapIntersection.observe(gap);
            this.gaps = gaps;
        }
    }
    onSelectionChange(event) {
        let wasChanged = this.selectionChanged;
        if (!this.readSelectionRange() || this.delayedAndroidKey)
            return;
        let { view } = this, sel = this.selectionRange;
        if (view.state.facet(editable) ? view.root.activeElement != this.dom : !hasSelection(view.dom, sel))
            return;
        let context = sel.anchorNode && view.docView.nearest(sel.anchorNode);
        if (context && context.ignoreEvent(event)) {
            if (!wasChanged)
                this.selectionChanged = false;
            return;
        }
        // Deletions on IE11 fire their events in the wrong order, giving
        // us a selection change event before the DOM changes are
        // reported.
        // Chrome Android has a similar issue when backspacing out a
        // selection (#645).
        if ((browser.ie && browser.ie_version <= 11 || browser.android && browser.chrome) && !view.state.selection.main.empty &&
            // (Selection.isCollapsed isn't reliable on IE)
            sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset))
            this.flushSoon();
        else
            this.flush(false);
    }
    readSelectionRange() {
        let { view } = this;
        // The Selection object is broken in shadow roots in Safari. See
        // https://github.com/codemirror/dev/issues/414
        let range = browser.safari && view.root.nodeType == 11 &&
            deepActiveElement(this.dom.ownerDocument) == this.dom &&
            safariSelectionRangeHack(this.view) || getSelection(view.root);
        if (!range || this.selectionRange.eq(range))
            return false;
        let local = hasSelection(this.dom, range);
        // Detect the situation where the browser has, on focus, moved the
        // selection to the start of the content element. Reset it to the
        // position from the editor state.
        if (local && !this.selectionChanged &&
            view.inputState.lastFocusTime > Date.now() - 200 &&
            view.inputState.lastTouchTime < Date.now() - 300 &&
            atElementStart(this.dom, range)) {
            this.view.inputState.lastFocusTime = 0;
            view.docView.updateSelection();
            return false;
        }
        this.selectionRange.setRange(range);
        if (local)
            this.selectionChanged = true;
        return true;
    }
    setSelectionRange(anchor, head) {
        this.selectionRange.set(anchor.node, anchor.offset, head.node, head.offset);
        this.selectionChanged = false;
    }
    clearSelectionRange() {
        this.selectionRange.set(null, 0, null, 0);
    }
    listenForScroll() {
        this.parentCheck = -1;
        let i = 0, changed = null;
        for (let dom = this.dom; dom;) {
            if (dom.nodeType == 1) {
                if (!changed && i < this.scrollTargets.length && this.scrollTargets[i] == dom)
                    i++;
                else if (!changed)
                    changed = this.scrollTargets.slice(0, i);
                if (changed)
                    changed.push(dom);
                dom = dom.assignedSlot || dom.parentNode;
            }
            else if (dom.nodeType == 11) { // Shadow root
                dom = dom.host;
            }
            else {
                break;
            }
        }
        if (i < this.scrollTargets.length && !changed)
            changed = this.scrollTargets.slice(0, i);
        if (changed) {
            for (let dom of this.scrollTargets)
                dom.removeEventListener("scroll", this.onScroll);
            for (let dom of this.scrollTargets = changed)
                dom.addEventListener("scroll", this.onScroll);
        }
    }
    ignore(f) {
        if (!this.active)
            return f();
        try {
            this.stop();
            return f();
        }
        finally {
            this.start();
            this.clear();
        }
    }
    start() {
        if (this.active)
            return;
        this.observer.observe(this.dom, observeOptions);
        if (useCharData)
            this.dom.addEventListener("DOMCharacterDataModified", this.onCharData);
        this.active = true;
    }
    stop() {
        if (!this.active)
            return;
        this.active = false;
        this.observer.disconnect();
        if (useCharData)
            this.dom.removeEventListener("DOMCharacterDataModified", this.onCharData);
    }
    // Throw away any pending changes
    clear() {
        this.processRecords();
        this.queue.length = 0;
        this.selectionChanged = false;
    }
    // Chrome Android, especially in combination with GBoard, not only
    // doesn't reliably fire regular key events, but also often
    // surrounds the effect of enter or backspace with a bunch of
    // composition events that, when interrupted, cause text duplication
    // or other kinds of corruption. This hack makes the editor back off
    // from handling DOM changes for a moment when such a key is
    // detected (via beforeinput or keydown), and then tries to flush
    // them or, if that has no effect, dispatches the given key.
    delayAndroidKey(key, keyCode) {
        var _a;
        if (!this.delayedAndroidKey)
            this.view.win.requestAnimationFrame(() => {
                let key = this.delayedAndroidKey;
                this.delayedAndroidKey = null;
                this.delayedFlush = -1;
                if (!this.flush() && key.force)
                    dispatchKey(this.dom, key.key, key.keyCode);
            });
        // Since backspace beforeinput is sometimes signalled spuriously,
        // Enter always takes precedence.
        if (!this.delayedAndroidKey || key == "Enter")
            this.delayedAndroidKey = {
                key, keyCode,
                // Only run the key handler when no changes are detected if
                // this isn't coming right after another change, in which case
                // it is probably part of a weird chain of updates, and should
                // be ignored if it returns the DOM to its previous state.
                force: this.lastChange < Date.now() - 50 || !!((_a = this.delayedAndroidKey) === null || _a === void 0 ? void 0 : _a.force)
            };
    }
    flushSoon() {
        if (this.delayedFlush < 0)
            this.delayedFlush = this.view.win.requestAnimationFrame(() => { this.delayedFlush = -1; this.flush(); });
    }
    forceFlush() {
        if (this.delayedFlush >= 0) {
            this.view.win.cancelAnimationFrame(this.delayedFlush);
            this.delayedFlush = -1;
        }
        this.flush();
    }
    processRecords() {
        let records = this.queue;
        for (let mut of this.observer.takeRecords())
            records.push(mut);
        if (records.length)
            this.queue = [];
        let from = -1, to = -1, typeOver = false;
        for (let record of records) {
            let range = this.readMutation(record);
            if (!range)
                continue;
            if (range.typeOver)
                typeOver = true;
            if (from == -1) {
                ({ from, to } = range);
            }
            else {
                from = Math.min(range.from, from);
                to = Math.max(range.to, to);
            }
        }
        return { from, to, typeOver };
    }
    // Apply pending changes, if any
    flush(readSelection = true) {
        // Completely hold off flushing when pending keys are setthe code
        // managing those will make sure processRecords is called and the
        // view is resynchronized after
        if (this.delayedFlush >= 0 || this.delayedAndroidKey)
            return false;
        if (readSelection)
            this.readSelectionRange();
        let { from, to, typeOver } = this.processRecords();
        let newSel = this.selectionChanged && hasSelection(this.dom, this.selectionRange);
        if (from < 0 && !newSel)
            return false;
        if (from > -1)
            this.lastChange = Date.now();
        this.view.inputState.lastFocusTime = 0;
        this.selectionChanged = false;
        let startState = this.view.state;
        let handled = this.onChange(from, to, typeOver);
        // The view wasn't updated
        if (this.view.state == startState)
            this.view.update([]);
        return handled;
    }
    readMutation(rec) {
        let cView = this.view.docView.nearest(rec.target);
        if (!cView || cView.ignoreMutation(rec))
            return null;
        cView.markDirty(rec.type == "attributes");
        if (rec.type == "attributes")
            cView.dirty |= 4 /* Dirty.Attrs */;
        if (rec.type == "childList") {
            let childBefore = findChild(cView, rec.previousSibling || rec.target.previousSibling, -1);
            let childAfter = findChild(cView, rec.nextSibling || rec.target.nextSibling, 1);
            return { from: childBefore ? cView.posAfter(childBefore) : cView.posAtStart,
                to: childAfter ? cView.posBefore(childAfter) : cView.posAtEnd, typeOver: false };
        }
        else if (rec.type == "characterData") {
            return { from: cView.posAtStart, to: cView.posAtEnd, typeOver: rec.target.nodeValue == rec.oldValue };
        }
        else {
            return null;
        }
    }
    setWindow(win) {
        if (win != this.win) {
            this.removeWindowListeners(this.win);
            this.win = win;
            this.addWindowListeners(this.win);
        }
    }
    addWindowListeners(win) {
        win.addEventListener("resize", this.onResize);
        win.addEventListener("beforeprint", this.onPrint);
        win.addEventListener("scroll", this.onScroll);
        win.document.addEventListener("selectionchange", this.onSelectionChange);
    }
    removeWindowListeners(win) {
        win.removeEventListener("scroll", this.onScroll);
        win.removeEventListener("resize", this.onResize);
        win.removeEventListener("beforeprint", this.onPrint);
        win.document.removeEventListener("selectionchange", this.onSelectionChange);
    }
    destroy() {
        var _a, _b, _c;
        this.stop();
        (_a = this.intersection) === null || _a === void 0 ? void 0 : _a.disconnect();
        (_b = this.gapIntersection) === null || _b === void 0 ? void 0 : _b.disconnect();
        (_c = this.resize) === null || _c === void 0 ? void 0 : _c.disconnect();
        for (let dom of this.scrollTargets)
            dom.removeEventListener("scroll", this.onScroll);
        this.removeWindowListeners(this.win);
        clearTimeout(this.parentCheck);
        clearTimeout(this.resizeTimeout);
    }
}
function findChild(cView, dom, dir) {
    while (dom) {
        let curView = ContentView.get(dom);
        if (curView && curView.parent == cView)
            return curView;
        let parent = dom.parentNode;
        dom = parent != cView.dom ? parent : dir > 0 ? dom.nextSibling : dom.previousSibling;
    }
    return null;
}
// Used to work around a Safari Selection/shadow DOM bug (#414)
function safariSelectionRangeHack(view) {
    let found = null;
    // Because Safari (at least in 2018-2021) doesn't provide regular
    // access to the selection inside a shadowroot, we have to perform a
    // ridiculous hack to get at itusing `execCommand` to trigger a
    // `beforeInput` event so that we can read the target range from the
    // event.
    function read(event) {
        event.preventDefault();
        event.stopImmediatePropagation();
        found = event.getTargetRanges()[0];
    }
    view.contentDOM.addEventListener("beforeinput", read, true);
    view.dom.ownerDocument.execCommand("indent");
    view.contentDOM.removeEventListener("beforeinput", read, true);
    if (!found)
        return null;
    let anchorNode = found.startContainer, anchorOffset = found.startOffset;
    let focusNode = found.endContainer, focusOffset = found.endOffset;
    let curAnchor = view.docView.domAtPos(view.state.selection.main.anchor);
    // Since such a range doesn't distinguish between anchor and head,
    // use a heuristic that flips it around if its end matches the
    // current anchor.
    if (isEquivalentPosition(curAnchor.node, curAnchor.offset, focusNode, focusOffset))
        [anchorNode, anchorOffset, focusNode, focusOffset] = [focusNode, focusOffset, anchorNode, anchorOffset];
    return { anchorNode, anchorOffset, focusNode, focusOffset };
}

function applyDOMChange(view, start, end, typeOver) {
    let change, newSel;
    let sel = view.state.selection.main;
    if (start > -1) {
        let bounds = view.docView.domBoundsAround(start, end, 0);
        if (!bounds || view.state.readOnly)
            return false;
        let { from, to } = bounds;
        let selPoints = view.docView.impreciseHead || view.docView.impreciseAnchor ? [] : selectionPoints(view);
        let reader = new DOMReader(selPoints, view.state);
        reader.readRange(bounds.startDOM, bounds.endDOM);
        let preferredPos = sel.from, preferredSide = null;
        // Prefer anchoring to end when Backspace is pressed (or, on
        // Android, when something was deleted)
        if (view.inputState.lastKeyCode === 8 && view.inputState.lastKeyTime > Date.now() - 100 ||
            browser.android && reader.text.length < to - from) {
            preferredPos = sel.to;
            preferredSide = "end";
        }
        let diff = findDiff(view.state.doc.sliceString(from, to, LineBreakPlaceholder), reader.text, preferredPos - from, preferredSide);
        if (diff) {
            // Chrome inserts two newlines when pressing shift-enter at the
            // end of a line. This drops one of those.
            if (browser.chrome && view.inputState.lastKeyCode == 13 &&
                diff.toB == diff.from + 2 && reader.text.slice(diff.from, diff.toB) == LineBreakPlaceholder + LineBreakPlaceholder)
                diff.toB--;
            change = { from: from + diff.from, to: from + diff.toA,
                insert: state_dist/* Text.of */.xv.of(reader.text.slice(diff.from, diff.toB).split(LineBreakPlaceholder)) };
        }
        newSel = selectionFromPoints(selPoints, from);
    }
    else if (view.hasFocus || !view.state.facet(editable)) {
        let domSel = view.observer.selectionRange;
        let { impreciseHead: iHead, impreciseAnchor: iAnchor } = view.docView;
        let head = iHead && iHead.node == domSel.focusNode && iHead.offset == domSel.focusOffset ||
            !contains(view.contentDOM, domSel.focusNode)
            ? view.state.selection.main.head
            : view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset);
        let anchor = iAnchor && iAnchor.node == domSel.anchorNode && iAnchor.offset == domSel.anchorOffset ||
            !contains(view.contentDOM, domSel.anchorNode)
            ? view.state.selection.main.anchor
            : view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset);
        if (head != sel.head || anchor != sel.anchor)
            newSel = state_dist/* EditorSelection.single */.jT.single(anchor, head);
    }
    if (!change && !newSel)
        return false;
    if (!change && typeOver && !sel.empty && newSel && newSel.main.empty) {
        // Heuristic to notice typing over a selected character
        change = { from: sel.from, to: sel.to, insert: view.state.doc.slice(sel.from, sel.to) };
    }
    else if (change && change.from >= sel.from && change.to <= sel.to &&
        (change.from != sel.from || change.to != sel.to) &&
        (sel.to - sel.from) - (change.to - change.from) <= 4) {
        // If the change is inside the selection and covers most of it,
        // assume it is a selection replace (with identical characters at
        // the start/end not included in the diff)
        change = {
            from: sel.from, to: sel.to,
            insert: view.state.doc.slice(sel.from, change.from).append(change.insert).append(view.state.doc.slice(change.to, sel.to))
        };
    }
    else if ((browser.mac || browser.android) && change && change.from == change.to && change.from == sel.head - 1 &&
        /^\. ?$/.test(change.insert.toString())) {
        // Detect insert-period-on-double-space Mac and Android behavior,
        // and transform it into a regular space insert.
        if (newSel && change.insert.length == 2)
            newSel = state_dist/* EditorSelection.single */.jT.single(newSel.main.anchor - 1, newSel.main.head - 1);
        change = { from: sel.from, to: sel.to, insert: state_dist/* Text.of */.xv.of([" "]) };
    }
    if (change) {
        let startState = view.state;
        if (browser.ios && view.inputState.flushIOSKey(view))
            return true;
        // Android browsers don't fire reasonable key events for enter,
        // backspace, or delete. So this detects changes that look like
        // they're caused by those keys, and reinterprets them as key
        // events. (Some of these keys are also handled by beforeinput
        // events and the pendingAndroidKey mechanism, but that's not
        // reliable in all situations.)
        if (browser.android &&
            ((change.from == sel.from && change.to == sel.to &&
                change.insert.length == 1 && change.insert.lines == 2 &&
                dispatchKey(view.contentDOM, "Enter", 13)) ||
                (change.from == sel.from - 1 && change.to == sel.to && change.insert.length == 0 &&
                    dispatchKey(view.contentDOM, "Backspace", 8)) ||
                (change.from == sel.from && change.to == sel.to + 1 && change.insert.length == 0 &&
                    dispatchKey(view.contentDOM, "Delete", 46))))
            return true;
        let text = change.insert.toString();
        if (view.state.facet(inputHandler).some(h => h(view, change.from, change.to, text)))
            return true;
        if (view.inputState.composing >= 0)
            view.inputState.composing++;
        let tr;
        if (change.from >= sel.from && change.to <= sel.to && change.to - change.from >= (sel.to - sel.from) / 3 &&
            (!newSel || newSel.main.empty && newSel.main.from == change.from + change.insert.length) &&
            view.inputState.composing < 0) {
            let before = sel.from < change.from ? startState.sliceDoc(sel.from, change.from) : "";
            let after = sel.to > change.to ? startState.sliceDoc(change.to, sel.to) : "";
            tr = startState.replaceSelection(view.state.toText(before + change.insert.sliceString(0, undefined, view.state.lineBreak) + after));
        }
        else {
            let changes = startState.changes(change);
            let mainSel = newSel && !startState.selection.main.eq(newSel.main) && newSel.main.to <= changes.newLength
                ? newSel.main : undefined;
            // Try to apply a composition change to all cursors
            if (startState.selection.ranges.length > 1 && view.inputState.composing >= 0 &&
                change.to <= sel.to && change.to >= sel.to - 10) {
                let replaced = view.state.sliceDoc(change.from, change.to);
                let compositionRange = compositionSurroundingNode(view) || view.state.doc.lineAt(sel.head);
                let offset = sel.to - change.to, size = sel.to - sel.from;
                tr = startState.changeByRange(range => {
                    if (range.from == sel.from && range.to == sel.to)
                        return { changes, range: mainSel || range.map(changes) };
                    let to = range.to - offset, from = to - replaced.length;
                    if (range.to - range.from != size || view.state.sliceDoc(from, to) != replaced ||
                        // Unfortunately, there's no way to make multiple
                        // changes in the same node work without aborting
                        // composition, so cursors in the composition range are
                        // ignored.
                        compositionRange && range.to >= compositionRange.from && range.from <= compositionRange.to)
                        return { range };
                    let rangeChanges = startState.changes({ from, to, insert: change.insert }), selOff = range.to - sel.to;
                    return {
                        changes: rangeChanges,
                        range: !mainSel ? range.map(rangeChanges) :
                            state_dist/* EditorSelection.range */.jT.range(Math.max(0, mainSel.anchor + selOff), Math.max(0, mainSel.head + selOff))
                    };
                });
            }
            else {
                tr = {
                    changes,
                    selection: mainSel && startState.selection.replaceRange(mainSel)
                };
            }
        }
        let userEvent = "input.type";
        if (view.composing) {
            userEvent += ".compose";
            if (view.inputState.compositionFirstChange) {
                userEvent += ".start";
                view.inputState.compositionFirstChange = false;
            }
        }
        view.dispatch(tr, { scrollIntoView: true, userEvent });
        return true;
    }
    else if (newSel && !newSel.main.eq(sel)) {
        let scrollIntoView = false, userEvent = "select";
        if (view.inputState.lastSelectionTime > Date.now() - 50) {
            if (view.inputState.lastSelectionOrigin == "select")
                scrollIntoView = true;
            userEvent = view.inputState.lastSelectionOrigin;
        }
        view.dispatch({ selection: newSel, scrollIntoView, userEvent });
        return true;
    }
    else {
        return false;
    }
}
function findDiff(a, b, preferredPos, preferredSide) {
    let minLen = Math.min(a.length, b.length);
    let from = 0;
    while (from < minLen && a.charCodeAt(from) == b.charCodeAt(from))
        from++;
    if (from == minLen && a.length == b.length)
        return null;
    let toA = a.length, toB = b.length;
    while (toA > 0 && toB > 0 && a.charCodeAt(toA - 1) == b.charCodeAt(toB - 1)) {
        toA--;
        toB--;
    }
    if (preferredSide == "end") {
        let adjust = Math.max(0, from - Math.min(toA, toB));
        preferredPos -= toA + adjust - from;
    }
    if (toA < from && a.length < b.length) {
        let move = preferredPos <= from && preferredPos >= toA ? from - preferredPos : 0;
        from -= move;
        toB = from + (toB - toA);
        toA = from;
    }
    else if (toB < from) {
        let move = preferredPos <= from && preferredPos >= toB ? from - preferredPos : 0;
        from -= move;
        toA = from + (toA - toB);
        toB = from;
    }
    return { from, toA, toB };
}
function selectionPoints(view) {
    let result = [];
    if (view.root.activeElement != view.contentDOM)
        return result;
    let { anchorNode, anchorOffset, focusNode, focusOffset } = view.observer.selectionRange;
    if (anchorNode) {
        result.push(new DOMPoint(anchorNode, anchorOffset));
        if (focusNode != anchorNode || focusOffset != anchorOffset)
            result.push(new DOMPoint(focusNode, focusOffset));
    }
    return result;
}
function selectionFromPoints(points, base) {
    if (points.length == 0)
        return null;
    let anchor = points[0].pos, head = points.length == 2 ? points[1].pos : anchor;
    return anchor > -1 && head > -1 ? state_dist/* EditorSelection.single */.jT.single(anchor + base, head + base) : null;
}

// The editor's update state machine looks something like this:
//
//     Idle  Updating  Idle (unchecked)  Measuring  Idle
//                                               
//                                         Updating (measure)
//
// The difference between 'Idle' and 'Idle (unchecked)' lies in
// whether a layout check has been scheduled. A regular update through
// the `update` method updates the DOM in a write-only fashion, and
// relies on a check (scheduled with `requestAnimationFrame`) to make
// sure everything is where it should be and the viewport covers the
// visible code. That check continues to measure and then optionally
// update until it reaches a coherent state.
/**
An editor view represents the editor's user interface. It holds
the editable DOM surface, and possibly other elements such as the
line number gutter. It handles events and dispatches state
transactions for editing actions.
*/
class EditorView {
    /**
    Construct a new view. You'll want to either provide a `parent`
    option, or put `view.dom` into your document after creating a
    view, so that the user can see the editor.
    */
    constructor(config = {}) {
        this.plugins = [];
        this.pluginMap = new Map;
        this.editorAttrs = {};
        this.contentAttrs = {};
        this.bidiCache = [];
        this.destroyed = false;
        /**
        @internal
        */
        this.updateState = 2 /* UpdateState.Updating */;
        /**
        @internal
        */
        this.measureScheduled = -1;
        /**
        @internal
        */
        this.measureRequests = [];
        this.contentDOM = document.createElement("div");
        this.scrollDOM = document.createElement("div");
        this.scrollDOM.tabIndex = -1;
        this.scrollDOM.className = "cm-scroller";
        this.scrollDOM.appendChild(this.contentDOM);
        this.announceDOM = document.createElement("div");
        this.announceDOM.style.cssText = "position: absolute; top: -10000px";
        this.announceDOM.setAttribute("aria-live", "polite");
        this.dom = document.createElement("div");
        this.dom.appendChild(this.announceDOM);
        this.dom.appendChild(this.scrollDOM);
        this._dispatch = config.dispatch || ((tr) => this.update([tr]));
        this.dispatch = this.dispatch.bind(this);
        this._root = (config.root || getRoot(config.parent) || document);
        this.viewState = new ViewState(config.state || state_dist/* EditorState.create */.yy.create(config));
        this.plugins = this.state.facet(viewPlugin).map(spec => new PluginInstance(spec));
        for (let plugin of this.plugins)
            plugin.update(this);
        this.observer = new DOMObserver(this, (from, to, typeOver) => {
            return applyDOMChange(this, from, to, typeOver);
        }, event => {
            this.inputState.runScrollHandlers(this, event);
            if (this.observer.intersecting)
                this.measure();
        });
        this.inputState = new InputState(this);
        this.inputState.ensureHandlers(this, this.plugins);
        this.docView = new DocView(this);
        this.mountStyles();
        this.updateAttrs();
        this.updateState = 0 /* UpdateState.Idle */;
        this.requestMeasure();
        if (config.parent)
            config.parent.appendChild(this.dom);
    }
    /**
    The current editor state.
    */
    get state() { return this.viewState.state; }
    /**
    To be able to display large documents without consuming too much
    memory or overloading the browser, CodeMirror only draws the
    code that is visible (plus a margin around it) to the DOM. This
    property tells you the extent of the current drawn viewport, in
    document positions.
    */
    get viewport() { return this.viewState.viewport; }
    /**
    When there are, for example, large collapsed ranges in the
    viewport, its size can be a lot bigger than the actual visible
    content. Thus, if you are doing something like styling the
    content in the viewport, it is preferable to only do so for
    these ranges, which are the subset of the viewport that is
    actually drawn.
    */
    get visibleRanges() { return this.viewState.visibleRanges; }
    /**
    Returns false when the editor is entirely scrolled out of view
    or otherwise hidden.
    */
    get inView() { return this.viewState.inView; }
    /**
    Indicates whether the user is currently composing text via
    [IME](https://en.wikipedia.org/wiki/Input_method), and at least
    one change has been made in the current composition.
    */
    get composing() { return this.inputState.composing > 0; }
    /**
    Indicates whether the user is currently in composing state. Note
    that on some platforms, like Android, this will be the case a
    lot, since just putting the cursor on a word starts a
    composition there.
    */
    get compositionStarted() { return this.inputState.composing >= 0; }
    /**
    The document or shadow root that the view lives in.
    */
    get root() { return this._root; }
    /**
    @internal
    */
    get win() { return this.dom.ownerDocument.defaultView || window; }
    dispatch(...input) {
        this._dispatch(input.length == 1 && input[0] instanceof state_dist/* Transaction */.YW ? input[0]
            : this.state.update(...input));
    }
    /**
    Update the view for the given array of transactions. This will
    update the visible document and selection to match the state
    produced by the transactions, and notify view plugins of the
    change. You should usually call
    [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead, which uses this
    as a primitive.
    */
    update(transactions) {
        if (this.updateState != 0 /* UpdateState.Idle */)
            throw new Error("Calls to EditorView.update are not allowed while an update is in progress");
        let redrawn = false, attrsChanged = false, update;
        let state = this.state;
        for (let tr of transactions) {
            if (tr.startState != state)
                throw new RangeError("Trying to update state with a transaction that doesn't start from the previous state.");
            state = tr.state;
        }
        if (this.destroyed) {
            this.viewState.state = state;
            return;
        }
        this.observer.clear();
        // When the phrases change, redraw the editor
        if (state.facet(state_dist/* EditorState.phrases */.yy.phrases) != this.state.facet(state_dist/* EditorState.phrases */.yy.phrases))
            return this.setState(state);
        update = ViewUpdate.create(this, state, transactions);
        let scrollTarget = this.viewState.scrollTarget;
        try {
            this.updateState = 2 /* UpdateState.Updating */;
            for (let tr of transactions) {
                if (scrollTarget)
                    scrollTarget = scrollTarget.map(tr.changes);
                if (tr.scrollIntoView) {
                    let { main } = tr.state.selection;
                    scrollTarget = new ScrollTarget(main.empty ? main : state_dist/* EditorSelection.cursor */.jT.cursor(main.head, main.head > main.anchor ? -1 : 1));
                }
                for (let e of tr.effects)
                    if (e.is(scrollIntoView))
                        scrollTarget = e.value;
            }
            this.viewState.update(update, scrollTarget);
            this.bidiCache = CachedOrder.update(this.bidiCache, update.changes);
            if (!update.empty) {
                this.updatePlugins(update);
                this.inputState.update(update);
            }
            redrawn = this.docView.update(update);
            if (this.state.facet(styleModule) != this.styleModules)
                this.mountStyles();
            attrsChanged = this.updateAttrs();
            this.showAnnouncements(transactions);
            this.docView.updateSelection(redrawn, transactions.some(tr => tr.isUserEvent("select.pointer")));
        }
        finally {
            this.updateState = 0 /* UpdateState.Idle */;
        }
        if (update.startState.facet(theme) != update.state.facet(theme))
            this.viewState.mustMeasureContent = true;
        if (redrawn || attrsChanged || scrollTarget || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent)
            this.requestMeasure();
        if (!update.empty)
            for (let listener of this.state.facet(updateListener))
                listener(update);
    }
    /**
    Reset the view to the given state. (This will cause the entire
    document to be redrawn and all view plugins to be reinitialized,
    so you should probably only use it when the new state isn't
    derived from the old state. Otherwise, use
    [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead.)
    */
    setState(newState) {
        if (this.updateState != 0 /* UpdateState.Idle */)
            throw new Error("Calls to EditorView.setState are not allowed while an update is in progress");
        if (this.destroyed) {
            this.viewState.state = newState;
            return;
        }
        this.updateState = 2 /* UpdateState.Updating */;
        let hadFocus = this.hasFocus;
        try {
            for (let plugin of this.plugins)
                plugin.destroy(this);
            this.viewState = new ViewState(newState);
            this.plugins = newState.facet(viewPlugin).map(spec => new PluginInstance(spec));
            this.pluginMap.clear();
            for (let plugin of this.plugins)
                plugin.update(this);
            this.docView = new DocView(this);
            this.inputState.ensureHandlers(this, this.plugins);
            this.mountStyles();
            this.updateAttrs();
            this.bidiCache = [];
        }
        finally {
            this.updateState = 0 /* UpdateState.Idle */;
        }
        if (hadFocus)
            this.focus();
        this.requestMeasure();
    }
    updatePlugins(update) {
        let prevSpecs = update.startState.facet(viewPlugin), specs = update.state.facet(viewPlugin);
        if (prevSpecs != specs) {
            let newPlugins = [];
            for (let spec of specs) {
                let found = prevSpecs.indexOf(spec);
                if (found < 0) {
                    newPlugins.push(new PluginInstance(spec));
                }
                else {
                    let plugin = this.plugins[found];
                    plugin.mustUpdate = update;
                    newPlugins.push(plugin);
                }
            }
            for (let plugin of this.plugins)
                if (plugin.mustUpdate != update)
                    plugin.destroy(this);
            this.plugins = newPlugins;
            this.pluginMap.clear();
            this.inputState.ensureHandlers(this, this.plugins);
        }
        else {
            for (let p of this.plugins)
                p.mustUpdate = update;
        }
        for (let i = 0; i < this.plugins.length; i++)
            this.plugins[i].update(this);
    }
    /**
    @internal
    */
    measure(flush = true) {
        if (this.destroyed)
            return;
        if (this.measureScheduled > -1)
            cancelAnimationFrame(this.measureScheduled);
        this.measureScheduled = 0; // Prevent requestMeasure calls from scheduling another animation frame
        if (flush)
            this.observer.forceFlush();
        let updated = null;
        let { scrollHeight, scrollTop, clientHeight } = this.scrollDOM;
        let refHeight = scrollTop > scrollHeight - clientHeight - 4 ? scrollHeight : scrollTop;
        try {
            for (let i = 0;; i++) {
                this.updateState = 1 /* UpdateState.Measuring */;
                let oldViewport = this.viewport;
                let refBlock = this.viewState.lineBlockAtHeight(refHeight);
                let changed = this.viewState.measure(this);
                if (!changed && !this.measureRequests.length && this.viewState.scrollTarget == null)
                    break;
                if (i > 5) {
                    console.warn(this.measureRequests.length
                        ? "Measure loop restarted more than 5 times"
                        : "Viewport failed to stabilize");
                    break;
                }
                let measuring = [];
                // Only run measure requests in this cycle when the viewport didn't change
                if (!(changed & 4 /* UpdateFlag.Viewport */))
                    [this.measureRequests, measuring] = [measuring, this.measureRequests];
                let measured = measuring.map(m => {
                    try {
                        return m.read(this);
                    }
                    catch (e) {
                        logException(this.state, e);
                        return BadMeasure;
                    }
                });
                let update = ViewUpdate.create(this, this.state, []), redrawn = false, scrolled = false;
                update.flags |= changed;
                if (!updated)
                    updated = update;
                else
                    updated.flags |= changed;
                this.updateState = 2 /* UpdateState.Updating */;
                if (!update.empty) {
                    this.updatePlugins(update);
                    this.inputState.update(update);
                    this.updateAttrs();
                    redrawn = this.docView.update(update);
                }
                for (let i = 0; i < measuring.length; i++)
                    if (measured[i] != BadMeasure) {
                        try {
                            let m = measuring[i];
                            if (m.write)
                                m.write(measured[i], this);
                        }
                        catch (e) {
                            logException(this.state, e);
                        }
                    }
                if (this.viewState.scrollTarget) {
                    this.docView.scrollIntoView(this.viewState.scrollTarget);
                    this.viewState.scrollTarget = null;
                    scrolled = true;
                }
                else {
                    let diff = this.viewState.lineBlockAt(refBlock.from).top - refBlock.top;
                    if (diff > 1 || diff < -1) {
                        this.scrollDOM.scrollTop += diff;
                        scrolled = true;
                    }
                }
                if (redrawn)
                    this.docView.updateSelection(true);
                if (this.viewport.from == oldViewport.from && this.viewport.to == oldViewport.to &&
                    !scrolled && this.measureRequests.length == 0)
                    break;
            }
        }
        finally {
            this.updateState = 0 /* UpdateState.Idle */;
            this.measureScheduled = -1;
        }
        if (updated && !updated.empty)
            for (let listener of this.state.facet(updateListener))
                listener(updated);
    }
    /**
    Get the CSS classes for the currently active editor themes.
    */
    get themeClasses() {
        return baseThemeID + " " +
            (this.state.facet(darkTheme) ? baseDarkID : baseLightID) + " " +
            this.state.facet(theme);
    }
    updateAttrs() {
        let editorAttrs = attrsFromFacet(this, editorAttributes, {
            class: "cm-editor" + (this.hasFocus ? " cm-focused " : " ") + this.themeClasses
        });
        let contentAttrs = {
            spellcheck: "false",
            autocorrect: "off",
            autocapitalize: "off",
            translate: "no",
            contenteditable: !this.state.facet(editable) ? "false" : "true",
            class: "cm-content",
            style: `${browser.tabSize}: ${this.state.tabSize}`,
            role: "textbox",
            "aria-multiline": "true"
        };
        if (this.state.readOnly)
            contentAttrs["aria-readonly"] = "true";
        attrsFromFacet(this, contentAttributes, contentAttrs);
        let changed = this.observer.ignore(() => {
            let changedContent = updateAttrs(this.contentDOM, this.contentAttrs, contentAttrs);
            let changedEditor = updateAttrs(this.dom, this.editorAttrs, editorAttrs);
            return changedContent || changedEditor;
        });
        this.editorAttrs = editorAttrs;
        this.contentAttrs = contentAttrs;
        return changed;
    }
    showAnnouncements(trs) {
        let first = true;
        for (let tr of trs)
            for (let effect of tr.effects)
                if (effect.is(EditorView.announce)) {
                    if (first)
                        this.announceDOM.textContent = "";
                    first = false;
                    let div = this.announceDOM.appendChild(document.createElement("div"));
                    div.textContent = effect.value;
                }
    }
    mountStyles() {
        this.styleModules = this.state.facet(styleModule);
        style_mod/* StyleModule.mount */.V.mount(this.root, this.styleModules.concat(baseTheme$1).reverse());
    }
    readMeasured() {
        if (this.updateState == 2 /* UpdateState.Updating */)
            throw new Error("Reading the editor layout isn't allowed during an update");
        if (this.updateState == 0 /* UpdateState.Idle */ && this.measureScheduled > -1)
            this.measure(false);
    }
    /**
    Schedule a layout measurement, optionally providing callbacks to
    do custom DOM measuring followed by a DOM write phase. Using
    this is preferable reading DOM layout directly from, for
    example, an event handler, because it'll make sure measuring and
    drawing done by other components is synchronized, avoiding
    unnecessary DOM layout computations.
    */
    requestMeasure(request) {
        if (this.measureScheduled < 0)
            this.measureScheduled = this.win.requestAnimationFrame(() => this.measure());
        if (request) {
            if (request.key != null)
                for (let i = 0; i < this.measureRequests.length; i++) {
                    if (this.measureRequests[i].key === request.key) {
                        this.measureRequests[i] = request;
                        return;
                    }
                }
            this.measureRequests.push(request);
        }
    }
    /**
    Get the value of a specific plugin, if present. Note that
    plugins that crash can be dropped from a view, so even when you
    know you registered a given plugin, it is recommended to check
    the return value of this method.
    */
    plugin(plugin) {
        let known = this.pluginMap.get(plugin);
        if (known === undefined || known && known.spec != plugin)
            this.pluginMap.set(plugin, known = this.plugins.find(p => p.spec == plugin) || null);
        return known && known.update(this).value;
    }
    /**
    The top position of the document, in screen coordinates. This
    may be negative when the editor is scrolled down. Points
    directly to the top of the first line, not above the padding.
    */
    get documentTop() {
        return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop;
    }
    /**
    Reports the padding above and below the document.
    */
    get documentPadding() {
        return { top: this.viewState.paddingTop, bottom: this.viewState.paddingBottom };
    }
    /**
    Find the text line or block widget at the given vertical
    position (which is interpreted as relative to the [top of the
    document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop)).
    */
    elementAtHeight(height) {
        this.readMeasured();
        return this.viewState.elementAtHeight(height);
    }
    /**
    Find the line block (see
    [`lineBlockAt`](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) at the given
    height, again interpreted relative to the [top of the
    document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop).
    */
    lineBlockAtHeight(height) {
        this.readMeasured();
        return this.viewState.lineBlockAtHeight(height);
    }
    /**
    Get the extent and vertical position of all [line
    blocks](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) in the viewport. Positions
    are relative to the [top of the
    document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop);
    */
    get viewportLineBlocks() {
        return this.viewState.viewportLines;
    }
    /**
    Find the line block around the given document position. A line
    block is a range delimited on both sides by either a
    non-[hidden](https://codemirror.net/6/docs/ref/#view.Decoration^replace) line breaks, or the
    start/end of the document. It will usually just hold a line of
    text, but may be broken into multiple textblocks by block
    widgets.
    */
    lineBlockAt(pos) {
        return this.viewState.lineBlockAt(pos);
    }
    /**
    The editor's total content height.
    */
    get contentHeight() {
        return this.viewState.contentHeight;
    }
    /**
    Move a cursor position by [grapheme
    cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak). `forward` determines whether
    the motion is away from the line start, or towards it. In
    bidirectional text, the line is traversed in visual order, using
    the editor's [text direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection).
    When the start position was the last one on the line, the
    returned position will be across the line break. If there is no
    further line, the original position is returned.
    
    By default, this method moves over a single cluster. The
    optional `by` argument can be used to move across more. It will
    be called with the first cluster as argument, and should return
    a predicate that determines, for each subsequent cluster,
    whether it should also be moved over.
    */
    moveByChar(start, forward, by) {
        return skipAtoms(this, start, moveByChar(this, start, forward, by));
    }
    /**
    Move a cursor position across the next group of either
    [letters](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) or non-letter
    non-whitespace characters.
    */
    moveByGroup(start, forward) {
        return skipAtoms(this, start, moveByChar(this, start, forward, initial => byGroup(this, start.head, initial)));
    }
    /**
    Move to the next line boundary in the given direction. If
    `includeWrap` is true, line wrapping is on, and there is a
    further wrap point on the current line, the wrap point will be
    returned. Otherwise this function will return the start or end
    of the line.
    */
    moveToLineBoundary(start, forward, includeWrap = true) {
        return moveToLineBoundary(this, start, forward, includeWrap);
    }
    /**
    Move a cursor position vertically. When `distance` isn't given,
    it defaults to moving to the next line (including wrapped
    lines). Otherwise, `distance` should provide a positive distance
    in pixels.
    
    When `start` has a
    [`goalColumn`](https://codemirror.net/6/docs/ref/#state.SelectionRange.goalColumn), the vertical
    motion will use that as a target horizontal position. Otherwise,
    the cursor's own horizontal position is used. The returned
    cursor will have its goal column set to whichever column was
    used.
    */
    moveVertically(start, forward, distance) {
        return skipAtoms(this, start, moveVertically(this, start, forward, distance));
    }
    /**
    Find the DOM parent node and offset (child offset if `node` is
    an element, character offset when it is a text node) at the
    given document position.
    
    Note that for positions that aren't currently in
    `visibleRanges`, the resulting DOM position isn't necessarily
    meaningful (it may just point before or after a placeholder
    element).
    */
    domAtPos(pos) {
        return this.docView.domAtPos(pos);
    }
    /**
    Find the document position at the given DOM node. Can be useful
    for associating positions with DOM events. Will raise an error
    when `node` isn't part of the editor content.
    */
    posAtDOM(node, offset = 0) {
        return this.docView.posFromDOM(node, offset);
    }
    posAtCoords(coords, precise = true) {
        this.readMeasured();
        return posAtCoords(this, coords, precise);
    }
    /**
    Get the screen coordinates at the given document position.
    `side` determines whether the coordinates are based on the
    element before (-1) or after (1) the position (if no element is
    available on the given side, the method will transparently use
    another strategy to get reasonable coordinates).
    */
    coordsAtPos(pos, side = 1) {
        this.readMeasured();
        let rect = this.docView.coordsAt(pos, side);
        if (!rect || rect.left == rect.right)
            return rect;
        let line = this.state.doc.lineAt(pos), order = this.bidiSpans(line);
        let span = order[BidiSpan.find(order, pos - line.from, -1, side)];
        return flattenRect(rect, (span.dir == Direction.LTR) == (side > 0));
    }
    /**
    The default width of a character in the editor. May not
    accurately reflect the width of all characters (given variable
    width fonts or styling of invididual ranges).
    */
    get defaultCharacterWidth() { return this.viewState.heightOracle.charWidth; }
    /**
    The default height of a line in the editor. May not be accurate
    for all lines.
    */
    get defaultLineHeight() { return this.viewState.heightOracle.lineHeight; }
    /**
    The text direction
    ([`direction`](https://developer.mozilla.org/en-US/docs/Web/CSS/direction)
    CSS property) of the editor's content element.
    */
    get textDirection() { return this.viewState.defaultTextDirection; }
    /**
    Find the text direction of the block at the given position, as
    assigned by CSS. If
    [`perLineTextDirection`](https://codemirror.net/6/docs/ref/#view.EditorView^perLineTextDirection)
    isn't enabled, or the given position is outside of the viewport,
    this will always return the same as
    [`textDirection`](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection). Note that
    this may trigger a DOM layout.
    */
    textDirectionAt(pos) {
        let perLine = this.state.facet(perLineTextDirection);
        if (!perLine || pos < this.viewport.from || pos > this.viewport.to)
            return this.textDirection;
        this.readMeasured();
        return this.docView.textDirectionAt(pos);
    }
    /**
    Whether this editor [wraps lines](https://codemirror.net/6/docs/ref/#view.EditorView.lineWrapping)
    (as determined by the
    [`white-space`](https://developer.mozilla.org/en-US/docs/Web/CSS/white-space)
    CSS property of its content element).
    */
    get lineWrapping() { return this.viewState.heightOracle.lineWrapping; }
    /**
    Returns the bidirectional text structure of the given line
    (which should be in the current document) as an array of span
    objects. The order of these spans matches the [text
    direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection)if that is
    left-to-right, the leftmost spans come first, otherwise the
    rightmost spans come first.
    */
    bidiSpans(line) {
        if (line.length > MaxBidiLine)
            return trivialOrder(line.length);
        let dir = this.textDirectionAt(line.from);
        for (let entry of this.bidiCache)
            if (entry.from == line.from && entry.dir == dir)
                return entry.order;
        let order = computeOrder(line.text, dir);
        this.bidiCache.push(new CachedOrder(line.from, line.to, dir, order));
        return order;
    }
    /**
    Check whether the editor has focus.
    */
    get hasFocus() {
        var _a;
        // Safari return false for hasFocus when the context menu is open
        // or closing, which leads us to ignore selection changes from the
        // context menu because it looks like the editor isn't focused.
        // This kludges around that.
        return (this.dom.ownerDocument.hasFocus() || browser.safari && ((_a = this.inputState) === null || _a === void 0 ? void 0 : _a.lastContextMenu) > Date.now() - 3e4) &&
            this.root.activeElement == this.contentDOM;
    }
    /**
    Put focus on the editor.
    */
    focus() {
        this.observer.ignore(() => {
            focusPreventScroll(this.contentDOM);
            this.docView.updateSelection();
        });
    }
    /**
    Update the [root](https://codemirror.net/6/docs/ref/##view.EditorViewConfig.root) in which the editor lives. This is only
    necessary when moving the editor's existing DOM to a new window or shadow root.
    */
    setRoot(root) {
        if (this._root != root) {
            this._root = root;
            this.observer.setWindow((root.nodeType == 9 ? root : root.ownerDocument).defaultView || window);
            this.mountStyles();
        }
    }
    /**
    Clean up this editor view, removing its element from the
    document, unregistering event handlers, and notifying
    plugins. The view instance can no longer be used after
    calling this.
    */
    destroy() {
        for (let plugin of this.plugins)
            plugin.destroy(this);
        this.plugins = [];
        this.inputState.destroy();
        this.dom.remove();
        this.observer.destroy();
        if (this.measureScheduled > -1)
            cancelAnimationFrame(this.measureScheduled);
        this.destroyed = true;
    }
    /**
    Returns an effect that can be
    [added](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) to a transaction to
    cause it to scroll the given position or range into view.
    */
    static scrollIntoView(pos, options = {}) {
        return scrollIntoView.of(new ScrollTarget(typeof pos == "number" ? state_dist/* EditorSelection.cursor */.jT.cursor(pos) : pos, options.y, options.x, options.yMargin, options.xMargin));
    }
    /**
    Returns an extension that can be used to add DOM event handlers.
    The value should be an object mapping event names to handler
    functions. For any given event, such functions are ordered by
    extension precedence, and the first handler to return true will
    be assumed to have handled that event, and no other handlers or
    built-in behavior will be activated for it. These are registered
    on the [content element](https://codemirror.net/6/docs/ref/#view.EditorView.contentDOM), except
    for `scroll` handlers, which will be called any time the
    editor's [scroll element](https://codemirror.net/6/docs/ref/#view.EditorView.scrollDOM) or one of
    its parent nodes is scrolled.
    */
    static domEventHandlers(handlers) {
        return ViewPlugin.define(() => ({}), { eventHandlers: handlers });
    }
    /**
    Create a theme extension. The first argument can be a
    [`style-mod`](https://github.com/marijnh/style-mod#documentation)
    style spec providing the styles for the theme. These will be
    prefixed with a generated class for the style.
    
    Because the selectors will be prefixed with a scope class, rule
    that directly match the editor's [wrapper
    element](https://codemirror.net/6/docs/ref/#view.EditorView.dom)to which the scope class will be
    addedneed to be explicitly differentiated by adding an `&` to
    the selector for that elementfor example
    `&.cm-focused`.
    
    When `dark` is set to true, the theme will be marked as dark,
    which will cause the `&dark` rules from [base
    themes](https://codemirror.net/6/docs/ref/#view.EditorView^baseTheme) to be used (as opposed to
    `&light` when a light theme is active).
    */
    static theme(spec, options) {
        let prefix = style_mod/* StyleModule.newName */.V.newName();
        let result = [theme.of(prefix), styleModule.of(buildTheme(`.${prefix}`, spec))];
        if (options && options.dark)
            result.push(darkTheme.of(true));
        return result;
    }
    /**
    Create an extension that adds styles to the base theme. Like
    with [`theme`](https://codemirror.net/6/docs/ref/#view.EditorView^theme), use `&` to indicate the
    place of the editor wrapper element when directly targeting
    that. You can also use `&dark` or `&light` instead to only
    target editors with a dark or light theme.
    */
    static baseTheme(spec) {
        return state_dist/* Prec.lowest */.Wl.lowest(styleModule.of(buildTheme("." + baseThemeID, spec, lightDarkIDs)));
    }
    /**
    Retrieve an editor view instance from the view's DOM
    representation.
    */
    static findFromDOM(dom) {
        var _a;
        let content = dom.querySelector(".cm-content");
        let cView = content && ContentView.get(content) || ContentView.get(dom);
        return ((_a = cView === null || cView === void 0 ? void 0 : cView.rootView) === null || _a === void 0 ? void 0 : _a.view) || null;
    }
}
/**
Facet to add a [style
module](https://github.com/marijnh/style-mod#documentation) to
an editor view. The view will ensure that the module is
mounted in its [document
root](https://codemirror.net/6/docs/ref/#view.EditorView.constructor^config.root).
*/
EditorView.styleModule = styleModule;
/**
An input handler can override the way changes to the editable
DOM content are handled. Handlers are passed the document
positions between which the change was found, and the new
content. When one returns true, no further input handlers are
called and the default behavior is prevented.
*/
EditorView.inputHandler = inputHandler;
/**
By default, the editor assumes all its content has the same
[text direction](https://codemirror.net/6/docs/ref/#view.Direction). Configure this with a `true`
value to make it read the text direction of every (rendered)
line separately.
*/
EditorView.perLineTextDirection = perLineTextDirection;
/**
Allows you to provide a function that should be called when the
library catches an exception from an extension (mostly from view
plugins, but may be used by other extensions to route exceptions
from user-code-provided callbacks). This is mostly useful for
debugging and logging. See [`logException`](https://codemirror.net/6/docs/ref/#view.logException).
*/
EditorView.exceptionSink = exceptionSink;
/**
A facet that can be used to register a function to be called
every time the view updates.
*/
EditorView.updateListener = updateListener;
/**
Facet that controls whether the editor content DOM is editable.
When its highest-precedence value is `false`, the element will
not have its `contenteditable` attribute set. (Note that this
doesn't affect API calls that change the editor content, even
when those are bound to keys or buttons. See the
[`readOnly`](https://codemirror.net/6/docs/ref/#state.EditorState.readOnly) facet for that.)
*/
EditorView.editable = editable;
/**
Allows you to influence the way mouse selection happens. The
functions in this facet will be called for a `mousedown` event
on the editor, and can return an object that overrides the way a
selection is computed from that mouse click or drag.
*/
EditorView.mouseSelectionStyle = mouseSelectionStyle;
/**
Facet used to configure whether a given selection drag event
should move or copy the selection. The given predicate will be
called with the `mousedown` event, and can return `true` when
the drag should move the content.
*/
EditorView.dragMovesSelection = dragMovesSelection$1;
/**
Facet used to configure whether a given selecting click adds a
new range to the existing selection or replaces it entirely. The
default behavior is to check `event.metaKey` on macOS, and
`event.ctrlKey` elsewhere.
*/
EditorView.clickAddsSelectionRange = clickAddsSelectionRange;
/**
A facet that determines which [decorations](https://codemirror.net/6/docs/ref/#view.Decoration)
are shown in the view. Decorations can be provided in two
waysdirectly, or via a function that takes an editor view.

Only decoration sets provided directly are allowed to influence
the editor's vertical layout structure. The ones provided as
functions are called _after_ the new viewport has been computed,
and thus **must not** introduce block widgets or replacing
decorations that cover line breaks.

If you want decorated ranges to behave like atomic units for
cursor motion and deletion purposes, also provide the range set
containing the decorations to
[`EditorView.atomicRanges`](https://codemirror.net/6/docs/ref/#view.EditorView^atomicRanges).
*/
EditorView.decorations = decorations;
/**
Used to provide ranges that should be treated as atoms as far as
cursor motion is concerned. This causes methods like
[`moveByChar`](https://codemirror.net/6/docs/ref/#view.EditorView.moveByChar) and
[`moveVertically`](https://codemirror.net/6/docs/ref/#view.EditorView.moveVertically) (and the
commands built on top of them) to skip across such regions when
a selection endpoint would enter them. This does _not_ prevent
direct programmatic [selection
updates](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection) from moving into such
regions.
*/
EditorView.atomicRanges = atomicRanges;
/**
Facet that allows extensions to provide additional scroll
margins (space around the sides of the scrolling element that
should be considered invisible). This can be useful when the
plugin introduces elements that cover part of that element (for
example a horizontally fixed gutter).
*/
EditorView.scrollMargins = scrollMargins;
/**
This facet records whether a dark theme is active. The extension
returned by [`theme`](https://codemirror.net/6/docs/ref/#view.EditorView^theme) automatically
includes an instance of this when the `dark` option is set to
true.
*/
EditorView.darkTheme = darkTheme;
/**
Facet that provides additional DOM attributes for the editor's
editable DOM element.
*/
EditorView.contentAttributes = contentAttributes;
/**
Facet that provides DOM attributes for the editor's outer
element.
*/
EditorView.editorAttributes = editorAttributes;
/**
An extension that enables line wrapping in the editor (by
setting CSS `white-space` to `pre-wrap` in the content).
*/
EditorView.lineWrapping = /*@__PURE__*/EditorView.contentAttributes.of({ "class": "cm-lineWrapping" });
/**
State effect used to include screen reader announcements in a
transaction. These will be added to the DOM in a visually hidden
element with `aria-live="polite"` set, and should be used to
describe effects that are visually obvious but may not be
noticed by screen reader users (such as moving to the next
search match).
*/
EditorView.announce = /*@__PURE__*/state_dist/* StateEffect.define */.Py.define();
// Maximum line length for which we compute accurate bidi info
const MaxBidiLine = 4096;
const BadMeasure = {};
class CachedOrder {
    constructor(from, to, dir, order) {
        this.from = from;
        this.to = to;
        this.dir = dir;
        this.order = order;
    }
    static update(cache, changes) {
        if (changes.empty)
            return cache;
        let result = [], lastDir = cache.length ? cache[cache.length - 1].dir : Direction.LTR;
        for (let i = Math.max(0, cache.length - 10); i < cache.length; i++) {
            let entry = cache[i];
            if (entry.dir == lastDir && !changes.touchesRange(entry.from, entry.to))
                result.push(new CachedOrder(changes.mapPos(entry.from, 1), changes.mapPos(entry.to, -1), entry.dir, entry.order));
        }
        return result;
    }
}
function attrsFromFacet(view, facet, base) {
    for (let sources = view.state.facet(facet), i = sources.length - 1; i >= 0; i--) {
        let source = sources[i], value = typeof source == "function" ? source(view) : source;
        if (value)
            combineAttrs(value, base);
    }
    return base;
}

const currentPlatform = browser.mac ? "mac" : browser.windows ? "win" : browser.linux ? "linux" : "key";
function normalizeKeyName(name, platform) {
    const parts = name.split(/-(?!$)/);
    let result = parts[parts.length - 1];
    if (result == "Space")
        result = " ";
    let alt, ctrl, shift, meta;
    for (let i = 0; i < parts.length - 1; ++i) {
        const mod = parts[i];
        if (/^(cmd|meta|m)$/i.test(mod))
            meta = true;
        else if (/^a(lt)?$/i.test(mod))
            alt = true;
        else if (/^(c|ctrl|control)$/i.test(mod))
            ctrl = true;
        else if (/^s(hift)?$/i.test(mod))
            shift = true;
        else if (/^mod$/i.test(mod)) {
            if (platform == "mac")
                meta = true;
            else
                ctrl = true;
        }
        else
            throw new Error("Unrecognized modifier name: " + mod);
    }
    if (alt)
        result = "Alt-" + result;
    if (ctrl)
        result = "Ctrl-" + result;
    if (meta)
        result = "Meta-" + result;
    if (shift)
        result = "Shift-" + result;
    return result;
}
function modifiers(name, event, shift) {
    if (event.altKey)
        name = "Alt-" + name;
    if (event.ctrlKey)
        name = "Ctrl-" + name;
    if (event.metaKey)
        name = "Meta-" + name;
    if (shift !== false && event.shiftKey)
        name = "Shift-" + name;
    return name;
}
const handleKeyEvents = /*@__PURE__*/state_dist/* Prec.default */.Wl["default"](/*@__PURE__*/EditorView.domEventHandlers({
    keydown(event, view) {
        return runHandlers(getKeymap(view.state), event, view, "editor");
    }
}));
/**
Facet used for registering keymaps.

You can add multiple keymaps to an editor. Their priorities
determine their precedence (the ones specified early or with high
priority get checked first). When a handler has returned `true`
for a given key, no further handlers are called.
*/
const keymap = /*@__PURE__*/state_dist/* Facet.define */.r$.define({ enables: handleKeyEvents });
const Keymaps = /*@__PURE__*/new WeakMap();
// This is hidden behind an indirection, rather than directly computed
// by the facet, to keep internal types out of the facet's type.
function getKeymap(state) {
    let bindings = state.facet(keymap);
    let map = Keymaps.get(bindings);
    if (!map)
        Keymaps.set(bindings, map = buildKeymap(bindings.reduce((a, b) => a.concat(b), [])));
    return map;
}
/**
Run the key handlers registered for a given scope. The event
object should be a `"keydown"` event. Returns true if any of the
handlers handled it.
*/
function runScopeHandlers(view, event, scope) {
    return runHandlers(getKeymap(view.state), event, view, scope);
}
let storedPrefix = null;
const PrefixTimeout = 4000;
function buildKeymap(bindings, platform = currentPlatform) {
    let bound = Object.create(null);
    let isPrefix = Object.create(null);
    let checkPrefix = (name, is) => {
        let current = isPrefix[name];
        if (current == null)
            isPrefix[name] = is;
        else if (current != is)
            throw new Error("Key binding " + name + " is used both as a regular binding and as a multi-stroke prefix");
    };
    let add = (scope, key, command, preventDefault) => {
        var _a, _b;
        let scopeObj = bound[scope] || (bound[scope] = Object.create(null));
        let parts = key.split(/ (?!$)/).map(k => normalizeKeyName(k, platform));
        for (let i = 1; i < parts.length; i++) {
            let prefix = parts.slice(0, i).join(" ");
            checkPrefix(prefix, true);
            if (!scopeObj[prefix])
                scopeObj[prefix] = {
                    preventDefault: true,
                    run: [(view) => {
                            let ourObj = storedPrefix = { view, prefix, scope };
                            setTimeout(() => { if (storedPrefix == ourObj)
                                storedPrefix = null; }, PrefixTimeout);
                            return true;
                        }]
                };
        }
        let full = parts.join(" ");
        checkPrefix(full, false);
        let binding = scopeObj[full] || (scopeObj[full] = { preventDefault: false, run: ((_b = (_a = scopeObj._any) === null || _a === void 0 ? void 0 : _a.run) === null || _b === void 0 ? void 0 : _b.slice()) || [] });
        if (command)
            binding.run.push(command);
        if (preventDefault)
            binding.preventDefault = true;
    };
    for (let b of bindings) {
        let scopes = b.scope ? b.scope.split(" ") : ["editor"];
        if (b.any)
            for (let scope of scopes) {
                let scopeObj = bound[scope] || (bound[scope] = Object.create(null));
                if (!scopeObj._any)
                    scopeObj._any = { preventDefault: false, run: [] };
                for (let key in scopeObj)
                    scopeObj[key].run.push(b.any);
            }
        let name = b[platform] || b.key;
        if (!name)
            continue;
        for (let scope of scopes) {
            add(scope, name, b.run, b.preventDefault);
            if (b.shift)
                add(scope, "Shift-" + name, b.shift, b.preventDefault);
        }
    }
    return bound;
}
function runHandlers(map, event, view, scope) {
    let name = keyName(event);
    let charCode = (0,state_dist/* codePointAt */.gm)(name, 0), isChar = (0,state_dist/* codePointSize */.nZ)(charCode) == name.length && name != " ";
    let prefix = "", fallthrough = false;
    if (storedPrefix && storedPrefix.view == view && storedPrefix.scope == scope) {
        prefix = storedPrefix.prefix + " ";
        if (fallthrough = modifierCodes.indexOf(event.keyCode) < 0)
            storedPrefix = null;
    }
    let ran = new Set;
    let runFor = (binding) => {
        if (binding) {
            for (let cmd of binding.run)
                if (!ran.has(cmd)) {
                    ran.add(cmd);
                    if (cmd(view, event))
                        return true;
                }
            if (binding.preventDefault)
                fallthrough = true;
        }
        return false;
    };
    let scopeObj = map[scope], baseName, shiftName;
    if (scopeObj) {
        if (runFor(scopeObj[prefix + modifiers(name, event, !isChar)]))
            return true;
        if (isChar && (event.shiftKey || event.altKey || event.metaKey || charCode > 127) &&
            (baseName = base[event.keyCode]) && baseName != name) {
            if (runFor(scopeObj[prefix + modifiers(baseName, event, true)]))
                return true;
            else if (event.shiftKey && (shiftName = shift[event.keyCode]) != name && shiftName != baseName &&
                runFor(scopeObj[prefix + modifiers(shiftName, event, false)]))
                return true;
        }
        else if (isChar && event.shiftKey) {
            if (runFor(scopeObj[prefix + modifiers(name, event, true)]))
                return true;
        }
        if (runFor(scopeObj._any))
            return true;
    }
    return fallthrough;
}

const CanHidePrimary = !browser.ios; // FIXME test IE
const selectionConfig = /*@__PURE__*/state_dist/* Facet.define */.r$.define({
    combine(configs) {
        return (0,state_dist/* combineConfig */.BO)(configs, {
            cursorBlinkRate: 1200,
            drawRangeCursor: true
        }, {
            cursorBlinkRate: (a, b) => Math.min(a, b),
            drawRangeCursor: (a, b) => a || b
        });
    }
});
/**
Returns an extension that hides the browser's native selection and
cursor, replacing the selection with a background behind the text
(with the `cm-selectionBackground` class), and the
cursors with elements overlaid over the code (using
`cm-cursor-primary` and `cm-cursor-secondary`).

This allows the editor to display secondary selection ranges, and
tends to produce a type of selection more in line with that users
expect in a text editor (the native selection styling will often
leave gaps between lines and won't fill the horizontal space after
a line when the selection continues past it).

It does have a performance cost, in that it requires an extra DOM
layout cycle for many updates (the selection is drawn based on DOM
layout information that's only available after laying out the
content).
*/
function drawSelection(config = {}) {
    return [
        selectionConfig.of(config),
        drawSelectionPlugin,
        hideNativeSelection
    ];
}
class Piece {
    constructor(left, top, width, height, className) {
        this.left = left;
        this.top = top;
        this.width = width;
        this.height = height;
        this.className = className;
    }
    draw() {
        let elt = document.createElement("div");
        elt.className = this.className;
        this.adjust(elt);
        return elt;
    }
    adjust(elt) {
        elt.style.left = this.left + "px";
        elt.style.top = this.top + "px";
        if (this.width >= 0)
            elt.style.width = this.width + "px";
        elt.style.height = this.height + "px";
    }
    eq(p) {
        return this.left == p.left && this.top == p.top && this.width == p.width && this.height == p.height &&
            this.className == p.className;
    }
}
const drawSelectionPlugin = /*@__PURE__*/(/* unused pure expression or super */ null && (ViewPlugin.fromClass(class {
    constructor(view) {
        this.view = view;
        this.rangePieces = [];
        this.cursors = [];
        this.measureReq = { read: this.readPos.bind(this), write: this.drawSel.bind(this) };
        this.selectionLayer = view.scrollDOM.appendChild(document.createElement("div"));
        this.selectionLayer.className = "cm-selectionLayer";
        this.selectionLayer.setAttribute("aria-hidden", "true");
        this.cursorLayer = view.scrollDOM.appendChild(document.createElement("div"));
        this.cursorLayer.className = "cm-cursorLayer";
        this.cursorLayer.setAttribute("aria-hidden", "true");
        view.requestMeasure(this.measureReq);
        this.setBlinkRate();
    }
    setBlinkRate() {
        this.cursorLayer.style.animationDuration = this.view.state.facet(selectionConfig).cursorBlinkRate + "ms";
    }
    update(update) {
        let confChanged = update.startState.facet(selectionConfig) != update.state.facet(selectionConfig);
        if (confChanged || update.selectionSet || update.geometryChanged || update.viewportChanged)
            this.view.requestMeasure(this.measureReq);
        if (update.transactions.some(tr => tr.scrollIntoView))
            this.cursorLayer.style.animationName = this.cursorLayer.style.animationName == "cm-blink" ? "cm-blink2" : "cm-blink";
        if (confChanged)
            this.setBlinkRate();
    }
    readPos() {
        let { state } = this.view, conf = state.facet(selectionConfig);
        let rangePieces = state.selection.ranges.map(r => r.empty ? [] : measureRange(this.view, r)).reduce((a, b) => a.concat(b));
        let cursors = [];
        for (let r of state.selection.ranges) {
            let prim = r == state.selection.main;
            if (r.empty ? !prim || CanHidePrimary : conf.drawRangeCursor) {
                let piece = measureCursor(this.view, r, prim);
                if (piece)
                    cursors.push(piece);
            }
        }
        return { rangePieces, cursors };
    }
    drawSel({ rangePieces, cursors }) {
        if (rangePieces.length != this.rangePieces.length || rangePieces.some((p, i) => !p.eq(this.rangePieces[i]))) {
            this.selectionLayer.textContent = "";
            for (let p of rangePieces)
                this.selectionLayer.appendChild(p.draw());
            this.rangePieces = rangePieces;
        }
        if (cursors.length != this.cursors.length || cursors.some((c, i) => !c.eq(this.cursors[i]))) {
            let oldCursors = this.cursorLayer.children;
            if (oldCursors.length !== cursors.length) {
                this.cursorLayer.textContent = "";
                for (const c of cursors)
                    this.cursorLayer.appendChild(c.draw());
            }
            else {
                cursors.forEach((c, idx) => c.adjust(oldCursors[idx]));
            }
            this.cursors = cursors;
        }
    }
    destroy() {
        this.selectionLayer.remove();
        this.cursorLayer.remove();
    }
})));
const themeSpec = {
    ".cm-line": {
        "& ::selection": { backgroundColor: "transparent !important" },
        "&::selection": { backgroundColor: "transparent !important" }
    }
};
if (CanHidePrimary)
    themeSpec[".cm-line"].caretColor = "transparent !important";
const hideNativeSelection = /*@__PURE__*/(/* unused pure expression or super */ null && (Prec.highest(/*@__PURE__*/EditorView.theme(themeSpec))));
function getBase(view) {
    let rect = view.scrollDOM.getBoundingClientRect();
    let left = view.textDirection == Direction.LTR ? rect.left : rect.right - view.scrollDOM.clientWidth;
    return { left: left - view.scrollDOM.scrollLeft, top: rect.top - view.scrollDOM.scrollTop };
}
function wrappedLine(view, pos, inside) {
    let range = EditorSelection.cursor(pos);
    return { from: Math.max(inside.from, view.moveToLineBoundary(range, false, true).from),
        to: Math.min(inside.to, view.moveToLineBoundary(range, true, true).from),
        type: BlockType.Text };
}
function blockAt(view, pos) {
    let line = view.lineBlockAt(pos);
    if (Array.isArray(line.type))
        for (let l of line.type) {
            if (l.to > pos || l.to == pos && (l.to == line.to || l.type == BlockType.Text))
                return l;
        }
    return line;
}
function measureRange(view, range) {
    if (range.to <= view.viewport.from || range.from >= view.viewport.to)
        return [];
    let from = Math.max(range.from, view.viewport.from), to = Math.min(range.to, view.viewport.to);
    let ltr = view.textDirection == Direction.LTR;
    let content = view.contentDOM, contentRect = content.getBoundingClientRect(), base = getBase(view);
    let lineStyle = window.getComputedStyle(content.firstChild);
    let leftSide = contentRect.left + parseInt(lineStyle.paddingLeft) + Math.min(0, parseInt(lineStyle.textIndent));
    let rightSide = contentRect.right - parseInt(lineStyle.paddingRight);
    let startBlock = blockAt(view, from), endBlock = blockAt(view, to);
    let visualStart = startBlock.type == BlockType.Text ? startBlock : null;
    let visualEnd = endBlock.type == BlockType.Text ? endBlock : null;
    if (view.lineWrapping) {
        if (visualStart)
            visualStart = wrappedLine(view, from, visualStart);
        if (visualEnd)
            visualEnd = wrappedLine(view, to, visualEnd);
    }
    if (visualStart && visualEnd && visualStart.from == visualEnd.from) {
        return pieces(drawForLine(range.from, range.to, visualStart));
    }
    else {
        let top = visualStart ? drawForLine(range.from, null, visualStart) : drawForWidget(startBlock, false);
        let bottom = visualEnd ? drawForLine(null, range.to, visualEnd) : drawForWidget(endBlock, true);
        let between = [];
        if ((visualStart || startBlock).to < (visualEnd || endBlock).from - 1)
            between.push(piece(leftSide, top.bottom, rightSide, bottom.top));
        else if (top.bottom < bottom.top && view.elementAtHeight((top.bottom + bottom.top) / 2).type == BlockType.Text)
            top.bottom = bottom.top = (top.bottom + bottom.top) / 2;
        return pieces(top).concat(between).concat(pieces(bottom));
    }
    function piece(left, top, right, bottom) {
        return new Piece(left - base.left, top - base.top - 0.01 /* C.Epsilon */, right - left, bottom - top + 0.01 /* C.Epsilon */, "cm-selectionBackground");
    }
    function pieces({ top, bottom, horizontal }) {
        let pieces = [];
        for (let i = 0; i < horizontal.length; i += 2)
            pieces.push(piece(horizontal[i], top, horizontal[i + 1], bottom));
        return pieces;
    }
    // Gets passed from/to in line-local positions
    function drawForLine(from, to, line) {
        let top = 1e9, bottom = -1e9, horizontal = [];
        function addSpan(from, fromOpen, to, toOpen, dir) {
            // Passing 2/-2 is a kludge to force the view to return
            // coordinates on the proper side of block widgets, since
            // normalizing the side there, though appropriate for most
            // coordsAtPos queries, would break selection drawing.
            let fromCoords = view.coordsAtPos(from, (from == line.to ? -2 : 2));
            let toCoords = view.coordsAtPos(to, (to == line.from ? 2 : -2));
            top = Math.min(fromCoords.top, toCoords.top, top);
            bottom = Math.max(fromCoords.bottom, toCoords.bottom, bottom);
            if (dir == Direction.LTR)
                horizontal.push(ltr && fromOpen ? leftSide : fromCoords.left, ltr && toOpen ? rightSide : toCoords.right);
            else
                horizontal.push(!ltr && toOpen ? leftSide : toCoords.left, !ltr && fromOpen ? rightSide : fromCoords.right);
        }
        let start = from !== null && from !== void 0 ? from : line.from, end = to !== null && to !== void 0 ? to : line.to;
        // Split the range by visible range and document line
        for (let r of view.visibleRanges)
            if (r.to > start && r.from < end) {
                for (let pos = Math.max(r.from, start), endPos = Math.min(r.to, end);;) {
                    let docLine = view.state.doc.lineAt(pos);
                    for (let span of view.bidiSpans(docLine)) {
                        let spanFrom = span.from + docLine.from, spanTo = span.to + docLine.from;
                        if (spanFrom >= endPos)
                            break;
                        if (spanTo > pos)
                            addSpan(Math.max(spanFrom, pos), from == null && spanFrom <= start, Math.min(spanTo, endPos), to == null && spanTo >= end, span.dir);
                    }
                    pos = docLine.to + 1;
                    if (pos >= endPos)
                        break;
                }
            }
        if (horizontal.length == 0)
            addSpan(start, from == null, end, to == null, view.textDirection);
        return { top, bottom, horizontal };
    }
    function drawForWidget(block, top) {
        let y = contentRect.top + (top ? block.top : block.bottom);
        return { top: y, bottom: y, horizontal: [] };
    }
}
function measureCursor(view, cursor, primary) {
    let pos = view.coordsAtPos(cursor.head, cursor.assoc || 1);
    if (!pos)
        return null;
    let base = getBase(view);
    return new Piece(pos.left - base.left, pos.top - base.top, -1, pos.bottom - pos.top, primary ? "cm-cursor cm-cursor-primary" : "cm-cursor cm-cursor-secondary");
}

const setDropCursorPos = /*@__PURE__*/state_dist/* StateEffect.define */.Py.define({
    map(pos, mapping) { return pos == null ? null : mapping.mapPos(pos); }
});
const dropCursorPos = /*@__PURE__*/state_dist/* StateField.define */.QQ.define({
    create() { return null; },
    update(pos, tr) {
        if (pos != null)
            pos = tr.changes.mapPos(pos);
        return tr.effects.reduce((pos, e) => e.is(setDropCursorPos) ? e.value : pos, pos);
    }
});
const drawDropCursor = /*@__PURE__*/ViewPlugin.fromClass(class {
    constructor(view) {
        this.view = view;
        this.cursor = null;
        this.measureReq = { read: this.readPos.bind(this), write: this.drawCursor.bind(this) };
    }
    update(update) {
        var _a;
        let cursorPos = update.state.field(dropCursorPos);
        if (cursorPos == null) {
            if (this.cursor != null) {
                (_a = this.cursor) === null || _a === void 0 ? void 0 : _a.remove();
                this.cursor = null;
            }
        }
        else {
            if (!this.cursor) {
                this.cursor = this.view.scrollDOM.appendChild(document.createElement("div"));
                this.cursor.className = "cm-dropCursor";
            }
            if (update.startState.field(dropCursorPos) != cursorPos || update.docChanged || update.geometryChanged)
                this.view.requestMeasure(this.measureReq);
        }
    }
    readPos() {
        let pos = this.view.state.field(dropCursorPos);
        let rect = pos != null && this.view.coordsAtPos(pos);
        if (!rect)
            return null;
        let outer = this.view.scrollDOM.getBoundingClientRect();
        return {
            left: rect.left - outer.left + this.view.scrollDOM.scrollLeft,
            top: rect.top - outer.top + this.view.scrollDOM.scrollTop,
            height: rect.bottom - rect.top
        };
    }
    drawCursor(pos) {
        if (this.cursor) {
            if (pos) {
                this.cursor.style.left = pos.left + "px";
                this.cursor.style.top = pos.top + "px";
                this.cursor.style.height = pos.height + "px";
            }
            else {
                this.cursor.style.left = "-100000px";
            }
        }
    }
    destroy() {
        if (this.cursor)
            this.cursor.remove();
    }
    setDropPos(pos) {
        if (this.view.state.field(dropCursorPos) != pos)
            this.view.dispatch({ effects: setDropCursorPos.of(pos) });
    }
}, {
    eventHandlers: {
        dragover(event) {
            this.setDropPos(this.view.posAtCoords({ x: event.clientX, y: event.clientY }));
        },
        dragleave(event) {
            if (event.target == this.view.contentDOM || !this.view.contentDOM.contains(event.relatedTarget))
                this.setDropPos(null);
        },
        dragend() {
            this.setDropPos(null);
        },
        drop() {
            this.setDropPos(null);
        }
    }
});
/**
Draws a cursor at the current drop position when something is
dragged over the editor.
*/
function dropCursor() {
    return [dropCursorPos, drawDropCursor];
}

function iterMatches(doc, re, from, to, f) {
    re.lastIndex = 0;
    for (let cursor = doc.iterRange(from, to), pos = from, m; !cursor.next().done; pos += cursor.value.length) {
        if (!cursor.lineBreak)
            while (m = re.exec(cursor.value))
                f(pos + m.index, m);
    }
}
function matchRanges(view, maxLength) {
    let visible = view.visibleRanges;
    if (visible.length == 1 && visible[0].from == view.viewport.from &&
        visible[0].to == view.viewport.to)
        return visible;
    let result = [];
    for (let { from, to } of visible) {
        from = Math.max(view.state.doc.lineAt(from).from, from - maxLength);
        to = Math.min(view.state.doc.lineAt(to).to, to + maxLength);
        if (result.length && result[result.length - 1].to >= from)
            result[result.length - 1].to = to;
        else
            result.push({ from, to });
    }
    return result;
}
/**
Helper class used to make it easier to maintain decorations on
visible code that matches a given regular expression. To be used
in a [view plugin](https://codemirror.net/6/docs/ref/#view.ViewPlugin). Instances of this object
represent a matching configuration.
*/
class MatchDecorator {
    /**
    Create a decorator.
    */
    constructor(config) {
        const { regexp, decoration, decorate, boundary, maxLength = 1000 } = config;
        if (!regexp.global)
            throw new RangeError("The regular expression given to MatchDecorator should have its 'g' flag set");
        this.regexp = regexp;
        if (decorate) {
            this.addMatch = (match, view, from, add) => decorate(add, from, from + match[0].length, match, view);
        }
        else if (typeof decoration == "function") {
            this.addMatch = (match, view, from, add) => {
                let deco = decoration(match, view, from);
                if (deco)
                    add(from, from + match[0].length, deco);
            };
        }
        else if (decoration) {
            this.addMatch = (match, _view, from, add) => add(from, from + match[0].length, decoration);
        }
        else {
            throw new RangeError("Either 'decorate' or 'decoration' should be provided to MatchDecorator");
        }
        this.boundary = boundary;
        this.maxLength = maxLength;
    }
    /**
    Compute the full set of decorations for matches in the given
    view's viewport. You'll want to call this when initializing your
    plugin.
    */
    createDeco(view) {
        let build = new RangeSetBuilder(), add = build.add.bind(build);
        for (let { from, to } of matchRanges(view, this.maxLength))
            iterMatches(view.state.doc, this.regexp, from, to, (from, m) => this.addMatch(m, view, from, add));
        return build.finish();
    }
    /**
    Update a set of decorations for a view update. `deco` _must_ be
    the set of decorations produced by _this_ `MatchDecorator` for
    the view state before the update.
    */
    updateDeco(update, deco) {
        let changeFrom = 1e9, changeTo = -1;
        if (update.docChanged)
            update.changes.iterChanges((_f, _t, from, to) => {
                if (to > update.view.viewport.from && from < update.view.viewport.to) {
                    changeFrom = Math.min(from, changeFrom);
                    changeTo = Math.max(to, changeTo);
                }
            });
        if (update.viewportChanged || changeTo - changeFrom > 1000)
            return this.createDeco(update.view);
        if (changeTo > -1)
            return this.updateRange(update.view, deco.map(update.changes), changeFrom, changeTo);
        return deco;
    }
    updateRange(view, deco, updateFrom, updateTo) {
        for (let r of view.visibleRanges) {
            let from = Math.max(r.from, updateFrom), to = Math.min(r.to, updateTo);
            if (to > from) {
                let fromLine = view.state.doc.lineAt(from), toLine = fromLine.to < to ? view.state.doc.lineAt(to) : fromLine;
                let start = Math.max(r.from, fromLine.from), end = Math.min(r.to, toLine.to);
                if (this.boundary) {
                    for (; from > fromLine.from; from--)
                        if (this.boundary.test(fromLine.text[from - 1 - fromLine.from])) {
                            start = from;
                            break;
                        }
                    for (; to < toLine.to; to++)
                        if (this.boundary.test(toLine.text[to - toLine.from])) {
                            end = to;
                            break;
                        }
                }
                let ranges = [], m;
                let add = (from, to, deco) => ranges.push(deco.range(from, to));
                if (fromLine == toLine) {
                    this.regexp.lastIndex = start - fromLine.from;
                    while ((m = this.regexp.exec(fromLine.text)) && m.index < end - fromLine.from)
                        this.addMatch(m, view, m.index + fromLine.from, add);
                }
                else {
                    iterMatches(view.state.doc, this.regexp, start, end, (from, m) => this.addMatch(m, view, from, add));
                }
                deco = deco.update({ filterFrom: start, filterTo: end, filter: (from, to) => from < start || to > end, add: ranges });
            }
        }
        return deco;
    }
}

const UnicodeRegexpSupport = /x/.unicode != null ? "gu" : "g";
const Specials = /*@__PURE__*/new RegExp("[\u0000-\u0008\u000a-\u001f\u007f-\u009f\u00ad\u061c\u200b\u200e\u200f\u2028\u2029\u202d\u202e\u2066\u2067\u2069\ufeff\ufff9-\ufffc]", UnicodeRegexpSupport);
const Names = {
    0: "null",
    7: "bell",
    8: "backspace",
    10: "newline",
    11: "vertical tab",
    13: "carriage return",
    27: "escape",
    8203: "zero width space",
    8204: "zero width non-joiner",
    8205: "zero width joiner",
    8206: "left-to-right mark",
    8207: "right-to-left mark",
    8232: "line separator",
    8237: "left-to-right override",
    8238: "right-to-left override",
    8294: "left-to-right isolate",
    8295: "right-to-left isolate",
    8297: "pop directional isolate",
    8233: "paragraph separator",
    65279: "zero width no-break space",
    65532: "object replacement"
};
let _supportsTabSize = null;
function supportsTabSize() {
    var _a;
    if (_supportsTabSize == null && typeof document != "undefined" && document.body) {
        let styles = document.body.style;
        _supportsTabSize = ((_a = styles.tabSize) !== null && _a !== void 0 ? _a : styles.MozTabSize) != null;
    }
    return _supportsTabSize || false;
}
const specialCharConfig = /*@__PURE__*/state_dist/* Facet.define */.r$.define({
    combine(configs) {
        let config = (0,state_dist/* combineConfig */.BO)(configs, {
            render: null,
            specialChars: Specials,
            addSpecialChars: null
        });
        if (config.replaceTabs = !supportsTabSize())
            config.specialChars = new RegExp("\t|" + config.specialChars.source, UnicodeRegexpSupport);
        if (config.addSpecialChars)
            config.specialChars = new RegExp(config.specialChars.source + "|" + config.addSpecialChars.source, UnicodeRegexpSupport);
        return config;
    }
});
/**
Returns an extension that installs highlighting of special
characters.
*/
function highlightSpecialChars(
/**
Configuration options.
*/
config = {}) {
    return [specialCharConfig.of(config), specialCharPlugin()];
}
let _plugin = null;
function specialCharPlugin() {
    return _plugin || (_plugin = ViewPlugin.fromClass(class {
        constructor(view) {
            this.view = view;
            this.decorations = Decoration.none;
            this.decorationCache = Object.create(null);
            this.decorator = this.makeDecorator(view.state.facet(specialCharConfig));
            this.decorations = this.decorator.createDeco(view);
        }
        makeDecorator(conf) {
            return new MatchDecorator({
                regexp: conf.specialChars,
                decoration: (m, view, pos) => {
                    let { doc } = view.state;
                    let code = codePointAt(m[0], 0);
                    if (code == 9) {
                        let line = doc.lineAt(pos);
                        let size = view.state.tabSize, col = countColumn(line.text, size, pos - line.from);
                        return Decoration.replace({ widget: new TabWidget((size - (col % size)) * this.view.defaultCharacterWidth) });
                    }
                    return this.decorationCache[code] ||
                        (this.decorationCache[code] = Decoration.replace({ widget: new SpecialCharWidget(conf, code) }));
                },
                boundary: conf.replaceTabs ? undefined : /[^]/
            });
        }
        update(update) {
            let conf = update.state.facet(specialCharConfig);
            if (update.startState.facet(specialCharConfig) != conf) {
                this.decorator = this.makeDecorator(conf);
                this.decorations = this.decorator.createDeco(update.view);
            }
            else {
                this.decorations = this.decorator.updateDeco(update, this.decorations);
            }
        }
    }, {
        decorations: v => v.decorations
    }));
}
const DefaultPlaceholder = "\u2022";
// Assigns placeholder characters from the Control Pictures block to
// ASCII control characters
function placeholder$1(code) {
    if (code >= 32)
        return DefaultPlaceholder;
    if (code == 10)
        return "\u2424";
    return String.fromCharCode(9216 + code);
}
class SpecialCharWidget extends (/* unused pure expression or super */ null && (WidgetType)) {
    constructor(options, code) {
        super();
        this.options = options;
        this.code = code;
    }
    eq(other) { return other.code == this.code; }
    toDOM(view) {
        let ph = placeholder$1(this.code);
        let desc = view.state.phrase("Control character") + " " + (Names[this.code] || "0x" + this.code.toString(16));
        let custom = this.options.render && this.options.render(this.code, desc, ph);
        if (custom)
            return custom;
        let span = document.createElement("span");
        span.textContent = ph;
        span.title = desc;
        span.setAttribute("aria-label", desc);
        span.className = "cm-specialChar";
        return span;
    }
    ignoreEvent() { return false; }
}
class TabWidget extends (/* unused pure expression or super */ null && (WidgetType)) {
    constructor(width) {
        super();
        this.width = width;
    }
    eq(other) { return other.width == this.width; }
    toDOM() {
        let span = document.createElement("span");
        span.textContent = "\t";
        span.className = "cm-tab";
        span.style.width = this.width + "px";
        return span;
    }
    ignoreEvent() { return false; }
}

const dist_plugin = /*@__PURE__*/(/* unused pure expression or super */ null && (ViewPlugin.fromClass(class {
    constructor() {
        this.height = 1000;
        this.attrs = { style: "padding-bottom: 1000px" };
    }
    update(update) {
        let height = update.view.viewState.editorHeight - update.view.defaultLineHeight;
        if (height != this.height) {
            this.height = height;
            this.attrs = { style: `padding-bottom: ${height}px` };
        }
    }
})));
/**
Returns an extension that makes sure the content has a bottom
margin equivalent to the height of the editor, minus one line
height, so that every line in the document can be scrolled to the
top of the editor.

This is only meaningful when the editor is scrollable, and should
not be enabled in editors that take the size of their content.
*/
function scrollPastEnd() {
    return [dist_plugin, contentAttributes.of(view => { var _a; return ((_a = view.plugin(dist_plugin)) === null || _a === void 0 ? void 0 : _a.attrs) || null; })];
}

/**
Mark lines that have a cursor on them with the `"cm-activeLine"`
DOM class.
*/
function highlightActiveLine() {
    return activeLineHighlighter;
}
const lineDeco = /*@__PURE__*/Decoration.line({ class: "cm-activeLine" });
const activeLineHighlighter = /*@__PURE__*/ViewPlugin.fromClass(class {
    constructor(view) {
        this.decorations = this.getDeco(view);
    }
    update(update) {
        if (update.docChanged || update.selectionSet)
            this.decorations = this.getDeco(update.view);
    }
    getDeco(view) {
        let lastLineStart = -1, deco = [];
        for (let r of view.state.selection.ranges) {
            let line = view.lineBlockAt(r.head);
            if (line.from > lastLineStart) {
                deco.push(lineDeco.range(line.from));
                lastLineStart = line.from;
            }
        }
        return Decoration.set(deco);
    }
}, {
    decorations: v => v.decorations
});

class Placeholder extends (/* unused pure expression or super */ null && (WidgetType)) {
    constructor(content) {
        super();
        this.content = content;
    }
    toDOM() {
        let wrap = document.createElement("span");
        wrap.className = "cm-placeholder";
        wrap.style.pointerEvents = "none";
        wrap.appendChild(typeof this.content == "string" ? document.createTextNode(this.content) : this.content);
        if (typeof this.content == "string")
            wrap.setAttribute("aria-label", "placeholder " + this.content);
        else
            wrap.setAttribute("aria-hidden", "true");
        return wrap;
    }
    ignoreEvent() { return false; }
}
/**
Extension that enables a placeholdera piece of example content
to show when the editor is empty.
*/
function placeholder(content) {
    return ViewPlugin.fromClass(class {
        constructor(view) {
            this.view = view;
            this.placeholder = Decoration.set([Decoration.widget({ widget: new Placeholder(content), side: 1 }).range(0)]);
        }
        get decorations() { return this.view.state.doc.length ? Decoration.none : this.placeholder; }
    }, { decorations: v => v.decorations });
}

// Don't compute precise column positions for line offsets above this
// (since it could get expensive). Assume offset==column for them.
const MaxOff = 2000;
function rectangleFor(state, a, b) {
    let startLine = Math.min(a.line, b.line), endLine = Math.max(a.line, b.line);
    let ranges = [];
    if (a.off > MaxOff || b.off > MaxOff || a.col < 0 || b.col < 0) {
        let startOff = Math.min(a.off, b.off), endOff = Math.max(a.off, b.off);
        for (let i = startLine; i <= endLine; i++) {
            let line = state.doc.line(i);
            if (line.length <= endOff)
                ranges.push(EditorSelection.range(line.from + startOff, line.to + endOff));
        }
    }
    else {
        let startCol = Math.min(a.col, b.col), endCol = Math.max(a.col, b.col);
        for (let i = startLine; i <= endLine; i++) {
            let line = state.doc.line(i);
            let start = findColumn(line.text, startCol, state.tabSize, true);
            if (start > -1) {
                let end = findColumn(line.text, endCol, state.tabSize);
                ranges.push(EditorSelection.range(line.from + start, line.from + end));
            }
        }
    }
    return ranges;
}
function absoluteColumn(view, x) {
    let ref = view.coordsAtPos(view.viewport.from);
    return ref ? Math.round(Math.abs((ref.left - x) / view.defaultCharacterWidth)) : -1;
}
function getPos(view, event) {
    let offset = view.posAtCoords({ x: event.clientX, y: event.clientY }, false);
    let line = view.state.doc.lineAt(offset), off = offset - line.from;
    let col = off > MaxOff ? -1
        : off == line.length ? absoluteColumn(view, event.clientX)
            : countColumn(line.text, view.state.tabSize, offset - line.from);
    return { line: line.number, col, off };
}
function rectangleSelectionStyle(view, event) {
    let start = getPos(view, event), startSel = view.state.selection;
    if (!start)
        return null;
    return {
        update(update) {
            if (update.docChanged) {
                let newStart = update.changes.mapPos(update.startState.doc.line(start.line).from);
                let newLine = update.state.doc.lineAt(newStart);
                start = { line: newLine.number, col: start.col, off: Math.min(start.off, newLine.length) };
                startSel = startSel.map(update.changes);
            }
        },
        get(event, _extend, multiple) {
            let cur = getPos(view, event);
            if (!cur)
                return startSel;
            let ranges = rectangleFor(view.state, start, cur);
            if (!ranges.length)
                return startSel;
            if (multiple)
                return EditorSelection.create(ranges.concat(startSel.ranges));
            else
                return EditorSelection.create(ranges);
        }
    };
}
/**
Create an extension that enables rectangular selections. By
default, it will react to left mouse drag with the Alt key held
down. When such a selection occurs, the text within the rectangle
that was dragged over will be selected, as one selection
[range](https://codemirror.net/6/docs/ref/#state.SelectionRange) per line.
*/
function rectangularSelection(options) {
    let filter = (options === null || options === void 0 ? void 0 : options.eventFilter) || (e => e.altKey && e.button == 0);
    return EditorView.mouseSelectionStyle.of((view, event) => filter(event) ? rectangleSelectionStyle(view, event) : null);
}
const keys = {
    Alt: [18, e => e.altKey],
    Control: [17, e => e.ctrlKey],
    Shift: [16, e => e.shiftKey],
    Meta: [91, e => e.metaKey]
};
const showCrosshair = { style: "cursor: crosshair" };
/**
Returns an extension that turns the pointer cursor into a
crosshair when a given modifier key, defaulting to Alt, is held
down. Can serve as a visual hint that rectangular selection is
going to happen when paired with
[`rectangularSelection`](https://codemirror.net/6/docs/ref/#view.rectangularSelection).
*/
function crosshairCursor(options = {}) {
    let [code, getter] = keys[options.key || "Alt"];
    let plugin = ViewPlugin.fromClass(class {
        constructor(view) {
            this.view = view;
            this.isDown = false;
        }
        set(isDown) {
            if (this.isDown != isDown) {
                this.isDown = isDown;
                this.view.update([]);
            }
        }
    }, {
        eventHandlers: {
            keydown(e) {
                this.set(e.keyCode == code || getter(e));
            },
            keyup(e) {
                if (e.keyCode == code || !getter(e))
                    this.set(false);
            }
        }
    });
    return [
        plugin,
        EditorView.contentAttributes.of(view => { var _a; return ((_a = view.plugin(plugin)) === null || _a === void 0 ? void 0 : _a.isDown) ? showCrosshair : null; })
    ];
}

const Outside = "-10000px";
class TooltipViewManager {
    constructor(view, facet, createTooltipView) {
        this.facet = facet;
        this.createTooltipView = createTooltipView;
        this.input = view.state.facet(facet);
        this.tooltips = this.input.filter(t => t);
        this.tooltipViews = this.tooltips.map(createTooltipView);
    }
    update(update) {
        let input = update.state.facet(this.facet);
        let tooltips = input.filter(x => x);
        if (input === this.input) {
            for (let t of this.tooltipViews)
                if (t.update)
                    t.update(update);
            return false;
        }
        let tooltipViews = [];
        for (let i = 0; i < tooltips.length; i++) {
            let tip = tooltips[i], known = -1;
            if (!tip)
                continue;
            for (let i = 0; i < this.tooltips.length; i++) {
                let other = this.tooltips[i];
                if (other && other.create == tip.create)
                    known = i;
            }
            if (known < 0) {
                tooltipViews[i] = this.createTooltipView(tip);
            }
            else {
                let tooltipView = tooltipViews[i] = this.tooltipViews[known];
                if (tooltipView.update)
                    tooltipView.update(update);
            }
        }
        for (let t of this.tooltipViews)
            if (tooltipViews.indexOf(t) < 0)
                t.dom.remove();
        this.input = input;
        this.tooltips = tooltips;
        this.tooltipViews = tooltipViews;
        return true;
    }
}
/**
Creates an extension that configures tooltip behavior.
*/
function tooltips(config = {}) {
    return tooltipConfig.of(config);
}
function windowSpace(view) {
    let { win } = view;
    return { top: 0, left: 0, bottom: win.innerHeight, right: win.innerWidth };
}
const tooltipConfig = /*@__PURE__*/state_dist/* Facet.define */.r$.define({
    combine: values => {
        var _a, _b, _c;
        return ({
            position: browser.ios ? "absolute" : ((_a = values.find(conf => conf.position)) === null || _a === void 0 ? void 0 : _a.position) || "fixed",
            parent: ((_b = values.find(conf => conf.parent)) === null || _b === void 0 ? void 0 : _b.parent) || null,
            tooltipSpace: ((_c = values.find(conf => conf.tooltipSpace)) === null || _c === void 0 ? void 0 : _c.tooltipSpace) || windowSpace,
        });
    }
});
const tooltipPlugin = /*@__PURE__*/ViewPlugin.fromClass(class {
    constructor(view) {
        this.view = view;
        this.inView = true;
        this.lastTransaction = 0;
        this.measureTimeout = -1;
        let config = view.state.facet(tooltipConfig);
        this.position = config.position;
        this.parent = config.parent;
        this.classes = view.themeClasses;
        this.createContainer();
        this.measureReq = { read: this.readMeasure.bind(this), write: this.writeMeasure.bind(this), key: this };
        this.manager = new TooltipViewManager(view, showTooltip, t => this.createTooltip(t));
        this.intersectionObserver = typeof IntersectionObserver == "function" ? new IntersectionObserver(entries => {
            if (Date.now() > this.lastTransaction - 50 &&
                entries.length > 0 && entries[entries.length - 1].intersectionRatio < 1)
                this.measureSoon();
        }, { threshold: [1] }) : null;
        this.observeIntersection();
        view.win.addEventListener("resize", this.measureSoon = this.measureSoon.bind(this));
        this.maybeMeasure();
    }
    createContainer() {
        if (this.parent) {
            this.container = document.createElement("div");
            this.container.style.position = "relative";
            this.container.className = this.view.themeClasses;
            this.parent.appendChild(this.container);
        }
        else {
            this.container = this.view.dom;
        }
    }
    observeIntersection() {
        if (this.intersectionObserver) {
            this.intersectionObserver.disconnect();
            for (let tooltip of this.manager.tooltipViews)
                this.intersectionObserver.observe(tooltip.dom);
        }
    }
    measureSoon() {
        if (this.measureTimeout < 0)
            this.measureTimeout = setTimeout(() => {
                this.measureTimeout = -1;
                this.maybeMeasure();
            }, 50);
    }
    update(update) {
        if (update.transactions.length)
            this.lastTransaction = Date.now();
        let updated = this.manager.update(update);
        if (updated)
            this.observeIntersection();
        let shouldMeasure = updated || update.geometryChanged;
        let newConfig = update.state.facet(tooltipConfig);
        if (newConfig.position != this.position) {
            this.position = newConfig.position;
            for (let t of this.manager.tooltipViews)
                t.dom.style.position = this.position;
            shouldMeasure = true;
        }
        if (newConfig.parent != this.parent) {
            if (this.parent)
                this.container.remove();
            this.parent = newConfig.parent;
            this.createContainer();
            for (let t of this.manager.tooltipViews)
                this.container.appendChild(t.dom);
            shouldMeasure = true;
        }
        else if (this.parent && this.view.themeClasses != this.classes) {
            this.classes = this.container.className = this.view.themeClasses;
        }
        if (shouldMeasure)
            this.maybeMeasure();
    }
    createTooltip(tooltip) {
        let tooltipView = tooltip.create(this.view);
        tooltipView.dom.classList.add("cm-tooltip");
        if (tooltip.arrow && !tooltipView.dom.querySelector(".cm-tooltip > .cm-tooltip-arrow")) {
            let arrow = document.createElement("div");
            arrow.className = "cm-tooltip-arrow";
            tooltipView.dom.appendChild(arrow);
        }
        tooltipView.dom.style.position = this.position;
        tooltipView.dom.style.top = Outside;
        this.container.appendChild(tooltipView.dom);
        if (tooltipView.mount)
            tooltipView.mount(this.view);
        return tooltipView;
    }
    destroy() {
        var _a;
        this.view.win.removeEventListener("resize", this.measureSoon);
        for (let { dom } of this.manager.tooltipViews)
            dom.remove();
        (_a = this.intersectionObserver) === null || _a === void 0 ? void 0 : _a.disconnect();
        clearTimeout(this.measureTimeout);
    }
    readMeasure() {
        let editor = this.view.dom.getBoundingClientRect();
        return {
            editor,
            parent: this.parent ? this.container.getBoundingClientRect() : editor,
            pos: this.manager.tooltips.map((t, i) => {
                let tv = this.manager.tooltipViews[i];
                return tv.getCoords ? tv.getCoords(t.pos) : this.view.coordsAtPos(t.pos);
            }),
            size: this.manager.tooltipViews.map(({ dom }) => dom.getBoundingClientRect()),
            space: this.view.state.facet(tooltipConfig).tooltipSpace(this.view),
        };
    }
    writeMeasure(measured) {
        let { editor, space } = measured;
        let others = [];
        for (let i = 0; i < this.manager.tooltips.length; i++) {
            let tooltip = this.manager.tooltips[i], tView = this.manager.tooltipViews[i], { dom } = tView;
            let pos = measured.pos[i], size = measured.size[i];
            // Hide tooltips that are outside of the editor.
            if (!pos || pos.bottom <= Math.max(editor.top, space.top) ||
                pos.top >= Math.min(editor.bottom, space.bottom) ||
                pos.right < Math.max(editor.left, space.left) - .1 ||
                pos.left > Math.min(editor.right, space.right) + .1) {
                dom.style.top = Outside;
                continue;
            }
            let arrow = tooltip.arrow ? tView.dom.querySelector(".cm-tooltip-arrow") : null;
            let arrowHeight = arrow ? 7 /* Arrow.Size */ : 0;
            let width = size.right - size.left, height = size.bottom - size.top;
            let offset = tView.offset || noOffset, ltr = this.view.textDirection == Direction.LTR;
            let left = size.width > space.right - space.left ? (ltr ? space.left : space.right - size.width)
                : ltr ? Math.min(pos.left - (arrow ? 14 /* Arrow.Offset */ : 0) + offset.x, space.right - width)
                    : Math.max(space.left, pos.left - width + (arrow ? 14 /* Arrow.Offset */ : 0) - offset.x);
            let above = !!tooltip.above;
            if (!tooltip.strictSide && (above
                ? pos.top - (size.bottom - size.top) - offset.y < space.top
                : pos.bottom + (size.bottom - size.top) + offset.y > space.bottom) &&
                above == (space.bottom - pos.bottom > pos.top - space.top))
                above = !above;
            let top = above ? pos.top - height - arrowHeight - offset.y : pos.bottom + arrowHeight + offset.y;
            let right = left + width;
            if (tView.overlap !== true)
                for (let r of others)
                    if (r.left < right && r.right > left && r.top < top + height && r.bottom > top)
                        top = above ? r.top - height - 2 - arrowHeight : r.bottom + arrowHeight + 2;
            if (this.position == "absolute") {
                dom.style.top = (top - measured.parent.top) + "px";
                dom.style.left = (left - measured.parent.left) + "px";
            }
            else {
                dom.style.top = top + "px";
                dom.style.left = left + "px";
            }
            if (arrow)
                arrow.style.left = `${pos.left + (ltr ? offset.x : -offset.x) - (left + 14 /* Arrow.Offset */ - 7 /* Arrow.Size */)}px`;
            if (tView.overlap !== true)
                others.push({ left, top, right, bottom: top + height });
            dom.classList.toggle("cm-tooltip-above", above);
            dom.classList.toggle("cm-tooltip-below", !above);
            if (tView.positioned)
                tView.positioned();
        }
    }
    maybeMeasure() {
        if (this.manager.tooltips.length) {
            if (this.view.inView)
                this.view.requestMeasure(this.measureReq);
            if (this.inView != this.view.inView) {
                this.inView = this.view.inView;
                if (!this.inView)
                    for (let tv of this.manager.tooltipViews)
                        tv.dom.style.top = Outside;
            }
        }
    }
}, {
    eventHandlers: {
        scroll() { this.maybeMeasure(); }
    }
});
const baseTheme = /*@__PURE__*/EditorView.baseTheme({
    ".cm-tooltip": {
        zIndex: 100
    },
    "&light .cm-tooltip": {
        border: "1px solid #bbb",
        backgroundColor: "#f5f5f5"
    },
    "&light .cm-tooltip-section:not(:first-child)": {
        borderTop: "1px solid #bbb",
    },
    "&dark .cm-tooltip": {
        backgroundColor: "#333338",
        color: "white"
    },
    ".cm-tooltip-arrow": {
        height: `${7 /* Arrow.Size */}px`,
        width: `${7 /* Arrow.Size */ * 2}px`,
        position: "absolute",
        zIndex: -1,
        overflow: "hidden",
        "&:before, &:after": {
            content: "''",
            position: "absolute",
            width: 0,
            height: 0,
            borderLeft: `${7 /* Arrow.Size */}px solid transparent`,
            borderRight: `${7 /* Arrow.Size */}px solid transparent`,
        },
        ".cm-tooltip-above &": {
            bottom: `-${7 /* Arrow.Size */}px`,
            "&:before": {
                borderTop: `${7 /* Arrow.Size */}px solid #bbb`,
            },
            "&:after": {
                borderTop: `${7 /* Arrow.Size */}px solid #f5f5f5`,
                bottom: "1px"
            }
        },
        ".cm-tooltip-below &": {
            top: `-${7 /* Arrow.Size */}px`,
            "&:before": {
                borderBottom: `${7 /* Arrow.Size */}px solid #bbb`,
            },
            "&:after": {
                borderBottom: `${7 /* Arrow.Size */}px solid #f5f5f5`,
                top: "1px"
            }
        },
    },
    "&dark .cm-tooltip .cm-tooltip-arrow": {
        "&:before": {
            borderTopColor: "#333338",
            borderBottomColor: "#333338"
        },
        "&:after": {
            borderTopColor: "transparent",
            borderBottomColor: "transparent"
        }
    }
});
const noOffset = { x: 0, y: 0 };
/**
Facet to which an extension can add a value to show a tooltip.
*/
const showTooltip = /*@__PURE__*/state_dist/* Facet.define */.r$.define({
    enables: [tooltipPlugin, baseTheme]
});
const showHoverTooltip = /*@__PURE__*/state_dist/* Facet.define */.r$.define();
class HoverTooltipHost {
    constructor(view) {
        this.view = view;
        this.mounted = false;
        this.dom = document.createElement("div");
        this.dom.classList.add("cm-tooltip-hover");
        this.manager = new TooltipViewManager(view, showHoverTooltip, t => this.createHostedView(t));
    }
    // Needs to be static so that host tooltip instances always match
    static create(view) {
        return new HoverTooltipHost(view);
    }
    createHostedView(tooltip) {
        let hostedView = tooltip.create(this.view);
        hostedView.dom.classList.add("cm-tooltip-section");
        this.dom.appendChild(hostedView.dom);
        if (this.mounted && hostedView.mount)
            hostedView.mount(this.view);
        return hostedView;
    }
    mount(view) {
        for (let hostedView of this.manager.tooltipViews) {
            if (hostedView.mount)
                hostedView.mount(view);
        }
        this.mounted = true;
    }
    positioned() {
        for (let hostedView of this.manager.tooltipViews) {
            if (hostedView.positioned)
                hostedView.positioned();
        }
    }
    update(update) {
        this.manager.update(update);
    }
}
const showHoverTooltipHost = /*@__PURE__*/showTooltip.compute([showHoverTooltip], state => {
    let tooltips = state.facet(showHoverTooltip).filter(t => t);
    if (tooltips.length === 0)
        return null;
    return {
        pos: Math.min(...tooltips.map(t => t.pos)),
        end: Math.max(...tooltips.filter(t => t.end != null).map(t => t.end)),
        create: HoverTooltipHost.create,
        above: tooltips[0].above,
        arrow: tooltips.some(t => t.arrow),
    };
});
class HoverPlugin {
    constructor(view, source, field, setHover, hoverTime) {
        this.view = view;
        this.source = source;
        this.field = field;
        this.setHover = setHover;
        this.hoverTime = hoverTime;
        this.hoverTimeout = -1;
        this.restartTimeout = -1;
        this.pending = null;
        this.lastMove = { x: 0, y: 0, target: view.dom, time: 0 };
        this.checkHover = this.checkHover.bind(this);
        view.dom.addEventListener("mouseleave", this.mouseleave = this.mouseleave.bind(this));
        view.dom.addEventListener("mousemove", this.mousemove = this.mousemove.bind(this));
    }
    update() {
        if (this.pending) {
            this.pending = null;
            clearTimeout(this.restartTimeout);
            this.restartTimeout = setTimeout(() => this.startHover(), 20);
        }
    }
    get active() {
        return this.view.state.field(this.field);
    }
    checkHover() {
        this.hoverTimeout = -1;
        if (this.active)
            return;
        let hovered = Date.now() - this.lastMove.time;
        if (hovered < this.hoverTime)
            this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime - hovered);
        else
            this.startHover();
    }
    startHover() {
        clearTimeout(this.restartTimeout);
        let { lastMove } = this;
        let pos = this.view.contentDOM.contains(lastMove.target) ? this.view.posAtCoords(lastMove) : null;
        if (pos == null)
            return;
        let posCoords = this.view.coordsAtPos(pos);
        if (posCoords == null || lastMove.y < posCoords.top || lastMove.y > posCoords.bottom ||
            lastMove.x < posCoords.left - this.view.defaultCharacterWidth ||
            lastMove.x > posCoords.right + this.view.defaultCharacterWidth)
            return;
        let bidi = this.view.bidiSpans(this.view.state.doc.lineAt(pos)).find(s => s.from <= pos && s.to >= pos);
        let rtl = bidi && bidi.dir == Direction.RTL ? -1 : 1;
        let open = this.source(this.view, pos, (lastMove.x < posCoords.left ? -rtl : rtl));
        if (open === null || open === void 0 ? void 0 : open.then) {
            let pending = this.pending = { pos };
            open.then(result => {
                if (this.pending == pending) {
                    this.pending = null;
                    if (result)
                        this.view.dispatch({ effects: this.setHover.of(result) });
                }
            }, e => logException(this.view.state, e, "hover tooltip"));
        }
        else if (open) {
            this.view.dispatch({ effects: this.setHover.of(open) });
        }
    }
    mousemove(event) {
        var _a;
        this.lastMove = { x: event.clientX, y: event.clientY, target: event.target, time: Date.now() };
        if (this.hoverTimeout < 0)
            this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime);
        let tooltip = this.active;
        if (tooltip && !isInTooltip(this.lastMove.target) || this.pending) {
            let { pos } = tooltip || this.pending, end = (_a = tooltip === null || tooltip === void 0 ? void 0 : tooltip.end) !== null && _a !== void 0 ? _a : pos;
            if ((pos == end ? this.view.posAtCoords(this.lastMove) != pos
                : !isOverRange(this.view, pos, end, event.clientX, event.clientY, 6 /* Hover.MaxDist */))) {
                this.view.dispatch({ effects: this.setHover.of(null) });
                this.pending = null;
            }
        }
    }
    mouseleave() {
        clearTimeout(this.hoverTimeout);
        this.hoverTimeout = -1;
        if (this.active)
            this.view.dispatch({ effects: this.setHover.of(null) });
    }
    destroy() {
        clearTimeout(this.hoverTimeout);
        this.view.dom.removeEventListener("mouseleave", this.mouseleave);
        this.view.dom.removeEventListener("mousemove", this.mousemove);
    }
}
function isInTooltip(elt) {
    for (let cur = elt; cur; cur = cur.parentNode)
        if (cur.nodeType == 1 && cur.classList.contains("cm-tooltip"))
            return true;
    return false;
}
function isOverRange(view, from, to, x, y, margin) {
    let range = document.createRange();
    let fromDOM = view.domAtPos(from), toDOM = view.domAtPos(to);
    range.setEnd(toDOM.node, toDOM.offset);
    range.setStart(fromDOM.node, fromDOM.offset);
    let rects = range.getClientRects();
    range.detach();
    for (let i = 0; i < rects.length; i++) {
        let rect = rects[i];
        let dist = Math.max(rect.top - y, y - rect.bottom, rect.left - x, x - rect.right);
        if (dist <= margin)
            return true;
    }
    return false;
}
/**
Set up a hover tooltip, which shows up when the pointer hovers
over ranges of text. The callback is called when the mouse hovers
over the document text. It should, if there is a tooltip
associated with position `pos`, return the tooltip description
(either directly or in a promise). The `side` argument indicates
on which side of the position the pointer isit will be -1 if the
pointer is before the position, 1 if after the position.

Note that all hover tooltips are hosted within a single tooltip
container element. This allows multiple tooltips over the same
range to be "merged" together without overlapping.
*/
function hoverTooltip(source, options = {}) {
    let setHover = StateEffect.define();
    let hoverState = StateField.define({
        create() { return null; },
        update(value, tr) {
            if (value && (options.hideOnChange && (tr.docChanged || tr.selection) ||
                options.hideOn && options.hideOn(tr, value)))
                return null;
            if (value && tr.docChanged) {
                let newPos = tr.changes.mapPos(value.pos, -1, MapMode.TrackDel);
                if (newPos == null)
                    return null;
                let copy = Object.assign(Object.create(null), value);
                copy.pos = newPos;
                if (value.end != null)
                    copy.end = tr.changes.mapPos(value.end);
                value = copy;
            }
            for (let effect of tr.effects) {
                if (effect.is(setHover))
                    value = effect.value;
                if (effect.is(closeHoverTooltipEffect))
                    value = null;
            }
            return value;
        },
        provide: f => showHoverTooltip.from(f)
    });
    return [
        hoverState,
        ViewPlugin.define(view => new HoverPlugin(view, source, hoverState, setHover, options.hoverTime || 300 /* Hover.Time */)),
        showHoverTooltipHost
    ];
}
/**
Get the active tooltip view for a given tooltip, if available.
*/
function getTooltip(view, tooltip) {
    let plugin = view.plugin(tooltipPlugin);
    if (!plugin)
        return null;
    let found = plugin.manager.tooltips.indexOf(tooltip);
    return found < 0 ? null : plugin.manager.tooltipViews[found];
}
/**
Returns true if any hover tooltips are currently active.
*/
function hasHoverTooltips(state) {
    return state.facet(showHoverTooltip).some(x => x);
}
const closeHoverTooltipEffect = /*@__PURE__*/(/* unused pure expression or super */ null && (StateEffect.define()));
/**
Transaction effect that closes all hover tooltips.
*/
const closeHoverTooltips = /*@__PURE__*/(/* unused pure expression or super */ null && (closeHoverTooltipEffect.of(null)));
/**
Tell the tooltip extension to recompute the position of the active
tooltips. This can be useful when something happens (such as a
re-positioning or CSS change affecting the editor) that could
invalidate the existing tooltip positions.
*/
function repositionTooltips(view) {
    var _a;
    (_a = view.plugin(tooltipPlugin)) === null || _a === void 0 ? void 0 : _a.maybeMeasure();
}

const panelConfig = /*@__PURE__*/state_dist/* Facet.define */.r$.define({
    combine(configs) {
        let topContainer, bottomContainer;
        for (let c of configs) {
            topContainer = topContainer || c.topContainer;
            bottomContainer = bottomContainer || c.bottomContainer;
        }
        return { topContainer, bottomContainer };
    }
});
/**
Configures the panel-managing extension.
*/
function panels(config) {
    return config ? [panelConfig.of(config)] : [];
}
/**
Get the active panel created by the given constructor, if any.
This can be useful when you need access to your panels' DOM
structure.
*/
function getPanel(view, panel) {
    let plugin = view.plugin(panelPlugin);
    let index = plugin ? plugin.specs.indexOf(panel) : -1;
    return index > -1 ? plugin.panels[index] : null;
}
const panelPlugin = /*@__PURE__*/ViewPlugin.fromClass(class {
    constructor(view) {
        this.input = view.state.facet(showPanel);
        this.specs = this.input.filter(s => s);
        this.panels = this.specs.map(spec => spec(view));
        let conf = view.state.facet(panelConfig);
        this.top = new PanelGroup(view, true, conf.topContainer);
        this.bottom = new PanelGroup(view, false, conf.bottomContainer);
        this.top.sync(this.panels.filter(p => p.top));
        this.bottom.sync(this.panels.filter(p => !p.top));
        for (let p of this.panels) {
            p.dom.classList.add("cm-panel");
            if (p.mount)
                p.mount();
        }
    }
    update(update) {
        let conf = update.state.facet(panelConfig);
        if (this.top.container != conf.topContainer) {
            this.top.sync([]);
            this.top = new PanelGroup(update.view, true, conf.topContainer);
        }
        if (this.bottom.container != conf.bottomContainer) {
            this.bottom.sync([]);
            this.bottom = new PanelGroup(update.view, false, conf.bottomContainer);
        }
        this.top.syncClasses();
        this.bottom.syncClasses();
        let input = update.state.facet(showPanel);
        if (input != this.input) {
            let specs = input.filter(x => x);
            let panels = [], top = [], bottom = [], mount = [];
            for (let spec of specs) {
                let known = this.specs.indexOf(spec), panel;
                if (known < 0) {
                    panel = spec(update.view);
                    mount.push(panel);
                }
                else {
                    panel = this.panels[known];
                    if (panel.update)
                        panel.update(update);
                }
                panels.push(panel);
                (panel.top ? top : bottom).push(panel);
            }
            this.specs = specs;
            this.panels = panels;
            this.top.sync(top);
            this.bottom.sync(bottom);
            for (let p of mount) {
                p.dom.classList.add("cm-panel");
                if (p.mount)
                    p.mount();
            }
        }
        else {
            for (let p of this.panels)
                if (p.update)
                    p.update(update);
        }
    }
    destroy() {
        this.top.sync([]);
        this.bottom.sync([]);
    }
}, {
    provide: plugin => EditorView.scrollMargins.of(view => {
        let value = view.plugin(plugin);
        return value && { top: value.top.scrollMargin(), bottom: value.bottom.scrollMargin() };
    })
});
class PanelGroup {
    constructor(view, top, container) {
        this.view = view;
        this.top = top;
        this.container = container;
        this.dom = undefined;
        this.classes = "";
        this.panels = [];
        this.syncClasses();
    }
    sync(panels) {
        for (let p of this.panels)
            if (p.destroy && panels.indexOf(p) < 0)
                p.destroy();
        this.panels = panels;
        this.syncDOM();
    }
    syncDOM() {
        if (this.panels.length == 0) {
            if (this.dom) {
                this.dom.remove();
                this.dom = undefined;
            }
            return;
        }
        if (!this.dom) {
            this.dom = document.createElement("div");
            this.dom.className = this.top ? "cm-panels cm-panels-top" : "cm-panels cm-panels-bottom";
            this.dom.style[this.top ? "top" : "bottom"] = "0";
            let parent = this.container || this.view.dom;
            parent.insertBefore(this.dom, this.top ? parent.firstChild : null);
        }
        let curDOM = this.dom.firstChild;
        for (let panel of this.panels) {
            if (panel.dom.parentNode == this.dom) {
                while (curDOM != panel.dom)
                    curDOM = rm(curDOM);
                curDOM = curDOM.nextSibling;
            }
            else {
                this.dom.insertBefore(panel.dom, curDOM);
            }
        }
        while (curDOM)
            curDOM = rm(curDOM);
    }
    scrollMargin() {
        return !this.dom || this.container ? 0
            : Math.max(0, this.top ?
                this.dom.getBoundingClientRect().bottom - Math.max(0, this.view.scrollDOM.getBoundingClientRect().top) :
                Math.min(innerHeight, this.view.scrollDOM.getBoundingClientRect().bottom) - this.dom.getBoundingClientRect().top);
    }
    syncClasses() {
        if (!this.container || this.classes == this.view.themeClasses)
            return;
        for (let cls of this.classes.split(" "))
            if (cls)
                this.container.classList.remove(cls);
        for (let cls of (this.classes = this.view.themeClasses).split(" "))
            if (cls)
                this.container.classList.add(cls);
    }
}
function rm(node) {
    let next = node.nextSibling;
    node.remove();
    return next;
}
/**
Opening a panel is done by providing a constructor function for
the panel through this facet. (The panel is closed again when its
constructor is no longer provided.) Values of `null` are ignored.
*/
const showPanel = /*@__PURE__*/state_dist/* Facet.define */.r$.define({
    enables: panelPlugin
});

/**
A gutter marker represents a bit of information attached to a line
in a specific gutter. Your own custom markers have to extend this
class.
*/
class GutterMarker extends state_dist/* RangeValue */.uU {
    /**
    @internal
    */
    compare(other) {
        return this == other || this.constructor == other.constructor && this.eq(other);
    }
    /**
    Compare this marker to another marker of the same type.
    */
    eq(other) { return false; }
    /**
    Called if the marker has a `toDOM` method and its representation
    was removed from a gutter.
    */
    destroy(dom) { }
}
GutterMarker.prototype.elementClass = "";
GutterMarker.prototype.toDOM = undefined;
GutterMarker.prototype.mapMode = state_dist/* MapMode.TrackBefore */.gc.TrackBefore;
GutterMarker.prototype.startSide = GutterMarker.prototype.endSide = -1;
GutterMarker.prototype.point = true;
/**
Facet used to add a class to all gutter elements for a given line.
Markers given to this facet should _only_ define an
[`elementclass`](https://codemirror.net/6/docs/ref/#view.GutterMarker.elementClass), not a
[`toDOM`](https://codemirror.net/6/docs/ref/#view.GutterMarker.toDOM) (or the marker will appear
in all gutters for the line).
*/
const gutterLineClass = /*@__PURE__*/state_dist/* Facet.define */.r$.define();
const defaults = {
    class: "",
    renderEmptyElements: false,
    elementStyle: "",
    markers: () => state_dist/* RangeSet.empty */.Xs.empty,
    lineMarker: () => null,
    lineMarkerChange: null,
    initialSpacer: null,
    updateSpacer: null,
    domEventHandlers: {}
};
const activeGutters = /*@__PURE__*/state_dist/* Facet.define */.r$.define();
/**
Define an editor gutter. The order in which the gutters appear is
determined by their extension priority.
*/
function gutter(config) {
    return [gutters(), activeGutters.of(Object.assign(Object.assign({}, defaults), config))];
}
const unfixGutters = /*@__PURE__*/state_dist/* Facet.define */.r$.define({
    combine: values => values.some(x => x)
});
/**
The gutter-drawing plugin is automatically enabled when you add a
gutter, but you can use this function to explicitly configure it.

Unless `fixed` is explicitly set to `false`, the gutters are
fixed, meaning they don't scroll along with the content
horizontally (except on Internet Explorer, which doesn't support
CSS [`position:
sticky`](https://developer.mozilla.org/en-US/docs/Web/CSS/position#sticky)).
*/
function gutters(config) {
    let result = [
        gutterView,
    ];
    if (config && config.fixed === false)
        result.push(unfixGutters.of(true));
    return result;
}
const gutterView = /*@__PURE__*/ViewPlugin.fromClass(class {
    constructor(view) {
        this.view = view;
        this.prevViewport = view.viewport;
        this.dom = document.createElement("div");
        this.dom.className = "cm-gutters";
        this.dom.setAttribute("aria-hidden", "true");
        this.dom.style.minHeight = this.view.contentHeight + "px";
        this.gutters = view.state.facet(activeGutters).map(conf => new SingleGutterView(view, conf));
        for (let gutter of this.gutters)
            this.dom.appendChild(gutter.dom);
        this.fixed = !view.state.facet(unfixGutters);
        if (this.fixed) {
            // FIXME IE11 fallback, which doesn't support position: sticky,
            // by using position: relative + event handlers that realign the
            // gutter (or just force fixed=false on IE11?)
            this.dom.style.position = "sticky";
        }
        this.syncGutters(false);
        view.scrollDOM.insertBefore(this.dom, view.contentDOM);
    }
    update(update) {
        if (this.updateGutters(update)) {
            // Detach during sync when the viewport changed significantly
            // (such as during scrolling), since for large updates that is
            // faster.
            let vpA = this.prevViewport, vpB = update.view.viewport;
            let vpOverlap = Math.min(vpA.to, vpB.to) - Math.max(vpA.from, vpB.from);
            this.syncGutters(vpOverlap < (vpB.to - vpB.from) * 0.8);
        }
        if (update.geometryChanged)
            this.dom.style.minHeight = this.view.contentHeight + "px";
        if (this.view.state.facet(unfixGutters) != !this.fixed) {
            this.fixed = !this.fixed;
            this.dom.style.position = this.fixed ? "sticky" : "";
        }
        this.prevViewport = update.view.viewport;
    }
    syncGutters(detach) {
        let after = this.dom.nextSibling;
        if (detach)
            this.dom.remove();
        let lineClasses = state_dist/* RangeSet.iter */.Xs.iter(this.view.state.facet(gutterLineClass), this.view.viewport.from);
        let classSet = [];
        let contexts = this.gutters.map(gutter => new UpdateContext(gutter, this.view.viewport, -this.view.documentPadding.top));
        for (let line of this.view.viewportLineBlocks) {
            let text;
            if (Array.isArray(line.type)) {
                for (let b of line.type)
                    if (b.type == BlockType.Text) {
                        text = b;
                        break;
                    }
            }
            else {
                text = line.type == BlockType.Text ? line : undefined;
            }
            if (!text)
                continue;
            if (classSet.length)
                classSet = [];
            advanceCursor(lineClasses, classSet, line.from);
            for (let cx of contexts)
                cx.line(this.view, text, classSet);
        }
        for (let cx of contexts)
            cx.finish();
        if (detach)
            this.view.scrollDOM.insertBefore(this.dom, after);
    }
    updateGutters(update) {
        let prev = update.startState.facet(activeGutters), cur = update.state.facet(activeGutters);
        let change = update.docChanged || update.heightChanged || update.viewportChanged ||
            !state_dist/* RangeSet.eq */.Xs.eq(update.startState.facet(gutterLineClass), update.state.facet(gutterLineClass), update.view.viewport.from, update.view.viewport.to);
        if (prev == cur) {
            for (let gutter of this.gutters)
                if (gutter.update(update))
                    change = true;
        }
        else {
            change = true;
            let gutters = [];
            for (let conf of cur) {
                let known = prev.indexOf(conf);
                if (known < 0) {
                    gutters.push(new SingleGutterView(this.view, conf));
                }
                else {
                    this.gutters[known].update(update);
                    gutters.push(this.gutters[known]);
                }
            }
            for (let g of this.gutters) {
                g.dom.remove();
                if (gutters.indexOf(g) < 0)
                    g.destroy();
            }
            for (let g of gutters)
                this.dom.appendChild(g.dom);
            this.gutters = gutters;
        }
        return change;
    }
    destroy() {
        for (let view of this.gutters)
            view.destroy();
        this.dom.remove();
    }
}, {
    provide: plugin => EditorView.scrollMargins.of(view => {
        let value = view.plugin(plugin);
        if (!value || value.gutters.length == 0 || !value.fixed)
            return null;
        return view.textDirection == Direction.LTR ? { left: value.dom.offsetWidth } : { right: value.dom.offsetWidth };
    })
});
function asArray(val) { return (Array.isArray(val) ? val : [val]); }
function advanceCursor(cursor, collect, pos) {
    while (cursor.value && cursor.from <= pos) {
        if (cursor.from == pos)
            collect.push(cursor.value);
        cursor.next();
    }
}
class UpdateContext {
    constructor(gutter, viewport, height) {
        this.gutter = gutter;
        this.height = height;
        this.localMarkers = [];
        this.i = 0;
        this.cursor = state_dist/* RangeSet.iter */.Xs.iter(gutter.markers, viewport.from);
    }
    line(view, line, extraMarkers) {
        if (this.localMarkers.length)
            this.localMarkers = [];
        advanceCursor(this.cursor, this.localMarkers, line.from);
        let localMarkers = extraMarkers.length ? this.localMarkers.concat(extraMarkers) : this.localMarkers;
        let forLine = this.gutter.config.lineMarker(view, line, localMarkers);
        if (forLine)
            localMarkers.unshift(forLine);
        let gutter = this.gutter;
        if (localMarkers.length == 0 && !gutter.config.renderEmptyElements)
            return;
        let above = line.top - this.height;
        if (this.i == gutter.elements.length) {
            let newElt = new GutterElement(view, line.height, above, localMarkers);
            gutter.elements.push(newElt);
            gutter.dom.appendChild(newElt.dom);
        }
        else {
            gutter.elements[this.i].update(view, line.height, above, localMarkers);
        }
        this.height = line.bottom;
        this.i++;
    }
    finish() {
        let gutter = this.gutter;
        while (gutter.elements.length > this.i) {
            let last = gutter.elements.pop();
            gutter.dom.removeChild(last.dom);
            last.destroy();
        }
    }
}
class SingleGutterView {
    constructor(view, config) {
        this.view = view;
        this.config = config;
        this.elements = [];
        this.spacer = null;
        this.dom = document.createElement("div");
        this.dom.className = "cm-gutter" + (this.config.class ? " " + this.config.class : "");
        for (let prop in config.domEventHandlers) {
            this.dom.addEventListener(prop, (event) => {
                let line = view.lineBlockAtHeight(event.clientY - view.documentTop);
                if (config.domEventHandlers[prop](view, line, event))
                    event.preventDefault();
            });
        }
        this.markers = asArray(config.markers(view));
        if (config.initialSpacer) {
            this.spacer = new GutterElement(view, 0, 0, [config.initialSpacer(view)]);
            this.dom.appendChild(this.spacer.dom);
            this.spacer.dom.style.cssText += "visibility: hidden; pointer-events: none";
        }
    }
    update(update) {
        let prevMarkers = this.markers;
        this.markers = asArray(this.config.markers(update.view));
        if (this.spacer && this.config.updateSpacer) {
            let updated = this.config.updateSpacer(this.spacer.markers[0], update);
            if (updated != this.spacer.markers[0])
                this.spacer.update(update.view, 0, 0, [updated]);
        }
        let vp = update.view.viewport;
        return !state_dist/* RangeSet.eq */.Xs.eq(this.markers, prevMarkers, vp.from, vp.to) ||
            (this.config.lineMarkerChange ? this.config.lineMarkerChange(update) : false);
    }
    destroy() {
        for (let elt of this.elements)
            elt.destroy();
    }
}
class GutterElement {
    constructor(view, height, above, markers) {
        this.height = -1;
        this.above = 0;
        this.markers = [];
        this.dom = document.createElement("div");
        this.dom.className = "cm-gutterElement";
        this.update(view, height, above, markers);
    }
    update(view, height, above, markers) {
        if (this.height != height)
            this.dom.style.height = (this.height = height) + "px";
        if (this.above != above)
            this.dom.style.marginTop = (this.above = above) ? above + "px" : "";
        if (!sameMarkers(this.markers, markers))
            this.setMarkers(view, markers);
    }
    setMarkers(view, markers) {
        let cls = "cm-gutterElement", domPos = this.dom.firstChild;
        for (let iNew = 0, iOld = 0;;) {
            let skipTo = iOld, marker = iNew < markers.length ? markers[iNew++] : null, matched = false;
            if (marker) {
                let c = marker.elementClass;
                if (c)
                    cls += " " + c;
                for (let i = iOld; i < this.markers.length; i++)
                    if (this.markers[i].compare(marker)) {
                        skipTo = i;
                        matched = true;
                        break;
                    }
            }
            else {
                skipTo = this.markers.length;
            }
            while (iOld < skipTo) {
                let next = this.markers[iOld++];
                if (next.toDOM) {
                    next.destroy(domPos);
                    let after = domPos.nextSibling;
                    domPos.remove();
                    domPos = after;
                }
            }
            if (!marker)
                break;
            if (marker.toDOM) {
                if (matched)
                    domPos = domPos.nextSibling;
                else
                    this.dom.insertBefore(marker.toDOM(view), domPos);
            }
            if (matched)
                iOld++;
        }
        this.dom.className = cls;
        this.markers = markers;
    }
    destroy() {
        this.setMarkers(null, []); // First argument not used unless creating markers
    }
}
function sameMarkers(a, b) {
    if (a.length != b.length)
        return false;
    for (let i = 0; i < a.length; i++)
        if (!a[i].compare(b[i]))
            return false;
    return true;
}
/**
Facet used to provide markers to the line number gutter.
*/
const lineNumberMarkers = /*@__PURE__*/state_dist/* Facet.define */.r$.define();
const lineNumberConfig = /*@__PURE__*/state_dist/* Facet.define */.r$.define({
    combine(values) {
        return (0,state_dist/* combineConfig */.BO)(values, { formatNumber: String, domEventHandlers: {} }, {
            domEventHandlers(a, b) {
                let result = Object.assign({}, a);
                for (let event in b) {
                    let exists = result[event], add = b[event];
                    result[event] = exists ? (view, line, event) => exists(view, line, event) || add(view, line, event) : add;
                }
                return result;
            }
        });
    }
});
class NumberMarker extends GutterMarker {
    constructor(number) {
        super();
        this.number = number;
    }
    eq(other) { return this.number == other.number; }
    toDOM() { return document.createTextNode(this.number); }
}
function formatNumber(view, number) {
    return view.state.facet(lineNumberConfig).formatNumber(number, view.state);
}
const lineNumberGutter = /*@__PURE__*/activeGutters.compute([lineNumberConfig], state => ({
    class: "cm-lineNumbers",
    renderEmptyElements: false,
    markers(view) { return view.state.facet(lineNumberMarkers); },
    lineMarker(view, line, others) {
        if (others.some(m => m.toDOM))
            return null;
        return new NumberMarker(formatNumber(view, view.state.doc.lineAt(line.from).number));
    },
    lineMarkerChange: update => update.startState.facet(lineNumberConfig) != update.state.facet(lineNumberConfig),
    initialSpacer(view) {
        return new NumberMarker(formatNumber(view, maxLineNumber(view.state.doc.lines)));
    },
    updateSpacer(spacer, update) {
        let max = formatNumber(update.view, maxLineNumber(update.view.state.doc.lines));
        return max == spacer.number ? spacer : new NumberMarker(max);
    },
    domEventHandlers: state.facet(lineNumberConfig).domEventHandlers
}));
/**
Create a line number gutter extension.
*/
function lineNumbers(config = {}) {
    return [
        lineNumberConfig.of(config),
        gutters(),
        lineNumberGutter
    ];
}
function maxLineNumber(lines) {
    let last = 9;
    while (last < lines)
        last = last * 10 + 9;
    return last;
}
const activeLineGutterMarker = /*@__PURE__*/new class extends GutterMarker {
    constructor() {
        super(...arguments);
        this.elementClass = "cm-activeLineGutter";
    }
};
const activeLineGutterHighlighter = /*@__PURE__*/(/* unused pure expression or super */ null && (gutterLineClass.compute(["selection"], state => {
    let marks = [], last = -1;
    for (let range of state.selection.ranges) {
        let linePos = state.doc.lineAt(range.head).from;
        if (linePos > last) {
            last = linePos;
            marks.push(activeLineGutterMarker.range(linePos));
        }
    }
    return RangeSet.of(marks);
})));
/**
Returns an extension that adds a `cm-activeLineGutter` class to
all gutter elements on the [active
line](https://codemirror.net/6/docs/ref/#view.highlightActiveLine).
*/
function highlightActiveLineGutter() {
    return activeLineGutterHighlighter;
}

/**
@internal
*/
const __test = { HeightMap, HeightOracle, MeasuredHeights, QueryType, ChangedRange, computeOrder, moveVisually };




/***/ }),

/***/ 7680:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "JB": () => (/* binding */ rectToClientRect),
/* harmony export */   "RR": () => (/* binding */ flip),
/* harmony export */   "cv": () => (/* binding */ offset),
/* harmony export */   "dp": () => (/* binding */ size),
/* harmony export */   "oo": () => (/* binding */ computePosition),
/* harmony export */   "uY": () => (/* binding */ shift),
/* harmony export */   "x7": () => (/* binding */ arrow)
/* harmony export */ });
/* unused harmony exports autoPlacement, detectOverflow, hide, inline, limitShift */
function getAlignment(placement) {
  return placement.split('-')[1];
}

function getLengthFromAxis(axis) {
  return axis === 'y' ? 'height' : 'width';
}

function getSide(placement) {
  return placement.split('-')[0];
}

function getMainAxisFromPlacement(placement) {
  return ['top', 'bottom'].includes(getSide(placement)) ? 'x' : 'y';
}

function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const mainAxis = getMainAxisFromPlacement(placement);
  const length = getLengthFromAxis(mainAxis);
  const commonAlign = reference[length] / 2 - floating[length] / 2;
  const side = getSide(placement);
  const isVertical = mainAxis === 'x';
  let coords;
  switch (side) {
    case 'top':
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case 'bottom':
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case 'right':
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case 'left':
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case 'start':
      coords[mainAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case 'end':
      coords[mainAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}

/**
 * Computes the `x` and `y` coordinates that will place the floating element
 * next to a reference element when it is given a certain positioning strategy.
 *
 * This export does not have any `platform` interface logic. You will need to
 * write one for the platform you are using Floating UI with.
 */
const computePosition = async (reference, floating, config) => {
  const {
    placement = 'bottom',
    strategy = 'absolute',
    middleware = [],
    platform
  } = config;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));
  if (false) {}
  let rects = await platform.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x,
    y
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i = 0; i < validMiddleware.length; i++) {
    const {
      name,
      fn
    } = validMiddleware[i];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn({
      x,
      y,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform,
      elements: {
        reference,
        floating
      }
    });
    x = nextX != null ? nextX : x;
    y = nextY != null ? nextY : y;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data
      }
    };
    if (false) {}
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === 'object') {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x,
          y
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i = -1;
      continue;
    }
  }
  return {
    x,
    y,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};

function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}

function getSideObjectFromPadding(padding) {
  return typeof padding !== 'number' ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}

function rectToClientRect(rect) {
  return {
    ...rect,
    top: rect.y,
    left: rect.x,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  };
}

/**
 * Resolves with an object of overflow side offsets that determine how much the
 * element is overflowing a given clipping boundary.
 * - positive = overflowing the boundary by that number of pixels
 * - negative = how many pixels left before it will overflow
 * - 0 = lies flush with the boundary
 * @see https://floating-ui.com/docs/detectOverflow
 */
async function detectOverflow(middlewareArguments, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x,
    y,
    platform,
    rects,
    elements,
    strategy
  } = middlewareArguments;
  const {
    boundary = 'clippingAncestors',
    rootBoundary = 'viewport',
    elementContext = 'floating',
    altBoundary = false,
    padding = 0
  } = options;
  const paddingObject = getSideObjectFromPadding(padding);
  const altContext = elementContext === 'floating' ? 'reference' : 'floating';
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform.getClippingRect({
    element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || (await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating))),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === 'floating' ? {
    ...rects.floating,
    x,
    y
  } : rects.reference;
  const offsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating));
  const offsetScale = (await (platform.isElement == null ? void 0 : platform.isElement(offsetParent))) ? (await (platform.getScale == null ? void 0 : platform.getScale(offsetParent))) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({
    rect,
    offsetParent,
    strategy
  }) : rect);
  if (false) {}
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}

const min = Math.min;
const max = Math.max;

function within(min$1, value, max$1) {
  return max(min$1, min(value, max$1));
}

/**
 * Positions an inner element of the floating element such that it is centered
 * to the reference element.
 * @see https://floating-ui.com/docs/arrow
 */
const arrow = options => ({
  name: 'arrow',
  options,
  async fn(middlewareArguments) {
    // Since `element` is required, we don't Partial<> the type.
    const {
      element,
      padding = 0
    } = options || {};
    const {
      x,
      y,
      placement,
      rects,
      platform
    } = middlewareArguments;
    if (element == null) {
      if (false) {}
      return {};
    }
    const paddingObject = getSideObjectFromPadding(padding);
    const coords = {
      x,
      y
    };
    const axis = getMainAxisFromPlacement(placement);
    const length = getLengthFromAxis(axis);
    const arrowDimensions = await platform.getDimensions(element);
    const minProp = axis === 'y' ? 'top' : 'left';
    const maxProp = axis === 'y' ? 'bottom' : 'right';
    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element));
    let clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
    if (clientSize === 0) {
      clientSize = rects.floating[length];
    }
    const centerToReference = endDiff / 2 - startDiff / 2;

    // Make sure the arrow doesn't overflow the floating element if the center
    // point is outside the floating element's bounds.
    const min = paddingObject[minProp];
    const max = clientSize - arrowDimensions[length] - paddingObject[maxProp];
    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
    const offset = within(min, center, max);

    // If the reference is small enough that the arrow's padding causes it to
    // to point to nothing for an aligned placement, adjust the offset of the
    // floating element itself. This stops `shift()` from taking action, but can
    // be worked around by calling it again after the `arrow()` if desired.
    const shouldAddOffset = getAlignment(placement) != null && center != offset && rects.reference[length] / 2 - (center < min ? paddingObject[minProp] : paddingObject[maxProp]) - arrowDimensions[length] / 2 < 0;
    const alignmentOffset = shouldAddOffset ? center < min ? min - center : max - center : 0;
    return {
      [axis]: coords[axis] - alignmentOffset,
      data: {
        [axis]: offset,
        centerOffset: center - offset
      }
    };
  }
});

const sides = (/* unused pure expression or super */ null && (['top', 'right', 'bottom', 'left']));
const allPlacements = /*#__PURE__*/(/* unused pure expression or super */ null && (sides.reduce((acc, side) => acc.concat(side, side + "-start", side + "-end"), [])));

const oppositeSideMap = {
  left: 'right',
  right: 'left',
  bottom: 'top',
  top: 'bottom'
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, side => oppositeSideMap[side]);
}

function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const mainAxis = getMainAxisFromPlacement(placement);
  const length = getLengthFromAxis(mainAxis);
  let mainAlignmentSide = mainAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return {
    main: mainAlignmentSide,
    cross: getOppositePlacement(mainAlignmentSide)
  };
}

const oppositeAlignmentMap = {
  start: 'end',
  end: 'start'
};
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, alignment => oppositeAlignmentMap[alignment]);
}

function getPlacementList(alignment, autoAlignment, allowedPlacements) {
  const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter(placement => getAlignment(placement) === alignment), ...allowedPlacements.filter(placement => getAlignment(placement) !== alignment)] : allowedPlacements.filter(placement => getSide(placement) === placement);
  return allowedPlacementsSortedByAlignment.filter(placement => {
    if (alignment) {
      return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);
    }
    return true;
  });
}
/**
 * Automatically chooses the `placement` which has the most space available.
 * @see https://floating-ui.com/docs/autoPlacement
 */
const autoPlacement = function (options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: 'autoPlacement',
    options,
    async fn(middlewareArguments) {
      var _middlewareData$autoP, _middlewareData$autoP2, _placementsSortedByLe;
      const {
        rects,
        middlewareData,
        placement,
        platform,
        elements
      } = middlewareArguments;
      const {
        alignment,
        allowedPlacements = allPlacements,
        autoAlignment = true,
        ...detectOverflowOptions
      } = options;
      const placements = alignment !== undefined || allowedPlacements === allPlacements ? getPlacementList(alignment || null, autoAlignment, allowedPlacements) : allowedPlacements;
      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);
      const currentIndex = ((_middlewareData$autoP = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP.index) || 0;
      const currentPlacement = placements[currentIndex];
      if (currentPlacement == null) {
        return {};
      }
      const {
        main,
        cross
      } = getAlignmentSides(currentPlacement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));

      // Make `computeCoords` start from the right place.
      if (placement !== currentPlacement) {
        return {
          reset: {
            placement: placements[0]
          }
        };
      }
      const currentOverflows = [overflow[getSide(currentPlacement)], overflow[main], overflow[cross]];
      const allOverflows = [...(((_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.overflows) || []), {
        placement: currentPlacement,
        overflows: currentOverflows
      }];
      const nextPlacement = placements[currentIndex + 1];

      // There are more placements to check.
      if (nextPlacement) {
        return {
          data: {
            index: currentIndex + 1,
            overflows: allOverflows
          },
          reset: {
            placement: nextPlacement
          }
        };
      }
      const placementsSortedByLeastOverflow = allOverflows.slice().sort((a, b) => a.overflows[0] - b.overflows[0]);
      const placementThatFitsOnAllSides = (_placementsSortedByLe = placementsSortedByLeastOverflow.find(_ref => {
        let {
          overflows
        } = _ref;
        return overflows.every(overflow => overflow <= 0);
      })) == null ? void 0 : _placementsSortedByLe.placement;
      const resetPlacement = placementThatFitsOnAllSides || placementsSortedByLeastOverflow[0].placement;
      if (resetPlacement !== placement) {
        return {
          data: {
            index: currentIndex + 1,
            overflows: allOverflows
          },
          reset: {
            placement: resetPlacement
          }
        };
      }
      return {};
    }
  };
};

function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}

function getSideList(side, isStart, rtl) {
  const lr = ['left', 'right'];
  const rl = ['right', 'left'];
  const tb = ['top', 'bottom'];
  const bt = ['bottom', 'top'];
  switch (side) {
    case 'top':
    case 'bottom':
      if (rtl) return isStart ? rl : lr;
      return isStart ? lr : rl;
    case 'left':
    case 'right':
      return isStart ? tb : bt;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === 'start', rtl);
  if (alignment) {
    list = list.map(side => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}

/**
 * Changes the placement of the floating element to one that will fit if the
 * initially specified `placement` does not.
 * @see https://floating-ui.com/docs/flip
 */
const flip = function (options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: 'flip',
    options,
    async fn(middlewareArguments) {
      var _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform,
        elements
      } = middlewareArguments;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = 'bestFit',
        fallbackAxisSideDirection = 'none',
        flipAlignment = true,
        ...detectOverflowOptions
      } = options;
      const side = getSide(placement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      if (!specifiedFallbackPlacements && fallbackAxisSideDirection !== 'none') {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const {
          main,
          cross
        } = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[main], overflow[cross]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];

      // One or more sides is overflowing.
      if (!overflows.every(side => side <= 0)) {
        var _middlewareData$flip2;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements[nextIndex];
        if (nextPlacement) {
          // Try next placement and re-run the lifecycle.
          return {
            data: {
              index: nextIndex,
              overflows: overflowsData
            },
            reset: {
              placement: nextPlacement
            }
          };
        }
        let resetPlacement = 'bottom';
        switch (fallbackStrategy) {
          case 'bestFit':
            {
              var _overflowsData$map$so;
              const placement = (_overflowsData$map$so = overflowsData.map(d => [d, d.overflows.filter(overflow => overflow > 0).reduce((acc, overflow) => acc + overflow, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$map$so[0].placement;
              if (placement) {
                resetPlacement = placement;
              }
              break;
            }
          case 'initialPlacement':
            resetPlacement = initialPlacement;
            break;
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};

function getSideOffsets(overflow, rect) {
  return {
    top: overflow.top - rect.height,
    right: overflow.right - rect.width,
    bottom: overflow.bottom - rect.height,
    left: overflow.left - rect.width
  };
}
function isAnySideFullyClipped(overflow) {
  return sides.some(side => overflow[side] >= 0);
}
/**
 * Provides data to hide the floating element in applicable situations, such as
 * when it is not in the same clipping context as the reference element.
 * @see https://floating-ui.com/docs/hide
 */
const hide = function (options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: 'hide',
    options,
    async fn(middlewareArguments) {
      const {
        strategy = 'referenceHidden',
        ...detectOverflowOptions
      } = options;
      const {
        rects
      } = middlewareArguments;
      switch (strategy) {
        case 'referenceHidden':
          {
            const overflow = await detectOverflow(middlewareArguments, {
              ...detectOverflowOptions,
              elementContext: 'reference'
            });
            const offsets = getSideOffsets(overflow, rects.reference);
            return {
              data: {
                referenceHiddenOffsets: offsets,
                referenceHidden: isAnySideFullyClipped(offsets)
              }
            };
          }
        case 'escaped':
          {
            const overflow = await detectOverflow(middlewareArguments, {
              ...detectOverflowOptions,
              altBoundary: true
            });
            const offsets = getSideOffsets(overflow, rects.floating);
            return {
              data: {
                escapedOffsets: offsets,
                escaped: isAnySideFullyClipped(offsets)
              }
            };
          }
        default:
          {
            return {};
          }
      }
    }
  };
};

/**
 * Provides improved positioning for inline reference elements that can span
 * over multiple lines, such as hyperlinks or range selections.
 * @see https://floating-ui.com/docs/inline
 */
const inline = function (options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: 'inline',
    options,
    async fn(middlewareArguments) {
      const {
        placement,
        elements,
        rects,
        platform,
        strategy
      } = middlewareArguments;
      // A MouseEvent's client{X,Y} coords can be up to 2 pixels off a
      // ClientRect's bounds, despite the event listener being triggered. A
      // padding of 2 seems to handle this issue.
      const {
        padding = 2,
        x,
        y
      } = options;
      const fallback = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({
        rect: rects.reference,
        offsetParent: await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating)),
        strategy
      }) : rects.reference);
      const clientRects = (await (platform.getClientRects == null ? void 0 : platform.getClientRects(elements.reference))) || [];
      const paddingObject = getSideObjectFromPadding(padding);
      function getBoundingClientRect() {
        // There are two rects and they are disjoined.
        if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x != null && y != null) {
          // Find the first rect in which the point is fully inside.
          return clientRects.find(rect => x > rect.left - paddingObject.left && x < rect.right + paddingObject.right && y > rect.top - paddingObject.top && y < rect.bottom + paddingObject.bottom) || fallback;
        }

        // There are 2 or more connected rects.
        if (clientRects.length >= 2) {
          if (getMainAxisFromPlacement(placement) === 'x') {
            const firstRect = clientRects[0];
            const lastRect = clientRects[clientRects.length - 1];
            const isTop = getSide(placement) === 'top';
            const top = firstRect.top;
            const bottom = lastRect.bottom;
            const left = isTop ? firstRect.left : lastRect.left;
            const right = isTop ? firstRect.right : lastRect.right;
            const width = right - left;
            const height = bottom - top;
            return {
              top,
              bottom,
              left,
              right,
              width,
              height,
              x: left,
              y: top
            };
          }
          const isLeftSide = getSide(placement) === 'left';
          const maxRight = max(...clientRects.map(rect => rect.right));
          const minLeft = min(...clientRects.map(rect => rect.left));
          const measureRects = clientRects.filter(rect => isLeftSide ? rect.left === minLeft : rect.right === maxRight);
          const top = measureRects[0].top;
          const bottom = measureRects[measureRects.length - 1].bottom;
          const left = minLeft;
          const right = maxRight;
          const width = right - left;
          const height = bottom - top;
          return {
            top,
            bottom,
            left,
            right,
            width,
            height,
            x: left,
            y: top
          };
        }
        return fallback;
      }
      const resetRects = await platform.getElementRects({
        reference: {
          getBoundingClientRect
        },
        floating: elements.floating,
        strategy
      });
      if (rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height) {
        return {
          reset: {
            rects: resetRects
          }
        };
      }
      return {};
    }
  };
};

async function convertValueToCoords(middlewareArguments, value) {
  const {
    placement,
    platform,
    elements
  } = middlewareArguments;
  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getMainAxisFromPlacement(placement) === 'x';
  const mainAxisMulti = ['left', 'top'].includes(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = typeof value === 'function' ? value(middlewareArguments) : value;

  // eslint-disable-next-line prefer-const
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === 'number' ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: 0,
    crossAxis: 0,
    alignmentAxis: null,
    ...rawValue
  };
  if (alignment && typeof alignmentAxis === 'number') {
    crossAxis = alignment === 'end' ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}

/**
 * Displaces the floating element from its reference element.
 * @see https://floating-ui.com/docs/offset
 */
const offset = function (value) {
  if (value === void 0) {
    value = 0;
  }
  return {
    name: 'offset',
    options: value,
    async fn(middlewareArguments) {
      const {
        x,
        y
      } = middlewareArguments;
      const diffCoords = await convertValueToCoords(middlewareArguments, value);
      return {
        x: x + diffCoords.x,
        y: y + diffCoords.y,
        data: diffCoords
      };
    }
  };
};

function getCrossAxis(axis) {
  return axis === 'x' ? 'y' : 'x';
}

/**
 * Shifts the floating element in order to keep it in view when it will overflow
 * a clipping boundary.
 * @see https://floating-ui.com/docs/shift
 */
const shift = function (options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: 'shift',
    options,
    async fn(middlewareArguments) {
      const {
        x,
        y,
        placement
      } = middlewareArguments;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: _ref => {
            let {
              x,
              y
            } = _ref;
            return {
              x,
              y
            };
          }
        },
        ...detectOverflowOptions
      } = options;
      const coords = {
        x,
        y
      };
      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);
      const mainAxis = getMainAxisFromPlacement(getSide(placement));
      const crossAxis = getCrossAxis(mainAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === 'y' ? 'top' : 'left';
        const maxSide = mainAxis === 'y' ? 'bottom' : 'right';
        const min = mainAxisCoord + overflow[minSide];
        const max = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = within(min, mainAxisCoord, max);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === 'y' ? 'top' : 'left';
        const maxSide = crossAxis === 'y' ? 'bottom' : 'right';
        const min = crossAxisCoord + overflow[minSide];
        const max = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = within(min, crossAxisCoord, max);
      }
      const limitedCoords = limiter.fn({
        ...middlewareArguments,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x,
          y: limitedCoords.y - y
        }
      };
    }
  };
};
/**
 * Built-in `limiter` that will stop `shift()` at a certain point.
 */
const limitShift = function (options) {
  if (options === void 0) {
    options = {};
  }
  return {
    options,
    fn(middlewareArguments) {
      const {
        x,
        y,
        placement,
        rects,
        middlewareData
      } = middlewareArguments;
      const {
        offset = 0,
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true
      } = options;
      const coords = {
        x,
        y
      };
      const mainAxis = getMainAxisFromPlacement(placement);
      const crossAxis = getCrossAxis(mainAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      const rawOffset = typeof offset === 'function' ? offset(middlewareArguments) : offset;
      const computedOffset = typeof rawOffset === 'number' ? {
        mainAxis: rawOffset,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...rawOffset
      };
      if (checkMainAxis) {
        const len = mainAxis === 'y' ? 'height' : 'width';
        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;
        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;
        if (mainAxisCoord < limitMin) {
          mainAxisCoord = limitMin;
        } else if (mainAxisCoord > limitMax) {
          mainAxisCoord = limitMax;
        }
      }
      if (checkCrossAxis) {
        var _middlewareData$offse, _middlewareData$offse2;
        const len = mainAxis === 'y' ? 'width' : 'height';
        const isOriginSide = ['top', 'left'].includes(getSide(placement));
        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);
        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);
        if (crossAxisCoord < limitMin) {
          crossAxisCoord = limitMin;
        } else if (crossAxisCoord > limitMax) {
          crossAxisCoord = limitMax;
        }
      }
      return {
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      };
    }
  };
};

/**
 * Provides data to change the size of the floating element. For instance,
 * prevent it from overflowing its clipping boundary or match the width of the
 * reference element.
 * @see https://floating-ui.com/docs/size
 */
const size = function (options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: 'size',
    options,
    async fn(middlewareArguments) {
      const {
        placement,
        rects,
        platform,
        elements
      } = middlewareArguments;
      const {
        apply = () => {},
        ...detectOverflowOptions
      } = options;
      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);
      const side = getSide(placement);
      const alignment = getAlignment(placement);
      let heightSide;
      let widthSide;
      if (side === 'top' || side === 'bottom') {
        heightSide = side;
        widthSide = alignment === ((await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating))) ? 'start' : 'end') ? 'left' : 'right';
      } else {
        widthSide = side;
        heightSide = alignment === 'end' ? 'top' : 'bottom';
      }
      const xMin = max(overflow.left, 0);
      const xMax = max(overflow.right, 0);
      const yMin = max(overflow.top, 0);
      const yMax = max(overflow.bottom, 0);
      const dimensions = {
        availableHeight: rects.floating.height - (['left', 'right'].includes(placement) ? 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom)) : overflow[heightSide]),
        availableWidth: rects.floating.width - (['top', 'bottom'].includes(placement) ? 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right)) : overflow[widthSide])
      };
      await apply({
        ...middlewareArguments,
        ...dimensions
      });
      const nextDimensions = await platform.getDimensions(elements.floating);
      if (rects.floating.width !== nextDimensions.width || rects.floating.height !== nextDimensions.height) {
        return {
          reset: {
            rects: true
          }
        };
      }
      return {};
    }
  };
};




/***/ }),

/***/ 7555:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Kx": () => (/* binding */ getOverflowAncestors),
/* harmony export */   "Me": () => (/* binding */ autoUpdate),
/* harmony export */   "oo": () => (/* binding */ computePosition)
/* harmony export */ });
/* unused harmony export platform */
/* harmony import */ var _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7680);



function getWindow(node) {
  var _node$ownerDocument;
  return ((_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}

function getComputedStyle$1(element) {
  return getWindow(element).getComputedStyle(element);
}

function getNodeName(node) {
  return isNode(node) ? (node.nodeName || '').toLowerCase() : '';
}

let uaString;
function getUAString() {
  if (uaString) {
    return uaString;
  }
  const uaData = navigator.userAgentData;
  if (uaData && Array.isArray(uaData.brands)) {
    uaString = uaData.brands.map(item => item.brand + "/" + item.version).join(' ');
    return uaString;
  }
  return navigator.userAgent;
}

function isHTMLElement(value) {
  return value instanceof getWindow(value).HTMLElement;
}
function isElement(value) {
  return value instanceof getWindow(value).Element;
}
function isNode(value) {
  return value instanceof getWindow(value).Node;
}
function isShadowRoot(node) {
  // Browsers without `ShadowRoot` support
  if (typeof ShadowRoot === 'undefined') {
    return false;
  }
  const OwnElement = getWindow(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle$1(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !['inline', 'contents'].includes(display);
}
function isTableElement(element) {
  return ['table', 'td', 'th'].includes(getNodeName(element));
}
function isContainingBlock(element) {
  // TODO: Try and use feature detection here instead
  const isFirefox = /firefox/i.test(getUAString());
  const css = getComputedStyle$1(element);
  const backdropFilter = css.backdropFilter || css.WebkitBackdropFilter;

  // This is non-exhaustive but covers the most common CSS properties that
  // create a containing block.
  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block
  return css.transform !== 'none' || css.perspective !== 'none' || (backdropFilter ? backdropFilter !== 'none' : false) || isFirefox && css.willChange === 'filter' || isFirefox && (css.filter ? css.filter !== 'none' : false) || ['transform', 'perspective'].some(value => css.willChange.includes(value)) || ['paint', 'layout', 'strict', 'content'].some(
  // TS 4.1 compat
  value => {
    const contain = css.contain;
    return contain != null ? contain.includes(value) : false;
  });
}
function isLayoutViewport() {
  // Not Safari
  return !/^((?!chrome|android).)*safari/i.test(getUAString());
  // Feature detection for this fails in various ways
  //  Always-visible scrollbar or not
  //  Width of <html>, etc.
  // const vV = win.visualViewport;
  // return vV ? Math.abs(win.innerWidth / vV.scale - vV.width) < 0.5 : true;
}

function isLastTraversableNode(node) {
  return ['html', 'body', '#document'].includes(getNodeName(node));
}

const min = Math.min;
const max = Math.max;
const round = Math.round;

function getCssDimensions(element) {
  const css = getComputedStyle$1(element);
  let width = parseFloat(css.width);
  let height = parseFloat(css.height);
  const offsetWidth = element.offsetWidth;
  const offsetHeight = element.offsetHeight;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    fallback: shouldFallback
  };
}

function unwrapElement(element) {
  return !isElement(element) ? element.contextElement : element;
}

const FALLBACK_SCALE = {
  x: 1,
  y: 1
};
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement(domElement)) {
    return FALLBACK_SCALE;
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    fallback
  } = getCssDimensions(domElement);
  let x = (fallback ? round(rect.width) : rect.width) / width;
  let y = (fallback ? round(rect.height) : rect.height) / height;

  // 0, NaN, or Infinity should always fallback to 1.

  if (!x || !Number.isFinite(x)) {
    x = 1;
  }
  if (!y || !Number.isFinite(y)) {
    y = 1;
  }
  return {
    x,
    y
  };
}

function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  var _win$visualViewport, _win$visualViewport2;
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale = FALLBACK_SCALE;
  if (includeScale) {
    if (offsetParent) {
      if (isElement(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  const win = domElement ? getWindow(domElement) : window;
  const addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
  let x = (clientRect.left + (addVisualOffsets ? ((_win$visualViewport = win.visualViewport) == null ? void 0 : _win$visualViewport.offsetLeft) || 0 : 0)) / scale.x;
  let y = (clientRect.top + (addVisualOffsets ? ((_win$visualViewport2 = win.visualViewport) == null ? void 0 : _win$visualViewport2.offsetTop) || 0 : 0)) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow(domElement);
    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentIFrame = win.frameElement;
    while (currentIFrame && offsetParent && offsetWin !== win) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css = getComputedStyle(currentIFrame);
      iframeRect.x += (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
      iframeRect.y += (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x *= iframeScale.x;
      y *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x += iframeRect.x;
      y += iframeRect.y;
      currentIFrame = getWindow(currentIFrame).frameElement;
    }
  }
  return {
    width,
    height,
    top: y,
    right: x + width,
    bottom: y + height,
    left: x,
    x,
    y
  };
}

function getDocumentElement(node) {
  return ((isNode(node) ? node.ownerDocument : node.document) || window.document).documentElement;
}

function getNodeScroll(element) {
  if (isElement(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.pageXOffset,
    scrollTop: element.pageYOffset
  };
}

function getWindowScrollBarX(element) {
  // If <html> has a CSS width greater than the viewport, then this will be
  // incorrect for RTL.
  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;
}

function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const rect = getBoundingClientRect(element, true, strategy === 'fixed', offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== 'fixed') {
    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent, true);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}

function getParentNode(node) {
  if (getNodeName(node) === 'html') {
    return node;
  }
  const result =
  // Step into the shadow DOM of the parent of a slotted node
  node.assignedSlot ||
  // DOM Element detected
  node.parentNode || (
  // ShadowRoot detected
  isShadowRoot(node) ? node.host : null) ||
  // Fallback
  getDocumentElement(node);
  return isShadowRoot(result) ? result.host : result;
}

function getTrueOffsetParent(element) {
  if (!isHTMLElement(element) || getComputedStyle$1(element).position === 'fixed') {
    return null;
  }
  return element.offsetParent;
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else {
      currentNode = getParentNode(currentNode);
    }
  }
  return null;
}

// Gets the closest ancestor positioned element. Handles some edge cases,
// such as table ancestors and cross browser bugs.
function getOffsetParent(element) {
  const window = getWindow(element);
  let offsetParent = getTrueOffsetParent(element);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle$1(offsetParent).position === 'static') {
    offsetParent = getTrueOffsetParent(offsetParent);
  }
  if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle$1(offsetParent).position === 'static' && !isContainingBlock(offsetParent))) {
    return window;
  }
  return offsetParent || getContainingBlock(element) || window;
}

function getDimensions(element) {
  return getCssDimensions(element);
}

function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  if (offsetParent === documentElement) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = {
    x: 1,
    y: 1
  };
  const offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== 'fixed') {
    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
    // This doesn't appear to need to be negated.
    // else if (documentElement) {
    //   offsets.x = getWindowScrollBarX(documentElement);
    // }
  }

  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y
  };
}

function getViewportRect(element, strategy) {
  const win = getWindow(element);
  const html = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x = 0;
  let y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const layoutViewport = isLayoutViewport();
    if (layoutViewport || !layoutViewport && strategy === 'fixed') {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x,
    y
  };
}

// Gets the entire size of the scrollable document area, even extending outside
// of the `<html>` and `<body>` rect bounds if horizontally scrollable
function getDocumentRect(element) {
  var _element$ownerDocumen;
  const html = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  const width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  const height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  let x = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y = -scroll.scrollTop;
  if (getComputedStyle$1(body || html).direction === 'rtl') {
    x += max(html.clientWidth, body ? body.clientWidth : 0) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}

function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);
  if (isLastTraversableNode(parentNode)) {
    // @ts-ignore assume body is always available
    return node.ownerDocument.body;
  }
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}

function getOverflowAncestors(node, list) {
  var _node$ownerDocument;
  if (list === void 0) {
    list = [];
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.body);
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor));
}

// Returns the inner client rect, subtracting scrollbars if present
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, true, strategy === 'fixed');
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  const scale = isHTMLElement(element) ? getScale(element) : {
    x: 1,
    y: 1
  };
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x = left * scale.x;
  const y = top * scale.y;
  return {
    top: y,
    left: x,
    right: x + width,
    bottom: y + height,
    x,
    y,
    width,
    height
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  if (clippingAncestor === 'viewport') {
    return (0,_floating_ui_core__WEBPACK_IMPORTED_MODULE_0__/* .rectToClientRect */ .JB)(getViewportRect(element, strategy));
  }
  if (isElement(clippingAncestor)) {
    return getInnerBoundingClientRect(clippingAncestor, strategy);
  }
  return (0,_floating_ui_core__WEBPACK_IMPORTED_MODULE_0__/* .rectToClientRect */ .JB)(getDocumentRect(getDocumentElement(element)));
}

// A "clipping ancestor" is an `overflow` element with the characteristic of
// clipping (or hiding) child elements. This returns all clipping ancestors
// of the given element up the tree.
function getClippingElementAncestors(element, cache) {
  const cachedResult = cache.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors(element).filter(el => isElement(el) && getNodeName(el) !== 'body');
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle$1(element).position === 'fixed';
  let currentNode = elementIsFixed ? getParentNode(element) : element;

  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block
  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle$1(currentNode);
    const containingBlock = isContainingBlock(currentNode);
    const shouldDropCurrentNode = elementIsFixed ? !containingBlock && !currentContainingBlockComputedStyle : !containingBlock && computedStyle.position === 'static' && !!currentContainingBlockComputedStyle && ['absolute', 'fixed'].includes(currentContainingBlockComputedStyle.position);
    if (shouldDropCurrentNode) {
      // Drop non-containing blocks
      result = result.filter(ancestor => ancestor !== currentNode);
    } else {
      // Record last containing block for next iteration
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache.set(element, result);
  return result;
}

// Gets the maximum area that the element is visible in due to any number of
// clipping ancestors
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === 'clippingAncestors' ? getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}

const platform = {
  getClippingRect,
  convertOffsetParentRelativeRectToViewportRelativeRect,
  isElement,
  getDimensions,
  getOffsetParent,
  getDocumentElement,
  getScale,
  async getElementRects(_ref) {
    let {
      reference,
      floating,
      strategy
    } = _ref;
    const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
    const getDimensionsFn = this.getDimensions;
    return {
      reference: getRectRelativeToOffsetParent(reference, await getOffsetParentFn(floating), strategy),
      floating: {
        x: 0,
        y: 0,
        ...(await getDimensionsFn(floating))
      }
    };
  },
  getClientRects: element => Array.from(element.getClientRects()),
  isRTL: element => getComputedStyle$1(element).direction === 'rtl'
};

/**
 * Automatically updates the position of the floating element when necessary.
 * @see https://floating-ui.com/docs/autoUpdate
 */
function autoUpdate(reference, floating, update, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll: _ancestorScroll = true,
    ancestorResize = true,
    elementResize = true,
    animationFrame = false
  } = options;
  const ancestorScroll = _ancestorScroll && !animationFrame;
  const ancestors = ancestorScroll || ancestorResize ? [...(isElement(reference) ? getOverflowAncestors(reference) : reference.contextElement ? getOverflowAncestors(reference.contextElement) : []), ...getOverflowAncestors(floating)] : [];
  ancestors.forEach(ancestor => {
    ancestorScroll && ancestor.addEventListener('scroll', update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener('resize', update);
  });
  let observer = null;
  if (elementResize) {
    let initialUpdate = true;
    observer = new ResizeObserver(() => {
      if (!initialUpdate) {
        update();
      }
      initialUpdate = false;
    });
    isElement(reference) && !animationFrame && observer.observe(reference);
    if (!isElement(reference) && reference.contextElement && !animationFrame) {
      observer.observe(reference.contextElement);
    }
    observer.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update();
  return () => {
    var _observer;
    ancestors.forEach(ancestor => {
      ancestorScroll && ancestor.removeEventListener('scroll', update);
      ancestorResize && ancestor.removeEventListener('resize', update);
    });
    (_observer = observer) == null ? void 0 : _observer.disconnect();
    observer = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}

/**
 * Computes the `x` and `y` coordinates that will place the floating element
 * next to a reference element when it is given a certain CSS positioning
 * strategy.
 */
const computePosition = (reference, floating, options) => {
  // This caches the expensive `getClippingElementAncestors` function so that
  // multiple lifecycle resets re-use the same result. It only lives for a
  // single call. If other functions become expensive, we can add them as well.
  const cache = new Map();
  const mergedOptions = {
    platform,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache
  };
  return (0,_floating_ui_core__WEBPACK_IMPORTED_MODULE_0__/* .computePosition */ .oo)(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};




/***/ }),

/***/ 8731:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Jq": () => (/* binding */ NodeType),
/* harmony export */   "Lj": () => (/* binding */ NodeSet),
/* harmony export */   "_b": () => (/* binding */ Parser),
/* harmony export */   "i9": () => (/* binding */ TreeFragment),
/* harmony export */   "md": () => (/* binding */ NodeProp),
/* harmony export */   "mp": () => (/* binding */ Tree),
/* harmony export */   "vj": () => (/* binding */ IterMode)
/* harmony export */ });
/* unused harmony exports DefaultBufferLength, MountedTree, NodeWeakMap, TreeBuffer, TreeCursor, parseMixed */
// FIXME profile adding a per-Tree TreeNode cache, validating it by
// parent pointer
/// The default maximum length of a `TreeBuffer` node.
const DefaultBufferLength = 1024;
let nextPropID = 0;
class Range {
    constructor(from, to) {
        this.from = from;
        this.to = to;
    }
}
/// Each [node type](#common.NodeType) or [individual tree](#common.Tree)
/// can have metadata associated with it in props. Instances of this
/// class represent prop names.
class NodeProp {
    /// Create a new node prop type.
    constructor(config = {}) {
        this.id = nextPropID++;
        this.perNode = !!config.perNode;
        this.deserialize = config.deserialize || (() => {
            throw new Error("This node type doesn't define a deserialize function");
        });
    }
    /// This is meant to be used with
    /// [`NodeSet.extend`](#common.NodeSet.extend) or
    /// [`LRParser.configure`](#lr.ParserConfig.props) to compute
    /// prop values for each node type in the set. Takes a [match
    /// object](#common.NodeType^match) or function that returns undefined
    /// if the node type doesn't get this prop, and the prop's value if
    /// it does.
    add(match) {
        if (this.perNode)
            throw new RangeError("Can't add per-node props to node types");
        if (typeof match != "function")
            match = NodeType.match(match);
        return (type) => {
            let result = match(type);
            return result === undefined ? null : [this, result];
        };
    }
}
/// Prop that is used to describe matching delimiters. For opening
/// delimiters, this holds an array of node names (written as a
/// space-separated string when declaring this prop in a grammar)
/// for the node types of closing delimiters that match it.
NodeProp.closedBy = new NodeProp({ deserialize: str => str.split(" ") });
/// The inverse of [`closedBy`](#common.NodeProp^closedBy). This is
/// attached to closing delimiters, holding an array of node names
/// of types of matching opening delimiters.
NodeProp.openedBy = new NodeProp({ deserialize: str => str.split(" ") });
/// Used to assign node types to groups (for example, all node
/// types that represent an expression could be tagged with an
/// `"Expression"` group).
NodeProp.group = new NodeProp({ deserialize: str => str.split(" ") });
/// The hash of the [context](#lr.ContextTracker.constructor)
/// that the node was parsed in, if any. Used to limit reuse of
/// contextual nodes.
NodeProp.contextHash = new NodeProp({ perNode: true });
/// The distance beyond the end of the node that the tokenizer
/// looked ahead for any of the tokens inside the node. (The LR
/// parser only stores this when it is larger than 25, for
/// efficiency reasons.)
NodeProp.lookAhead = new NodeProp({ perNode: true });
/// This per-node prop is used to replace a given node, or part of a
/// node, with another tree. This is useful to include trees from
/// different languages in mixed-language parsers.
NodeProp.mounted = new NodeProp({ perNode: true });
/// A mounted tree, which can be [stored](#common.NodeProp^mounted) on
/// a tree node to indicate that parts of its content are
/// represented by another tree.
class MountedTree {
    constructor(
    /// The inner tree.
    tree, 
    /// If this is null, this tree replaces the entire node (it will
    /// be included in the regular iteration instead of its host
    /// node). If not, only the given ranges are considered to be
    /// covered by this tree. This is used for trees that are mixed in
    /// a way that isn't strictly hierarchical. Such mounted trees are
    /// only entered by [`resolveInner`](#common.Tree.resolveInner)
    /// and [`enter`](#common.SyntaxNode.enter).
    overlay, 
    /// The parser used to create this subtree.
    parser) {
        this.tree = tree;
        this.overlay = overlay;
        this.parser = parser;
    }
}
const noProps = Object.create(null);
/// Each node in a syntax tree has a node type associated with it.
class NodeType {
    /// @internal
    constructor(
    /// The name of the node type. Not necessarily unique, but if the
    /// grammar was written properly, different node types with the
    /// same name within a node set should play the same semantic
    /// role.
    name, 
    /// @internal
    props, 
    /// The id of this node in its set. Corresponds to the term ids
    /// used in the parser.
    id, 
    /// @internal
    flags = 0) {
        this.name = name;
        this.props = props;
        this.id = id;
        this.flags = flags;
    }
    /// Define a node type.
    static define(spec) {
        let props = spec.props && spec.props.length ? Object.create(null) : noProps;
        let flags = (spec.top ? 1 /* Top */ : 0) | (spec.skipped ? 2 /* Skipped */ : 0) |
            (spec.error ? 4 /* Error */ : 0) | (spec.name == null ? 8 /* Anonymous */ : 0);
        let type = new NodeType(spec.name || "", props, spec.id, flags);
        if (spec.props)
            for (let src of spec.props) {
                if (!Array.isArray(src))
                    src = src(type);
                if (src) {
                    if (src[0].perNode)
                        throw new RangeError("Can't store a per-node prop on a node type");
                    props[src[0].id] = src[1];
                }
            }
        return type;
    }
    /// Retrieves a node prop for this type. Will return `undefined` if
    /// the prop isn't present on this node.
    prop(prop) { return this.props[prop.id]; }
    /// True when this is the top node of a grammar.
    get isTop() { return (this.flags & 1 /* Top */) > 0; }
    /// True when this node is produced by a skip rule.
    get isSkipped() { return (this.flags & 2 /* Skipped */) > 0; }
    /// Indicates whether this is an error node.
    get isError() { return (this.flags & 4 /* Error */) > 0; }
    /// When true, this node type doesn't correspond to a user-declared
    /// named node, for example because it is used to cache repetition.
    get isAnonymous() { return (this.flags & 8 /* Anonymous */) > 0; }
    /// Returns true when this node's name or one of its
    /// [groups](#common.NodeProp^group) matches the given string.
    is(name) {
        if (typeof name == 'string') {
            if (this.name == name)
                return true;
            let group = this.prop(NodeProp.group);
            return group ? group.indexOf(name) > -1 : false;
        }
        return this.id == name;
    }
    /// Create a function from node types to arbitrary values by
    /// specifying an object whose property names are node or
    /// [group](#common.NodeProp^group) names. Often useful with
    /// [`NodeProp.add`](#common.NodeProp.add). You can put multiple
    /// names, separated by spaces, in a single property name to map
    /// multiple node names to a single value.
    static match(map) {
        let direct = Object.create(null);
        for (let prop in map)
            for (let name of prop.split(" "))
                direct[name] = map[prop];
        return (node) => {
            for (let groups = node.prop(NodeProp.group), i = -1; i < (groups ? groups.length : 0); i++) {
                let found = direct[i < 0 ? node.name : groups[i]];
                if (found)
                    return found;
            }
        };
    }
}
/// An empty dummy node type to use when no actual type is available.
NodeType.none = new NodeType("", Object.create(null), 0, 8 /* Anonymous */);
/// A node set holds a collection of node types. It is used to
/// compactly represent trees by storing their type ids, rather than a
/// full pointer to the type object, in a numeric array. Each parser
/// [has](#lr.LRParser.nodeSet) a node set, and [tree
/// buffers](#common.TreeBuffer) can only store collections of nodes
/// from the same set. A set can have a maximum of 2**16 (65536) node
/// types in it, so that the ids fit into 16-bit typed array slots.
class NodeSet {
    /// Create a set with the given types. The `id` property of each
    /// type should correspond to its position within the array.
    constructor(
    /// The node types in this set, by id.
    types) {
        this.types = types;
        for (let i = 0; i < types.length; i++)
            if (types[i].id != i)
                throw new RangeError("Node type ids should correspond to array positions when creating a node set");
    }
    /// Create a copy of this set with some node properties added. The
    /// arguments to this method can be created with
    /// [`NodeProp.add`](#common.NodeProp.add).
    extend(...props) {
        let newTypes = [];
        for (let type of this.types) {
            let newProps = null;
            for (let source of props) {
                let add = source(type);
                if (add) {
                    if (!newProps)
                        newProps = Object.assign({}, type.props);
                    newProps[add[0].id] = add[1];
                }
            }
            newTypes.push(newProps ? new NodeType(type.name, newProps, type.id, type.flags) : type);
        }
        return new NodeSet(newTypes);
    }
}
const CachedNode = new WeakMap(), CachedInnerNode = new WeakMap();
/// Options that control iteration. Can be combined with the `|`
/// operator to enable multiple ones.
var IterMode;
(function (IterMode) {
    /// When enabled, iteration will only visit [`Tree`](#common.Tree)
    /// objects, not nodes packed into
    /// [`TreeBuffer`](#common.TreeBuffer)s.
    IterMode[IterMode["ExcludeBuffers"] = 1] = "ExcludeBuffers";
    /// Enable this to make iteration include anonymous nodes (such as
    /// the nodes that wrap repeated grammar constructs into a balanced
    /// tree).
    IterMode[IterMode["IncludeAnonymous"] = 2] = "IncludeAnonymous";
    /// By default, regular [mounted](#common.NodeProp^mounted) nodes
    /// replace their base node in iteration. Enable this to ignore them
    /// instead.
    IterMode[IterMode["IgnoreMounts"] = 4] = "IgnoreMounts";
    /// This option only applies in
    /// [`enter`](#common.SyntaxNode.enter)-style methods. It tells the
    /// library to not enter mounted overlays if one covers the given
    /// position.
    IterMode[IterMode["IgnoreOverlays"] = 8] = "IgnoreOverlays";
})(IterMode || (IterMode = {}));
/// A piece of syntax tree. There are two ways to approach these
/// trees: the way they are actually stored in memory, and the
/// convenient way.
///
/// Syntax trees are stored as a tree of `Tree` and `TreeBuffer`
/// objects. By packing detail information into `TreeBuffer` leaf
/// nodes, the representation is made a lot more memory-efficient.
///
/// However, when you want to actually work with tree nodes, this
/// representation is very awkward, so most client code will want to
/// use the [`TreeCursor`](#common.TreeCursor) or
/// [`SyntaxNode`](#common.SyntaxNode) interface instead, which provides
/// a view on some part of this data structure, and can be used to
/// move around to adjacent nodes.
class Tree {
    /// Construct a new tree. See also [`Tree.build`](#common.Tree^build).
    constructor(
    /// The type of the top node.
    type, 
    /// This node's child nodes.
    children, 
    /// The positions (offsets relative to the start of this tree) of
    /// the children.
    positions, 
    /// The total length of this tree
    length, 
    /// Per-node [node props](#common.NodeProp) to associate with this node.
    props) {
        this.type = type;
        this.children = children;
        this.positions = positions;
        this.length = length;
        /// @internal
        this.props = null;
        if (props && props.length) {
            this.props = Object.create(null);
            for (let [prop, value] of props)
                this.props[typeof prop == "number" ? prop : prop.id] = value;
        }
    }
    /// @internal
    toString() {
        let mounted = this.prop(NodeProp.mounted);
        if (mounted && !mounted.overlay)
            return mounted.tree.toString();
        let children = "";
        for (let ch of this.children) {
            let str = ch.toString();
            if (str) {
                if (children)
                    children += ",";
                children += str;
            }
        }
        return !this.type.name ? children :
            (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) +
                (children.length ? "(" + children + ")" : "");
    }
    /// Get a [tree cursor](#common.TreeCursor) positioned at the top of
    /// the tree. Mode can be used to [control](#common.IterMode) which
    /// nodes the cursor visits.
    cursor(mode = 0) {
        return new TreeCursor(this.topNode, mode);
    }
    /// Get a [tree cursor](#common.TreeCursor) pointing into this tree
    /// at the given position and side (see
    /// [`moveTo`](#common.TreeCursor.moveTo).
    cursorAt(pos, side = 0, mode = 0) {
        let scope = CachedNode.get(this) || this.topNode;
        let cursor = new TreeCursor(scope);
        cursor.moveTo(pos, side);
        CachedNode.set(this, cursor._tree);
        return cursor;
    }
    /// Get a [syntax node](#common.SyntaxNode) object for the top of the
    /// tree.
    get topNode() {
        return new TreeNode(this, 0, 0, null);
    }
    /// Get the [syntax node](#common.SyntaxNode) at the given position.
    /// If `side` is -1, this will move into nodes that end at the
    /// position. If 1, it'll move into nodes that start at the
    /// position. With 0, it'll only enter nodes that cover the position
    /// from both sides.
    ///
    /// Note that this will not enter
    /// [overlays](#common.MountedTree.overlay), and you often want
    /// [`resolveInner`](#common.Tree.resolveInner) instead.
    resolve(pos, side = 0) {
        let node = resolveNode(CachedNode.get(this) || this.topNode, pos, side, false);
        CachedNode.set(this, node);
        return node;
    }
    /// Like [`resolve`](#common.Tree.resolve), but will enter
    /// [overlaid](#common.MountedTree.overlay) nodes, producing a syntax node
    /// pointing into the innermost overlaid tree at the given position
    /// (with parent links going through all parent structure, including
    /// the host trees).
    resolveInner(pos, side = 0) {
        let node = resolveNode(CachedInnerNode.get(this) || this.topNode, pos, side, true);
        CachedInnerNode.set(this, node);
        return node;
    }
    /// Iterate over the tree and its children, calling `enter` for any
    /// node that touches the `from`/`to` region (if given) before
    /// running over such a node's children, and `leave` (if given) when
    /// leaving the node. When `enter` returns `false`, that node will
    /// not have its children iterated over (or `leave` called).
    iterate(spec) {
        let { enter, leave, from = 0, to = this.length } = spec;
        for (let c = this.cursor((spec.mode || 0) | IterMode.IncludeAnonymous);;) {
            let entered = false;
            if (c.from <= to && c.to >= from && (c.type.isAnonymous || enter(c) !== false)) {
                if (c.firstChild())
                    continue;
                entered = true;
            }
            for (;;) {
                if (entered && leave && !c.type.isAnonymous)
                    leave(c);
                if (c.nextSibling())
                    break;
                if (!c.parent())
                    return;
                entered = true;
            }
        }
    }
    /// Get the value of the given [node prop](#common.NodeProp) for this
    /// node. Works with both per-node and per-type props.
    prop(prop) {
        return !prop.perNode ? this.type.prop(prop) : this.props ? this.props[prop.id] : undefined;
    }
    /// Returns the node's [per-node props](#common.NodeProp.perNode) in a
    /// format that can be passed to the [`Tree`](#common.Tree)
    /// constructor.
    get propValues() {
        let result = [];
        if (this.props)
            for (let id in this.props)
                result.push([+id, this.props[id]]);
        return result;
    }
    /// Balance the direct children of this tree, producing a copy of
    /// which may have children grouped into subtrees with type
    /// [`NodeType.none`](#common.NodeType^none).
    balance(config = {}) {
        return this.children.length <= 8 /* BranchFactor */ ? this :
            balanceRange(NodeType.none, this.children, this.positions, 0, this.children.length, 0, this.length, (children, positions, length) => new Tree(this.type, children, positions, length, this.propValues), config.makeTree || ((children, positions, length) => new Tree(NodeType.none, children, positions, length)));
    }
    /// Build a tree from a postfix-ordered buffer of node information,
    /// or a cursor over such a buffer.
    static build(data) { return buildTree(data); }
}
/// The empty tree
Tree.empty = new Tree(NodeType.none, [], [], 0);
class FlatBufferCursor {
    constructor(buffer, index) {
        this.buffer = buffer;
        this.index = index;
    }
    get id() { return this.buffer[this.index - 4]; }
    get start() { return this.buffer[this.index - 3]; }
    get end() { return this.buffer[this.index - 2]; }
    get size() { return this.buffer[this.index - 1]; }
    get pos() { return this.index; }
    next() { this.index -= 4; }
    fork() { return new FlatBufferCursor(this.buffer, this.index); }
}
/// Tree buffers contain (type, start, end, endIndex) quads for each
/// node. In such a buffer, nodes are stored in prefix order (parents
/// before children, with the endIndex of the parent indicating which
/// children belong to it).
class TreeBuffer {
    /// Create a tree buffer.
    constructor(
    /// The buffer's content.
    buffer, 
    /// The total length of the group of nodes in the buffer.
    length, 
    /// The node set used in this buffer.
    set) {
        this.buffer = buffer;
        this.length = length;
        this.set = set;
    }
    /// @internal
    get type() { return NodeType.none; }
    /// @internal
    toString() {
        let result = [];
        for (let index = 0; index < this.buffer.length;) {
            result.push(this.childString(index));
            index = this.buffer[index + 3];
        }
        return result.join(",");
    }
    /// @internal
    childString(index) {
        let id = this.buffer[index], endIndex = this.buffer[index + 3];
        let type = this.set.types[id], result = type.name;
        if (/\W/.test(result) && !type.isError)
            result = JSON.stringify(result);
        index += 4;
        if (endIndex == index)
            return result;
        let children = [];
        while (index < endIndex) {
            children.push(this.childString(index));
            index = this.buffer[index + 3];
        }
        return result + "(" + children.join(",") + ")";
    }
    /// @internal
    findChild(startIndex, endIndex, dir, pos, side) {
        let { buffer } = this, pick = -1;
        for (let i = startIndex; i != endIndex; i = buffer[i + 3]) {
            if (checkSide(side, pos, buffer[i + 1], buffer[i + 2])) {
                pick = i;
                if (dir > 0)
                    break;
            }
        }
        return pick;
    }
    /// @internal
    slice(startI, endI, from, to) {
        let b = this.buffer;
        let copy = new Uint16Array(endI - startI);
        for (let i = startI, j = 0; i < endI;) {
            copy[j++] = b[i++];
            copy[j++] = b[i++] - from;
            copy[j++] = b[i++] - from;
            copy[j++] = b[i++] - startI;
        }
        return new TreeBuffer(copy, to - from, this.set);
    }
}
function checkSide(side, pos, from, to) {
    switch (side) {
        case -2 /* Before */: return from < pos;
        case -1 /* AtOrBefore */: return to >= pos && from < pos;
        case 0 /* Around */: return from < pos && to > pos;
        case 1 /* AtOrAfter */: return from <= pos && to > pos;
        case 2 /* After */: return to > pos;
        case 4 /* DontCare */: return true;
    }
}
function enterUnfinishedNodesBefore(node, pos) {
    let scan = node.childBefore(pos);
    while (scan) {
        let last = scan.lastChild;
        if (!last || last.to != scan.to)
            break;
        if (last.type.isError && last.from == last.to) {
            node = scan;
            scan = last.prevSibling;
        }
        else {
            scan = last;
        }
    }
    return node;
}
function resolveNode(node, pos, side, overlays) {
    var _a;
    // Move up to a node that actually holds the position, if possible
    while (node.from == node.to ||
        (side < 1 ? node.from >= pos : node.from > pos) ||
        (side > -1 ? node.to <= pos : node.to < pos)) {
        let parent = !overlays && node instanceof TreeNode && node.index < 0 ? null : node.parent;
        if (!parent)
            return node;
        node = parent;
    }
    let mode = overlays ? 0 : IterMode.IgnoreOverlays;
    // Must go up out of overlays when those do not overlap with pos
    if (overlays)
        for (let scan = node, parent = scan.parent; parent; scan = parent, parent = scan.parent) {
            if (scan instanceof TreeNode && scan.index < 0 && ((_a = parent.enter(pos, side, mode)) === null || _a === void 0 ? void 0 : _a.from) != scan.from)
                node = parent;
        }
    for (;;) {
        let inner = node.enter(pos, side, mode);
        if (!inner)
            return node;
        node = inner;
    }
}
class TreeNode {
    constructor(_tree, from, 
    // Index in parent node, set to -1 if the node is not a direct child of _parent.node (overlay)
    index, _parent) {
        this._tree = _tree;
        this.from = from;
        this.index = index;
        this._parent = _parent;
    }
    get type() { return this._tree.type; }
    get name() { return this._tree.type.name; }
    get to() { return this.from + this._tree.length; }
    nextChild(i, dir, pos, side, mode = 0) {
        for (let parent = this;;) {
            for (let { children, positions } = parent._tree, e = dir > 0 ? children.length : -1; i != e; i += dir) {
                let next = children[i], start = positions[i] + parent.from;
                if (!checkSide(side, pos, start, start + next.length))
                    continue;
                if (next instanceof TreeBuffer) {
                    if (mode & IterMode.ExcludeBuffers)
                        continue;
                    let index = next.findChild(0, next.buffer.length, dir, pos - start, side);
                    if (index > -1)
                        return new BufferNode(new BufferContext(parent, next, i, start), null, index);
                }
                else if ((mode & IterMode.IncludeAnonymous) || (!next.type.isAnonymous || hasChild(next))) {
                    let mounted;
                    if (!(mode & IterMode.IgnoreMounts) &&
                        next.props && (mounted = next.prop(NodeProp.mounted)) && !mounted.overlay)
                        return new TreeNode(mounted.tree, start, i, parent);
                    let inner = new TreeNode(next, start, i, parent);
                    return (mode & IterMode.IncludeAnonymous) || !inner.type.isAnonymous ? inner
                        : inner.nextChild(dir < 0 ? next.children.length - 1 : 0, dir, pos, side);
                }
            }
            if ((mode & IterMode.IncludeAnonymous) || !parent.type.isAnonymous)
                return null;
            if (parent.index >= 0)
                i = parent.index + dir;
            else
                i = dir < 0 ? -1 : parent._parent._tree.children.length;
            parent = parent._parent;
            if (!parent)
                return null;
        }
    }
    get firstChild() { return this.nextChild(0, 1, 0, 4 /* DontCare */); }
    get lastChild() { return this.nextChild(this._tree.children.length - 1, -1, 0, 4 /* DontCare */); }
    childAfter(pos) { return this.nextChild(0, 1, pos, 2 /* After */); }
    childBefore(pos) { return this.nextChild(this._tree.children.length - 1, -1, pos, -2 /* Before */); }
    enter(pos, side, mode = 0) {
        let mounted;
        if (!(mode & IterMode.IgnoreOverlays) && (mounted = this._tree.prop(NodeProp.mounted)) && mounted.overlay) {
            let rPos = pos - this.from;
            for (let { from, to } of mounted.overlay) {
                if ((side > 0 ? from <= rPos : from < rPos) &&
                    (side < 0 ? to >= rPos : to > rPos))
                    return new TreeNode(mounted.tree, mounted.overlay[0].from + this.from, -1, this);
            }
        }
        return this.nextChild(0, 1, pos, side, mode);
    }
    nextSignificantParent() {
        let val = this;
        while (val.type.isAnonymous && val._parent)
            val = val._parent;
        return val;
    }
    get parent() {
        return this._parent ? this._parent.nextSignificantParent() : null;
    }
    get nextSibling() {
        return this._parent && this.index >= 0 ? this._parent.nextChild(this.index + 1, 1, 0, 4 /* DontCare */) : null;
    }
    get prevSibling() {
        return this._parent && this.index >= 0 ? this._parent.nextChild(this.index - 1, -1, 0, 4 /* DontCare */) : null;
    }
    cursor(mode = 0) { return new TreeCursor(this, mode); }
    get tree() { return this._tree; }
    toTree() { return this._tree; }
    resolve(pos, side = 0) {
        return resolveNode(this, pos, side, false);
    }
    resolveInner(pos, side = 0) {
        return resolveNode(this, pos, side, true);
    }
    enterUnfinishedNodesBefore(pos) { return enterUnfinishedNodesBefore(this, pos); }
    getChild(type, before = null, after = null) {
        let r = getChildren(this, type, before, after);
        return r.length ? r[0] : null;
    }
    getChildren(type, before = null, after = null) {
        return getChildren(this, type, before, after);
    }
    /// @internal
    toString() { return this._tree.toString(); }
    get node() { return this; }
    matchContext(context) { return matchNodeContext(this, context); }
}
function getChildren(node, type, before, after) {
    let cur = node.cursor(), result = [];
    if (!cur.firstChild())
        return result;
    if (before != null)
        while (!cur.type.is(before))
            if (!cur.nextSibling())
                return result;
    for (;;) {
        if (after != null && cur.type.is(after))
            return result;
        if (cur.type.is(type))
            result.push(cur.node);
        if (!cur.nextSibling())
            return after == null ? result : [];
    }
}
function matchNodeContext(node, context, i = context.length - 1) {
    for (let p = node.parent; i >= 0; p = p.parent) {
        if (!p)
            return false;
        if (!p.type.isAnonymous) {
            if (context[i] && context[i] != p.name)
                return false;
            i--;
        }
    }
    return true;
}
class BufferContext {
    constructor(parent, buffer, index, start) {
        this.parent = parent;
        this.buffer = buffer;
        this.index = index;
        this.start = start;
    }
}
class BufferNode {
    constructor(context, _parent, index) {
        this.context = context;
        this._parent = _parent;
        this.index = index;
        this.type = context.buffer.set.types[context.buffer.buffer[index]];
    }
    get name() { return this.type.name; }
    get from() { return this.context.start + this.context.buffer.buffer[this.index + 1]; }
    get to() { return this.context.start + this.context.buffer.buffer[this.index + 2]; }
    child(dir, pos, side) {
        let { buffer } = this.context;
        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.context.start, side);
        return index < 0 ? null : new BufferNode(this.context, this, index);
    }
    get firstChild() { return this.child(1, 0, 4 /* DontCare */); }
    get lastChild() { return this.child(-1, 0, 4 /* DontCare */); }
    childAfter(pos) { return this.child(1, pos, 2 /* After */); }
    childBefore(pos) { return this.child(-1, pos, -2 /* Before */); }
    enter(pos, side, mode = 0) {
        if (mode & IterMode.ExcludeBuffers)
            return null;
        let { buffer } = this.context;
        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], side > 0 ? 1 : -1, pos - this.context.start, side);
        return index < 0 ? null : new BufferNode(this.context, this, index);
    }
    get parent() {
        return this._parent || this.context.parent.nextSignificantParent();
    }
    externalSibling(dir) {
        return this._parent ? null : this.context.parent.nextChild(this.context.index + dir, dir, 0, 4 /* DontCare */);
    }
    get nextSibling() {
        let { buffer } = this.context;
        let after = buffer.buffer[this.index + 3];
        if (after < (this._parent ? buffer.buffer[this._parent.index + 3] : buffer.buffer.length))
            return new BufferNode(this.context, this._parent, after);
        return this.externalSibling(1);
    }
    get prevSibling() {
        let { buffer } = this.context;
        let parentStart = this._parent ? this._parent.index + 4 : 0;
        if (this.index == parentStart)
            return this.externalSibling(-1);
        return new BufferNode(this.context, this._parent, buffer.findChild(parentStart, this.index, -1, 0, 4 /* DontCare */));
    }
    cursor(mode = 0) { return new TreeCursor(this, mode); }
    get tree() { return null; }
    toTree() {
        let children = [], positions = [];
        let { buffer } = this.context;
        let startI = this.index + 4, endI = buffer.buffer[this.index + 3];
        if (endI > startI) {
            let from = buffer.buffer[this.index + 1], to = buffer.buffer[this.index + 2];
            children.push(buffer.slice(startI, endI, from, to));
            positions.push(0);
        }
        return new Tree(this.type, children, positions, this.to - this.from);
    }
    resolve(pos, side = 0) {
        return resolveNode(this, pos, side, false);
    }
    resolveInner(pos, side = 0) {
        return resolveNode(this, pos, side, true);
    }
    enterUnfinishedNodesBefore(pos) { return enterUnfinishedNodesBefore(this, pos); }
    /// @internal
    toString() { return this.context.buffer.childString(this.index); }
    getChild(type, before = null, after = null) {
        let r = getChildren(this, type, before, after);
        return r.length ? r[0] : null;
    }
    getChildren(type, before = null, after = null) {
        return getChildren(this, type, before, after);
    }
    get node() { return this; }
    matchContext(context) { return matchNodeContext(this, context); }
}
/// A tree cursor object focuses on a given node in a syntax tree, and
/// allows you to move to adjacent nodes.
class TreeCursor {
    /// @internal
    constructor(node, 
    /// @internal
    mode = 0) {
        this.mode = mode;
        /// @internal
        this.buffer = null;
        this.stack = [];
        /// @internal
        this.index = 0;
        this.bufferNode = null;
        if (node instanceof TreeNode) {
            this.yieldNode(node);
        }
        else {
            this._tree = node.context.parent;
            this.buffer = node.context;
            for (let n = node._parent; n; n = n._parent)
                this.stack.unshift(n.index);
            this.bufferNode = node;
            this.yieldBuf(node.index);
        }
    }
    /// Shorthand for `.type.name`.
    get name() { return this.type.name; }
    yieldNode(node) {
        if (!node)
            return false;
        this._tree = node;
        this.type = node.type;
        this.from = node.from;
        this.to = node.to;
        return true;
    }
    yieldBuf(index, type) {
        this.index = index;
        let { start, buffer } = this.buffer;
        this.type = type || buffer.set.types[buffer.buffer[index]];
        this.from = start + buffer.buffer[index + 1];
        this.to = start + buffer.buffer[index + 2];
        return true;
    }
    yield(node) {
        if (!node)
            return false;
        if (node instanceof TreeNode) {
            this.buffer = null;
            return this.yieldNode(node);
        }
        this.buffer = node.context;
        return this.yieldBuf(node.index, node.type);
    }
    /// @internal
    toString() {
        return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
    }
    /// @internal
    enterChild(dir, pos, side) {
        if (!this.buffer)
            return this.yield(this._tree.nextChild(dir < 0 ? this._tree._tree.children.length - 1 : 0, dir, pos, side, this.mode));
        let { buffer } = this.buffer;
        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.buffer.start, side);
        if (index < 0)
            return false;
        this.stack.push(this.index);
        return this.yieldBuf(index);
    }
    /// Move the cursor to this node's first child. When this returns
    /// false, the node has no child, and the cursor has not been moved.
    firstChild() { return this.enterChild(1, 0, 4 /* DontCare */); }
    /// Move the cursor to this node's last child.
    lastChild() { return this.enterChild(-1, 0, 4 /* DontCare */); }
    /// Move the cursor to the first child that ends after `pos`.
    childAfter(pos) { return this.enterChild(1, pos, 2 /* After */); }
    /// Move to the last child that starts before `pos`.
    childBefore(pos) { return this.enterChild(-1, pos, -2 /* Before */); }
    /// Move the cursor to the child around `pos`. If side is -1 the
    /// child may end at that position, when 1 it may start there. This
    /// will also enter [overlaid](#common.MountedTree.overlay)
    /// [mounted](#common.NodeProp^mounted) trees unless `overlays` is
    /// set to false.
    enter(pos, side, mode = this.mode) {
        if (!this.buffer)
            return this.yield(this._tree.enter(pos, side, mode));
        return mode & IterMode.ExcludeBuffers ? false : this.enterChild(1, pos, side);
    }
    /// Move to the node's parent node, if this isn't the top node.
    parent() {
        if (!this.buffer)
            return this.yieldNode((this.mode & IterMode.IncludeAnonymous) ? this._tree._parent : this._tree.parent);
        if (this.stack.length)
            return this.yieldBuf(this.stack.pop());
        let parent = (this.mode & IterMode.IncludeAnonymous) ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
        this.buffer = null;
        return this.yieldNode(parent);
    }
    /// @internal
    sibling(dir) {
        if (!this.buffer)
            return !this._tree._parent ? false
                : this.yield(this._tree.index < 0 ? null
                    : this._tree._parent.nextChild(this._tree.index + dir, dir, 0, 4 /* DontCare */, this.mode));
        let { buffer } = this.buffer, d = this.stack.length - 1;
        if (dir < 0) {
            let parentStart = d < 0 ? 0 : this.stack[d] + 4;
            if (this.index != parentStart)
                return this.yieldBuf(buffer.findChild(parentStart, this.index, -1, 0, 4 /* DontCare */));
        }
        else {
            let after = buffer.buffer[this.index + 3];
            if (after < (d < 0 ? buffer.buffer.length : buffer.buffer[this.stack[d] + 3]))
                return this.yieldBuf(after);
        }
        return d < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + dir, dir, 0, 4 /* DontCare */, this.mode)) : false;
    }
    /// Move to this node's next sibling, if any.
    nextSibling() { return this.sibling(1); }
    /// Move to this node's previous sibling, if any.
    prevSibling() { return this.sibling(-1); }
    atLastNode(dir) {
        let index, parent, { buffer } = this;
        if (buffer) {
            if (dir > 0) {
                if (this.index < buffer.buffer.buffer.length)
                    return false;
            }
            else {
                for (let i = 0; i < this.index; i++)
                    if (buffer.buffer.buffer[i + 3] < this.index)
                        return false;
            }
            ({ index, parent } = buffer);
        }
        else {
            ({ index, _parent: parent } = this._tree);
        }
        for (; parent; { index, _parent: parent } = parent) {
            if (index > -1)
                for (let i = index + dir, e = dir < 0 ? -1 : parent._tree.children.length; i != e; i += dir) {
                    let child = parent._tree.children[i];
                    if ((this.mode & IterMode.IncludeAnonymous) ||
                        child instanceof TreeBuffer ||
                        !child.type.isAnonymous ||
                        hasChild(child))
                        return false;
                }
        }
        return true;
    }
    move(dir, enter) {
        if (enter && this.enterChild(dir, 0, 4 /* DontCare */))
            return true;
        for (;;) {
            if (this.sibling(dir))
                return true;
            if (this.atLastNode(dir) || !this.parent())
                return false;
        }
    }
    /// Move to the next node in a
    /// [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order_(NLR))
    /// traversal, going from a node to its first child or, if the
    /// current node is empty or `enter` is false, its next sibling or
    /// the next sibling of the first parent node that has one.
    next(enter = true) { return this.move(1, enter); }
    /// Move to the next node in a last-to-first pre-order traveral. A
    /// node is followed by its last child or, if it has none, its
    /// previous sibling or the previous sibling of the first parent
    /// node that has one.
    prev(enter = true) { return this.move(-1, enter); }
    /// Move the cursor to the innermost node that covers `pos`. If
    /// `side` is -1, it will enter nodes that end at `pos`. If it is 1,
    /// it will enter nodes that start at `pos`.
    moveTo(pos, side = 0) {
        // Move up to a node that actually holds the position, if possible
        while (this.from == this.to ||
            (side < 1 ? this.from >= pos : this.from > pos) ||
            (side > -1 ? this.to <= pos : this.to < pos))
            if (!this.parent())
                break;
        // Then scan down into child nodes as far as possible
        while (this.enterChild(1, pos, side)) { }
        return this;
    }
    /// Get a [syntax node](#common.SyntaxNode) at the cursor's current
    /// position.
    get node() {
        if (!this.buffer)
            return this._tree;
        let cache = this.bufferNode, result = null, depth = 0;
        if (cache && cache.context == this.buffer) {
            scan: for (let index = this.index, d = this.stack.length; d >= 0;) {
                for (let c = cache; c; c = c._parent)
                    if (c.index == index) {
                        if (index == this.index)
                            return c;
                        result = c;
                        depth = d + 1;
                        break scan;
                    }
                index = this.stack[--d];
            }
        }
        for (let i = depth; i < this.stack.length; i++)
            result = new BufferNode(this.buffer, result, this.stack[i]);
        return this.bufferNode = new BufferNode(this.buffer, result, this.index);
    }
    /// Get the [tree](#common.Tree) that represents the current node, if
    /// any. Will return null when the node is in a [tree
    /// buffer](#common.TreeBuffer).
    get tree() {
        return this.buffer ? null : this._tree._tree;
    }
    /// Iterate over the current node and all its descendants, calling
    /// `enter` when entering a node and `leave`, if given, when leaving
    /// one. When `enter` returns `false`, any children of that node are
    /// skipped, and `leave` isn't called for it.
    iterate(enter, leave) {
        for (let depth = 0;;) {
            let mustLeave = false;
            if (this.type.isAnonymous || enter(this) !== false) {
                if (this.firstChild()) {
                    depth++;
                    continue;
                }
                if (!this.type.isAnonymous)
                    mustLeave = true;
            }
            for (;;) {
                if (mustLeave && leave)
                    leave(this);
                mustLeave = this.type.isAnonymous;
                if (this.nextSibling())
                    break;
                if (!depth)
                    return;
                this.parent();
                depth--;
                mustLeave = true;
            }
        }
    }
    /// Test whether the current node matches a given contexta sequence
    /// of direct parent node names. Empty strings in the context array
    /// are treated as wildcards.
    matchContext(context) {
        if (!this.buffer)
            return matchNodeContext(this.node, context);
        let { buffer } = this.buffer, { types } = buffer.set;
        for (let i = context.length - 1, d = this.stack.length - 1; i >= 0; d--) {
            if (d < 0)
                return matchNodeContext(this.node, context, i);
            let type = types[buffer.buffer[this.stack[d]]];
            if (!type.isAnonymous) {
                if (context[i] && context[i] != type.name)
                    return false;
                i--;
            }
        }
        return true;
    }
}
function hasChild(tree) {
    return tree.children.some(ch => ch instanceof TreeBuffer || !ch.type.isAnonymous || hasChild(ch));
}
function buildTree(data) {
    var _a;
    let { buffer, nodeSet, maxBufferLength = DefaultBufferLength, reused = [], minRepeatType = nodeSet.types.length } = data;
    let cursor = Array.isArray(buffer) ? new FlatBufferCursor(buffer, buffer.length) : buffer;
    let types = nodeSet.types;
    let contextHash = 0, lookAhead = 0;
    function takeNode(parentStart, minPos, children, positions, inRepeat) {
        let { id, start, end, size } = cursor;
        let lookAheadAtStart = lookAhead;
        while (size < 0) {
            cursor.next();
            if (size == -1 /* Reuse */) {
                let node = reused[id];
                children.push(node);
                positions.push(start - parentStart);
                return;
            }
            else if (size == -3 /* ContextChange */) { // Context change
                contextHash = id;
                return;
            }
            else if (size == -4 /* LookAhead */) {
                lookAhead = id;
                return;
            }
            else {
                throw new RangeError(`Unrecognized record size: ${size}`);
            }
        }
        let type = types[id], node, buffer;
        let startPos = start - parentStart;
        if (end - start <= maxBufferLength && (buffer = findBufferSize(cursor.pos - minPos, inRepeat))) {
            // Small enough for a buffer, and no reused nodes inside
            let data = new Uint16Array(buffer.size - buffer.skip);
            let endPos = cursor.pos - buffer.size, index = data.length;
            while (cursor.pos > endPos)
                index = copyToBuffer(buffer.start, data, index);
            node = new TreeBuffer(data, end - buffer.start, nodeSet);
            startPos = buffer.start - parentStart;
        }
        else { // Make it a node
            let endPos = cursor.pos - size;
            cursor.next();
            let localChildren = [], localPositions = [];
            let localInRepeat = id >= minRepeatType ? id : -1;
            let lastGroup = 0, lastEnd = end;
            while (cursor.pos > endPos) {
                if (localInRepeat >= 0 && cursor.id == localInRepeat && cursor.size >= 0) {
                    if (cursor.end <= lastEnd - maxBufferLength) {
                        makeRepeatLeaf(localChildren, localPositions, start, lastGroup, cursor.end, lastEnd, localInRepeat, lookAheadAtStart);
                        lastGroup = localChildren.length;
                        lastEnd = cursor.end;
                    }
                    cursor.next();
                }
                else {
                    takeNode(start, endPos, localChildren, localPositions, localInRepeat);
                }
            }
            if (localInRepeat >= 0 && lastGroup > 0 && lastGroup < localChildren.length)
                makeRepeatLeaf(localChildren, localPositions, start, lastGroup, start, lastEnd, localInRepeat, lookAheadAtStart);
            localChildren.reverse();
            localPositions.reverse();
            if (localInRepeat > -1 && lastGroup > 0) {
                let make = makeBalanced(type);
                node = balanceRange(type, localChildren, localPositions, 0, localChildren.length, 0, end - start, make, make);
            }
            else {
                node = makeTree(type, localChildren, localPositions, end - start, lookAheadAtStart - end);
            }
        }
        children.push(node);
        positions.push(startPos);
    }
    function makeBalanced(type) {
        return (children, positions, length) => {
            let lookAhead = 0, lastI = children.length - 1, last, lookAheadProp;
            if (lastI >= 0 && (last = children[lastI]) instanceof Tree) {
                if (!lastI && last.type == type && last.length == length)
                    return last;
                if (lookAheadProp = last.prop(NodeProp.lookAhead))
                    lookAhead = positions[lastI] + last.length + lookAheadProp;
            }
            return makeTree(type, children, positions, length, lookAhead);
        };
    }
    function makeRepeatLeaf(children, positions, base, i, from, to, type, lookAhead) {
        let localChildren = [], localPositions = [];
        while (children.length > i) {
            localChildren.push(children.pop());
            localPositions.push(positions.pop() + base - from);
        }
        children.push(makeTree(nodeSet.types[type], localChildren, localPositions, to - from, lookAhead - to));
        positions.push(from - base);
    }
    function makeTree(type, children, positions, length, lookAhead = 0, props) {
        if (contextHash) {
            let pair = [NodeProp.contextHash, contextHash];
            props = props ? [pair].concat(props) : [pair];
        }
        if (lookAhead > 25) {
            let pair = [NodeProp.lookAhead, lookAhead];
            props = props ? [pair].concat(props) : [pair];
        }
        return new Tree(type, children, positions, length, props);
    }
    function findBufferSize(maxSize, inRepeat) {
        // Scan through the buffer to find previous siblings that fit
        // together in a TreeBuffer, and don't contain any reused nodes
        // (which can't be stored in a buffer).
        // If `inRepeat` is > -1, ignore node boundaries of that type for
        // nesting, but make sure the end falls either at the start
        // (`maxSize`) or before such a node.
        let fork = cursor.fork();
        let size = 0, start = 0, skip = 0, minStart = fork.end - maxBufferLength;
        let result = { size: 0, start: 0, skip: 0 };
        scan: for (let minPos = fork.pos - maxSize; fork.pos > minPos;) {
            let nodeSize = fork.size;
            // Pretend nested repeat nodes of the same type don't exist
            if (fork.id == inRepeat && nodeSize >= 0) {
                // Except that we store the current state as a valid return
                // value.
                result.size = size;
                result.start = start;
                result.skip = skip;
                skip += 4;
                size += 4;
                fork.next();
                continue;
            }
            let startPos = fork.pos - nodeSize;
            if (nodeSize < 0 || startPos < minPos || fork.start < minStart)
                break;
            let localSkipped = fork.id >= minRepeatType ? 4 : 0;
            let nodeStart = fork.start;
            fork.next();
            while (fork.pos > startPos) {
                if (fork.size < 0) {
                    if (fork.size == -3 /* ContextChange */)
                        localSkipped += 4;
                    else
                        break scan;
                }
                else if (fork.id >= minRepeatType) {
                    localSkipped += 4;
                }
                fork.next();
            }
            start = nodeStart;
            size += nodeSize;
            skip += localSkipped;
        }
        if (inRepeat < 0 || size == maxSize) {
            result.size = size;
            result.start = start;
            result.skip = skip;
        }
        return result.size > 4 ? result : undefined;
    }
    function copyToBuffer(bufferStart, buffer, index) {
        let { id, start, end, size } = cursor;
        cursor.next();
        if (size >= 0 && id < minRepeatType) {
            let startIndex = index;
            if (size > 4) {
                let endPos = cursor.pos - (size - 4);
                while (cursor.pos > endPos)
                    index = copyToBuffer(bufferStart, buffer, index);
            }
            buffer[--index] = startIndex;
            buffer[--index] = end - bufferStart;
            buffer[--index] = start - bufferStart;
            buffer[--index] = id;
        }
        else if (size == -3 /* ContextChange */) {
            contextHash = id;
        }
        else if (size == -4 /* LookAhead */) {
            lookAhead = id;
        }
        return index;
    }
    let children = [], positions = [];
    while (cursor.pos > 0)
        takeNode(data.start || 0, data.bufferStart || 0, children, positions, -1);
    let length = (_a = data.length) !== null && _a !== void 0 ? _a : (children.length ? positions[0] + children[0].length : 0);
    return new Tree(types[data.topID], children.reverse(), positions.reverse(), length);
}
const nodeSizeCache = new WeakMap;
function nodeSize(balanceType, node) {
    if (!balanceType.isAnonymous || node instanceof TreeBuffer || node.type != balanceType)
        return 1;
    let size = nodeSizeCache.get(node);
    if (size == null) {
        size = 1;
        for (let child of node.children) {
            if (child.type != balanceType || !(child instanceof Tree)) {
                size = 1;
                break;
            }
            size += nodeSize(balanceType, child);
        }
        nodeSizeCache.set(node, size);
    }
    return size;
}
function balanceRange(
// The type the balanced tree's inner nodes.
balanceType, 
// The direct children and their positions
children, positions, 
// The index range in children/positions to use
from, to, 
// The start position of the nodes, relative to their parent.
start, 
// Length of the outer node
length, 
// Function to build the top node of the balanced tree
mkTop, 
// Function to build internal nodes for the balanced tree
mkTree) {
    let total = 0;
    for (let i = from; i < to; i++)
        total += nodeSize(balanceType, children[i]);
    let maxChild = Math.ceil((total * 1.5) / 8 /* BranchFactor */);
    let localChildren = [], localPositions = [];
    function divide(children, positions, from, to, offset) {
        for (let i = from; i < to;) {
            let groupFrom = i, groupStart = positions[i], groupSize = nodeSize(balanceType, children[i]);
            i++;
            for (; i < to; i++) {
                let nextSize = nodeSize(balanceType, children[i]);
                if (groupSize + nextSize >= maxChild)
                    break;
                groupSize += nextSize;
            }
            if (i == groupFrom + 1) {
                if (groupSize > maxChild) {
                    let only = children[groupFrom]; // Only trees can have a size > 1
                    divide(only.children, only.positions, 0, only.children.length, positions[groupFrom] + offset);
                    continue;
                }
                localChildren.push(children[groupFrom]);
            }
            else {
                let length = positions[i - 1] + children[i - 1].length - groupStart;
                localChildren.push(balanceRange(balanceType, children, positions, groupFrom, i, groupStart, length, null, mkTree));
            }
            localPositions.push(groupStart + offset - start);
        }
    }
    divide(children, positions, from, to, 0);
    return (mkTop || mkTree)(localChildren, localPositions, length);
}
/// Provides a way to associate values with pieces of trees. As long
/// as that part of the tree is reused, the associated values can be
/// retrieved from an updated tree.
class NodeWeakMap {
    constructor() {
        this.map = new WeakMap();
    }
    setBuffer(buffer, index, value) {
        let inner = this.map.get(buffer);
        if (!inner)
            this.map.set(buffer, inner = new Map);
        inner.set(index, value);
    }
    getBuffer(buffer, index) {
        let inner = this.map.get(buffer);
        return inner && inner.get(index);
    }
    /// Set the value for this syntax node.
    set(node, value) {
        if (node instanceof BufferNode)
            this.setBuffer(node.context.buffer, node.index, value);
        else if (node instanceof TreeNode)
            this.map.set(node.tree, value);
    }
    /// Retrieve value for this syntax node, if it exists in the map.
    get(node) {
        return node instanceof BufferNode ? this.getBuffer(node.context.buffer, node.index)
            : node instanceof TreeNode ? this.map.get(node.tree) : undefined;
    }
    /// Set the value for the node that a cursor currently points to.
    cursorSet(cursor, value) {
        if (cursor.buffer)
            this.setBuffer(cursor.buffer.buffer, cursor.index, value);
        else
            this.map.set(cursor.tree, value);
    }
    /// Retrieve the value for the node that a cursor currently points
    /// to.
    cursorGet(cursor) {
        return cursor.buffer ? this.getBuffer(cursor.buffer.buffer, cursor.index) : this.map.get(cursor.tree);
    }
}

/// Tree fragments are used during [incremental
/// parsing](#common.Parser.startParse) to track parts of old trees
/// that can be reused in a new parse. An array of fragments is used
/// to track regions of an old tree whose nodes might be reused in new
/// parses. Use the static
/// [`applyChanges`](#common.TreeFragment^applyChanges) method to
/// update fragments for document changes.
class TreeFragment {
    /// Construct a tree fragment. You'll usually want to use
    /// [`addTree`](#common.TreeFragment^addTree) and
    /// [`applyChanges`](#common.TreeFragment^applyChanges) instead of
    /// calling this directly.
    constructor(
    /// The start of the unchanged range pointed to by this fragment.
    /// This refers to an offset in the _updated_ document (as opposed
    /// to the original tree).
    from, 
    /// The end of the unchanged range.
    to, 
    /// The tree that this fragment is based on.
    tree, 
    /// The offset between the fragment's tree and the document that
    /// this fragment can be used against. Add this when going from
    /// document to tree positions, subtract it to go from tree to
    /// document positions.
    offset, openStart = false, openEnd = false) {
        this.from = from;
        this.to = to;
        this.tree = tree;
        this.offset = offset;
        this.open = (openStart ? 1 /* Start */ : 0) | (openEnd ? 2 /* End */ : 0);
    }
    /// Whether the start of the fragment represents the start of a
    /// parse, or the end of a change. (In the second case, it may not
    /// be safe to reuse some nodes at the start, depending on the
    /// parsing algorithm.)
    get openStart() { return (this.open & 1 /* Start */) > 0; }
    /// Whether the end of the fragment represents the end of a
    /// full-document parse, or the start of a change.
    get openEnd() { return (this.open & 2 /* End */) > 0; }
    /// Create a set of fragments from a freshly parsed tree, or update
    /// an existing set of fragments by replacing the ones that overlap
    /// with a tree with content from the new tree. When `partial` is
    /// true, the parse is treated as incomplete, and the resulting
    /// fragment has [`openEnd`](#common.TreeFragment.openEnd) set to
    /// true.
    static addTree(tree, fragments = [], partial = false) {
        let result = [new TreeFragment(0, tree.length, tree, 0, false, partial)];
        for (let f of fragments)
            if (f.to > tree.length)
                result.push(f);
        return result;
    }
    /// Apply a set of edits to an array of fragments, removing or
    /// splitting fragments as necessary to remove edited ranges, and
    /// adjusting offsets for fragments that moved.
    static applyChanges(fragments, changes, minGap = 128) {
        if (!changes.length)
            return fragments;
        let result = [];
        let fI = 1, nextF = fragments.length ? fragments[0] : null;
        for (let cI = 0, pos = 0, off = 0;; cI++) {
            let nextC = cI < changes.length ? changes[cI] : null;
            let nextPos = nextC ? nextC.fromA : 1e9;
            if (nextPos - pos >= minGap)
                while (nextF && nextF.from < nextPos) {
                    let cut = nextF;
                    if (pos >= cut.from || nextPos <= cut.to || off) {
                        let fFrom = Math.max(cut.from, pos) - off, fTo = Math.min(cut.to, nextPos) - off;
                        cut = fFrom >= fTo ? null : new TreeFragment(fFrom, fTo, cut.tree, cut.offset + off, cI > 0, !!nextC);
                    }
                    if (cut)
                        result.push(cut);
                    if (nextF.to > nextPos)
                        break;
                    nextF = fI < fragments.length ? fragments[fI++] : null;
                }
            if (!nextC)
                break;
            pos = nextC.toA;
            off = nextC.toA - nextC.toB;
        }
        return result;
    }
}
/// A superclass that parsers should extend.
class Parser {
    /// Start a parse, returning a [partial parse](#common.PartialParse)
    /// object. [`fragments`](#common.TreeFragment) can be passed in to
    /// make the parse incremental.
    ///
    /// By default, the entire input is parsed. You can pass `ranges`,
    /// which should be a sorted array of non-empty, non-overlapping
    /// ranges, to parse only those ranges. The tree returned in that
    /// case will start at `ranges[0].from`.
    startParse(input, fragments, ranges) {
        if (typeof input == "string")
            input = new StringInput(input);
        ranges = !ranges ? [new Range(0, input.length)] : ranges.length ? ranges.map(r => new Range(r.from, r.to)) : [new Range(0, 0)];
        return this.createParse(input, fragments || [], ranges);
    }
    /// Run a full parse, returning the resulting tree.
    parse(input, fragments, ranges) {
        let parse = this.startParse(input, fragments, ranges);
        for (;;) {
            let done = parse.advance();
            if (done)
                return done;
        }
    }
}
class StringInput {
    constructor(string) {
        this.string = string;
    }
    get length() { return this.string.length; }
    chunk(from) { return this.string.slice(from); }
    get lineChunks() { return false; }
    read(from, to) { return this.string.slice(from, to); }
}

/// Create a parse wrapper that, after the inner parse completes,
/// scans its tree for mixed language regions with the `nest`
/// function, runs the resulting [inner parses](#common.NestedParse),
/// and then [mounts](#common.NodeProp^mounted) their results onto the
/// tree.
function parseMixed(nest) {
    return (parse, input, fragments, ranges) => new MixedParse(parse, nest, input, fragments, ranges);
}
class InnerParse {
    constructor(parser, parse, overlay, target, ranges) {
        this.parser = parser;
        this.parse = parse;
        this.overlay = overlay;
        this.target = target;
        this.ranges = ranges;
    }
}
class ActiveOverlay {
    constructor(parser, predicate, mounts, index, start, target, prev) {
        this.parser = parser;
        this.predicate = predicate;
        this.mounts = mounts;
        this.index = index;
        this.start = start;
        this.target = target;
        this.prev = prev;
        this.depth = 0;
        this.ranges = [];
    }
}
const stoppedInner = new NodeProp({ perNode: true });
class MixedParse {
    constructor(base, nest, input, fragments, ranges) {
        this.nest = nest;
        this.input = input;
        this.fragments = fragments;
        this.ranges = ranges;
        this.inner = [];
        this.innerDone = 0;
        this.baseTree = null;
        this.stoppedAt = null;
        this.baseParse = base;
    }
    advance() {
        if (this.baseParse) {
            let done = this.baseParse.advance();
            if (!done)
                return null;
            this.baseParse = null;
            this.baseTree = done;
            this.startInner();
            if (this.stoppedAt != null)
                for (let inner of this.inner)
                    inner.parse.stopAt(this.stoppedAt);
        }
        if (this.innerDone == this.inner.length) {
            let result = this.baseTree;
            if (this.stoppedAt != null)
                result = new Tree(result.type, result.children, result.positions, result.length, result.propValues.concat([[stoppedInner, this.stoppedAt]]));
            return result;
        }
        let inner = this.inner[this.innerDone], done = inner.parse.advance();
        if (done) {
            this.innerDone++;
            // This is a somewhat dodgy but super helpful hack where we
            // patch up nodes created by the inner parse (and thus
            // presumably not aliased anywhere else) to hold the information
            // about the inner parse.
            let props = Object.assign(Object.create(null), inner.target.props);
            props[NodeProp.mounted.id] = new MountedTree(done, inner.overlay, inner.parser);
            inner.target.props = props;
        }
        return null;
    }
    get parsedPos() {
        if (this.baseParse)
            return 0;
        let pos = this.input.length;
        for (let i = this.innerDone; i < this.inner.length; i++) {
            if (this.inner[i].ranges[0].from < pos)
                pos = Math.min(pos, this.inner[i].parse.parsedPos);
        }
        return pos;
    }
    stopAt(pos) {
        this.stoppedAt = pos;
        if (this.baseParse)
            this.baseParse.stopAt(pos);
        else
            for (let i = this.innerDone; i < this.inner.length; i++)
                this.inner[i].parse.stopAt(pos);
    }
    startInner() {
        let fragmentCursor = new FragmentCursor(this.fragments);
        let overlay = null;
        let covered = null;
        let cursor = new TreeCursor(new TreeNode(this.baseTree, this.ranges[0].from, 0, null), IterMode.IncludeAnonymous | IterMode.IgnoreMounts);
        scan: for (let nest, isCovered; this.stoppedAt == null || cursor.from < this.stoppedAt;) {
            let enter = true, range;
            if (fragmentCursor.hasNode(cursor)) {
                if (overlay) {
                    let match = overlay.mounts.find(m => m.frag.from <= cursor.from && m.frag.to >= cursor.to && m.mount.overlay);
                    if (match)
                        for (let r of match.mount.overlay) {
                            let from = r.from + match.pos, to = r.to + match.pos;
                            if (from >= cursor.from && to <= cursor.to && !overlay.ranges.some(r => r.from < to && r.to > from))
                                overlay.ranges.push({ from, to });
                        }
                }
                enter = false;
            }
            else if (covered && (isCovered = checkCover(covered.ranges, cursor.from, cursor.to))) {
                enter = isCovered != 2 /* Full */;
            }
            else if (!cursor.type.isAnonymous && cursor.from < cursor.to && (nest = this.nest(cursor, this.input))) {
                if (!cursor.tree)
                    materialize(cursor);
                let oldMounts = fragmentCursor.findMounts(cursor.from, nest.parser);
                if (typeof nest.overlay == "function") {
                    overlay = new ActiveOverlay(nest.parser, nest.overlay, oldMounts, this.inner.length, cursor.from, cursor.tree, overlay);
                }
                else {
                    let ranges = punchRanges(this.ranges, nest.overlay || [new Range(cursor.from, cursor.to)]);
                    if (ranges.length)
                        this.inner.push(new InnerParse(nest.parser, nest.parser.startParse(this.input, enterFragments(oldMounts, ranges), ranges), nest.overlay ? nest.overlay.map(r => new Range(r.from - cursor.from, r.to - cursor.from)) : null, cursor.tree, ranges));
                    if (!nest.overlay)
                        enter = false;
                    else if (ranges.length)
                        covered = { ranges, depth: 0, prev: covered };
                }
            }
            else if (overlay && (range = overlay.predicate(cursor))) {
                if (range === true)
                    range = new Range(cursor.from, cursor.to);
                if (range.from < range.to)
                    overlay.ranges.push(range);
            }
            if (enter && cursor.firstChild()) {
                if (overlay)
                    overlay.depth++;
                if (covered)
                    covered.depth++;
            }
            else {
                for (;;) {
                    if (cursor.nextSibling())
                        break;
                    if (!cursor.parent())
                        break scan;
                    if (overlay && !--overlay.depth) {
                        let ranges = punchRanges(this.ranges, overlay.ranges);
                        if (ranges.length)
                            this.inner.splice(overlay.index, 0, new InnerParse(overlay.parser, overlay.parser.startParse(this.input, enterFragments(overlay.mounts, ranges), ranges), overlay.ranges.map(r => new Range(r.from - overlay.start, r.to - overlay.start)), overlay.target, ranges));
                        overlay = overlay.prev;
                    }
                    if (covered && !--covered.depth)
                        covered = covered.prev;
                }
            }
        }
    }
}
function checkCover(covered, from, to) {
    for (let range of covered) {
        if (range.from >= to)
            break;
        if (range.to > from)
            return range.from <= from && range.to >= to ? 2 /* Full */ : 1 /* Partial */;
    }
    return 0 /* None */;
}
// Take a piece of buffer and convert it into a stand-alone
// TreeBuffer.
function sliceBuf(buf, startI, endI, nodes, positions, off) {
    if (startI < endI) {
        let from = buf.buffer[startI + 1], to = buf.buffer[endI - 2];
        nodes.push(buf.slice(startI, endI, from, to));
        positions.push(from - off);
    }
}
// This function takes a node that's in a buffer, and converts it, and
// its parent buffer nodes, into a Tree. This is again acting on the
// assumption that the trees and buffers have been constructed by the
// parse that was ran via the mix parser, and thus aren't shared with
// any other code, making violations of the immutability safe.
function materialize(cursor) {
    let { node } = cursor, depth = 0;
    // Scan up to the nearest tree
    do {
        cursor.parent();
        depth++;
    } while (!cursor.tree);
    // Find the index of the buffer in that tree
    let i = 0, base = cursor.tree, off = 0;
    for (;; i++) {
        off = base.positions[i] + cursor.from;
        if (off <= node.from && off + base.children[i].length >= node.to)
            break;
    }
    let buf = base.children[i], b = buf.buffer;
    // Split a level in the buffer, putting the nodes before and after
    // the child that contains `node` into new buffers.
    function split(startI, endI, type, innerOffset, length) {
        let i = startI;
        while (b[i + 2] + off <= node.from)
            i = b[i + 3];
        let children = [], positions = [];
        sliceBuf(buf, startI, i, children, positions, innerOffset);
        let from = b[i + 1], to = b[i + 2];
        let isTarget = from + off == node.from && to + off == node.to && b[i] == node.type.id;
        children.push(isTarget ? node.toTree() : split(i + 4, b[i + 3], buf.set.types[b[i]], from, to - from));
        positions.push(from - innerOffset);
        sliceBuf(buf, b[i + 3], endI, children, positions, innerOffset);
        return new Tree(type, children, positions, length);
    }
    base.children[i] = split(0, b.length, NodeType.none, 0, buf.length);
    // Move the cursor back to the target node
    for (let d = 0; d <= depth; d++)
        cursor.childAfter(node.from);
}
class StructureCursor {
    constructor(root, offset) {
        this.offset = offset;
        this.done = false;
        this.cursor = root.cursor(IterMode.IncludeAnonymous | IterMode.IgnoreMounts);
    }
    // Move to the first node (in pre-order) that starts at or after `pos`.
    moveTo(pos) {
        let { cursor } = this, p = pos - this.offset;
        while (!this.done && cursor.from < p) {
            if (cursor.to >= pos && cursor.enter(p, 1, IterMode.IgnoreOverlays | IterMode.ExcludeBuffers)) ;
            else if (!cursor.next(false))
                this.done = true;
        }
    }
    hasNode(cursor) {
        this.moveTo(cursor.from);
        if (!this.done && this.cursor.from + this.offset == cursor.from && this.cursor.tree) {
            for (let tree = this.cursor.tree;;) {
                if (tree == cursor.tree)
                    return true;
                if (tree.children.length && tree.positions[0] == 0 && tree.children[0] instanceof Tree)
                    tree = tree.children[0];
                else
                    break;
            }
        }
        return false;
    }
}
class FragmentCursor {
    constructor(fragments) {
        var _a;
        this.fragments = fragments;
        this.curTo = 0;
        this.fragI = 0;
        if (fragments.length) {
            let first = this.curFrag = fragments[0];
            this.curTo = (_a = first.tree.prop(stoppedInner)) !== null && _a !== void 0 ? _a : first.to;
            this.inner = new StructureCursor(first.tree, -first.offset);
        }
        else {
            this.curFrag = this.inner = null;
        }
    }
    hasNode(node) {
        while (this.curFrag && node.from >= this.curTo)
            this.nextFrag();
        return this.curFrag && this.curFrag.from <= node.from && this.curTo >= node.to && this.inner.hasNode(node);
    }
    nextFrag() {
        var _a;
        this.fragI++;
        if (this.fragI == this.fragments.length) {
            this.curFrag = this.inner = null;
        }
        else {
            let frag = this.curFrag = this.fragments[this.fragI];
            this.curTo = (_a = frag.tree.prop(stoppedInner)) !== null && _a !== void 0 ? _a : frag.to;
            this.inner = new StructureCursor(frag.tree, -frag.offset);
        }
    }
    findMounts(pos, parser) {
        var _a;
        let result = [];
        if (this.inner) {
            this.inner.cursor.moveTo(pos, 1);
            for (let pos = this.inner.cursor.node; pos; pos = pos.parent) {
                let mount = (_a = pos.tree) === null || _a === void 0 ? void 0 : _a.prop(NodeProp.mounted);
                if (mount && mount.parser == parser) {
                    for (let i = this.fragI; i < this.fragments.length; i++) {
                        let frag = this.fragments[i];
                        if (frag.from >= pos.to)
                            break;
                        if (frag.tree == this.curFrag.tree)
                            result.push({
                                frag,
                                pos: pos.from - frag.offset,
                                mount
                            });
                    }
                }
            }
        }
        return result;
    }
}
function punchRanges(outer, ranges) {
    let copy = null, current = ranges;
    for (let i = 1, j = 0; i < outer.length; i++) {
        let gapFrom = outer[i - 1].to, gapTo = outer[i].from;
        for (; j < current.length; j++) {
            let r = current[j];
            if (r.from >= gapTo)
                break;
            if (r.to <= gapFrom)
                continue;
            if (!copy)
                current = copy = ranges.slice();
            if (r.from < gapFrom) {
                copy[j] = new Range(r.from, gapFrom);
                if (r.to > gapTo)
                    copy.splice(j + 1, 0, new Range(gapTo, r.to));
            }
            else if (r.to > gapTo) {
                copy[j--] = new Range(gapTo, r.to);
            }
            else {
                copy.splice(j--, 1);
            }
        }
    }
    return current;
}
function findCoverChanges(a, b, from, to) {
    let iA = 0, iB = 0, inA = false, inB = false, pos = -1e9;
    let result = [];
    for (;;) {
        let nextA = iA == a.length ? 1e9 : inA ? a[iA].to : a[iA].from;
        let nextB = iB == b.length ? 1e9 : inB ? b[iB].to : b[iB].from;
        if (inA != inB) {
            let start = Math.max(pos, from), end = Math.min(nextA, nextB, to);
            if (start < end)
                result.push(new Range(start, end));
        }
        pos = Math.min(nextA, nextB);
        if (pos == 1e9)
            break;
        if (nextA == pos) {
            if (!inA)
                inA = true;
            else {
                inA = false;
                iA++;
            }
        }
        if (nextB == pos) {
            if (!inB)
                inB = true;
            else {
                inB = false;
                iB++;
            }
        }
    }
    return result;
}
// Given a number of fragments for the outer tree, and a set of ranges
// to parse, find fragments for inner trees mounted around those
// ranges, if any.
function enterFragments(mounts, ranges) {
    let result = [];
    for (let { pos, mount, frag } of mounts) {
        let startPos = pos + (mount.overlay ? mount.overlay[0].from : 0), endPos = startPos + mount.tree.length;
        let from = Math.max(frag.from, startPos), to = Math.min(frag.to, endPos);
        if (mount.overlay) {
            let overlay = mount.overlay.map(r => new Range(r.from + pos, r.to + pos));
            let changes = findCoverChanges(ranges, overlay, from, to);
            for (let i = 0, pos = from;; i++) {
                let last = i == changes.length, end = last ? to : changes[i].from;
                if (end > pos)
                    result.push(new TreeFragment(pos, end, mount.tree, -startPos, frag.from >= pos || frag.openStart, frag.to <= end || frag.openEnd));
                if (last)
                    break;
                pos = changes[i].to;
            }
        }
        else {
            result.push(new TreeFragment(from, to, mount.tree, -startPos, frag.from >= startPos || frag.openStart, frag.to <= endPos || frag.openEnd));
        }
    }
    return result;
}




/***/ }),

/***/ 1087:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Gv": () => (/* binding */ styleTags),
/* harmony export */   "QR": () => (/* binding */ tagHighlighter),
/* harmony export */   "bW": () => (/* binding */ highlightTree),
/* harmony export */   "pJ": () => (/* binding */ tags)
/* harmony export */ });
/* unused harmony exports Tag, classHighlighter, getStyleTags */
/* harmony import */ var _lezer_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8731);


let nextTagID = 0;
/// Highlighting tags are markers that denote a highlighting category.
/// They are [associated](#highlight.styleTags) with parts of a syntax
/// tree by a language mode, and then mapped to an actual CSS style by
/// a [highlighter](#highlight.Highlighter).
///
/// Because syntax tree node types and highlight styles have to be
/// able to talk the same language, CodeMirror uses a mostly _closed_
/// [vocabulary](#highlight.tags) of syntax tags (as opposed to
/// traditional open string-based systems, which make it hard for
/// highlighting themes to cover all the tokens produced by the
/// various languages).
///
/// It _is_ possible to [define](#highlight.Tag^define) your own
/// highlighting tags for system-internal use (where you control both
/// the language package and the highlighter), but such tags will not
/// be picked up by regular highlighters (though you can derive them
/// from standard tags to allow highlighters to fall back to those).
class Tag {
    /// @internal
    constructor(
    /// The set of this tag and all its parent tags, starting with
    /// this one itself and sorted in order of decreasing specificity.
    set, 
    /// The base unmodified tag that this one is based on, if it's
    /// modified @internal
    base, 
    /// The modifiers applied to this.base @internal
    modified) {
        this.set = set;
        this.base = base;
        this.modified = modified;
        /// @internal
        this.id = nextTagID++;
    }
    /// Define a new tag. If `parent` is given, the tag is treated as a
    /// sub-tag of that parent, and
    /// [highlighters](#highlight.tagHighlighter) that don't mention
    /// this tag will try to fall back to the parent tag (or grandparent
    /// tag, etc).
    static define(parent) {
        if (parent === null || parent === void 0 ? void 0 : parent.base)
            throw new Error("Can not derive from a modified tag");
        let tag = new Tag([], null, []);
        tag.set.push(tag);
        if (parent)
            for (let t of parent.set)
                tag.set.push(t);
        return tag;
    }
    /// Define a tag _modifier_, which is a function that, given a tag,
    /// will return a tag that is a subtag of the original. Applying the
    /// same modifier to a twice tag will return the same value (`m1(t1)
    /// == m1(t1)`) and applying multiple modifiers will, regardless or
    /// order, produce the same tag (`m1(m2(t1)) == m2(m1(t1))`).
    ///
    /// When multiple modifiers are applied to a given base tag, each
    /// smaller set of modifiers is registered as a parent, so that for
    /// example `m1(m2(m3(t1)))` is a subtype of `m1(m2(t1))`,
    /// `m1(m3(t1)`, and so on.
    static defineModifier() {
        let mod = new Modifier;
        return (tag) => {
            if (tag.modified.indexOf(mod) > -1)
                return tag;
            return Modifier.get(tag.base || tag, tag.modified.concat(mod).sort((a, b) => a.id - b.id));
        };
    }
}
let nextModifierID = 0;
class Modifier {
    constructor() {
        this.instances = [];
        this.id = nextModifierID++;
    }
    static get(base, mods) {
        if (!mods.length)
            return base;
        let exists = mods[0].instances.find(t => t.base == base && sameArray(mods, t.modified));
        if (exists)
            return exists;
        let set = [], tag = new Tag(set, base, mods);
        for (let m of mods)
            m.instances.push(tag);
        let configs = permute(mods);
        for (let parent of base.set)
            for (let config of configs)
                set.push(Modifier.get(parent, config));
        return tag;
    }
}
function sameArray(a, b) {
    return a.length == b.length && a.every((x, i) => x == b[i]);
}
function permute(array) {
    let result = [array];
    for (let i = 0; i < array.length; i++) {
        for (let a of permute(array.slice(0, i).concat(array.slice(i + 1))))
            result.push(a);
    }
    return result;
}
/// This function is used to add a set of tags to a language syntax
/// via [`NodeSet.extend`](#common.NodeSet.extend) or
/// [`LRParser.configure`](#lr.LRParser.configure).
///
/// The argument object maps node selectors to [highlighting
/// tags](#highlight.Tag) or arrays of tags.
///
/// Node selectors may hold one or more (space-separated) node paths.
/// Such a path can be a [node name](#common.NodeType.name), or
/// multiple node names (or `*` wildcards) separated by slash
/// characters, as in `"Block/Declaration/VariableName"`. Such a path
/// matches the final node but only if its direct parent nodes are the
/// other nodes mentioned. A `*` in such a path matches any parent,
/// but only a single levelwildcards that match multiple parents
/// aren't supported, both for efficiency reasons and because Lezer
/// trees make it rather hard to reason about what they would match.)
///
/// A path can be ended with `/...` to indicate that the tag assigned
/// to the node should also apply to all child nodes, even if they
/// match their own style (by default, only the innermost style is
/// used).
///
/// When a path ends in `!`, as in `Attribute!`, no further matching
/// happens for the node's child nodes, and the entire node gets the
/// given style.
///
/// In this notation, node names that contain `/`, `!`, `*`, or `...`
/// must be quoted as JSON strings.
///
/// For example:
///
/// ```javascript
/// parser.withProps(
///   styleTags({
///     // Style Number and BigNumber nodes
///     "Number BigNumber": tags.number,
///     // Style Escape nodes whose parent is String
///     "String/Escape": tags.escape,
///     // Style anything inside Attributes nodes
///     "Attributes!": tags.meta,
///     // Add a style to all content inside Italic nodes
///     "Italic/...": tags.emphasis,
///     // Style InvalidString nodes as both `string` and `invalid`
///     "InvalidString": [tags.string, tags.invalid],
///     // Style the node named "/" as punctuation
///     '"/"': tags.punctuation
///   })
/// )
/// ```
function styleTags(spec) {
    let byName = Object.create(null);
    for (let prop in spec) {
        let tags = spec[prop];
        if (!Array.isArray(tags))
            tags = [tags];
        for (let part of prop.split(" "))
            if (part) {
                let pieces = [], mode = 2 /* Normal */, rest = part;
                for (let pos = 0;;) {
                    if (rest == "..." && pos > 0 && pos + 3 == part.length) {
                        mode = 1 /* Inherit */;
                        break;
                    }
                    let m = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(rest);
                    if (!m)
                        throw new RangeError("Invalid path: " + part);
                    pieces.push(m[0] == "*" ? "" : m[0][0] == '"' ? JSON.parse(m[0]) : m[0]);
                    pos += m[0].length;
                    if (pos == part.length)
                        break;
                    let next = part[pos++];
                    if (pos == part.length && next == "!") {
                        mode = 0 /* Opaque */;
                        break;
                    }
                    if (next != "/")
                        throw new RangeError("Invalid path: " + part);
                    rest = part.slice(pos);
                }
                let last = pieces.length - 1, inner = pieces[last];
                if (!inner)
                    throw new RangeError("Invalid path: " + part);
                let rule = new Rule(tags, mode, last > 0 ? pieces.slice(0, last) : null);
                byName[inner] = rule.sort(byName[inner]);
            }
    }
    return ruleNodeProp.add(byName);
}
const ruleNodeProp = new _lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .NodeProp */ .md();
class Rule {
    constructor(tags, mode, context, next) {
        this.tags = tags;
        this.mode = mode;
        this.context = context;
        this.next = next;
    }
    get opaque() { return this.mode == 0 /* Opaque */; }
    get inherit() { return this.mode == 1 /* Inherit */; }
    sort(other) {
        if (!other || other.depth < this.depth) {
            this.next = other;
            return this;
        }
        other.next = this.sort(other.next);
        return other;
    }
    get depth() { return this.context ? this.context.length : 0; }
}
Rule.empty = new Rule([], 2 /* Normal */, null);
/// Define a [highlighter](#highlight.Highlighter) from an array of
/// tag/class pairs. Classes associated with more specific tags will
/// take precedence.
function tagHighlighter(tags, options) {
    let map = Object.create(null);
    for (let style of tags) {
        if (!Array.isArray(style.tag))
            map[style.tag.id] = style.class;
        else
            for (let tag of style.tag)
                map[tag.id] = style.class;
    }
    let { scope, all = null } = options || {};
    return {
        style: (tags) => {
            let cls = all;
            for (let tag of tags) {
                for (let sub of tag.set) {
                    let tagClass = map[sub.id];
                    if (tagClass) {
                        cls = cls ? cls + " " + tagClass : tagClass;
                        break;
                    }
                }
            }
            return cls;
        },
        scope
    };
}
function highlightTags(highlighters, tags) {
    let result = null;
    for (let highlighter of highlighters) {
        let value = highlighter.style(tags);
        if (value)
            result = result ? result + " " + value : value;
    }
    return result;
}
/// Highlight the given [tree](#common.Tree) with the given
/// [highlighter](#highlight.Highlighter).
function highlightTree(tree, highlighter, 
/// Assign styling to a region of the text. Will be called, in order
/// of position, for any ranges where more than zero classes apply.
/// `classes` is a space separated string of CSS classes.
putStyle, 
/// The start of the range to highlight.
from = 0, 
/// The end of the range.
to = tree.length) {
    let builder = new HighlightBuilder(from, Array.isArray(highlighter) ? highlighter : [highlighter], putStyle);
    builder.highlightRange(tree.cursor(), from, to, "", builder.highlighters);
    builder.flush(to);
}
class HighlightBuilder {
    constructor(at, highlighters, span) {
        this.at = at;
        this.highlighters = highlighters;
        this.span = span;
        this.class = "";
    }
    startSpan(at, cls) {
        if (cls != this.class) {
            this.flush(at);
            if (at > this.at)
                this.at = at;
            this.class = cls;
        }
    }
    flush(to) {
        if (to > this.at && this.class)
            this.span(this.at, to, this.class);
    }
    highlightRange(cursor, from, to, inheritedClass, highlighters) {
        let { type, from: start, to: end } = cursor;
        if (start >= to || end <= from)
            return;
        if (type.isTop)
            highlighters = this.highlighters.filter(h => !h.scope || h.scope(type));
        let cls = inheritedClass;
        let rule = getStyleTags(cursor) || Rule.empty;
        let tagCls = highlightTags(highlighters, rule.tags);
        if (tagCls) {
            if (cls)
                cls += " ";
            cls += tagCls;
            if (rule.mode == 1 /* Inherit */)
                inheritedClass += (inheritedClass ? " " : "") + tagCls;
        }
        this.startSpan(cursor.from, cls);
        if (rule.opaque)
            return;
        let mounted = cursor.tree && cursor.tree.prop(_lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .NodeProp.mounted */ .md.mounted);
        if (mounted && mounted.overlay) {
            let inner = cursor.node.enter(mounted.overlay[0].from + start, 1);
            let innerHighlighters = this.highlighters.filter(h => !h.scope || h.scope(mounted.tree.type));
            let hasChild = cursor.firstChild();
            for (let i = 0, pos = start;; i++) {
                let next = i < mounted.overlay.length ? mounted.overlay[i] : null;
                let nextPos = next ? next.from + start : end;
                let rangeFrom = Math.max(from, pos), rangeTo = Math.min(to, nextPos);
                if (rangeFrom < rangeTo && hasChild) {
                    while (cursor.from < rangeTo) {
                        this.highlightRange(cursor, rangeFrom, rangeTo, inheritedClass, highlighters);
                        this.startSpan(Math.min(to, cursor.to), cls);
                        if (cursor.to >= nextPos || !cursor.nextSibling())
                            break;
                    }
                }
                if (!next || nextPos > to)
                    break;
                pos = next.to + start;
                if (pos > from) {
                    this.highlightRange(inner.cursor(), Math.max(from, next.from + start), Math.min(to, pos), inheritedClass, innerHighlighters);
                    this.startSpan(pos, cls);
                }
            }
            if (hasChild)
                cursor.parent();
        }
        else if (cursor.firstChild()) {
            do {
                if (cursor.to <= from)
                    continue;
                if (cursor.from >= to)
                    break;
                this.highlightRange(cursor, from, to, inheritedClass, highlighters);
                this.startSpan(Math.min(to, cursor.to), cls);
            } while (cursor.nextSibling());
            cursor.parent();
        }
    }
}
/// Match a syntax node's [highlight rules](#highlight.styleTags). If
/// there's a match, return its set of tags, and whether it is
/// opaque (uses a `!`) or applies to all child nodes (`/...`).
function getStyleTags(node) {
    let rule = node.type.prop(ruleNodeProp);
    while (rule && rule.context && !node.matchContext(rule.context))
        rule = rule.next;
    return rule || null;
}
const t = Tag.define;
const comment = t(), name = t(), typeName = t(name), propertyName = t(name), literal = t(), string = t(literal), number = t(literal), content = t(), heading = t(content), keyword = t(), operator = t(), punctuation = t(), bracket = t(punctuation), meta = t();
/// The default set of highlighting [tags](#highlight.Tag).
///
/// This collection is heavily biased towards programming languages,
/// and necessarily incomplete. A full ontology of syntactic
/// constructs would fill a stack of books, and be impractical to
/// write themes for. So try to make do with this set. If all else
/// fails, [open an
/// issue](https://github.com/codemirror/codemirror.next) to propose a
/// new tag, or [define](#highlight.Tag^define) a local custom tag for
/// your use case.
///
/// Note that it is not obligatory to always attach the most specific
/// tag possible to an elementif your grammar can't easily
/// distinguish a certain type of element (such as a local variable),
/// it is okay to style it as its more general variant (a variable).
/// 
/// For tags that extend some parent tag, the documentation links to
/// the parent.
const tags = {
    /// A comment.
    comment,
    /// A line [comment](#highlight.tags.comment).
    lineComment: t(comment),
    /// A block [comment](#highlight.tags.comment).
    blockComment: t(comment),
    /// A documentation [comment](#highlight.tags.comment).
    docComment: t(comment),
    /// Any kind of identifier.
    name,
    /// The [name](#highlight.tags.name) of a variable.
    variableName: t(name),
    /// A type [name](#highlight.tags.name).
    typeName: typeName,
    /// A tag name (subtag of [`typeName`](#highlight.tags.typeName)).
    tagName: t(typeName),
    /// A property or field [name](#highlight.tags.name).
    propertyName: propertyName,
    /// An attribute name (subtag of [`propertyName`](#highlight.tags.propertyName)).
    attributeName: t(propertyName),
    /// The [name](#highlight.tags.name) of a class.
    className: t(name),
    /// A label [name](#highlight.tags.name).
    labelName: t(name),
    /// A namespace [name](#highlight.tags.name).
    namespace: t(name),
    /// The [name](#highlight.tags.name) of a macro.
    macroName: t(name),
    /// A literal value.
    literal,
    /// A string [literal](#highlight.tags.literal).
    string,
    /// A documentation [string](#highlight.tags.string).
    docString: t(string),
    /// A character literal (subtag of [string](#highlight.tags.string)).
    character: t(string),
    /// An attribute value (subtag of [string](#highlight.tags.string)).
    attributeValue: t(string),
    /// A number [literal](#highlight.tags.literal).
    number,
    /// An integer [number](#highlight.tags.number) literal.
    integer: t(number),
    /// A floating-point [number](#highlight.tags.number) literal.
    float: t(number),
    /// A boolean [literal](#highlight.tags.literal).
    bool: t(literal),
    /// Regular expression [literal](#highlight.tags.literal).
    regexp: t(literal),
    /// An escape [literal](#highlight.tags.literal), for example a
    /// backslash escape in a string.
    escape: t(literal),
    /// A color [literal](#highlight.tags.literal).
    color: t(literal),
    /// A URL [literal](#highlight.tags.literal).
    url: t(literal),
    /// A language keyword.
    keyword,
    /// The [keyword](#highlight.tags.keyword) for the self or this
    /// object.
    self: t(keyword),
    /// The [keyword](#highlight.tags.keyword) for null.
    null: t(keyword),
    /// A [keyword](#highlight.tags.keyword) denoting some atomic value.
    atom: t(keyword),
    /// A [keyword](#highlight.tags.keyword) that represents a unit.
    unit: t(keyword),
    /// A modifier [keyword](#highlight.tags.keyword).
    modifier: t(keyword),
    /// A [keyword](#highlight.tags.keyword) that acts as an operator.
    operatorKeyword: t(keyword),
    /// A control-flow related [keyword](#highlight.tags.keyword).
    controlKeyword: t(keyword),
    /// A [keyword](#highlight.tags.keyword) that defines something.
    definitionKeyword: t(keyword),
    /// A [keyword](#highlight.tags.keyword) related to defining or
    /// interfacing with modules.
    moduleKeyword: t(keyword),
    /// An operator.
    operator,
    /// An [operator](#highlight.tags.operator) that dereferences something.
    derefOperator: t(operator),
    /// Arithmetic-related [operator](#highlight.tags.operator).
    arithmeticOperator: t(operator),
    /// Logical [operator](#highlight.tags.operator).
    logicOperator: t(operator),
    /// Bit [operator](#highlight.tags.operator).
    bitwiseOperator: t(operator),
    /// Comparison [operator](#highlight.tags.operator).
    compareOperator: t(operator),
    /// [Operator](#highlight.tags.operator) that updates its operand.
    updateOperator: t(operator),
    /// [Operator](#highlight.tags.operator) that defines something.
    definitionOperator: t(operator),
    /// Type-related [operator](#highlight.tags.operator).
    typeOperator: t(operator),
    /// Control-flow [operator](#highlight.tags.operator).
    controlOperator: t(operator),
    /// Program or markup punctuation.
    punctuation,
    /// [Punctuation](#highlight.tags.punctuation) that separates
    /// things.
    separator: t(punctuation),
    /// Bracket-style [punctuation](#highlight.tags.punctuation).
    bracket,
    /// Angle [brackets](#highlight.tags.bracket) (usually `<` and `>`
    /// tokens).
    angleBracket: t(bracket),
    /// Square [brackets](#highlight.tags.bracket) (usually `[` and `]`
    /// tokens).
    squareBracket: t(bracket),
    /// Parentheses (usually `(` and `)` tokens). Subtag of
    /// [bracket](#highlight.tags.bracket).
    paren: t(bracket),
    /// Braces (usually `{` and `}` tokens). Subtag of
    /// [bracket](#highlight.tags.bracket).
    brace: t(bracket),
    /// Content, for example plain text in XML or markup documents.
    content,
    /// [Content](#highlight.tags.content) that represents a heading.
    heading,
    /// A level 1 [heading](#highlight.tags.heading).
    heading1: t(heading),
    /// A level 2 [heading](#highlight.tags.heading).
    heading2: t(heading),
    /// A level 3 [heading](#highlight.tags.heading).
    heading3: t(heading),
    /// A level 4 [heading](#highlight.tags.heading).
    heading4: t(heading),
    /// A level 5 [heading](#highlight.tags.heading).
    heading5: t(heading),
    /// A level 6 [heading](#highlight.tags.heading).
    heading6: t(heading),
    /// A prose separator (such as a horizontal rule).
    contentSeparator: t(content),
    /// [Content](#highlight.tags.content) that represents a list.
    list: t(content),
    /// [Content](#highlight.tags.content) that represents a quote.
    quote: t(content),
    /// [Content](#highlight.tags.content) that is emphasized.
    emphasis: t(content),
    /// [Content](#highlight.tags.content) that is styled strong.
    strong: t(content),
    /// [Content](#highlight.tags.content) that is part of a link.
    link: t(content),
    /// [Content](#highlight.tags.content) that is styled as code or
    /// monospace.
    monospace: t(content),
    /// [Content](#highlight.tags.content) that has a strike-through
    /// style.
    strikethrough: t(content),
    /// Inserted text in a change-tracking format.
    inserted: t(),
    /// Deleted text.
    deleted: t(),
    /// Changed text.
    changed: t(),
    /// An invalid or unsyntactic element.
    invalid: t(),
    /// Metadata or meta-instruction.
    meta,
    /// [Metadata](#highlight.tags.meta) that applies to the entire
    /// document.
    documentMeta: t(meta),
    /// [Metadata](#highlight.tags.meta) that annotates or adds
    /// attributes to a given syntactic element.
    annotation: t(meta),
    /// Processing instruction or preprocessor directive. Subtag of
    /// [meta](#highlight.tags.meta).
    processingInstruction: t(meta),
    /// [Modifier](#highlight.Tag^defineModifier) that indicates that a
    /// given element is being defined. Expected to be used with the
    /// various [name](#highlight.tags.name) tags.
    definition: Tag.defineModifier(),
    /// [Modifier](#highlight.Tag^defineModifier) that indicates that
    /// something is constant. Mostly expected to be used with
    /// [variable names](#highlight.tags.variableName).
    constant: Tag.defineModifier(),
    /// [Modifier](#highlight.Tag^defineModifier) used to indicate that
    /// a [variable](#highlight.tags.variableName) or [property
    /// name](#highlight.tags.propertyName) is being called or defined
    /// as a function.
    function: Tag.defineModifier(),
    /// [Modifier](#highlight.Tag^defineModifier) that can be applied to
    /// [names](#highlight.tags.name) to indicate that they belong to
    /// the language's standard environment.
    standard: Tag.defineModifier(),
    /// [Modifier](#highlight.Tag^defineModifier) that indicates a given
    /// [names](#highlight.tags.name) is local to some scope.
    local: Tag.defineModifier(),
    /// A generic variant [modifier](#highlight.Tag^defineModifier) that
    /// can be used to tag language-specific alternative variants of
    /// some common tag. It is recommended for themes to define special
    /// forms of at least the [string](#highlight.tags.string) and
    /// [variable name](#highlight.tags.variableName) tags, since those
    /// come up a lot.
    special: Tag.defineModifier()
};
/// This is a highlighter that adds stable, predictable classes to
/// tokens, for styling with external CSS.
///
/// The following tags are mapped to their name prefixed with `"tok-"`
/// (for example `"tok-comment"`):
///
/// * [`link`](#highlight.tags.link)
/// * [`heading`](#highlight.tags.heading)
/// * [`emphasis`](#highlight.tags.emphasis)
/// * [`strong`](#highlight.tags.strong)
/// * [`keyword`](#highlight.tags.keyword)
/// * [`atom`](#highlight.tags.atom)
/// * [`bool`](#highlight.tags.bool)
/// * [`url`](#highlight.tags.url)
/// * [`labelName`](#highlight.tags.labelName)
/// * [`inserted`](#highlight.tags.inserted)
/// * [`deleted`](#highlight.tags.deleted)
/// * [`literal`](#highlight.tags.literal)
/// * [`string`](#highlight.tags.string)
/// * [`number`](#highlight.tags.number)
/// * [`variableName`](#highlight.tags.variableName)
/// * [`typeName`](#highlight.tags.typeName)
/// * [`namespace`](#highlight.tags.namespace)
/// * [`className`](#highlight.tags.className)
/// * [`macroName`](#highlight.tags.macroName)
/// * [`propertyName`](#highlight.tags.propertyName)
/// * [`operator`](#highlight.tags.operator)
/// * [`comment`](#highlight.tags.comment)
/// * [`meta`](#highlight.tags.meta)
/// * [`punctuation`](#highlight.tags.punctuation)
/// * [`invalid`](#highlight.tags.invalid)
///
/// In addition, these mappings are provided:
///
/// * [`regexp`](#highlight.tags.regexp),
///   [`escape`](#highlight.tags.escape), and
///   [`special`](#highlight.tags.special)[`(string)`](#highlight.tags.string)
///   are mapped to `"tok-string2"`
/// * [`special`](#highlight.tags.special)[`(variableName)`](#highlight.tags.variableName)
///   to `"tok-variableName2"`
/// * [`local`](#highlight.tags.local)[`(variableName)`](#highlight.tags.variableName)
///   to `"tok-variableName tok-local"`
/// * [`definition`](#highlight.tags.definition)[`(variableName)`](#highlight.tags.variableName)
///   to `"tok-variableName tok-definition"`
/// * [`definition`](#highlight.tags.definition)[`(propertyName)`](#highlight.tags.propertyName)
///   to `"tok-propertyName tok-definition"`
const classHighlighter = tagHighlighter([
    { tag: tags.link, class: "tok-link" },
    { tag: tags.heading, class: "tok-heading" },
    { tag: tags.emphasis, class: "tok-emphasis" },
    { tag: tags.strong, class: "tok-strong" },
    { tag: tags.keyword, class: "tok-keyword" },
    { tag: tags.atom, class: "tok-atom" },
    { tag: tags.bool, class: "tok-bool" },
    { tag: tags.url, class: "tok-url" },
    { tag: tags.labelName, class: "tok-labelName" },
    { tag: tags.inserted, class: "tok-inserted" },
    { tag: tags.deleted, class: "tok-deleted" },
    { tag: tags.literal, class: "tok-literal" },
    { tag: tags.string, class: "tok-string" },
    { tag: tags.number, class: "tok-number" },
    { tag: [tags.regexp, tags.escape, tags.special(tags.string)], class: "tok-string2" },
    { tag: tags.variableName, class: "tok-variableName" },
    { tag: tags.local(tags.variableName), class: "tok-variableName tok-local" },
    { tag: tags.definition(tags.variableName), class: "tok-variableName tok-definition" },
    { tag: tags.special(tags.variableName), class: "tok-variableName2" },
    { tag: tags.definition(tags.propertyName), class: "tok-propertyName tok-definition" },
    { tag: tags.typeName, class: "tok-typeName" },
    { tag: tags.namespace, class: "tok-namespace" },
    { tag: tags.className, class: "tok-className" },
    { tag: tags.macroName, class: "tok-macroName" },
    { tag: tags.propertyName, class: "tok-propertyName" },
    { tag: tags.operator, class: "tok-operator" },
    { tag: tags.comment, class: "tok-comment" },
    { tag: tags.meta, class: "tok-meta" },
    { tag: tags.invalid, class: "tok-invalid" },
    { tag: tags.punctuation, class: "tok-punctuation" }
]);




/***/ }),

/***/ 9277:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "wD": () => (/* binding */ FloatingFocusManager),
  "mN": () => (/* binding */ FloatingNode),
  "y0": () => (/* binding */ FloatingOverlay),
  "RB": () => (/* binding */ FloatingTree),
  "xp": () => (/* binding */ safePolygon),
  "eS": () => (/* binding */ useClick),
  "bQ": () => (/* binding */ useDismiss),
  "YF": () => (/* binding */ floating_ui_react_dom_interactions_useFloating),
  "jV": () => (/* binding */ useFloatingNodeId),
  "Zm": () => (/* binding */ useFloatingParentNodeId),
  "ay": () => (/* binding */ useFloatingTree),
  "XI": () => (/* binding */ useHover),
  "PC": () => (/* binding */ useId),
  "NI": () => (/* binding */ useInteractions),
  "c0": () => (/* binding */ useListNavigation),
  "qs": () => (/* binding */ useRole)
});

// UNUSED EXPORTS: FloatingDelayGroup, FloatingPortal, arrow, autoPlacement, autoUpdate, computePosition, detectOverflow, flip, getOverflowAncestors, hide, inline, inner, limitShift, offset, platform, shift, size, useDelayGroup, useDelayGroupContext, useFloatingPortalNode, useFocus, useInnerOffset, useTypeahead

// EXTERNAL MODULE: ./node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs
var floating_ui_dom = __webpack_require__(7555);
// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(4191);
var react_namespaceObject = /*#__PURE__*/__webpack_require__.t(react, 2);
// EXTERNAL MODULE: ./node_modules/react-dom/index.js
var react_dom = __webpack_require__(7668);
;// CONCATENATED MODULE: ./node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.mjs






var index = typeof document !== 'undefined' ? react.useLayoutEffect : react.useEffect;

// Fork of `fast-deep-equal` that only does the comparisons we need and compares
// functions
function deepEqual(a, b) {
  if (a === b) {
    return true;
  }

  if (typeof a !== typeof b) {
    return false;
  }

  if (typeof a === 'function' && a.toString() === b.toString()) {
    return true;
  }

  let length, i, keys;

  if (a && b && typeof a == 'object') {
    if (Array.isArray(a)) {
      length = a.length;
      if (length != b.length) return false;

      for (i = length; i-- !== 0;) {
        if (!deepEqual(a[i], b[i])) {
          return false;
        }
      }

      return true;
    }

    keys = Object.keys(a);
    length = keys.length;

    if (length !== Object.keys(b).length) {
      return false;
    }

    for (i = length; i-- !== 0;) {
      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) {
        return false;
      }
    }

    for (i = length; i-- !== 0;) {
      const key = keys[i];

      if (key === '_owner' && a.$$typeof) {
        continue;
      }

      if (!deepEqual(a[key], b[key])) {
        return false;
      }
    }

    return true;
  }

  return a !== a && b !== b;
}

function useLatestRef(value) {
  const ref = react.useRef(value);
  index(() => {
    ref.current = value;
  });
  return ref;
}

function useFloating(_temp) {
  let {
    middleware,
    placement = 'bottom',
    strategy = 'absolute',
    whileElementsMounted
  } = _temp === void 0 ? {} : _temp;
  const [data, setData] = react.useState({
    // Setting these to `null` will allow the consumer to determine if
    // `computePosition()` has run yet
    x: null,
    y: null,
    strategy,
    placement,
    middlewareData: {}
  });
  const [latestMiddleware, setLatestMiddleware] = react.useState(middleware);

  if (!deepEqual(latestMiddleware == null ? void 0 : latestMiddleware.map(_ref => {
    let {
      name,
      options
    } = _ref;
    return {
      name,
      options
    };
  }), middleware == null ? void 0 : middleware.map(_ref2 => {
    let {
      name,
      options
    } = _ref2;
    return {
      name,
      options
    };
  }))) {
    setLatestMiddleware(middleware);
  }

  const reference = react.useRef(null);
  const floating = react.useRef(null);
  const cleanupRef = react.useRef(null);
  const dataRef = react.useRef(data);
  const whileElementsMountedRef = useLatestRef(whileElementsMounted);
  const update = react.useCallback(() => {
    if (!reference.current || !floating.current) {
      return;
    }

    (0,floating_ui_dom/* computePosition */.oo)(reference.current, floating.current, {
      middleware: latestMiddleware,
      placement,
      strategy
    }).then(data => {
      if (isMountedRef.current && !deepEqual(dataRef.current, data)) {
        dataRef.current = data;
        react_dom.flushSync(() => {
          setData(data);
        });
      }
    });
  }, [latestMiddleware, placement, strategy]);
  index(() => {
    // Skip first update
    if (isMountedRef.current) {
      update();
    }
  }, [update]);
  const isMountedRef = react.useRef(false);
  index(() => {
    isMountedRef.current = true;
    return () => {
      isMountedRef.current = false;
    };
  }, []);
  const runElementMountCallback = react.useCallback(() => {
    if (typeof cleanupRef.current === 'function') {
      cleanupRef.current();
      cleanupRef.current = null;
    }

    if (reference.current && floating.current) {
      if (whileElementsMountedRef.current) {
        const cleanupFn = whileElementsMountedRef.current(reference.current, floating.current, update);
        cleanupRef.current = cleanupFn;
      } else {
        update();
      }
    }
  }, [update, whileElementsMountedRef]);
  const setReference = react.useCallback(node => {
    reference.current = node;
    runElementMountCallback();
  }, [runElementMountCallback]);
  const setFloating = react.useCallback(node => {
    floating.current = node;
    runElementMountCallback();
  }, [runElementMountCallback]);
  const refs = react.useMemo(() => ({
    reference,
    floating
  }), []);
  return react.useMemo(() => ({ ...data,
    update,
    refs,
    reference: setReference,
    floating: setFloating
  }), [data, update, refs, setReference, setFloating]);
}

/**
 * Positions an inner element of the floating element such that it is centered
 * to the reference element.
 * This wraps the core `arrow` middleware to allow React refs as the element.
 * @see https://floating-ui.com/docs/arrow
 */

const arrow = options => {
  const {
    element,
    padding
  } = options;

  function isRef(value) {
    return Object.prototype.hasOwnProperty.call(value, 'current');
  }

  return {
    name: 'arrow',
    options,

    fn(args) {
      if (isRef(element)) {
        if (element.current != null) {
          return arrow$1({
            element: element.current,
            padding
          }).fn(args);
        }

        return {};
      } else if (element) {
        return arrow$1({
          element,
          padding
        }).fn(args);
      }

      return {};
    }

  };
};



;// CONCATENATED MODULE: ./node_modules/aria-hidden/dist/es2015/index.js
var getDefaultParent = function (originalTarget) {
    if (typeof document === 'undefined') {
        return null;
    }
    var sampleTarget = Array.isArray(originalTarget) ? originalTarget[0] : originalTarget;
    return sampleTarget.ownerDocument.body;
};
var counterMap = new WeakMap();
var uncontrolledNodes = new WeakMap();
var markerMap = {};
var lockCount = 0;
/**
 * Marks everything except given node(or nodes) as aria-hidden
 * @param {Element | Element[]} originalTarget - elements to keep on the page
 * @param [parentNode] - top element, defaults to document.body
 * @param {String} [markerName] - a special attribute to mark every node
 * @param {String} [controlAttribute] - html Attribute to control
 * @return {Undo} undo command
 */
var applyAttributeToOthers = function (originalTarget, parentNode, markerName, controlAttribute) {
    var targets = Array.isArray(originalTarget) ? originalTarget : [originalTarget];
    if (!markerMap[markerName]) {
        markerMap[markerName] = new WeakMap();
    }
    var markerCounter = markerMap[markerName];
    var hiddenNodes = [];
    var elementsToKeep = new Set();
    var elementsToStop = new Set(targets);
    var keep = function (el) {
        if (!el || elementsToKeep.has(el)) {
            return;
        }
        elementsToKeep.add(el);
        keep(el.parentNode);
    };
    targets.forEach(keep);
    var deep = function (parent) {
        if (!parent || elementsToStop.has(parent)) {
            return;
        }
        Array.prototype.forEach.call(parent.children, function (node) {
            if (elementsToKeep.has(node)) {
                deep(node);
            }
            else {
                var attr = node.getAttribute(controlAttribute);
                var alreadyHidden = attr !== null && attr !== 'false';
                var counterValue = (counterMap.get(node) || 0) + 1;
                var markerValue = (markerCounter.get(node) || 0) + 1;
                counterMap.set(node, counterValue);
                markerCounter.set(node, markerValue);
                hiddenNodes.push(node);
                if (counterValue === 1 && alreadyHidden) {
                    uncontrolledNodes.set(node, true);
                }
                if (markerValue === 1) {
                    node.setAttribute(markerName, 'true');
                }
                if (!alreadyHidden) {
                    node.setAttribute(controlAttribute, 'true');
                }
            }
        });
    };
    deep(parentNode);
    elementsToKeep.clear();
    lockCount++;
    return function () {
        hiddenNodes.forEach(function (node) {
            var counterValue = counterMap.get(node) - 1;
            var markerValue = markerCounter.get(node) - 1;
            counterMap.set(node, counterValue);
            markerCounter.set(node, markerValue);
            if (!counterValue) {
                if (!uncontrolledNodes.has(node)) {
                    node.removeAttribute(controlAttribute);
                }
                uncontrolledNodes.delete(node);
            }
            if (!markerValue) {
                node.removeAttribute(markerName);
            }
        });
        lockCount--;
        if (!lockCount) {
            // clear
            counterMap = new WeakMap();
            counterMap = new WeakMap();
            uncontrolledNodes = new WeakMap();
            markerMap = {};
        }
    };
};
/**
 * Marks everything except given node(or nodes) as aria-hidden
 * @param {Element | Element[]} originalTarget - elements to keep on the page
 * @param [parentNode] - top element, defaults to document.body
 * @param {String} [markerName] - a special attribute to mark every node
 * @return {Undo} undo command
 */
var hideOthers = function (originalTarget, parentNode, markerName) {
    if (markerName === void 0) { markerName = 'data-aria-hidden'; }
    var targets = Array.from(Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
    var activeParentNode = parentNode || getDefaultParent(originalTarget);
    if (!activeParentNode) {
        return function () { return null; };
    }
    // we should not hide ariaLive elements - https://github.com/theKashey/aria-hidden/issues/10
    targets.push.apply(targets, Array.from(activeParentNode.querySelectorAll('[aria-live]')));
    return applyAttributeToOthers(targets, activeParentNode, markerName, 'aria-hidden');
};
/**
 * Marks everything except given node(or nodes) as inert
 * @param {Element | Element[]} originalTarget - elements to keep on the page
 * @param [parentNode] - top element, defaults to document.body
 * @param {String} [markerName] - a special attribute to mark every node
 * @return {Undo} undo command
 */
var inertOthers = function (originalTarget, parentNode, markerName) {
    if (markerName === void 0) { markerName = 'data-inert-ed'; }
    var activeParentNode = parentNode || getDefaultParent(originalTarget);
    if (!activeParentNode) {
        return function () { return null; };
    }
    return applyAttributeToOthers(originalTarget, activeParentNode, markerName, 'inert');
};
/**
 * @returns if current browser supports inert
 */
var supportsInert = function () {
    return typeof HTMLElement !== 'undefined' && HTMLElement.prototype.hasOwnProperty('inert');
};
/**
 * Automatic function to "suppress" DOM elements - _hide_ or _inert_ in the best possible way
 * @param {Element | Element[]} originalTarget - elements to keep on the page
 * @param [parentNode] - top element, defaults to document.body
 * @param {String} [markerName] - a special attribute to mark every node
 * @return {Undo} undo command
 */
var suppressOthers = function (originalTarget, parentNode, markerName) {
    if (markerName === void 0) { markerName = 'data-suppressed'; }
    return (supportsInert() ? inertOthers : hideOthers)(originalTarget, parentNode, markerName);
};

;// CONCATENATED MODULE: ./node_modules/@robocorp/ds/node_modules/@floating-ui/react-dom-interactions/dist/floating-ui.react-dom-interactions.mjs







var floating_ui_react_dom_interactions_index = typeof document !== 'undefined' ? react.useLayoutEffect : react.useEffect;

function createPubSub() {
  const map = new Map();
  return {
    emit(event, data) {
      var _map$get;

      (_map$get = map.get(event)) == null ? void 0 : _map$get.forEach(handler => handler(data));
    },

    on(event, listener) {
      map.set(event, [...(map.get(event) || []), listener]);
    },

    off(event, listener) {
      map.set(event, (map.get(event) || []).filter(l => l !== listener));
    }

  };
}

let serverHandoffComplete = false;
let count = 0;

const genId = () => "floating-ui-" + count++;

function useFloatingId() {
  const [id, setId] = react.useState(() => serverHandoffComplete ? genId() : undefined);
  floating_ui_react_dom_interactions_index(() => {
    if (id == null) {
      setId(genId());
    } // eslint-disable-next-line react-hooks/exhaustive-deps

  }, []);
  react.useEffect(() => {
    if (!serverHandoffComplete) {
      serverHandoffComplete = true;
    }
  }, []);
  return id;
} // `toString()` prevents bundlers from trying to `import { useId } from 'react'`


const useReactId = react_namespaceObject[/*#__PURE__*/'useId'.toString()];
/**
 * Uses React 18's built-in `useId()` when available, or falls back to a
 * slightly less performant (requiring a double render) implementation for
 * earlier React versions.
 * @see https://floating-ui.com/docs/useId
 */

const useId = useReactId != null ? useReactId : useFloatingId;

const FloatingNodeContext = /*#__PURE__*/react.createContext(null);
const FloatingTreeContext = /*#__PURE__*/react.createContext(null);
const useFloatingParentNodeId = () => {
  var _React$useContext$id, _React$useContext;

  return (_React$useContext$id = (_React$useContext = react.useContext(FloatingNodeContext)) == null ? void 0 : _React$useContext.id) != null ? _React$useContext$id : null;
};
const useFloatingTree = () => react.useContext(FloatingTreeContext);
/**
 * Registers a node into the floating tree, returning its id.
 */

const useFloatingNodeId = () => {
  const id = useId();
  const tree = useFloatingTree();
  const parentId = useFloatingParentNodeId();
  floating_ui_react_dom_interactions_index(() => {
    const node = {
      id,
      parentId
    };
    tree == null ? void 0 : tree.addNode(node);
    return () => {
      tree == null ? void 0 : tree.removeNode(node);
    };
  }, [tree, id, parentId]);
  return id;
};
/**
 * Provides parent node context for nested floating elements.
 * @see https://floating-ui.com/docs/FloatingTree
 */

const FloatingNode = _ref => {
  let {
    children,
    id
  } = _ref;
  const parentId = useFloatingParentNodeId();
  return /*#__PURE__*/react.createElement(FloatingNodeContext.Provider, {
    value: react.useMemo(() => ({
      id,
      parentId
    }), [id, parentId])
  }, children);
};
/**
 * Provides context for nested floating elements when they are not children of
 * each other on the DOM (i.e. portalled to a common node, rather than their
 * respective parent).
 * @see https://floating-ui.com/docs/FloatingTree
 */

const FloatingTree = _ref2 => {
  let {
    children
  } = _ref2;
  const nodesRef = react.useRef([]);
  const addNode = react.useCallback(node => {
    nodesRef.current = [...nodesRef.current, node];
  }, []);
  const removeNode = react.useCallback(node => {
    nodesRef.current = nodesRef.current.filter(n => n !== node);
  }, []);
  const events = react.useState(() => createPubSub())[0];
  return /*#__PURE__*/react.createElement(FloatingTreeContext.Provider, {
    value: react.useMemo(() => ({
      nodesRef,
      addNode,
      removeNode,
      events
    }), [nodesRef, addNode, removeNode, events])
  }, children);
};

function getDocument(floating) {
  var _floating$ownerDocume;

  return (_floating$ownerDocume = floating == null ? void 0 : floating.ownerDocument) != null ? _floating$ownerDocume : document;
}

function getWindow(value) {
  var _getDocument$defaultV;

  return (_getDocument$defaultV = getDocument(value).defaultView) != null ? _getDocument$defaultV : window;
}

function isElement(value) {
  return value ? value instanceof getWindow(value).Element : false;
}
function isHTMLElement(value) {
  return value ? value instanceof getWindow(value).HTMLElement : false;
}

// `toString()` prevents bundlers from trying to `import { useInsertionEffect } from 'react'`
const useInsertionEffect = react_namespaceObject[/*#__PURE__*/'useInsertionEffect'.toString()];
function useEvent(callback) {
  const ref = react.useRef(() => {
    if (false) {}
  });

  if (useInsertionEffect) {
    // eslint-disable-next-line react-hooks/rules-of-hooks
    useInsertionEffect(() => {
      ref.current = callback;
    });
  } else {
    ref.current = callback;
  }

  return react.useCallback(function () {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return ref.current == null ? void 0 : ref.current(...args);
  }, []);
}

function floating_ui_react_dom_interactions_useFloating(_temp) {
  let {
    open = false,
    onOpenChange: unstable_onOpenChange,
    whileElementsMounted,
    placement,
    middleware,
    strategy,
    nodeId
  } = _temp === void 0 ? {} : _temp;
  const [domReference, setDomReference] = react.useState(null);
  const tree = useFloatingTree();
  const domReferenceRef = react.useRef(null);
  const dataRef = react.useRef({});
  const events = react.useState(() => createPubSub())[0];
  const position = useFloating({
    placement,
    middleware,
    strategy,
    whileElementsMounted
  });
  const onOpenChange = useEvent(unstable_onOpenChange);
  const refs = react.useMemo(() => ({ ...position.refs,
    domReference: domReferenceRef
  }), [position.refs]);
  const context = react.useMemo(() => ({ ...position,
    refs,
    dataRef,
    nodeId,
    events,
    open,
    onOpenChange,
    _: {
      domReference
    }
  }), [position, nodeId, events, open, onOpenChange, refs, domReference]);
  floating_ui_react_dom_interactions_index(() => {
    const node = tree == null ? void 0 : tree.nodesRef.current.find(node => node.id === nodeId);

    if (node) {
      node.context = context;
    }
  });
  const {
    reference
  } = position;
  const setReference = react.useCallback(node => {
    if (isElement(node) || node === null) {
      context.refs.domReference.current = node;
      setDomReference(node);
    }

    reference(node);
  }, [reference, context.refs]);
  return react.useMemo(() => ({ ...position,
    context,
    refs,
    reference: setReference
  }), [position, refs, context, setReference]);
}

function mergeProps(userProps, propsList, elementKey) {
  const map = new Map();
  return { ...(elementKey === 'floating' && {
      tabIndex: -1
    }),
    ...userProps,
    ...propsList.map(value => value ? value[elementKey] : null).concat(userProps).reduce((acc, props) => {
      if (!props) {
        return acc;
      }

      Object.entries(props).forEach(_ref => {
        let [key, value] = _ref;

        if (key.indexOf('on') === 0) {
          if (!map.has(key)) {
            map.set(key, []);
          }

          if (typeof value === 'function') {
            var _map$get;

            (_map$get = map.get(key)) == null ? void 0 : _map$get.push(value);

            acc[key] = function () {
              var _map$get2;

              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }

              (_map$get2 = map.get(key)) == null ? void 0 : _map$get2.forEach(fn => fn(...args));
            };
          }
        } else {
          acc[key] = value;
        }
      });
      return acc;
    }, {})
  };
}

const useInteractions = function (propsList) {
  if (propsList === void 0) {
    propsList = [];
  }

  // The dependencies are a dynamic array, so we can't use the linter's
  // suggestion to add it to the deps array.
  const deps = propsList;
  const getReferenceProps = react.useCallback(userProps => mergeProps(userProps, propsList, 'reference'), // eslint-disable-next-line react-hooks/exhaustive-deps
  deps);
  const getFloatingProps = react.useCallback(userProps => mergeProps(userProps, propsList, 'floating'), // eslint-disable-next-line react-hooks/exhaustive-deps
  deps);
  const getItemProps = react.useCallback(userProps => mergeProps(userProps, propsList, 'item'), // eslint-disable-next-line react-hooks/exhaustive-deps
  deps);
  return react.useMemo(() => ({
    getReferenceProps,
    getFloatingProps,
    getItemProps
  }), [getReferenceProps, getFloatingProps, getItemProps]);
};

function getChildren(nodes, id) {
  var _nodes$filter;

  let allChildren = (_nodes$filter = nodes.filter(node => {
    var _node$context;

    return node.parentId === id && ((_node$context = node.context) == null ? void 0 : _node$context.open);
  })) != null ? _nodes$filter : [];
  let currentChildren = allChildren;

  while (currentChildren.length) {
    var _nodes$filter2;

    currentChildren = (_nodes$filter2 = nodes.filter(node => {
      var _currentChildren;

      return (_currentChildren = currentChildren) == null ? void 0 : _currentChildren.some(n => {
        var _node$context2;

        return node.parentId === n.id && ((_node$context2 = node.context) == null ? void 0 : _node$context2.open);
      });
    })) != null ? _nodes$filter2 : [];
    allChildren = allChildren.concat(currentChildren);
  }

  return allChildren;
}

function isPointInPolygon(point, polygon) {
  const [x, y] = point;
  let isInside = false;
  const length = polygon.length;

  for (let i = 0, j = length - 1; i < length; j = i++) {
    const [xi, yi] = polygon[i] || [0, 0];
    const [xj, yj] = polygon[j] || [0, 0];
    const intersect = yi >= y !== yj >= y && x <= (xj - xi) * (y - yi) / (yj - yi) + xi;

    if (intersect) {
      isInside = !isInside;
    }
  }

  return isInside;
}

function safePolygon(_temp) {
  let {
    restMs = 0,
    buffer = 0.5,
    blockPointerEvents = true,
    debug = null
  } = _temp === void 0 ? {} : _temp;
  let timeoutId;
  let polygonIsDestroyed = false;

  const fn = _ref => {
    let {
      x,
      y,
      placement,
      refs,
      onClose,
      nodeId,
      tree,
      leave = false
    } = _ref;
    return function onPointerMove(event) {
      var _refs$domReference$cu, _refs$floating$curren, _refs$floating$curren2;

      clearTimeout(timeoutId);

      function close() {
        clearTimeout(timeoutId);
        onClose();
      }

      if (event.pointerType && event.pointerType !== 'mouse') {
        return;
      }

      const {
        clientX,
        clientY
      } = event;
      const target = 'composedPath' in event ? event.composedPath()[0] : event.target;
      const targetNode = target; // If the pointer is over the reference, there is no need to run the logic

      if (event.type === 'pointermove' && (_refs$domReference$cu = refs.domReference.current) != null && _refs$domReference$cu.contains(targetNode)) {
        return;
      } // Prevent overlapping floating element from being stuck in an open-close
      // loop: https://github.com/floating-ui/floating-ui/issues/1910


      if (event.type === 'mouseleave' && isElement(event.relatedTarget) && (_refs$floating$curren = refs.floating.current) != null && _refs$floating$curren.contains(event.relatedTarget)) {
        return;
      } // If any nested child is open, abort.


      if (tree && getChildren(tree.nodesRef.current, nodeId).some(_ref2 => {
        let {
          context
        } = _ref2;
        return context == null ? void 0 : context.open;
      })) {
        return;
      } // The cursor landed, so we destroy the polygon logic


      if ((_refs$floating$curren2 = refs.floating.current) != null && _refs$floating$curren2.contains(targetNode) && !leave) {
        polygonIsDestroyed = true;
        return;
      }

      if (!refs.domReference.current || !refs.floating.current || placement == null || x == null || y == null) {
        return;
      }

      const refRect = refs.domReference.current.getBoundingClientRect();
      const rect = refs.floating.current.getBoundingClientRect();
      const side = placement.split('-')[0];
      const cursorLeaveFromRight = x > rect.right - rect.width / 2;
      const cursorLeaveFromBottom = y > rect.bottom - rect.height / 2; // If the pointer is leaving from the opposite side, the "buffer" logic
      // creates a point where the floating element remains open, but should be
      // ignored.
      // A constant of 1 handles floating point rounding errors.

      if (side === 'top' && y >= refRect.bottom - 1 || side === 'bottom' && y <= refRect.top + 1 || side === 'left' && x >= refRect.right - 1 || side === 'right' && x <= refRect.left + 1) {
        return close();
      } // Ignore when the cursor is within the rectangular trough between the
      // two elements. Since the triangle is created from the cursor point,
      // which can start beyond the ref element's edge, traversing back and
      // forth from the ref to the floating element can cause it to close. This
      // ensures it always remains open in that case.


      switch (side) {
        case 'top':
          if (clientX >= rect.left && clientX <= rect.right && clientY >= rect.top && clientY <= refRect.top + 1) {
            return;
          }

          break;

        case 'bottom':
          if (clientX >= rect.left && clientX <= rect.right && clientY >= refRect.bottom - 1 && clientY <= rect.bottom) {
            return;
          }

          break;

        case 'left':
          if (clientX >= rect.left && clientX <= refRect.left + 1 && clientY >= rect.top && clientY <= rect.bottom) {
            return;
          }

          break;

        case 'right':
          if (clientX >= refRect.right - 1 && clientX <= rect.right && clientY >= rect.top && clientY <= rect.bottom) {
            return;
          }

          break;
      }

      if (polygonIsDestroyed) {
        return close();
      }

      function getPolygon(_ref3) {
        let [x, y] = _ref3;
        const isFloatingWider = rect.width > refRect.width;
        const isFloatingTaller = rect.height > refRect.height;

        switch (side) {
          case 'top':
            {
              const cursorPointOne = [isFloatingWider ? x + buffer / 2 : cursorLeaveFromRight ? x + buffer * 4 : x - buffer * 4, y + buffer + 1];
              const cursorPointTwo = [isFloatingWider ? x - buffer / 2 : cursorLeaveFromRight ? x + buffer * 4 : x - buffer * 4, y + buffer + 1];
              const commonPoints = [[rect.left, cursorLeaveFromRight ? rect.bottom - buffer : isFloatingWider ? rect.bottom - buffer : rect.top], [rect.right, cursorLeaveFromRight ? isFloatingWider ? rect.bottom - buffer : rect.top : rect.bottom - buffer]];
              return [cursorPointOne, cursorPointTwo, ...commonPoints];
            }

          case 'bottom':
            {
              const cursorPointOne = [isFloatingWider ? x + buffer / 2 : cursorLeaveFromRight ? x + buffer * 4 : x - buffer * 4, y - buffer];
              const cursorPointTwo = [isFloatingWider ? x - buffer / 2 : cursorLeaveFromRight ? x + buffer * 4 : x - buffer * 4, y - buffer];
              const commonPoints = [[rect.left, cursorLeaveFromRight ? rect.top + buffer : isFloatingWider ? rect.top + buffer : rect.bottom], [rect.right, cursorLeaveFromRight ? isFloatingWider ? rect.top + buffer : rect.bottom : rect.top + buffer]];
              return [cursorPointOne, cursorPointTwo, ...commonPoints];
            }

          case 'left':
            {
              const cursorPointOne = [x + buffer + 1, isFloatingTaller ? y + buffer / 2 : cursorLeaveFromBottom ? y + buffer * 4 : y - buffer * 4];
              const cursorPointTwo = [x + buffer + 1, isFloatingTaller ? y - buffer / 2 : cursorLeaveFromBottom ? y + buffer * 4 : y - buffer * 4];
              const commonPoints = [[cursorLeaveFromBottom ? rect.right - buffer : isFloatingTaller ? rect.right - buffer : rect.left, rect.top], [cursorLeaveFromBottom ? isFloatingTaller ? rect.right - buffer : rect.left : rect.right - buffer, rect.bottom]];
              return [...commonPoints, cursorPointOne, cursorPointTwo];
            }

          case 'right':
            {
              const cursorPointOne = [x - buffer, isFloatingTaller ? y + buffer / 2 : cursorLeaveFromBottom ? y + buffer * 4 : y - buffer * 4];
              const cursorPointTwo = [x - buffer, isFloatingTaller ? y - buffer / 2 : cursorLeaveFromBottom ? y + buffer * 4 : y - buffer * 4];
              const commonPoints = [[cursorLeaveFromBottom ? rect.left + buffer : isFloatingTaller ? rect.left + buffer : rect.right, rect.top], [cursorLeaveFromBottom ? isFloatingTaller ? rect.left + buffer : rect.right : rect.left + buffer, rect.bottom]];
              return [cursorPointOne, cursorPointTwo, ...commonPoints];
            }
        }
      }

      const poly = getPolygon([x, y]);

      if (false) {}

      if (!isPointInPolygon([clientX, clientY], poly)) {
        close();
      } else if (restMs) {
        timeoutId = setTimeout(onClose, restMs);
      }
    };
  };

  fn.__options = {
    blockPointerEvents
  };
  return fn;
}

const DEFAULT_ID = 'floating-ui-root';
const useFloatingPortalNode = function (_temp) {
  let {
    id = DEFAULT_ID,
    enabled = true
  } = _temp === void 0 ? {} : _temp;
  const [portalEl, setPortalEl] = React.useState(null);
  floating_ui_react_dom_interactions_index(() => {
    if (!enabled) {
      return;
    }

    const rootNode = document.getElementById(id);

    if (rootNode) {
      setPortalEl(rootNode);
    } else {
      const newPortalEl = document.createElement('div');
      newPortalEl.id = id;
      setPortalEl(newPortalEl);

      if (!document.body.contains(newPortalEl)) {
        document.body.appendChild(newPortalEl);
      }
    }
  }, [id, enabled]);
  return portalEl;
};
/**
 * Portals your floating element outside of the main app node.
 * @see https://floating-ui.com/docs/FloatingPortal
 */

const FloatingPortal = _ref => {
  let {
    children,
    id = DEFAULT_ID,
    root = null
  } = _ref;
  const portalNode = useFloatingPortalNode({
    id,
    enabled: !root
  });

  if (root) {
    return /*#__PURE__*/createPortal(children, root);
  }

  if (portalNode) {
    return /*#__PURE__*/createPortal(children, portalNode);
  }

  return null;
};

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

// Avoid Chrome DevTools blue warning
function getPlatform() {
  const uaData = navigator.userAgentData;

  if (uaData != null && uaData.platform) {
    return uaData.platform;
  }

  return navigator.platform;
}
function getUserAgent() {
  const uaData = navigator.userAgentData;

  if (uaData != null && uaData.brands) {
    return uaData.brands.map(_ref => {
      let {
        brand,
        version
      } = _ref;
      return brand + "/" + version;
    }).join(' ');
  }

  return navigator.userAgent;
}

const identifier = 'data-floating-ui-scroll-lock';
/**
 * Provides base styling for a fixed overlay element to dim content or block
 * pointer events behind a floating element.
 * It's a regular `<div>`, so it can be styled via any CSS solution you prefer.
 * @see https://floating-ui.com/docs/FloatingOverlay
 */

const FloatingOverlay = /*#__PURE__*/react.forwardRef(function FloatingOverlay(_ref, ref) {
  let {
    lockScroll = false,
    ...rest
  } = _ref;
  floating_ui_react_dom_interactions_index(() => {
    var _window$visualViewpor, _window$visualViewpor2, _window$visualViewpor3, _window$visualViewpor4;

    if (!lockScroll) {
      return;
    }

    const alreadyLocked = document.body.hasAttribute(identifier);

    if (alreadyLocked) {
      return;
    }

    document.body.setAttribute(identifier, ''); // RTL <body> scrollbar

    const scrollbarX = Math.round(document.documentElement.getBoundingClientRect().left) + document.documentElement.scrollLeft;
    const paddingProp = scrollbarX ? 'paddingLeft' : 'paddingRight';
    const scrollbarWidth = window.innerWidth - document.documentElement.clientWidth; // Only iOS doesn't respect `overflow: hidden` on document.body, and this
    // technique has fewer side effects.

    if (!/iP(hone|ad|od)|iOS/.test(getPlatform())) {
      Object.assign(document.body.style, {
        overflow: 'hidden',
        [paddingProp]: scrollbarWidth + "px"
      });
      return () => {
        document.body.removeAttribute(identifier);
        Object.assign(document.body.style, {
          overflow: '',
          [paddingProp]: ''
        });
      };
    } // iOS 12 does not support `visuaViewport`.


    const offsetLeft = (_window$visualViewpor = (_window$visualViewpor2 = window.visualViewport) == null ? void 0 : _window$visualViewpor2.offsetLeft) != null ? _window$visualViewpor : 0;
    const offsetTop = (_window$visualViewpor3 = (_window$visualViewpor4 = window.visualViewport) == null ? void 0 : _window$visualViewpor4.offsetTop) != null ? _window$visualViewpor3 : 0;
    const scrollX = window.pageXOffset;
    const scrollY = window.pageYOffset;
    Object.assign(document.body.style, {
      position: 'fixed',
      overflow: 'hidden',
      top: -(scrollY - Math.floor(offsetTop)) + "px",
      left: -(scrollX - Math.floor(offsetLeft)) + "px",
      right: '0',
      [paddingProp]: scrollbarWidth + "px"
    });
    return () => {
      Object.assign(document.body.style, {
        position: '',
        overflow: '',
        top: '',
        left: '',
        right: '',
        [paddingProp]: ''
      });
      document.body.removeAttribute(identifier);
      window.scrollTo(scrollX, scrollY);
    };
  }, [lockScroll]);
  return /*#__PURE__*/react.createElement("div", _extends({
    ref: ref
  }, rest, {
    style: {
      position: 'fixed',
      overflow: 'auto',
      top: 0,
      right: 0,
      bottom: 0,
      left: 0,
      ...rest.style
    }
  }));
});

/**
 * Find the real active element. Traverses into shadowRoots.
 */
function activeElement(doc) {
  let activeElement = doc.activeElement;

  while (((_activeElement = activeElement) == null ? void 0 : (_activeElement$shadow = _activeElement.shadowRoot) == null ? void 0 : _activeElement$shadow.activeElement) != null) {
    var _activeElement, _activeElement$shadow;

    activeElement = activeElement.shadowRoot.activeElement;
  }

  return activeElement;
}

function getAncestors(nodes, id) {
  var _nodes$find;

  let allAncestors = [];
  let currentParentId = (_nodes$find = nodes.find(node => node.id === id)) == null ? void 0 : _nodes$find.parentId;

  while (currentParentId) {
    const currentNode = nodes.find(node => node.id === currentParentId);
    currentParentId = currentNode == null ? void 0 : currentNode.parentId;

    if (currentNode) {
      allAncestors = allAncestors.concat(currentNode);
    }
  }

  return allAncestors;
}

function getTarget(event) {
  if ('composedPath' in event) {
    return event.composedPath()[0];
  } // TS thinks `event` is of type never as it assumes all browsers support
  // `composedPath()`, but browsers without shadow DOM don't.


  return event.target;
}

const TYPEABLE_SELECTOR = "input:not([type='hidden']):not([disabled])," + "[contenteditable]:not([contenteditable='false']),textarea:not([disabled])";
function isTypeableElement(element) {
  return isHTMLElement(element) && element.matches(TYPEABLE_SELECTOR);
}

function stopEvent(event) {
  event.preventDefault();
  event.stopPropagation();
}

function floating_ui_react_dom_interactions_useLatestRef(value) {
  const ref = (0,react.useRef)(value);
  floating_ui_react_dom_interactions_index(() => {
    ref.current = value;
  });
  return ref;
}

function floating_ui_react_dom_interactions_focus(el, preventScroll) {
  if (preventScroll === void 0) {
    preventScroll = false;
  }

  // `mousedown` clicks occur before `focus`, so the button will steal the
  // focus unless we wait a frame.
  requestAnimationFrame(() => {
    el == null ? void 0 : el.focus({
      preventScroll
    });
  });
}

const SELECTOR = 'select:not([disabled]),a[href],button:not([disabled]),[tabindex],' + 'iframe,object,embed,area[href],audio[controls],video[controls],' + TYPEABLE_SELECTOR;
const FocusGuard = /*#__PURE__*/react.forwardRef(function FocusGuard(props, ref) {
  return /*#__PURE__*/react.createElement("span", _extends({}, props, {
    ref: ref,
    tabIndex: 0,
    style: {
      position: 'fixed',
      opacity: '0',
      pointerEvents: 'none',
      outline: '0'
    }
  }));
});

/**
 * Provides focus management for the floating element.
 * @see https://floating-ui.com/docs/FloatingFocusManager
 */
function FloatingFocusManager(_ref) {
  let {
    context: {
      refs,
      nodeId,
      onOpenChange,
      dataRef,
      events
    },
    children,
    order = ['content'],
    endGuard = true,
    initialFocus = 0,
    returnFocus = true,
    modal = true
  } = _ref;
  const orderRef = floating_ui_react_dom_interactions_useLatestRef(order);
  const tree = useFloatingTree();
  const getTabbableElements = react.useCallback(() => {
    return orderRef.current.map(type => {
      if (type === 'reference') {
        return refs.domReference.current;
      }

      if (refs.floating.current && type === 'floating') {
        return refs.floating.current;
      }

      if (type === 'content') {
        var _refs$floating$curren, _refs$floating$curren2;

        return Array.from((_refs$floating$curren = (_refs$floating$curren2 = refs.floating.current) == null ? void 0 : _refs$floating$curren2.querySelectorAll(SELECTOR)) != null ? _refs$floating$curren : []);
      }

      return null;
    }).flat().filter(el => {
      if (el === refs.floating.current || el === refs.domReference.current) {
        return true;
      }

      if (isHTMLElement(el)) {
        var _el$getAttribute;

        const tabIndex = (_el$getAttribute = el.getAttribute('tabindex')) != null ? _el$getAttribute : '0';
        return tabIndex[0].trim() !== '-';
      }
    });
  }, [orderRef, refs]);
  react.useEffect(() => {
    if (!modal) {
      return;
    } // If the floating element has no focusable elements inside it, fallback
    // to focusing the floating element and preventing tab navigation


    const noTabbableContentElements = getTabbableElements().filter(el => el !== refs.floating.current && el !== refs.domReference.current).length === 0;

    function onKeyDown(event) {
      if (event.key === 'Tab') {
        if (noTabbableContentElements) {
          stopEvent(event);
        }

        const els = getTabbableElements();
        const target = getTarget(event);

        if (orderRef.current[0] === 'reference' && target === refs.domReference.current) {
          stopEvent(event);

          if (event.shiftKey) {
            floating_ui_react_dom_interactions_focus(els[els.length - 1]);
          } else {
            floating_ui_react_dom_interactions_focus(els[1]);
          }
        }

        if (orderRef.current[1] === 'floating' && target === refs.floating.current && event.shiftKey) {
          stopEvent(event);
          floating_ui_react_dom_interactions_focus(els[0]);
        }
      }
    }

    const doc = getDocument(refs.floating.current);
    doc.addEventListener('keydown', onKeyDown);
    return () => {
      doc.removeEventListener('keydown', onKeyDown);
    };
  }, [modal, getTabbableElements, orderRef, refs]);
  react.useEffect(() => {
    let isPointerDown = false;

    function onFocusOut(event) {
      var _refs$floating$curren3, _getAncestors;

      const relatedTarget = event.relatedTarget;
      const focusMovedOutsideFloating = !((_refs$floating$curren3 = refs.floating.current) != null && _refs$floating$curren3.contains(relatedTarget));
      const focusMovedOutsideReference = isElement(refs.domReference.current) && !refs.domReference.current.contains(relatedTarget);
      const isChildOpen = tree && getChildren(tree.nodesRef.current, nodeId).length > 0;
      const isParentRelated = tree && event.currentTarget === refs.domReference.current && ((_getAncestors = getAncestors(tree.nodesRef.current, nodeId)) == null ? void 0 : _getAncestors.some(node => {
        var _node$context, _node$context$refs$fl;

        return (_node$context = node.context) == null ? void 0 : (_node$context$refs$fl = _node$context.refs.floating.current) == null ? void 0 : _node$context$refs$fl.contains(relatedTarget);
      }));

      if (focusMovedOutsideFloating && focusMovedOutsideReference && !isChildOpen && !isParentRelated && !isPointerDown) {
        onOpenChange(false);
      }
    }

    function onPointerDown() {
      // In Safari, buttons *lose* focus when pressing them. This causes the
      // reference `focusout` to fire, which closes the floating element.
      isPointerDown = true;
      setTimeout(() => {
        isPointerDown = false;
      });
    }

    const floating = refs.floating.current;
    const reference = refs.domReference.current;

    if (floating && isHTMLElement(reference)) {
      if (!modal) {
        floating.addEventListener('focusout', onFocusOut);
        reference.addEventListener('focusout', onFocusOut);
        reference.addEventListener('pointerdown', onPointerDown);
      }

      let cleanup;

      if (modal) {
        if (orderRef.current.includes('reference')) {
          cleanup = hideOthers([reference, floating]);
        } else {
          cleanup = hideOthers(floating);
        }
      }

      return () => {
        if (!modal) {
          floating.removeEventListener('focusout', onFocusOut);
          reference.removeEventListener('focusout', onFocusOut);
          reference.removeEventListener('pointerdown', onPointerDown);
        }

        cleanup == null ? void 0 : cleanup();
      };
    }
  }, [nodeId, tree, modal, onOpenChange, orderRef, dataRef, getTabbableElements, refs]);
  react.useEffect(() => {
    const floating = refs.floating.current;
    const doc = getDocument(floating);
    let returnFocusValue = returnFocus;
    let preventReturnFocusScroll = false;
    let previouslyFocusedElement = activeElement(doc);

    if (previouslyFocusedElement === doc.body && refs.domReference.current) {
      previouslyFocusedElement = refs.domReference.current;
    }

    if (typeof initialFocus === 'number') {
      var _getTabbableElements$;

      const el = (_getTabbableElements$ = getTabbableElements()[initialFocus]) != null ? _getTabbableElements$ : floating;
      floating_ui_react_dom_interactions_focus(el, el === floating);
    } else if (isHTMLElement(initialFocus.current)) {
      var _initialFocus$current;

      const el = (_initialFocus$current = initialFocus.current) != null ? _initialFocus$current : floating;
      floating_ui_react_dom_interactions_focus(el, el === floating);
    } // Dismissing via outside press should always ignore `returnFocus` to
    // prevent unwanted scrolling.


    function onDismiss(allowReturnFocus) {
      if (allowReturnFocus === void 0) {
        allowReturnFocus = false;
      }

      if (typeof allowReturnFocus === 'object') {
        returnFocusValue = true;
        preventReturnFocusScroll = allowReturnFocus.preventScroll;
      } else {
        returnFocusValue = allowReturnFocus;
      }
    }

    events.on('dismiss', onDismiss);
    return () => {
      events.off('dismiss', onDismiss);

      if (returnFocusValue && isHTMLElement(previouslyFocusedElement)) {
        floating_ui_react_dom_interactions_focus(previouslyFocusedElement, preventReturnFocusScroll);
      }
    };
  }, [getTabbableElements, initialFocus, returnFocus, refs, events]);

  const isTypeableCombobox = () => {
    var _refs$domReference$cu;

    return ((_refs$domReference$cu = refs.domReference.current) == null ? void 0 : _refs$domReference$cu.getAttribute('role')) === 'combobox' && isTypeableElement(refs.domReference.current);
  };

  return /*#__PURE__*/react.createElement(react.Fragment, null, modal && /*#__PURE__*/react.createElement(FocusGuard, {
    onFocus: event => {
      if (isTypeableCombobox()) {
        return;
      }

      stopEvent(event);
      const els = getTabbableElements();

      if (order[0] === 'reference') {
        floating_ui_react_dom_interactions_focus(els[0]);
      } else {
        floating_ui_react_dom_interactions_focus(els[els.length - 1]);
      }
    }
  }), /*#__PURE__*/react.cloneElement(children, order.includes('floating') ? {
    tabIndex: 0
  } : {}), modal && endGuard && /*#__PURE__*/react.createElement(FocusGuard, {
    onFocus: event => {
      if (isTypeableCombobox()) {
        return;
      }

      stopEvent(event);
      floating_ui_react_dom_interactions_focus(getTabbableElements()[0]);
    }
  }));
}

function usePrevious(value) {
  const ref = (0,react.useRef)();
  floating_ui_react_dom_interactions_index(() => {
    ref.current = value;
  }, [value]);
  return ref.current;
}

function getDelay(value, prop, pointerType) {
  if (pointerType && pointerType !== 'mouse') {
    return 0;
  }

  if (typeof value === 'number') {
    return value;
  }

  return value == null ? void 0 : value[prop];
}

/**
 * Adds hover event listeners that change the open state, like CSS :hover.
 * @see https://floating-ui.com/docs/useHover
 */
const useHover = function (context, _temp) {
  let {
    enabled = true,
    delay = 0,
    handleClose = null,
    mouseOnly = false,
    restMs = 0,
    move = true
  } = _temp === void 0 ? {} : _temp;
  const {
    open,
    onOpenChange,
    dataRef,
    events,
    refs,
    _
  } = context;
  const tree = useFloatingTree();
  const parentId = useFloatingParentNodeId();
  const handleCloseRef = floating_ui_react_dom_interactions_useLatestRef(handleClose);
  const delayRef = floating_ui_react_dom_interactions_useLatestRef(delay);
  const previousOpen = usePrevious(open);
  const pointerTypeRef = react.useRef();
  const timeoutRef = react.useRef();
  const handlerRef = react.useRef();
  const restTimeoutRef = react.useRef();
  const blockMouseMoveRef = react.useRef(true);
  const performedPointerEventsMutationRef = react.useRef(false);
  const isHoverOpen = react.useCallback(() => {
    var _dataRef$current$open;

    const type = (_dataRef$current$open = dataRef.current.openEvent) == null ? void 0 : _dataRef$current$open.type;
    return (type == null ? void 0 : type.includes('mouse')) && type !== 'mousedown';
  }, [dataRef]);
  react.useEffect(() => {
    if (!enabled) {
      return;
    }

    function onDismiss() {
      clearTimeout(timeoutRef.current);
      clearTimeout(restTimeoutRef.current);
      blockMouseMoveRef.current = true;
    }

    events.on('dismiss', onDismiss);
    return () => {
      events.off('dismiss', onDismiss);
    };
  }, [enabled, events, refs]);
  react.useEffect(() => {
    if (!enabled || !handleCloseRef.current) {
      return;
    }

    function onLeave() {
      if (isHoverOpen()) {
        onOpenChange(false);
      }
    }

    const html = getDocument(refs.floating.current).documentElement;
    html.addEventListener('mouseleave', onLeave);
    return () => {
      html.removeEventListener('mouseleave', onLeave);
    };
  }, [refs, onOpenChange, enabled, handleCloseRef, dataRef, isHoverOpen]);
  const closeWithDelay = react.useCallback(function (runElseBranch) {
    if (runElseBranch === void 0) {
      runElseBranch = true;
    }

    const closeDelay = getDelay(delayRef.current, 'close', pointerTypeRef.current);

    if (closeDelay && !handlerRef.current) {
      clearTimeout(timeoutRef.current);
      timeoutRef.current = setTimeout(() => onOpenChange(false), closeDelay);
    } else if (runElseBranch) {
      clearTimeout(timeoutRef.current);
      onOpenChange(false);
    }
  }, [delayRef, onOpenChange]);
  const cleanupPointerMoveHandler = react.useCallback(() => {
    if (handlerRef.current) {
      getDocument(refs.floating.current).removeEventListener('pointermove', handlerRef.current);
      handlerRef.current = undefined;
    }
  }, [refs]);
  const clearPointerEvents = react.useCallback(() => {
    getDocument(refs.floating.current).body.style.pointerEvents = '';
    performedPointerEventsMutationRef.current = false;
  }, [refs]); // Registering the mouse events on the reference directly to bypass React's
  // delegation system. If the cursor was on a disabled element and then entered
  // the reference (no gap), `mouseenter` doesn't fire in the delegation system.

  react.useEffect(() => {
    if (!enabled) {
      return;
    }

    function isClickLikeOpenEvent() {
      return dataRef.current.openEvent ? ['click', 'mousedown'].includes(dataRef.current.openEvent.type) : false;
    }

    function onMouseEnter(event) {
      clearTimeout(timeoutRef.current);
      blockMouseMoveRef.current = false;

      if (mouseOnly && pointerTypeRef.current !== 'mouse' || restMs > 0 && getDelay(delayRef.current, 'open') === 0) {
        return;
      }

      dataRef.current.openEvent = event;
      const openDelay = getDelay(delayRef.current, 'open', pointerTypeRef.current);

      if (openDelay) {
        timeoutRef.current = setTimeout(() => {
          onOpenChange(true);
        }, openDelay);
      } else {
        onOpenChange(true);
      }
    }

    function onMouseLeave(event) {
      if (isClickLikeOpenEvent()) {
        return;
      }

      const doc = getDocument(refs.floating.current);
      clearTimeout(restTimeoutRef.current);

      if (handleCloseRef.current) {
        clearTimeout(timeoutRef.current);
        handlerRef.current && doc.removeEventListener('pointermove', handlerRef.current);
        handlerRef.current = handleCloseRef.current({ ...context,
          tree,
          x: event.clientX,
          y: event.clientY,

          onClose() {
            clearPointerEvents();
            cleanupPointerMoveHandler();
            closeWithDelay();
          }

        });
        doc.addEventListener('pointermove', handlerRef.current);
        return;
      }

      closeWithDelay();
    } // Ensure the floating element closes after scrolling even if the pointer
    // did not move.
    // https://github.com/floating-ui/floating-ui/discussions/1692


    function onScrollMouseLeave(event) {
      if (isClickLikeOpenEvent()) {
        return;
      }

      handleCloseRef.current == null ? void 0 : handleCloseRef.current({ ...context,
        tree,
        x: event.clientX,
        y: event.clientY,
        leave: true,

        onClose() {
          clearPointerEvents();
          cleanupPointerMoveHandler();
          closeWithDelay();
        }

      })(event);
    }

    const floating = refs.floating.current;
    const reference = refs.domReference.current;

    if (isElement(reference)) {
      open && reference.addEventListener('mouseleave', onScrollMouseLeave);
      floating == null ? void 0 : floating.addEventListener('mouseleave', onScrollMouseLeave);
      move && reference.addEventListener('mousemove', onMouseEnter, {
        once: true
      });
      reference.addEventListener('mouseenter', onMouseEnter);
      reference.addEventListener('mouseleave', onMouseLeave);
      return () => {
        open && reference.removeEventListener('mouseleave', onScrollMouseLeave);
        floating == null ? void 0 : floating.removeEventListener('mouseleave', onScrollMouseLeave);
        move && reference.removeEventListener('mousemove', onMouseEnter);
        reference.removeEventListener('mouseenter', onMouseEnter);
        reference.removeEventListener('mouseleave', onMouseLeave);
      };
    }
  }, [// Ensure the effect is re-run when the reference changes.
  // https://github.com/floating-ui/floating-ui/issues/1833
  _.domReference, enabled, context, mouseOnly, restMs, move, closeWithDelay, cleanupPointerMoveHandler, clearPointerEvents, onOpenChange, open, tree, refs, delayRef, handleCloseRef, dataRef]); // Block pointer-events of every element other than the reference and floating
  // while the floating element is open and has a `handleClose` handler. Also
  // handles nested floating elements.
  // https://github.com/floating-ui/floating-ui/issues/1722

  floating_ui_react_dom_interactions_index(() => {
    if (!enabled) {
      return;
    }

    if (open && handleCloseRef.current && handleCloseRef.current.__options.blockPointerEvents && isHoverOpen()) {
      getDocument(refs.floating.current).body.style.pointerEvents = 'none';
      performedPointerEventsMutationRef.current = true;
      const reference = refs.domReference.current;
      const floating = refs.floating.current;

      if (isElement(reference) && floating) {
        var _tree$nodesRef$curren, _tree$nodesRef$curren2;

        const parentFloating = tree == null ? void 0 : (_tree$nodesRef$curren = tree.nodesRef.current.find(node => node.id === parentId)) == null ? void 0 : (_tree$nodesRef$curren2 = _tree$nodesRef$curren.context) == null ? void 0 : _tree$nodesRef$curren2.refs.floating.current;

        if (parentFloating) {
          parentFloating.style.pointerEvents = '';
        }

        reference.style.pointerEvents = 'auto';
        floating.style.pointerEvents = 'auto';
        return () => {
          reference.style.pointerEvents = '';
          floating.style.pointerEvents = '';
        };
      }
    }
  }, [enabled, open, parentId, refs, tree, handleCloseRef, dataRef, isHoverOpen]);
  floating_ui_react_dom_interactions_index(() => {
    if (previousOpen && !open) {
      pointerTypeRef.current = undefined;
      cleanupPointerMoveHandler();
      clearPointerEvents();
    }
  });
  react.useEffect(() => {
    return () => {
      cleanupPointerMoveHandler();
      clearTimeout(timeoutRef.current);
      clearTimeout(restTimeoutRef.current);

      if (performedPointerEventsMutationRef.current) {
        clearPointerEvents();
      }
    };
  }, [enabled, cleanupPointerMoveHandler, clearPointerEvents]);
  return react.useMemo(() => {
    if (!enabled) {
      return {};
    }

    function setPointerRef(event) {
      pointerTypeRef.current = event.pointerType;
    }

    return {
      reference: {
        onPointerDown: setPointerRef,
        onPointerEnter: setPointerRef,

        onMouseMove() {
          if (open || restMs === 0) {
            return;
          }

          clearTimeout(restTimeoutRef.current);
          restTimeoutRef.current = setTimeout(() => {
            if (!blockMouseMoveRef.current) {
              onOpenChange(true);
            }
          }, restMs);
        }

      },
      floating: {
        onMouseEnter() {
          clearTimeout(timeoutRef.current);
        },

        onMouseLeave() {
          closeWithDelay(false);
        }

      }
    };
  }, [enabled, restMs, open, onOpenChange, closeWithDelay]);
};

const FloatingDelayGroupContext = /*#__PURE__*/react.createContext({
  delay: 1000,
  initialDelay: 1000,
  currentId: null,
  setCurrentId: () => {},
  setState: () => {}
});
const useDelayGroupContext = () => React.useContext(FloatingDelayGroupContext);
/**
 * Provides context for a group of floating elements that should share a
 * `delay`.
 * @see https://floating-ui.com/docs/FloatingDelayGroup
 */

const FloatingDelayGroup = _ref => {
  let {
    children,
    delay
  } = _ref;
  const [state, setState] = React.useState({
    delay,
    initialDelay: delay,
    currentId: null
  });
  const setCurrentId = React.useCallback(currentId => {
    setState(state => ({ ...state,
      currentId
    }));
  }, []);
  return /*#__PURE__*/React.createElement(FloatingDelayGroupContext.Provider, {
    value: React.useMemo(() => ({ ...state,
      setState,
      setCurrentId
    }), [state, setState, setCurrentId])
  }, children);
};
const useDelayGroup = (_ref2, _ref3) => {
  let {
    open,
    onOpenChange
  } = _ref2;
  let {
    id
  } = _ref3;
  const {
    currentId,
    initialDelay,
    setState
  } = useDelayGroupContext();
  React.useEffect(() => {
    if (currentId) {
      setState(state => ({ ...state,
        delay: {
          open: 1,
          close: getDelay(initialDelay, 'close')
        }
      }));

      if (currentId !== id) {
        onOpenChange(false);
      }
    }
  }, [id, onOpenChange, setState, currentId, initialDelay]);
  React.useEffect(() => {
    if (!open && currentId === id) {
      onOpenChange(false);
      setState(state => ({ ...state,
        delay: initialDelay,
        currentId: null
      }));
    }
  }, [open, setState, currentId, id, onOpenChange, initialDelay]);
};

function getArgsWithCustomFloatingHeight(args, prop) {
  return { ...args,
    rects: { ...args.rects,
      floating: { ...args.rects.floating,
        height: args.elements.floating[prop]
      }
    }
  };
}

const inner = options => ({
  name: 'inner',
  options,

  async fn(middlewareArguments) {
    const {
      listRef,
      overflowRef,
      onFallbackChange,
      offset: innerOffset = 0,
      index = 0,
      minItemsVisible = 4,
      referenceOverflowThreshold = 0,
      ...detectOverflowOptions
    } = options;
    const {
      rects,
      elements: {
        floating
      }
    } = middlewareArguments;
    const item = listRef.current[index];

    if (false) {}

    if (!item) {
      return {};
    }

    const nextArgs = { ...middlewareArguments,
      ...(await offset(-item.offsetTop - rects.reference.height / 2 - item.offsetHeight / 2 - innerOffset).fn(middlewareArguments))
    };
    const overflow = await detectOverflow(getArgsWithCustomFloatingHeight(nextArgs, 'scrollHeight'), detectOverflowOptions);
    const refOverflow = await detectOverflow(nextArgs, { ...detectOverflowOptions,
      elementContext: 'reference'
    });
    const diffY = Math.max(0, overflow.top);
    const nextY = nextArgs.y + diffY;
    const maxHeight = Math.max(0, floating.scrollHeight - diffY - Math.max(0, overflow.bottom));
    floating.style.maxHeight = maxHeight + "px";
    floating.scrollTop = diffY; // There is not enough space, fallback to standard anchored positioning

    if (onFallbackChange) {
      if (floating.offsetHeight < item.offsetHeight * Math.min(minItemsVisible, listRef.current.length - 1) - 1 || refOverflow.top >= -referenceOverflowThreshold || refOverflow.bottom >= -referenceOverflowThreshold) {
        flushSync(() => onFallbackChange(true));
      } else {
        flushSync(() => onFallbackChange(false));
      }
    }

    if (overflowRef) {
      overflowRef.current = await detectOverflow(getArgsWithCustomFloatingHeight({ ...nextArgs,
        y: nextY
      }, 'offsetHeight'), detectOverflowOptions);
    }

    return {
      y: nextY
    };
  }

});
const useInnerOffset = (_ref, _ref2) => {
  let {
    open,
    refs
  } = _ref;
  let {
    enabled = true,
    overflowRef,
    onChange: unstable_onChange
  } = _ref2;
  const onChange = useEvent(unstable_onChange);
  const controlledScrollingRef = React.useRef(false);
  const prevScrollTopRef = React.useRef(null);
  const initialOverflowRef = React.useRef(null);
  React.useEffect(() => {
    if (!enabled) {
      return;
    }

    function onWheel(e) {
      if (e.ctrlKey || !el || overflowRef.current == null) {
        return;
      }

      const dY = e.deltaY;
      const isAtTop = overflowRef.current.top >= -0.5;
      const isAtBottom = overflowRef.current.bottom >= -0.5;
      const remainingScroll = el.scrollHeight - el.clientHeight;
      const sign = dY < 0 ? -1 : 1;
      const method = dY < 0 ? 'max' : 'min';

      if (el.scrollHeight <= el.clientHeight) {
        return;
      }

      if (!isAtTop && dY > 0 || !isAtBottom && dY < 0) {
        e.preventDefault();
        flushSync(() => {
          onChange(d => d + Math[method](dY, remainingScroll * sign));
        });
      } else if (/firefox/i.test(getUserAgent())) {
        // Needed to propagate scrolling during momentum scrolling phase once
        // it gets limited by the boundary. UX improvement, not critical.
        el.scrollTop += dY;
      }
    }

    const el = refs.floating.current;

    if (open && el) {
      el.addEventListener('wheel', onWheel); // Wait for the position to be ready.

      requestAnimationFrame(() => {
        prevScrollTopRef.current = el.scrollTop;

        if (overflowRef.current != null) {
          initialOverflowRef.current = { ...overflowRef.current
          };
        }
      });
      return () => {
        prevScrollTopRef.current = null;
        initialOverflowRef.current = null;
        el.removeEventListener('wheel', onWheel);
      };
    }
  }, [enabled, open, refs, overflowRef, onChange]);
  return React.useMemo(() => {
    if (!enabled) {
      return {};
    }

    return {
      floating: {
        onKeyDown() {
          controlledScrollingRef.current = true;
        },

        onWheel() {
          controlledScrollingRef.current = false;
        },

        onPointerMove() {
          controlledScrollingRef.current = false;
        },

        onScroll() {
          const el = refs.floating.current;

          if (!overflowRef.current || !el || !controlledScrollingRef.current) {
            return;
          }

          if (prevScrollTopRef.current !== null) {
            const scrollDiff = el.scrollTop - prevScrollTopRef.current;

            if (overflowRef.current.bottom < -0.5 && scrollDiff < -1 || overflowRef.current.top < -0.5 && scrollDiff > 1) {
              flushSync(() => onChange(d => d + scrollDiff));
            }
          } // [Firefox] Wait for the height change to have been applied.


          requestAnimationFrame(() => {
            prevScrollTopRef.current = el.scrollTop;
          });
        }

      }
    };
  }, [enabled, overflowRef, refs, onChange]);
};

/**
 * Adds relevant screen reader props for a given element `role`.
 * @see https://floating-ui.com/docs/useRole
 */
const useRole = function (_ref, _temp) {
  let {
    open
  } = _ref;
  let {
    enabled = true,
    role = 'dialog'
  } = _temp === void 0 ? {} : _temp;
  const rootId = useId();
  const referenceId = useId();
  return react.useMemo(() => {
    const floatingProps = {
      id: rootId,
      role
    };

    if (!enabled) {
      return {};
    }

    if (role === 'tooltip') {
      return {
        reference: {
          'aria-describedby': open ? rootId : undefined
        },
        floating: floatingProps
      };
    }

    return {
      reference: {
        'aria-expanded': open ? 'true' : 'false',
        'aria-haspopup': role === 'alertdialog' ? 'dialog' : role,
        'aria-controls': open ? rootId : undefined,
        ...(role === 'listbox' && {
          role: 'combobox'
        }),
        ...(role === 'menu' && {
          id: referenceId
        })
      },
      floating: { ...floatingProps,
        ...(role === 'menu' && {
          'aria-labelledby': referenceId
        })
      }
    };
  }, [enabled, role, open, rootId, referenceId]);
};

function isButtonTarget(event) {
  return isHTMLElement(event.target) && event.target.tagName === 'BUTTON';
}

function isSpaceIgnored(element) {
  return isTypeableElement(element);
}

/**
 * Adds click event listeners that change the open state.
 * @see https://floating-ui.com/docs/useClick
 */
const useClick = function (_ref, _temp) {
  let {
    open,
    onOpenChange,
    dataRef,
    refs
  } = _ref;
  let {
    enabled = true,
    event: eventOption = 'click',
    toggle = true,
    ignoreMouse = false,
    keyboardHandlers = true
  } = _temp === void 0 ? {} : _temp;
  const pointerTypeRef = react.useRef();
  return react.useMemo(() => {
    if (!enabled) {
      return {};
    }

    return {
      reference: {
        onPointerDown(event) {
          pointerTypeRef.current = event.pointerType;
        },

        onMouseDown(event) {
          // Ignore all buttons except for the "main" button.
          // https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button
          if (event.button !== 0) {
            return;
          }

          if (pointerTypeRef.current === 'mouse' && ignoreMouse) {
            return;
          }

          if (eventOption === 'click') {
            return;
          }

          if (open) {
            if (toggle && (dataRef.current.openEvent ? dataRef.current.openEvent.type === 'mousedown' : true)) {
              onOpenChange(false);
            }
          } else {
            onOpenChange(true);
          }

          dataRef.current.openEvent = event.nativeEvent;
        },

        onClick(event) {
          if (eventOption === 'mousedown' && pointerTypeRef.current) {
            pointerTypeRef.current = undefined;
            return;
          }

          if (pointerTypeRef.current === 'mouse' && ignoreMouse) {
            return;
          }

          if (open) {
            if (toggle && (dataRef.current.openEvent ? dataRef.current.openEvent.type === 'click' : true)) {
              onOpenChange(false);
            }
          } else {
            onOpenChange(true);
          }

          dataRef.current.openEvent = event.nativeEvent;
        },

        onKeyDown(event) {
          pointerTypeRef.current = undefined;

          if (!keyboardHandlers) {
            return;
          }

          if (isButtonTarget(event)) {
            return;
          }

          if (event.key === ' ' && !isSpaceIgnored(refs.domReference.current)) {
            // Prvent scrolling
            event.preventDefault();
          }

          if (event.key === 'Enter') {
            if (open) {
              if (toggle) {
                onOpenChange(false);
              }
            } else {
              onOpenChange(true);
            }
          }
        },

        onKeyUp(event) {
          if (!keyboardHandlers) {
            return;
          }

          if (isButtonTarget(event) || isSpaceIgnored(refs.domReference.current)) {
            return;
          }

          if (event.key === ' ') {
            if (open) {
              if (toggle) {
                onOpenChange(false);
              }
            } else {
              onOpenChange(true);
            }
          }
        }

      }
    };
  }, [enabled, dataRef, eventOption, ignoreMouse, keyboardHandlers, refs, toggle, open, onOpenChange]);
};

/**
 * Check whether the event.target is within the provided node. Uses event.composedPath if available for custom element support.
 *
 * @param event The event whose target/composedPath to check
 * @param node The node to check against
 * @returns Whether the event.target/composedPath is within the node.
 */
function isEventTargetWithin(event, node) {
  if (node == null) {
    return false;
  }

  if ('composedPath' in event) {
    return event.composedPath().includes(node);
  } // TS thinks `event` is of type never as it assumes all browsers support composedPath, but browsers without shadow dom don't


  const e = event;
  return e.target != null && node.contains(e.target);
}

const bubbleHandlerKeys = {
  pointerdown: 'onPointerDown',
  mousedown: 'onMouseDown',
  click: 'onClick'
};
const captureHandlerKeys = {
  pointerdown: 'onPointerDownCapture',
  mousedown: 'onMouseDownCapture',
  click: 'onClickCapture'
};

/**
 * Adds listeners that dismiss (close) the floating element.
 * @see https://floating-ui.com/docs/useDismiss
 */
const useDismiss = function (_ref, _temp) {
  let {
    open,
    onOpenChange,
    refs,
    events,
    nodeId
  } = _ref;
  let {
    enabled = true,
    escapeKey = true,
    outsidePress = true,
    outsidePressEvent = 'pointerdown',
    referencePress = false,
    referencePressEvent = 'pointerdown',
    ancestorScroll = false,
    bubbles = true
  } = _temp === void 0 ? {} : _temp;
  const tree = useFloatingTree();
  const nested = useFloatingParentNodeId() != null;
  const insideReactTreeRef = react.useRef(false);
  react.useEffect(() => {
    if (!open || !enabled) {
      return;
    }

    function onKeyDown(event) {
      if (event.key === 'Escape') {
        if (!bubbles && tree && getChildren(tree.nodesRef.current, nodeId).length > 0) {
          return;
        }

        events.emit('dismiss', {
          preventScroll: false
        });
        onOpenChange(false);
      }
    }

    function onOutsidePress(event) {
      // Given developers can stop the propagation of the synthetic event,
      // we can only be confident with a positive value.
      const insideReactTree = insideReactTreeRef.current;
      insideReactTreeRef.current = false;

      if (insideReactTree) {
        return;
      }

      const target = getTarget(event); // Check if the click occurred on the scrollbar

      if (isElement(target) && refs.floating.current) {
        var _refs$floating$curren;

        const win = (_refs$floating$curren = refs.floating.current.ownerDocument.defaultView) != null ? _refs$floating$curren : window;
        const canScrollX = target.scrollWidth > target.clientWidth;
        const canScrollY = target.scrollHeight > target.clientHeight;
        let xCond = canScrollY && event.offsetX > target.clientWidth; // In some browsers it is possible to change the <body> (or window)
        // scrollbar to the left side, but is very rare and is difficult to
        // check for. Plus, for modal dialogs with backdrops, it is more
        // important that the backdrop is checked but not so much the window.

        if (canScrollY) {
          const isRTL = win.getComputedStyle(target).direction === 'rtl';

          if (isRTL) {
            xCond = event.offsetX <= target.offsetWidth - target.clientWidth;
          }
        }

        if (xCond || canScrollX && event.offsetY > target.clientHeight) {
          return;
        }
      }

      const targetIsInsideChildren = tree && getChildren(tree.nodesRef.current, nodeId).some(node => {
        var _node$context;

        return isEventTargetWithin(event, (_node$context = node.context) == null ? void 0 : _node$context.refs.floating.current);
      });

      if (isEventTargetWithin(event, refs.floating.current) || isEventTargetWithin(event, refs.domReference.current) || targetIsInsideChildren) {
        return;
      }

      if (!bubbles && tree && getChildren(tree.nodesRef.current, nodeId).length > 0) {
        return;
      }

      events.emit('dismiss', nested ? {
        preventScroll: true
      } : false);
      onOpenChange(false);
    }

    function onScroll() {
      onOpenChange(false);
    }

    const doc = getDocument(refs.floating.current);
    escapeKey && doc.addEventListener('keydown', onKeyDown);
    outsidePress && doc.addEventListener(outsidePressEvent, onOutsidePress);
    let ancestors = [];

    if (ancestorScroll) {
      if (isElement(refs.domReference.current)) {
        ancestors = (0,floating_ui_dom/* getOverflowAncestors */.Kx)(refs.domReference.current);
      }

      if (isElement(refs.floating.current)) {
        ancestors = ancestors.concat((0,floating_ui_dom/* getOverflowAncestors */.Kx)(refs.floating.current));
      }

      if (!isElement(refs.reference.current) && refs.reference.current && // @ts-expect-error is VirtualElement
      refs.reference.current.contextElement) {
        ancestors = ancestors.concat( // @ts-expect-error is VirtualElement
        (0,floating_ui_dom/* getOverflowAncestors */.Kx)(refs.reference.current.contextElement));
      }
    } // Ignore the visual viewport for scrolling dismissal (allow pinch-zoom)


    ancestors = ancestors.filter(ancestor => {
      var _doc$defaultView;

      return ancestor !== ((_doc$defaultView = doc.defaultView) == null ? void 0 : _doc$defaultView.visualViewport);
    });
    ancestors.forEach(ancestor => {
      ancestor.addEventListener('scroll', onScroll, {
        passive: true
      });
    });
    return () => {
      escapeKey && doc.removeEventListener('keydown', onKeyDown);
      outsidePress && doc.removeEventListener(outsidePressEvent, onOutsidePress);
      ancestors.forEach(ancestor => {
        ancestor.removeEventListener('scroll', onScroll);
      });
    };
  }, [escapeKey, outsidePress, outsidePressEvent, events, tree, nodeId, open, onOpenChange, ancestorScroll, enabled, bubbles, refs, nested]);
  react.useEffect(() => {
    insideReactTreeRef.current = false;
  }, [outsidePress, outsidePressEvent]);
  return react.useMemo(() => {
    if (!enabled) {
      return {};
    }

    return {
      reference: {
        [bubbleHandlerKeys[referencePressEvent]]: () => {
          if (referencePress) {
            events.emit('dismiss');
            onOpenChange(false);
          }
        }
      },
      floating: {
        [captureHandlerKeys[outsidePressEvent]]: () => {
          insideReactTreeRef.current = true;
        }
      }
    };
  }, [enabled, events, referencePress, outsidePressEvent, referencePressEvent, onOpenChange]);
};

/**
 * Adds focus event listeners that change the open state, like CSS :focus.
 * @see https://floating-ui.com/docs/useFocus
 */
const useFocus = function (_ref, _temp) {
  let {
    open,
    onOpenChange,
    dataRef,
    refs,
    events
  } = _ref;
  let {
    enabled = true,
    keyboardOnly = true
  } = _temp === void 0 ? {} : _temp;
  const pointerTypeRef = React.useRef('');
  const blockFocusRef = React.useRef(false);
  const timeoutRef = React.useRef();
  React.useEffect(() => {
    var _doc$defaultView;

    if (!enabled) {
      return;
    }

    const doc = getDocument(refs.floating.current);
    const win = (_doc$defaultView = doc.defaultView) != null ? _doc$defaultView : window;

    function onBlur() {
      if (!open && isHTMLElement(refs.domReference.current)) {
        refs.domReference.current.blur();
      }
    }

    win.addEventListener('blur', onBlur);
    return () => {
      win.removeEventListener('blur', onBlur);
    };
  }, [refs, open, enabled]);
  React.useEffect(() => {
    if (!enabled) {
      return;
    }

    function onDismiss() {
      blockFocusRef.current = true;
    }

    events.on('dismiss', onDismiss);
    return () => {
      events.off('dismiss', onDismiss);
    };
  }, [events, enabled]);
  React.useEffect(() => {
    return () => {
      clearTimeout(timeoutRef.current);
    };
  }, []);
  return React.useMemo(() => {
    if (!enabled) {
      return {};
    }

    return {
      reference: {
        onPointerDown(_ref2) {
          let {
            pointerType
          } = _ref2;
          pointerTypeRef.current = pointerType;
          blockFocusRef.current = !!(pointerType && keyboardOnly);
        },

        onPointerLeave() {
          blockFocusRef.current = false;
        },

        onFocus(event) {
          var _dataRef$current$open, _refs$domReference$cu, _dataRef$current$open2;

          if (blockFocusRef.current) {
            return;
          } // Dismiss with click should ignore the subsequent `focus` trigger, but
          // only if the click originated inside the reference element.


          if (event.type === 'focus' && ((_dataRef$current$open = dataRef.current.openEvent) == null ? void 0 : _dataRef$current$open.type) === 'mousedown' && (_refs$domReference$cu = refs.domReference.current) != null && _refs$domReference$cu.contains((_dataRef$current$open2 = dataRef.current.openEvent) == null ? void 0 : _dataRef$current$open2.target)) {
            return;
          }

          dataRef.current.openEvent = event.nativeEvent;
          onOpenChange(true);
        },

        onBlur(event) {
          const target = event.relatedTarget; // Wait for the window blur listener to fire.

          timeoutRef.current = setTimeout(() => {
            var _refs$floating$curren, _refs$domReference$cu2;

            // When focusing the reference element (e.g. regular click), then
            // clicking into the floating element, prevent it from hiding.
            // Note: it must be focusable, e.g. `tabindex="-1"`.
            if ((_refs$floating$curren = refs.floating.current) != null && _refs$floating$curren.contains(target) || (_refs$domReference$cu2 = refs.domReference.current) != null && _refs$domReference$cu2.contains(target)) {
              return;
            }

            blockFocusRef.current = false;
            onOpenChange(false);
          });
        }

      }
    };
  }, [enabled, keyboardOnly, refs, dataRef, onOpenChange]);
};

const ARROW_UP = 'ArrowUp';
const ARROW_DOWN = 'ArrowDown';
const ARROW_LEFT = 'ArrowLeft';
const ARROW_RIGHT = 'ArrowRight';

function isDifferentRow(index, cols, prevRow) {
  return Math.floor(index / cols) !== prevRow;
}

function isIndexOutOfBounds(listRef, index) {
  return index < 0 || index >= listRef.current.length;
}

function findNonDisabledIndex(listRef, _temp) {
  let {
    startingIndex = -1,
    decrement = false,
    disabledIndices,
    amount = 1
  } = _temp === void 0 ? {} : _temp;
  const list = listRef.current;
  let index = startingIndex;

  do {
    var _list$index, _list$index2;

    index = index + (decrement ? -amount : amount);
  } while (index >= 0 && index <= list.length - 1 && (disabledIndices ? disabledIndices.includes(index) : list[index] == null || ((_list$index = list[index]) == null ? void 0 : _list$index.hasAttribute('disabled')) || ((_list$index2 = list[index]) == null ? void 0 : _list$index2.getAttribute('aria-disabled')) === 'true'));

  return index;
}

function doSwitch(orientation, vertical, horizontal) {
  switch (orientation) {
    case 'vertical':
      return vertical;

    case 'horizontal':
      return horizontal;

    default:
      return vertical || horizontal;
  }
}

function isMainOrientationKey(key, orientation) {
  const vertical = key === ARROW_UP || key === ARROW_DOWN;
  const horizontal = key === ARROW_LEFT || key === ARROW_RIGHT;
  return doSwitch(orientation, vertical, horizontal);
}

function isMainOrientationToEndKey(key, orientation, rtl) {
  const vertical = key === ARROW_DOWN;
  const horizontal = rtl ? key === ARROW_LEFT : key === ARROW_RIGHT;
  return doSwitch(orientation, vertical, horizontal) || key === 'Enter' || key == ' ' || key === '';
}

function isCrossOrientationOpenKey(key, orientation, rtl) {
  const vertical = rtl ? key === ARROW_LEFT : key === ARROW_RIGHT;
  const horizontal = key === ARROW_DOWN;
  return doSwitch(orientation, vertical, horizontal);
}

function isCrossOrientationCloseKey(key, orientation, rtl) {
  const vertical = rtl ? key === ARROW_RIGHT : key === ARROW_LEFT;
  const horizontal = key === ARROW_UP;
  return doSwitch(orientation, vertical, horizontal);
}

function getMinIndex(listRef, disabledIndices) {
  return findNonDisabledIndex(listRef, {
    disabledIndices
  });
}

function getMaxIndex(listRef, disabledIndices) {
  return findNonDisabledIndex(listRef, {
    decrement: true,
    startingIndex: listRef.current.length,
    disabledIndices
  });
}

/**
 * Adds focus-managed indexed navigation via arrow keys to a list of items
 * within the floating element.
 * @see https://floating-ui.com/docs/useListNavigation
 */
const useListNavigation = function (_ref, _temp2) {
  let {
    open,
    onOpenChange,
    refs
  } = _ref;
  let {
    listRef,
    activeIndex,
    onNavigate: unstable_onNavigate = () => {},
    enabled = true,
    selectedIndex = null,
    allowEscape = false,
    loop = false,
    nested = false,
    rtl = false,
    virtual = false,
    focusItemOnOpen = 'auto',
    focusItemOnHover = true,
    openOnArrowKeyDown = true,
    disabledIndices = undefined,
    orientation = 'vertical',
    cols = 1
  } = _temp2 === void 0 ? {
    listRef: {
      current: []
    },
    activeIndex: null,
    onNavigate: () => {}
  } : _temp2;

  if (false) {}

  const parentId = useFloatingParentNodeId();
  const tree = useFloatingTree();
  const previousOpen = usePrevious(open);
  const onNavigate = useEvent(unstable_onNavigate);
  const previousOnNavigate = useEvent(usePrevious(unstable_onNavigate));
  const focusItemOnOpenRef = react.useRef(focusItemOnOpen);
  const indexRef = react.useRef(selectedIndex != null ? selectedIndex : -1);
  const keyRef = react.useRef(null);
  const disabledIndicesRef = floating_ui_react_dom_interactions_useLatestRef(disabledIndices);
  const blockPointerLeaveRef = react.useRef(false);
  const frameRef = react.useRef(-1);
  const [activeId, setActiveId] = react.useState();
  const focusItem = react.useCallback((listRef, indexRef) => {
    // `mousedown` clicks occur before `focus`, so the button will steal the
    // focus unless we wait a frame.
    frameRef.current = requestAnimationFrame(() => {
      if (virtual) {
        var _listRef$current$inde;

        setActiveId((_listRef$current$inde = listRef.current[indexRef.current]) == null ? void 0 : _listRef$current$inde.id);
      } else {
        var _listRef$current$inde2;

        (_listRef$current$inde2 = listRef.current[indexRef.current]) == null ? void 0 : _listRef$current$inde2.focus({
          preventScroll: true
        });
      }
    });
  }, [virtual]); // Sync `selectedIndex` to be the `activeIndex` upon opening the floating
  // element. Also, reset `activeIndex` upon closing the floating element.

  floating_ui_react_dom_interactions_index(() => {
    if (!enabled) {
      return;
    }

    if (!previousOpen && open && focusItemOnOpenRef.current && selectedIndex != null) {
      onNavigate(selectedIndex);
    } // Unset `activeIndex`. Since the user can specify `onNavigate`
    // conditionally (onNavigate: open ? setActiveIndex : setSelectedIndex)
    // we store and call the previous function


    if (previousOpen && !open) {
      cancelAnimationFrame(frameRef.current);
      indexRef.current = -1;
      previousOnNavigate(null);
    }
  }, [open, previousOpen, selectedIndex, listRef, focusItem, enabled, onNavigate, previousOnNavigate]); // Sync `activeIndex` to be the focused item while the floating element is
  // open.

  floating_ui_react_dom_interactions_index(() => {
    if (!enabled) {
      return;
    }

    if (open) {
      if (activeIndex == null) {
        if (selectedIndex != null) {
          return;
        } // Reset while the floating element was open (e.g. the list changed).


        if (previousOpen) {
          indexRef.current = -1;
          focusItem(listRef, indexRef);
        } // Initial sync


        if (!previousOpen && focusItemOnOpenRef.current && (keyRef.current != null || focusItemOnOpenRef.current === true && keyRef.current == null)) {
          indexRef.current = keyRef.current == null || isMainOrientationToEndKey(keyRef.current, orientation, rtl) || nested ? getMinIndex(listRef, disabledIndicesRef.current) : getMaxIndex(listRef, disabledIndicesRef.current);
          onNavigate(indexRef.current);
          focusItem(listRef, indexRef);
        }
      } else if (!isIndexOutOfBounds(listRef, activeIndex)) {
        indexRef.current = activeIndex;
        focusItem(listRef, indexRef);
      }
    }
  }, [open, previousOpen, activeIndex, selectedIndex, nested, listRef, onNavigate, focusItem, enabled, allowEscape, orientation, rtl, virtual, disabledIndicesRef]); // Ensure the parent floating element has focus when a nested child closes
  // to allow arrow key navigation to work after the pointer leaves the child.

  floating_ui_react_dom_interactions_index(() => {
    if (!enabled) {
      return;
    }

    if (!open && previousOpen) {
      var _tree$nodesRef$curren, _tree$nodesRef$curren2;

      const parentFloating = tree == null ? void 0 : (_tree$nodesRef$curren = tree.nodesRef.current.find(node => node.id === parentId)) == null ? void 0 : (_tree$nodesRef$curren2 = _tree$nodesRef$curren.context) == null ? void 0 : _tree$nodesRef$curren2.refs.floating.current;

      if (parentFloating && !parentFloating.contains(activeElement(getDocument(parentFloating)))) {
        parentFloating.focus({
          preventScroll: true
        });
      }
    }
  }, [enabled, open, previousOpen, tree, parentId]);
  floating_ui_react_dom_interactions_index(() => {
    keyRef.current = null;
  });
  return react.useMemo(() => {
    if (!enabled) {
      return {};
    }

    const disabledIndices = disabledIndicesRef.current;

    function onKeyDown(event) {
      blockPointerLeaveRef.current = true;

      if (nested && isCrossOrientationCloseKey(event.key, orientation, rtl)) {
        stopEvent(event);
        onOpenChange(false);

        if (isHTMLElement(refs.domReference.current)) {
          refs.domReference.current.focus();
        }

        return;
      }

      const currentIndex = indexRef.current;
      const minIndex = getMinIndex(listRef, disabledIndices);
      const maxIndex = getMaxIndex(listRef, disabledIndices);

      if (event.key === 'Home') {
        indexRef.current = minIndex;
        onNavigate(indexRef.current);
      }

      if (event.key === 'End') {
        indexRef.current = maxIndex;
        onNavigate(indexRef.current);
      } // Grid navigation


      if (cols > 1) {
        const prevIndex = indexRef.current;

        if (event.key === ARROW_UP) {
          stopEvent(event);

          if (prevIndex === -1) {
            indexRef.current = maxIndex;
          } else {
            indexRef.current = findNonDisabledIndex(listRef, {
              startingIndex: prevIndex,
              amount: cols,
              decrement: true,
              disabledIndices
            });

            if (loop && (prevIndex - cols < minIndex || indexRef.current < 0)) {
              const col = prevIndex % cols;
              const maxCol = maxIndex % cols;
              const offset = maxIndex - (maxCol - col);

              if (maxCol === col) {
                indexRef.current = maxIndex;
              } else {
                indexRef.current = maxCol > col ? offset : offset - cols;
              }
            }
          }

          if (isIndexOutOfBounds(listRef, indexRef.current)) {
            indexRef.current = prevIndex;
          }

          onNavigate(indexRef.current);
        }

        if (event.key === ARROW_DOWN) {
          stopEvent(event);

          if (prevIndex === -1) {
            indexRef.current = minIndex;
          } else {
            indexRef.current = findNonDisabledIndex(listRef, {
              startingIndex: prevIndex,
              amount: cols,
              disabledIndices
            });

            if (loop && prevIndex + cols > maxIndex) {
              indexRef.current = findNonDisabledIndex(listRef, {
                startingIndex: prevIndex % cols - cols,
                amount: cols,
                disabledIndices
              });
            }
          }

          if (isIndexOutOfBounds(listRef, indexRef.current)) {
            indexRef.current = prevIndex;
          }

          onNavigate(indexRef.current);
        } // Remains on the same row/column


        if (orientation === 'both') {
          const prevRow = Math.floor(prevIndex / cols);

          if (event.key === ARROW_RIGHT) {
            stopEvent(event);

            if (prevIndex % cols !== cols - 1) {
              indexRef.current = findNonDisabledIndex(listRef, {
                startingIndex: prevIndex,
                disabledIndices
              });

              if (loop && isDifferentRow(indexRef.current, cols, prevRow)) {
                indexRef.current = findNonDisabledIndex(listRef, {
                  startingIndex: prevIndex - prevIndex % cols - 1,
                  disabledIndices
                });
              }
            } else if (loop) {
              indexRef.current = findNonDisabledIndex(listRef, {
                startingIndex: prevIndex - prevIndex % cols - 1,
                disabledIndices
              });
            }

            if (isDifferentRow(indexRef.current, cols, prevRow)) {
              indexRef.current = prevIndex;
            }
          }

          if (event.key === ARROW_LEFT) {
            stopEvent(event);

            if (prevIndex % cols !== 0) {
              indexRef.current = findNonDisabledIndex(listRef, {
                startingIndex: prevIndex,
                disabledIndices,
                decrement: true
              });

              if (loop && isDifferentRow(indexRef.current, cols, prevRow)) {
                indexRef.current = findNonDisabledIndex(listRef, {
                  startingIndex: prevIndex + (cols - prevIndex % cols),
                  decrement: true,
                  disabledIndices
                });
              }
            } else if (loop) {
              indexRef.current = findNonDisabledIndex(listRef, {
                startingIndex: prevIndex + (cols - prevIndex % cols),
                decrement: true,
                disabledIndices
              });
            }

            if (isDifferentRow(indexRef.current, cols, prevRow)) {
              indexRef.current = prevIndex;
            }
          }

          const lastRow = Math.floor(maxIndex / cols) === prevRow;

          if (isIndexOutOfBounds(listRef, indexRef.current)) {
            if (loop && lastRow) {
              indexRef.current = event.key === ARROW_LEFT ? maxIndex : findNonDisabledIndex(listRef, {
                startingIndex: prevIndex - prevIndex % cols - 1,
                disabledIndices
              });
            } else {
              indexRef.current = prevIndex;
            }
          }

          onNavigate(indexRef.current);
          return;
        }
      }

      if (isMainOrientationKey(event.key, orientation)) {
        stopEvent(event); // Reset the index if no item is focused.

        if (open && !virtual && activeElement(event.currentTarget.ownerDocument) === event.currentTarget) {
          indexRef.current = isMainOrientationToEndKey(event.key, orientation, rtl) ? minIndex : maxIndex;
          onNavigate(indexRef.current);
          return;
        }

        if (isMainOrientationToEndKey(event.key, orientation, rtl)) {
          if (loop) {
            indexRef.current = currentIndex >= maxIndex ? allowEscape && currentIndex !== listRef.current.length ? -1 : minIndex : findNonDisabledIndex(listRef, {
              startingIndex: currentIndex,
              disabledIndices
            });
          } else {
            indexRef.current = Math.min(maxIndex, findNonDisabledIndex(listRef, {
              startingIndex: currentIndex,
              disabledIndices
            }));
          }
        } else {
          if (loop) {
            indexRef.current = currentIndex <= minIndex ? allowEscape && currentIndex !== -1 ? listRef.current.length : maxIndex : findNonDisabledIndex(listRef, {
              startingIndex: currentIndex,
              decrement: true,
              disabledIndices
            });
          } else {
            indexRef.current = Math.max(minIndex, findNonDisabledIndex(listRef, {
              startingIndex: currentIndex,
              decrement: true,
              disabledIndices
            }));
          }
        }

        if (isIndexOutOfBounds(listRef, indexRef.current)) {
          onNavigate(null);
        } else {
          onNavigate(indexRef.current);
        }
      }
    }

    return {
      reference: { ...(virtual && open && activeIndex != null && {
          'aria-activedescendant': activeId
        }),

        onKeyDown(event) {
          blockPointerLeaveRef.current = true;

          if (virtual && open) {
            return onKeyDown(event);
          }

          const isNavigationKey = event.key.indexOf('Arrow') === 0 || event.key === 'Enter' || event.key === ' ' || event.key === '';

          if (isNavigationKey) {
            keyRef.current = event.key;
          }

          if (nested) {
            if (isCrossOrientationOpenKey(event.key, orientation, rtl)) {
              stopEvent(event);

              if (open) {
                indexRef.current = getMinIndex(listRef, disabledIndices);
                onNavigate(indexRef.current);
              } else {
                onOpenChange(true);
              }
            }

            return;
          }

          if (isMainOrientationKey(event.key, orientation)) {
            if (selectedIndex != null) {
              indexRef.current = selectedIndex;
            }

            stopEvent(event);

            if (!open && openOnArrowKeyDown) {
              onOpenChange(true);
            } else {
              onKeyDown(event);
            }

            if (open) {
              onNavigate(indexRef.current);
            }
          }
        }

      },
      floating: {
        'aria-orientation': orientation === 'both' ? undefined : orientation,
        ...(virtual && activeIndex != null && {
          'aria-activedescendant': activeId
        }),
        onKeyDown,

        onPointerMove() {
          blockPointerLeaveRef.current = false;
        }

      },
      item: {
        onFocus(_ref2) {
          let {
            currentTarget
          } = _ref2;
          const index = listRef.current.indexOf(currentTarget);

          if (index !== -1) {
            onNavigate(index);
          }
        },

        onClick: _ref3 => {
          let {
            currentTarget
          } = _ref3;
          return currentTarget.focus({
            preventScroll: true
          });
        },
        // Safari
        ...(focusItemOnHover && {
          onMouseMove(_ref4) {
            let {
              currentTarget
            } = _ref4;
            const target = currentTarget;

            if (target) {
              const index = listRef.current.indexOf(target);

              if (index !== -1) {
                onNavigate(index);
              }
            }
          },

          onPointerLeave() {
            if (!blockPointerLeaveRef.current) {
              indexRef.current = -1;
              focusItem(listRef, indexRef);
              onNavigate(null);

              if (!virtual) {
                requestAnimationFrame(() => {
                  var _refs$floating$curren;

                  (_refs$floating$curren = refs.floating.current) == null ? void 0 : _refs$floating$curren.focus({
                    preventScroll: true
                  });
                });
              }
            }
          }

        })
      }
    };
  }, [activeId, disabledIndicesRef, listRef, enabled, orientation, rtl, virtual, open, activeIndex, nested, selectedIndex, openOnArrowKeyDown, focusItemOnHover, allowEscape, cols, loop, refs, focusItem, onNavigate, onOpenChange]);
};

/**
 * Provides a matching callback that can be used to focus an item as the user
 * types, often used in tandem with `useListNavigation()`.
 * @see https://floating-ui.com/docs/useTypeahead
 */
const useTypeahead = function (_ref, _temp) {
  var _ref2;

  let {
    open,
    dataRef
  } = _ref;
  let {
    listRef,
    activeIndex,
    onMatch: unstable_onMatch = () => {},
    enabled = true,
    findMatch = null,
    resetMs = 1000,
    ignoreKeys = [],
    selectedIndex = null
  } = _temp === void 0 ? {
    listRef: {
      current: []
    },
    activeIndex: null
  } : _temp;
  const timeoutIdRef = React.useRef();
  const stringRef = React.useRef('');
  const prevIndexRef = React.useRef((_ref2 = selectedIndex != null ? selectedIndex : activeIndex) != null ? _ref2 : -1);
  const matchIndexRef = React.useRef(null);
  const onMatch = useEvent(unstable_onMatch);
  const findMatchRef = floating_ui_react_dom_interactions_useLatestRef(findMatch);
  const ignoreKeysRef = floating_ui_react_dom_interactions_useLatestRef(ignoreKeys);
  floating_ui_react_dom_interactions_index(() => {
    if (open) {
      clearTimeout(timeoutIdRef.current);
      matchIndexRef.current = null;
      stringRef.current = '';
    }
  }, [open]);
  floating_ui_react_dom_interactions_index(() => {
    // Sync arrow key navigation but not typeahead navigation
    if (open && stringRef.current === '') {
      var _ref3;

      prevIndexRef.current = (_ref3 = selectedIndex != null ? selectedIndex : activeIndex) != null ? _ref3 : -1;
    }
  }, [open, selectedIndex, activeIndex]);
  return React.useMemo(() => {
    if (!enabled) {
      return {};
    }

    function onKeyDown(event) {
      // Correctly scope nested non-portalled floating elements. Since the nested
      // floating element is inside of the another, we find the closest role
      // that indicates the floating element scope.
      const target = getTarget(event.nativeEvent);

      if (isElement(target) && (activeElement(getDocument(target)) !== event.currentTarget ? target.closest('[role="dialog"],[role="menu"],[role="listbox"],[role="tree"],[role="grid"]') !== event.currentTarget : false)) {
        return;
      }

      if (stringRef.current.length > 0 && stringRef.current[0] !== ' ') {
        dataRef.current.typing = true;

        if (event.key === ' ') {
          stopEvent(event);
        }
      }

      const listContent = listRef.current;

      if (listContent == null || ignoreKeysRef.current.includes(event.key) || // Character key
      event.key.length !== 1 || // Modifier key
      event.ctrlKey || event.metaKey || event.altKey) {
        return;
      } // Bail out if the list contains a word like "llama" or "aaron". TODO:
      // allow it in this case, too.


      const allowRapidSuccessionOfFirstLetter = listContent.every(text => {
        var _text$, _text$2;

        return text ? ((_text$ = text[0]) == null ? void 0 : _text$.toLocaleLowerCase()) !== ((_text$2 = text[1]) == null ? void 0 : _text$2.toLocaleLowerCase()) : true;
      }); // Allows the user to cycle through items that start with the same letter
      // in rapid succession

      if (allowRapidSuccessionOfFirstLetter && stringRef.current === event.key) {
        stringRef.current = '';
        prevIndexRef.current = matchIndexRef.current;
      }

      stringRef.current += event.key;
      clearTimeout(timeoutIdRef.current);
      timeoutIdRef.current = setTimeout(() => {
        stringRef.current = '';
        prevIndexRef.current = matchIndexRef.current;
        dataRef.current.typing = false;
      }, resetMs);
      const prevIndex = prevIndexRef.current;
      const orderedList = [...listContent.slice((prevIndex != null ? prevIndex : 0) + 1), ...listContent.slice(0, (prevIndex != null ? prevIndex : 0) + 1)];
      const str = findMatchRef.current ? findMatchRef.current(orderedList, stringRef.current) : orderedList.find(text => (text == null ? void 0 : text.toLocaleLowerCase().indexOf(stringRef.current.toLocaleLowerCase())) === 0);
      const index = str ? listContent.indexOf(str) : -1;

      if (index !== -1) {
        onMatch(index);
        matchIndexRef.current = index;
      }
    }

    return {
      reference: {
        onKeyDown
      },
      floating: {
        onKeyDown
      }
    };
  }, [enabled, dataRef, listRef, resetMs, ignoreKeysRef, findMatchRef, onMatch]);
};




/***/ }),

/***/ 795:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "Axios": () => (/* binding */ axios_Axios),
  "AxiosError": () => (/* binding */ axios_AxiosError),
  "AxiosHeaders": () => (/* binding */ axios_AxiosHeaders),
  "Cancel": () => (/* binding */ Cancel),
  "CancelToken": () => (/* binding */ axios_CancelToken),
  "CanceledError": () => (/* binding */ axios_CanceledError),
  "HttpStatusCode": () => (/* binding */ axios_HttpStatusCode),
  "VERSION": () => (/* binding */ axios_VERSION),
  "all": () => (/* binding */ axios_all),
  "default": () => (/* reexport */ lib_axios),
  "formToJSON": () => (/* binding */ formToJSON),
  "isAxiosError": () => (/* binding */ axios_isAxiosError),
  "isCancel": () => (/* binding */ axios_isCancel),
  "mergeConfig": () => (/* binding */ axios_mergeConfig),
  "spread": () => (/* binding */ axios_spread),
  "toFormData": () => (/* binding */ axios_toFormData)
});

;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/bind.js


function bind(fn, thisArg) {
  return function wrap() {
    return fn.apply(thisArg, arguments);
  };
}

;// CONCATENATED MODULE: ./node_modules/axios/lib/utils.js




// utils is a library of generic helper functions non-specific to axios

const {toString: utils_toString} = Object.prototype;
const {getPrototypeOf} = Object;

const kindOf = (cache => thing => {
    const str = utils_toString.call(thing);
    return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
})(Object.create(null));

const kindOfTest = (type) => {
  type = type.toLowerCase();
  return (thing) => kindOf(thing) === type
}

const typeOfTest = type => thing => typeof thing === type;

/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 *
 * @returns {boolean} True if value is an Array, otherwise false
 */
const {isArray} = Array;

/**
 * Determine if a value is undefined
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if the value is undefined, otherwise false
 */
const isUndefined = typeOfTest('undefined');

/**
 * Determine if a value is a Buffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Buffer, otherwise false
 */
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)
    && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}

/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */
const isArrayBuffer = kindOfTest('ArrayBuffer');


/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */
function isArrayBufferView(val) {
  let result;
  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
    result = ArrayBuffer.isView(val);
  } else {
    result = (val) && (val.buffer) && (isArrayBuffer(val.buffer));
  }
  return result;
}

/**
 * Determine if a value is a String
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a String, otherwise false
 */
const isString = typeOfTest('string');

/**
 * Determine if a value is a Function
 *
 * @param {*} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */
const isFunction = typeOfTest('function');

/**
 * Determine if a value is a Number
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Number, otherwise false
 */
const isNumber = typeOfTest('number');

/**
 * Determine if a value is an Object
 *
 * @param {*} thing The value to test
 *
 * @returns {boolean} True if value is an Object, otherwise false
 */
const isObject = (thing) => thing !== null && typeof thing === 'object';

/**
 * Determine if a value is a Boolean
 *
 * @param {*} thing The value to test
 * @returns {boolean} True if value is a Boolean, otherwise false
 */
const isBoolean = thing => thing === true || thing === false;

/**
 * Determine if a value is a plain Object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a plain Object, otherwise false
 */
const isPlainObject = (val) => {
  if (kindOf(val) !== 'object') {
    return false;
  }

  const prototype = getPrototypeOf(val);
  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
}

/**
 * Determine if a value is a Date
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Date, otherwise false
 */
const isDate = kindOfTest('Date');

/**
 * Determine if a value is a File
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a File, otherwise false
 */
const isFile = kindOfTest('File');

/**
 * Determine if a value is a Blob
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Blob, otherwise false
 */
const isBlob = kindOfTest('Blob');

/**
 * Determine if a value is a FileList
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a File, otherwise false
 */
const isFileList = kindOfTest('FileList');

/**
 * Determine if a value is a Stream
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Stream, otherwise false
 */
const isStream = (val) => isObject(val) && isFunction(val.pipe);

/**
 * Determine if a value is a FormData
 *
 * @param {*} thing The value to test
 *
 * @returns {boolean} True if value is an FormData, otherwise false
 */
const isFormData = (thing) => {
  const pattern = '[object FormData]';
  return thing && (
    (typeof FormData === 'function' && thing instanceof FormData) ||
    utils_toString.call(thing) === pattern ||
    (isFunction(thing.toString) && thing.toString() === pattern)
  );
}

/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */
const isURLSearchParams = kindOfTest('URLSearchParams');

/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 *
 * @returns {String} The String freed of excess whitespace
 */
const trim = (str) => str.trim ?
  str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');

/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 *
 * @param {Boolean} [allOwnKeys = false]
 * @returns {any}
 */
function forEach(obj, fn, {allOwnKeys = false} = {}) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  }

  let i;
  let l;

  // Force an array if not already something iterable
  if (typeof obj !== 'object') {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }

  if (isArray(obj)) {
    // Iterate over array values
    for (i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Iterate over object keys
    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys.length;
    let key;

    for (i = 0; i < len; i++) {
      key = keys[i];
      fn.call(null, obj[key], key, obj);
    }
  }
}

function findKey(obj, key) {
  key = key.toLowerCase();
  const keys = Object.keys(obj);
  let i = keys.length;
  let _key;
  while (i-- > 0) {
    _key = keys[i];
    if (key === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}

const _global = (() => {
  /*eslint no-undef:0*/
  if (typeof globalThis !== "undefined") return globalThis;
  return typeof self !== "undefined" ? self : (typeof window !== 'undefined' ? window : global)
})();

const isContextDefined = (context) => !isUndefined(context) && context !== _global;

/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 *
 * @returns {Object} Result of all merge properties
 */
function merge(/* obj1, obj2, obj3, ... */) {
  const {caseless} = isContextDefined(this) && this || {};
  const result = {};
  const assignValue = (val, key) => {
    const targetKey = caseless && findKey(result, key) || key;
    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
      result[targetKey] = merge(result[targetKey], val);
    } else if (isPlainObject(val)) {
      result[targetKey] = merge({}, val);
    } else if (isArray(val)) {
      result[targetKey] = val.slice();
    } else {
      result[targetKey] = val;
    }
  }

  for (let i = 0, l = arguments.length; i < l; i++) {
    arguments[i] && forEach(arguments[i], assignValue);
  }
  return result;
}

/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 *
 * @param {Boolean} [allOwnKeys]
 * @returns {Object} The resulting value of object a
 */
const extend = (a, b, thisArg, {allOwnKeys}= {}) => {
  forEach(b, (val, key) => {
    if (thisArg && isFunction(val)) {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  }, {allOwnKeys});
  return a;
}

/**
 * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
 *
 * @param {string} content with BOM
 *
 * @returns {string} content value without BOM
 */
const stripBOM = (content) => {
  if (content.charCodeAt(0) === 0xFEFF) {
    content = content.slice(1);
  }
  return content;
}

/**
 * Inherit the prototype methods from one constructor into another
 * @param {function} constructor
 * @param {function} superConstructor
 * @param {object} [props]
 * @param {object} [descriptors]
 *
 * @returns {void}
 */
const inherits = (constructor, superConstructor, props, descriptors) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, 'super', {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
}

/**
 * Resolve object with deep prototype chain to a flat object
 * @param {Object} sourceObj source object
 * @param {Object} [destObj]
 * @param {Function|Boolean} [filter]
 * @param {Function} [propFilter]
 *
 * @returns {Object}
 */
const toFlatObject = (sourceObj, destObj, filter, propFilter) => {
  let props;
  let i;
  let prop;
  const merged = {};

  destObj = destObj || {};
  // eslint-disable-next-line no-eq-null,eqeqeq
  if (sourceObj == null) return destObj;

  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i = props.length;
    while (i-- > 0) {
      prop = props[i];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter !== false && getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);

  return destObj;
}

/**
 * Determines whether a string ends with the characters of a specified string
 *
 * @param {String} str
 * @param {String} searchString
 * @param {Number} [position= 0]
 *
 * @returns {boolean}
 */
const endsWith = (str, searchString, position) => {
  str = String(str);
  if (position === undefined || position > str.length) {
    position = str.length;
  }
  position -= searchString.length;
  const lastIndex = str.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
}


/**
 * Returns new array from array like object or null if failed
 *
 * @param {*} [thing]
 *
 * @returns {?Array}
 */
const toArray = (thing) => {
  if (!thing) return null;
  if (isArray(thing)) return thing;
  let i = thing.length;
  if (!isNumber(i)) return null;
  const arr = new Array(i);
  while (i-- > 0) {
    arr[i] = thing[i];
  }
  return arr;
}

/**
 * Checking if the Uint8Array exists and if it does, it returns a function that checks if the
 * thing passed in is an instance of Uint8Array
 *
 * @param {TypedArray}
 *
 * @returns {Array}
 */
// eslint-disable-next-line func-names
const isTypedArray = (TypedArray => {
  // eslint-disable-next-line func-names
  return thing => {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== 'undefined' && getPrototypeOf(Uint8Array));

/**
 * For each entry in the object, call the function with the key and value.
 *
 * @param {Object<any, any>} obj - The object to iterate over.
 * @param {Function} fn - The function to call for each entry.
 *
 * @returns {void}
 */
const forEachEntry = (obj, fn) => {
  const generator = obj && obj[Symbol.iterator];

  const iterator = generator.call(obj);

  let result;

  while ((result = iterator.next()) && !result.done) {
    const pair = result.value;
    fn.call(obj, pair[0], pair[1]);
  }
}

/**
 * It takes a regular expression and a string, and returns an array of all the matches
 *
 * @param {string} regExp - The regular expression to match against.
 * @param {string} str - The string to search.
 *
 * @returns {Array<boolean>}
 */
const matchAll = (regExp, str) => {
  let matches;
  const arr = [];

  while ((matches = regExp.exec(str)) !== null) {
    arr.push(matches);
  }

  return arr;
}

/* Checking if the kindOfTest function returns true when passed an HTMLFormElement. */
const isHTMLForm = kindOfTest('HTMLFormElement');

const toCamelCase = str => {
  return str.toLowerCase().replace(/[_-\s]([a-z\d])(\w*)/g,
    function replacer(m, p1, p2) {
      return p1.toUpperCase() + p2;
    }
  );
};

/* Creating a function that will check if an object has a property. */
const utils_hasOwnProperty = (({hasOwnProperty}) => (obj, prop) => hasOwnProperty.call(obj, prop))(Object.prototype);

/**
 * Determine if a value is a RegExp object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a RegExp object, otherwise false
 */
const isRegExp = kindOfTest('RegExp');

const reduceDescriptors = (obj, reducer) => {
  const descriptors = Object.getOwnPropertyDescriptors(obj);
  const reducedDescriptors = {};

  forEach(descriptors, (descriptor, name) => {
    if (reducer(descriptor, name, obj) !== false) {
      reducedDescriptors[name] = descriptor;
    }
  });

  Object.defineProperties(obj, reducedDescriptors);
}

/**
 * Makes all methods read-only
 * @param {Object} obj
 */

const freezeMethods = (obj) => {
  reduceDescriptors(obj, (descriptor, name) => {
    // skip restricted props in strict mode
    if (isFunction(obj) && ['arguments', 'caller', 'callee'].indexOf(name) !== -1) {
      return false;
    }

    const value = obj[name];

    if (!isFunction(value)) return;

    descriptor.enumerable = false;

    if ('writable' in descriptor) {
      descriptor.writable = false;
      return;
    }

    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error('Can not rewrite read-only method \'' + name + '\'');
      };
    }
  });
}

const toObjectSet = (arrayOrString, delimiter) => {
  const obj = {};

  const define = (arr) => {
    arr.forEach(value => {
      obj[value] = true;
    });
  }

  isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));

  return obj;
}

const noop = () => {}

const toFiniteNumber = (value, defaultValue) => {
  value = +value;
  return Number.isFinite(value) ? value : defaultValue;
}

const toJSONObject = (obj) => {
  const stack = new Array(10);

  const visit = (source, i) => {

    if (isObject(source)) {
      if (stack.indexOf(source) >= 0) {
        return;
      }

      if(!('toJSON' in source)) {
        stack[i] = source;
        const target = isArray(source) ? [] : {};

        forEach(source, (value, key) => {
          const reducedValue = visit(value, i + 1);
          !isUndefined(reducedValue) && (target[key] = reducedValue);
        });

        stack[i] = undefined;

        return target;
      }
    }

    return source;
  }

  return visit(obj, 0);
}

/* harmony default export */ const utils = ({
  isArray,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString,
  isNumber,
  isBoolean,
  isObject,
  isPlainObject,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isRegExp,
  isFunction,
  isStream,
  isURLSearchParams,
  isTypedArray,
  isFileList,
  forEach,
  merge,
  extend,
  trim,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty: utils_hasOwnProperty,
  hasOwnProp: utils_hasOwnProperty, // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop,
  toFiniteNumber,
  findKey,
  global: _global,
  isContextDefined,
  toJSONObject
});

;// CONCATENATED MODULE: ./node_modules/axios/lib/core/AxiosError.js




/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [config] The config.
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 *
 * @returns {Error} The created error.
 */
function AxiosError(message, code, config, request, response) {
  Error.call(this);

  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = (new Error()).stack;
  }

  this.message = message;
  this.name = 'AxiosError';
  code && (this.code = code);
  config && (this.config = config);
  request && (this.request = request);
  response && (this.response = response);
}

utils.inherits(AxiosError, Error, {
  toJSON: function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: utils.toJSONObject(this.config),
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  }
});

const AxiosError_prototype = AxiosError.prototype;
const descriptors = {};

[
  'ERR_BAD_OPTION_VALUE',
  'ERR_BAD_OPTION',
  'ECONNABORTED',
  'ETIMEDOUT',
  'ERR_NETWORK',
  'ERR_FR_TOO_MANY_REDIRECTS',
  'ERR_DEPRECATED',
  'ERR_BAD_RESPONSE',
  'ERR_BAD_REQUEST',
  'ERR_CANCELED',
  'ERR_NOT_SUPPORT',
  'ERR_INVALID_URL'
// eslint-disable-next-line func-names
].forEach(code => {
  descriptors[code] = {value: code};
});

Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(AxiosError_prototype, 'isAxiosError', {value: true});

// eslint-disable-next-line func-names
AxiosError.from = (error, code, config, request, response, customProps) => {
  const axiosError = Object.create(AxiosError_prototype);

  utils.toFlatObject(error, axiosError, function filter(obj) {
    return obj !== Error.prototype;
  }, prop => {
    return prop !== 'isAxiosError';
  });

  AxiosError.call(axiosError, error.message, code, config, request, response);

  axiosError.cause = error;

  axiosError.name = error.name;

  customProps && Object.assign(axiosError, customProps);

  return axiosError;
};

/* harmony default export */ const core_AxiosError = (AxiosError);

// EXTERNAL MODULE: ./node_modules/form-data/lib/browser.js
var browser = __webpack_require__(9721);
;// CONCATENATED MODULE: ./node_modules/axios/lib/env/classes/FormData.js

/* harmony default export */ const classes_FormData = (browser);

;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/toFormData.js






/**
 * Determines if the given thing is a array or js object.
 *
 * @param {string} thing - The object or array to be visited.
 *
 * @returns {boolean}
 */
function isVisitable(thing) {
  return utils.isPlainObject(thing) || utils.isArray(thing);
}

/**
 * It removes the brackets from the end of a string
 *
 * @param {string} key - The key of the parameter.
 *
 * @returns {string} the key without the brackets.
 */
function removeBrackets(key) {
  return utils.endsWith(key, '[]') ? key.slice(0, -2) : key;
}

/**
 * It takes a path, a key, and a boolean, and returns a string
 *
 * @param {string} path - The path to the current key.
 * @param {string} key - The key of the current object being iterated over.
 * @param {string} dots - If true, the key will be rendered with dots instead of brackets.
 *
 * @returns {string} The path to the current key.
 */
function renderKey(path, key, dots) {
  if (!path) return key;
  return path.concat(key).map(function each(token, i) {
    // eslint-disable-next-line no-param-reassign
    token = removeBrackets(token);
    return !dots && i ? '[' + token + ']' : token;
  }).join(dots ? '.' : '');
}

/**
 * If the array is an array and none of its elements are visitable, then it's a flat array.
 *
 * @param {Array<any>} arr - The array to check
 *
 * @returns {boolean}
 */
function isFlatArray(arr) {
  return utils.isArray(arr) && !arr.some(isVisitable);
}

const predicates = utils.toFlatObject(utils, {}, null, function filter(prop) {
  return /^is[A-Z]/.test(prop);
});

/**
 * If the thing is a FormData object, return true, otherwise return false.
 *
 * @param {unknown} thing - The thing to check.
 *
 * @returns {boolean}
 */
function isSpecCompliant(thing) {
  return thing && utils.isFunction(thing.append) && thing[Symbol.toStringTag] === 'FormData' && thing[Symbol.iterator];
}

/**
 * Convert a data object to FormData
 *
 * @param {Object} obj
 * @param {?Object} [formData]
 * @param {?Object} [options]
 * @param {Function} [options.visitor]
 * @param {Boolean} [options.metaTokens = true]
 * @param {Boolean} [options.dots = false]
 * @param {?Boolean} [options.indexes = false]
 *
 * @returns {Object}
 **/

/**
 * It converts an object into a FormData object
 *
 * @param {Object<any, any>} obj - The object to convert to form data.
 * @param {string} formData - The FormData object to append to.
 * @param {Object<string, any>} options
 *
 * @returns
 */
function toFormData(obj, formData, options) {
  if (!utils.isObject(obj)) {
    throw new TypeError('target must be an object');
  }

  // eslint-disable-next-line no-param-reassign
  formData = formData || new (classes_FormData || FormData)();

  // eslint-disable-next-line no-param-reassign
  options = utils.toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined(option, source) {
    // eslint-disable-next-line no-eq-null,eqeqeq
    return !utils.isUndefined(source[option]);
  });

  const metaTokens = options.metaTokens;
  // eslint-disable-next-line no-use-before-define
  const visitor = options.visitor || defaultVisitor;
  const dots = options.dots;
  const indexes = options.indexes;
  const _Blob = options.Blob || typeof Blob !== 'undefined' && Blob;
  const useBlob = _Blob && isSpecCompliant(formData);

  if (!utils.isFunction(visitor)) {
    throw new TypeError('visitor must be a function');
  }

  function convertValue(value) {
    if (value === null) return '';

    if (utils.isDate(value)) {
      return value.toISOString();
    }

    if (!useBlob && utils.isBlob(value)) {
      throw new core_AxiosError('Blob is not supported. Use a Buffer instead.');
    }

    if (utils.isArrayBuffer(value) || utils.isTypedArray(value)) {
      return useBlob && typeof Blob === 'function' ? new Blob([value]) : Buffer.from(value);
    }

    return value;
  }

  /**
   * Default visitor.
   *
   * @param {*} value
   * @param {String|Number} key
   * @param {Array<String|Number>} path
   * @this {FormData}
   *
   * @returns {boolean} return true to visit the each prop of the value recursively
   */
  function defaultVisitor(value, key, path) {
    let arr = value;

    if (value && !path && typeof value === 'object') {
      if (utils.endsWith(key, '{}')) {
        // eslint-disable-next-line no-param-reassign
        key = metaTokens ? key : key.slice(0, -2);
        // eslint-disable-next-line no-param-reassign
        value = JSON.stringify(value);
      } else if (
        (utils.isArray(value) && isFlatArray(value)) ||
        (utils.isFileList(value) || utils.endsWith(key, '[]') && (arr = utils.toArray(value))
        )) {
        // eslint-disable-next-line no-param-reassign
        key = removeBrackets(key);

        arr.forEach(function each(el, index) {
          !(utils.isUndefined(el) || el === null) && formData.append(
            // eslint-disable-next-line no-nested-ternary
            indexes === true ? renderKey([key], index, dots) : (indexes === null ? key : key + '[]'),
            convertValue(el)
          );
        });
        return false;
      }
    }

    if (isVisitable(value)) {
      return true;
    }

    formData.append(renderKey(path, key, dots), convertValue(value));

    return false;
  }

  const stack = [];

  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });

  function build(value, path) {
    if (utils.isUndefined(value)) return;

    if (stack.indexOf(value) !== -1) {
      throw Error('Circular reference detected in ' + path.join('.'));
    }

    stack.push(value);

    utils.forEach(value, function each(el, key) {
      const result = !(utils.isUndefined(el) || el === null) && visitor.call(
        formData, el, utils.isString(key) ? key.trim() : key, path, exposedHelpers
      );

      if (result === true) {
        build(el, path ? path.concat(key) : [key]);
      }
    });

    stack.pop();
  }

  if (!utils.isObject(obj)) {
    throw new TypeError('data must be an object');
  }

  build(obj);

  return formData;
}

/* harmony default export */ const helpers_toFormData = (toFormData);

;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/AxiosURLSearchParams.js




/**
 * It encodes a string by replacing all characters that are not in the unreserved set with
 * their percent-encoded equivalents
 *
 * @param {string} str - The string to encode.
 *
 * @returns {string} The encoded string.
 */
function encode(str) {
  const charMap = {
    '!': '%21',
    "'": '%27',
    '(': '%28',
    ')': '%29',
    '~': '%7E',
    '%20': '+',
    '%00': '\x00'
  };
  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
    return charMap[match];
  });
}

/**
 * It takes a params object and converts it to a FormData object
 *
 * @param {Object<string, any>} params - The parameters to be converted to a FormData object.
 * @param {Object<string, any>} options - The options object passed to the Axios constructor.
 *
 * @returns {void}
 */
function AxiosURLSearchParams(params, options) {
  this._pairs = [];

  params && helpers_toFormData(params, this, options);
}

const AxiosURLSearchParams_prototype = AxiosURLSearchParams.prototype;

AxiosURLSearchParams_prototype.append = function append(name, value) {
  this._pairs.push([name, value]);
};

AxiosURLSearchParams_prototype.toString = function toString(encoder) {
  const _encode = encoder ? function(value) {
    return encoder.call(this, value, encode);
  } : encode;

  return this._pairs.map(function each(pair) {
    return _encode(pair[0]) + '=' + _encode(pair[1]);
  }, '').join('&');
};

/* harmony default export */ const helpers_AxiosURLSearchParams = (AxiosURLSearchParams);

;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/buildURL.js





/**
 * It replaces all instances of the characters `:`, `$`, `,`, `+`, `[`, and `]` with their
 * URI encoded counterparts
 *
 * @param {string} val The value to be encoded.
 *
 * @returns {string} The encoded value.
 */
function buildURL_encode(val) {
  return encodeURIComponent(val).
    replace(/%3A/gi, ':').
    replace(/%24/g, '$').
    replace(/%2C/gi, ',').
    replace(/%20/g, '+').
    replace(/%5B/gi, '[').
    replace(/%5D/gi, ']');
}

/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @param {?object} options
 *
 * @returns {string} The formatted url
 */
function buildURL(url, params, options) {
  /*eslint no-param-reassign:0*/
  if (!params) {
    return url;
  }
  
  const _encode = options && options.encode || buildURL_encode;

  const serializeFn = options && options.serialize;

  let serializedParams;

  if (serializeFn) {
    serializedParams = serializeFn(params, options);
  } else {
    serializedParams = utils.isURLSearchParams(params) ?
      params.toString() :
      new helpers_AxiosURLSearchParams(params, options).toString(_encode);
  }

  if (serializedParams) {
    const hashmarkIndex = url.indexOf("#");

    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }
    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
  }

  return url;
}

;// CONCATENATED MODULE: ./node_modules/axios/lib/core/InterceptorManager.js




class InterceptorManager {
  constructor() {
    this.handlers = [];
  }

  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  }

  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(id) {
    if (this.handlers[id]) {
      this.handlers[id] = null;
    }
  }

  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }

  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(fn) {
    utils.forEach(this.handlers, function forEachHandler(h) {
      if (h !== null) {
        fn(h);
      }
    });
  }
}

/* harmony default export */ const core_InterceptorManager = (InterceptorManager);

;// CONCATENATED MODULE: ./node_modules/axios/lib/defaults/transitional.js


/* harmony default export */ const defaults_transitional = ({
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
});

;// CONCATENATED MODULE: ./node_modules/axios/lib/platform/browser/classes/URLSearchParams.js



/* harmony default export */ const classes_URLSearchParams = (typeof URLSearchParams !== 'undefined' ? URLSearchParams : helpers_AxiosURLSearchParams);

;// CONCATENATED MODULE: ./node_modules/axios/lib/platform/browser/classes/FormData.js


/* harmony default export */ const browser_classes_FormData = (FormData);

;// CONCATENATED MODULE: ./node_modules/axios/lib/platform/browser/index.js



/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 * nativescript
 *  navigator.product -> 'NativeScript' or 'NS'
 *
 * @returns {boolean}
 */
const isStandardBrowserEnv = (() => {
  let product;
  if (typeof navigator !== 'undefined' && (
    (product = navigator.product) === 'ReactNative' ||
    product === 'NativeScript' ||
    product === 'NS')
  ) {
    return false;
  }

  return typeof window !== 'undefined' && typeof document !== 'undefined';
})();

/**
 * Determine if we're running in a standard browser webWorker environment
 *
 * Although the `isStandardBrowserEnv` method indicates that
 * `allows axios to run in a web worker`, the WebWorker will still be
 * filtered out due to its judgment standard
 * `typeof window !== 'undefined' && typeof document !== 'undefined'`.
 * This leads to a problem when axios post `FormData` in webWorker
 */
 const isStandardBrowserWebWorkerEnv = (() => {
  return (
    typeof WorkerGlobalScope !== 'undefined' &&
    // eslint-disable-next-line no-undef
    self instanceof WorkerGlobalScope &&
    typeof self.importScripts === 'function'
  );
})();


/* harmony default export */ const platform_browser = ({
  isBrowser: true,
  classes: {
    URLSearchParams: classes_URLSearchParams,
    FormData: browser_classes_FormData,
    Blob
  },
  isStandardBrowserEnv,
  isStandardBrowserWebWorkerEnv,
  protocols: ['http', 'https', 'file', 'blob', 'url', 'data']
});

;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/toURLEncodedForm.js






function toURLEncodedForm(data, options) {
  return helpers_toFormData(data, new platform_browser.classes.URLSearchParams(), Object.assign({
    visitor: function(value, key, path, helpers) {
      if (platform_browser.isNode && utils.isBuffer(value)) {
        this.append(key, value.toString('base64'));
        return false;
      }

      return helpers.defaultVisitor.apply(this, arguments);
    }
  }, options));
}

;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/formDataToJSON.js




/**
 * It takes a string like `foo[x][y][z]` and returns an array like `['foo', 'x', 'y', 'z']
 *
 * @param {string} name - The name of the property to get.
 *
 * @returns An array of strings.
 */
function parsePropPath(name) {
  // foo[x][y][z]
  // foo.x.y.z
  // foo-x-y-z
  // foo x y z
  return utils.matchAll(/\w+|\[(\w*)]/g, name).map(match => {
    return match[0] === '[]' ? '' : match[1] || match[0];
  });
}

/**
 * Convert an array to an object.
 *
 * @param {Array<any>} arr - The array to convert to an object.
 *
 * @returns An object with the same keys and values as the array.
 */
function arrayToObject(arr) {
  const obj = {};
  const keys = Object.keys(arr);
  let i;
  const len = keys.length;
  let key;
  for (i = 0; i < len; i++) {
    key = keys[i];
    obj[key] = arr[key];
  }
  return obj;
}

/**
 * It takes a FormData object and returns a JavaScript object
 *
 * @param {string} formData The FormData object to convert to JSON.
 *
 * @returns {Object<string, any> | null} The converted object.
 */
function formDataToJSON(formData) {
  function buildPath(path, value, target, index) {
    let name = path[index++];
    const isNumericKey = Number.isFinite(+name);
    const isLast = index >= path.length;
    name = !name && utils.isArray(target) ? target.length : name;

    if (isLast) {
      if (utils.hasOwnProp(target, name)) {
        target[name] = [target[name], value];
      } else {
        target[name] = value;
      }

      return !isNumericKey;
    }

    if (!target[name] || !utils.isObject(target[name])) {
      target[name] = [];
    }

    const result = buildPath(path, value, target[name], index);

    if (result && utils.isArray(target[name])) {
      target[name] = arrayToObject(target[name]);
    }

    return !isNumericKey;
  }

  if (utils.isFormData(formData) && utils.isFunction(formData.entries)) {
    const obj = {};

    utils.forEachEntry(formData, (name, value) => {
      buildPath(parsePropPath(name), value, obj, 0);
    });

    return obj;
  }

  return null;
}

/* harmony default export */ const helpers_formDataToJSON = (formDataToJSON);

;// CONCATENATED MODULE: ./node_modules/axios/lib/defaults/index.js










const DEFAULT_CONTENT_TYPE = {
  'Content-Type': undefined
};

/**
 * It takes a string, tries to parse it, and if it fails, it returns the stringified version
 * of the input
 *
 * @param {any} rawValue - The value to be stringified.
 * @param {Function} parser - A function that parses a string into a JavaScript object.
 * @param {Function} encoder - A function that takes a value and returns a string.
 *
 * @returns {string} A stringified version of the rawValue.
 */
function stringifySafely(rawValue, parser, encoder) {
  if (utils.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils.trim(rawValue);
    } catch (e) {
      if (e.name !== 'SyntaxError') {
        throw e;
      }
    }
  }

  return (encoder || JSON.stringify)(rawValue);
}

const defaults = {

  transitional: defaults_transitional,

  adapter: ['xhr', 'http'],

  transformRequest: [function transformRequest(data, headers) {
    const contentType = headers.getContentType() || '';
    const hasJSONContentType = contentType.indexOf('application/json') > -1;
    const isObjectPayload = utils.isObject(data);

    if (isObjectPayload && utils.isHTMLForm(data)) {
      data = new FormData(data);
    }

    const isFormData = utils.isFormData(data);

    if (isFormData) {
      if (!hasJSONContentType) {
        return data;
      }
      return hasJSONContentType ? JSON.stringify(helpers_formDataToJSON(data)) : data;
    }

    if (utils.isArrayBuffer(data) ||
      utils.isBuffer(data) ||
      utils.isStream(data) ||
      utils.isFile(data) ||
      utils.isBlob(data)
    ) {
      return data;
    }
    if (utils.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils.isURLSearchParams(data)) {
      headers.setContentType('application/x-www-form-urlencoded;charset=utf-8', false);
      return data.toString();
    }

    let isFileList;

    if (isObjectPayload) {
      if (contentType.indexOf('application/x-www-form-urlencoded') > -1) {
        return toURLEncodedForm(data, this.formSerializer).toString();
      }

      if ((isFileList = utils.isFileList(data)) || contentType.indexOf('multipart/form-data') > -1) {
        const _FormData = this.env && this.env.FormData;

        return helpers_toFormData(
          isFileList ? {'files[]': data} : data,
          _FormData && new _FormData(),
          this.formSerializer
        );
      }
    }

    if (isObjectPayload || hasJSONContentType ) {
      headers.setContentType('application/json', false);
      return stringifySafely(data);
    }

    return data;
  }],

  transformResponse: [function transformResponse(data) {
    const transitional = this.transitional || defaults.transitional;
    const forcedJSONParsing = transitional && transitional.forcedJSONParsing;
    const JSONRequested = this.responseType === 'json';

    if (data && utils.isString(data) && ((forcedJSONParsing && !this.responseType) || JSONRequested)) {
      const silentJSONParsing = transitional && transitional.silentJSONParsing;
      const strictJSONParsing = !silentJSONParsing && JSONRequested;

      try {
        return JSON.parse(data);
      } catch (e) {
        if (strictJSONParsing) {
          if (e.name === 'SyntaxError') {
            throw core_AxiosError.from(e, core_AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e;
        }
      }
    }

    return data;
  }],

  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,

  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',

  maxContentLength: -1,
  maxBodyLength: -1,

  env: {
    FormData: platform_browser.classes.FormData,
    Blob: platform_browser.classes.Blob
  },

  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },

  headers: {
    common: {
      'Accept': 'application/json, text/plain, */*'
    }
  }
};

utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
  defaults.headers[method] = {};
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
});

/* harmony default export */ const lib_defaults = (defaults);

;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/parseHeaders.js




// RawAxiosHeaders whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers
const ignoreDuplicateOf = utils.toObjectSet([
  'age', 'authorization', 'content-length', 'content-type', 'etag',
  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
  'last-modified', 'location', 'max-forwards', 'proxy-authorization',
  'referer', 'retry-after', 'user-agent'
]);

/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} rawHeaders Headers needing to be parsed
 *
 * @returns {Object} Headers parsed into an object
 */
/* harmony default export */ const parseHeaders = (rawHeaders => {
  const parsed = {};
  let key;
  let val;
  let i;

  rawHeaders && rawHeaders.split('\n').forEach(function parser(line) {
    i = line.indexOf(':');
    key = line.substring(0, i).trim().toLowerCase();
    val = line.substring(i + 1).trim();

    if (!key || (parsed[key] && ignoreDuplicateOf[key])) {
      return;
    }

    if (key === 'set-cookie') {
      if (parsed[key]) {
        parsed[key].push(val);
      } else {
        parsed[key] = [val];
      }
    } else {
      parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
    }
  });

  return parsed;
});

;// CONCATENATED MODULE: ./node_modules/axios/lib/core/AxiosHeaders.js





const $internals = Symbol('internals');

function normalizeHeader(header) {
  return header && String(header).trim().toLowerCase();
}

function normalizeValue(value) {
  if (value === false || value == null) {
    return value;
  }

  return utils.isArray(value) ? value.map(normalizeValue) : String(value);
}

function parseTokens(str) {
  const tokens = Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match;

  while ((match = tokensRE.exec(str))) {
    tokens[match[1]] = match[2];
  }

  return tokens;
}

function isValidHeaderName(str) {
  return /^[-_a-zA-Z]+$/.test(str.trim());
}

function matchHeaderValue(context, value, header, filter) {
  if (utils.isFunction(filter)) {
    return filter.call(this, value, header);
  }

  if (!utils.isString(value)) return;

  if (utils.isString(filter)) {
    return value.indexOf(filter) !== -1;
  }

  if (utils.isRegExp(filter)) {
    return filter.test(value);
  }
}

function formatHeader(header) {
  return header.trim()
    .toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str) => {
      return char.toUpperCase() + str;
    });
}

function buildAccessors(obj, header) {
  const accessorName = utils.toCamelCase(' ' + header);

  ['get', 'set', 'has'].forEach(methodName => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function(arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
      },
      configurable: true
    });
  });
}

class AxiosHeaders {
  constructor(headers) {
    headers && this.set(headers);
  }

  set(header, valueOrRewrite, rewrite) {
    const self = this;

    function setHeader(_value, _header, _rewrite) {
      const lHeader = normalizeHeader(_header);

      if (!lHeader) {
        throw new Error('header name must be a non-empty string');
      }

      const key = utils.findKey(self, lHeader);

      if(!key || self[key] === undefined || _rewrite === true || (_rewrite === undefined && self[key] !== false)) {
        self[key || _header] = normalizeValue(_value);
      }
    }

    const setHeaders = (headers, _rewrite) =>
      utils.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));

    if (utils.isPlainObject(header) || header instanceof this.constructor) {
      setHeaders(header, valueOrRewrite)
    } else if(utils.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
      setHeaders(parseHeaders(header), valueOrRewrite);
    } else {
      header != null && setHeader(valueOrRewrite, header, rewrite);
    }

    return this;
  }

  get(header, parser) {
    header = normalizeHeader(header);

    if (header) {
      const key = utils.findKey(this, header);

      if (key) {
        const value = this[key];

        if (!parser) {
          return value;
        }

        if (parser === true) {
          return parseTokens(value);
        }

        if (utils.isFunction(parser)) {
          return parser.call(this, value, key);
        }

        if (utils.isRegExp(parser)) {
          return parser.exec(value);
        }

        throw new TypeError('parser must be boolean|regexp|function');
      }
    }
  }

  has(header, matcher) {
    header = normalizeHeader(header);

    if (header) {
      const key = utils.findKey(this, header);

      return !!(key && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
    }

    return false;
  }

  delete(header, matcher) {
    const self = this;
    let deleted = false;

    function deleteHeader(_header) {
      _header = normalizeHeader(_header);

      if (_header) {
        const key = utils.findKey(self, _header);

        if (key && (!matcher || matchHeaderValue(self, self[key], key, matcher))) {
          delete self[key];

          deleted = true;
        }
      }
    }

    if (utils.isArray(header)) {
      header.forEach(deleteHeader);
    } else {
      deleteHeader(header);
    }

    return deleted;
  }

  clear() {
    return Object.keys(this).forEach(this.delete.bind(this));
  }

  normalize(format) {
    const self = this;
    const headers = {};

    utils.forEach(this, (value, header) => {
      const key = utils.findKey(headers, header);

      if (key) {
        self[key] = normalizeValue(value);
        delete self[header];
        return;
      }

      const normalized = format ? formatHeader(header) : String(header).trim();

      if (normalized !== header) {
        delete self[header];
      }

      self[normalized] = normalizeValue(value);

      headers[normalized] = true;
    });

    return this;
  }

  concat(...targets) {
    return this.constructor.concat(this, ...targets);
  }

  toJSON(asStrings) {
    const obj = Object.create(null);

    utils.forEach(this, (value, header) => {
      value != null && value !== false && (obj[header] = asStrings && utils.isArray(value) ? value.join(', ') : value);
    });

    return obj;
  }

  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }

  toString() {
    return Object.entries(this.toJSON()).map(([header, value]) => header + ': ' + value).join('\n');
  }

  get [Symbol.toStringTag]() {
    return 'AxiosHeaders';
  }

  static from(thing) {
    return thing instanceof this ? thing : new this(thing);
  }

  static concat(first, ...targets) {
    const computed = new this(first);

    targets.forEach((target) => computed.set(target));

    return computed;
  }

  static accessor(header) {
    const internals = this[$internals] = (this[$internals] = {
      accessors: {}
    });

    const accessors = internals.accessors;
    const prototype = this.prototype;

    function defineAccessor(_header) {
      const lHeader = normalizeHeader(_header);

      if (!accessors[lHeader]) {
        buildAccessors(prototype, _header);
        accessors[lHeader] = true;
      }
    }

    utils.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);

    return this;
  }
}

AxiosHeaders.accessor(['Content-Type', 'Content-Length', 'Accept', 'Accept-Encoding', 'User-Agent']);

utils.freezeMethods(AxiosHeaders.prototype);
utils.freezeMethods(AxiosHeaders);

/* harmony default export */ const core_AxiosHeaders = (AxiosHeaders);

;// CONCATENATED MODULE: ./node_modules/axios/lib/core/transformData.js






/**
 * Transform the data for a request or a response
 *
 * @param {Array|Function} fns A single function or Array of functions
 * @param {?Object} response The response object
 *
 * @returns {*} The resulting transformed data
 */
function transformData(fns, response) {
  const config = this || lib_defaults;
  const context = response || config;
  const headers = core_AxiosHeaders.from(context.headers);
  let data = context.data;

  utils.forEach(fns, function transform(fn) {
    data = fn.call(config, data, headers.normalize(), response ? response.status : undefined);
  });

  headers.normalize();

  return data;
}

;// CONCATENATED MODULE: ./node_modules/axios/lib/cancel/isCancel.js


function isCancel(value) {
  return !!(value && value.__CANCEL__);
}

;// CONCATENATED MODULE: ./node_modules/axios/lib/cancel/CanceledError.js





/**
 * A `CanceledError` is an object that is thrown when an operation is canceled.
 *
 * @param {string=} message The message.
 * @param {Object=} config The config.
 * @param {Object=} request The request.
 *
 * @returns {CanceledError} The created error.
 */
function CanceledError(message, config, request) {
  // eslint-disable-next-line no-eq-null,eqeqeq
  core_AxiosError.call(this, message == null ? 'canceled' : message, core_AxiosError.ERR_CANCELED, config, request);
  this.name = 'CanceledError';
}

utils.inherits(CanceledError, core_AxiosError, {
  __CANCEL__: true
});

/* harmony default export */ const cancel_CanceledError = (CanceledError);

;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/null.js
// eslint-disable-next-line strict
/* harmony default export */ const helpers_null = (null);

;// CONCATENATED MODULE: ./node_modules/axios/lib/core/settle.js




/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 *
 * @returns {object} The response.
 */
function settle(resolve, reject, response) {
  const validateStatus = response.config.validateStatus;
  if (!response.status || !validateStatus || validateStatus(response.status)) {
    resolve(response);
  } else {
    reject(new core_AxiosError(
      'Request failed with status code ' + response.status,
      [core_AxiosError.ERR_BAD_REQUEST, core_AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
      response.config,
      response.request,
      response
    ));
  }
}

;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/cookies.js





/* harmony default export */ const cookies = (platform_browser.isStandardBrowserEnv ?

// Standard browser envs support document.cookie
  (function standardBrowserEnv() {
    return {
      write: function write(name, value, expires, path, domain, secure) {
        const cookie = [];
        cookie.push(name + '=' + encodeURIComponent(value));

        if (utils.isNumber(expires)) {
          cookie.push('expires=' + new Date(expires).toGMTString());
        }

        if (utils.isString(path)) {
          cookie.push('path=' + path);
        }

        if (utils.isString(domain)) {
          cookie.push('domain=' + domain);
        }

        if (secure === true) {
          cookie.push('secure');
        }

        document.cookie = cookie.join('; ');
      },

      read: function read(name) {
        const match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
        return (match ? decodeURIComponent(match[3]) : null);
      },

      remove: function remove(name) {
        this.write(name, '', Date.now() - 86400000);
      }
    };
  })() :

// Non standard browser env (web workers, react-native) lack needed support.
  (function nonStandardBrowserEnv() {
    return {
      write: function write() {},
      read: function read() { return null; },
      remove: function remove() {}
    };
  })());

;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/isAbsoluteURL.js


/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 *
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */
function isAbsoluteURL(url) {
  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
  // by any combination of letters, digits, plus, period, or hyphen.
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
}

;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/combineURLs.js


/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 *
 * @returns {string} The combined URL
 */
function combineURLs(baseURL, relativeURL) {
  return relativeURL
    ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '')
    : baseURL;
}

;// CONCATENATED MODULE: ./node_modules/axios/lib/core/buildFullPath.js





/**
 * Creates a new URL by combining the baseURL with the requestedURL,
 * only when the requestedURL is not already an absolute URL.
 * If the requestURL is absolute, this function returns the requestedURL untouched.
 *
 * @param {string} baseURL The base URL
 * @param {string} requestedURL Absolute or relative URL to combine
 *
 * @returns {string} The combined full path
 */
function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
}

;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/isURLSameOrigin.js





/* harmony default export */ const isURLSameOrigin = (platform_browser.isStandardBrowserEnv ?

// Standard browser envs have full support of the APIs needed to test
// whether the request URL is of the same origin as current location.
  (function standardBrowserEnv() {
    const msie = /(msie|trident)/i.test(navigator.userAgent);
    const urlParsingNode = document.createElement('a');
    let originURL;

    /**
    * Parse a URL to discover it's components
    *
    * @param {String} url The URL to be parsed
    * @returns {Object}
    */
    function resolveURL(url) {
      let href = url;

      if (msie) {
        // IE needs attribute set twice to normalize properties
        urlParsingNode.setAttribute('href', href);
        href = urlParsingNode.href;
      }

      urlParsingNode.setAttribute('href', href);

      // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
      return {
        href: urlParsingNode.href,
        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
        host: urlParsingNode.host,
        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
        hostname: urlParsingNode.hostname,
        port: urlParsingNode.port,
        pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
          urlParsingNode.pathname :
          '/' + urlParsingNode.pathname
      };
    }

    originURL = resolveURL(window.location.href);

    /**
    * Determine if a URL shares the same origin as the current location
    *
    * @param {String} requestURL The URL to test
    * @returns {boolean} True if URL shares the same origin, otherwise false
    */
    return function isURLSameOrigin(requestURL) {
      const parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
      return (parsed.protocol === originURL.protocol &&
          parsed.host === originURL.host);
    };
  })() :

  // Non standard browser envs (web workers, react-native) lack needed support.
  (function nonStandardBrowserEnv() {
    return function isURLSameOrigin() {
      return true;
    };
  })());

;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/parseProtocol.js


function parseProtocol(url) {
  const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
  return match && match[1] || '';
}

;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/speedometer.js


/**
 * Calculate data maxRate
 * @param {Number} [samplesCount= 10]
 * @param {Number} [min= 1000]
 * @returns {Function}
 */
function speedometer(samplesCount, min) {
  samplesCount = samplesCount || 10;
  const bytes = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head = 0;
  let tail = 0;
  let firstSampleTS;

  min = min !== undefined ? min : 1000;

  return function push(chunkLength) {
    const now = Date.now();

    const startedAt = timestamps[tail];

    if (!firstSampleTS) {
      firstSampleTS = now;
    }

    bytes[head] = chunkLength;
    timestamps[head] = now;

    let i = tail;
    let bytesCount = 0;

    while (i !== head) {
      bytesCount += bytes[i++];
      i = i % samplesCount;
    }

    head = (head + 1) % samplesCount;

    if (head === tail) {
      tail = (tail + 1) % samplesCount;
    }

    if (now - firstSampleTS < min) {
      return;
    }

    const passed = startedAt && now - startedAt;

    return passed ? Math.round(bytesCount * 1000 / passed) : undefined;
  };
}

/* harmony default export */ const helpers_speedometer = (speedometer);

;// CONCATENATED MODULE: ./node_modules/axios/lib/adapters/xhr.js
















function progressEventReducer(listener, isDownloadStream) {
  let bytesNotified = 0;
  const _speedometer = helpers_speedometer(50, 250);

  return e => {
    const loaded = e.loaded;
    const total = e.lengthComputable ? e.total : undefined;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange = loaded <= total;

    bytesNotified = loaded;

    const data = {
      loaded,
      total,
      progress: total ? (loaded / total) : undefined,
      bytes: progressBytes,
      rate: rate ? rate : undefined,
      estimated: rate && total && inRange ? (total - loaded) / rate : undefined,
      event: e
    };

    data[isDownloadStream ? 'download' : 'upload'] = true;

    listener(data);
  };
}

const isXHRAdapterSupported = typeof XMLHttpRequest !== 'undefined';

/* harmony default export */ const xhr = (isXHRAdapterSupported && function (config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    let requestData = config.data;
    const requestHeaders = core_AxiosHeaders.from(config.headers).normalize();
    const responseType = config.responseType;
    let onCanceled;
    function done() {
      if (config.cancelToken) {
        config.cancelToken.unsubscribe(onCanceled);
      }

      if (config.signal) {
        config.signal.removeEventListener('abort', onCanceled);
      }
    }

    if (utils.isFormData(requestData) && (platform_browser.isStandardBrowserEnv || platform_browser.isStandardBrowserWebWorkerEnv)) {
      requestHeaders.setContentType(false); // Let the browser set it
    }

    let request = new XMLHttpRequest();

    // HTTP basic authentication
    if (config.auth) {
      const username = config.auth.username || '';
      const password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';
      requestHeaders.set('Authorization', 'Basic ' + btoa(username + ':' + password));
    }

    const fullPath = buildFullPath(config.baseURL, config.url);

    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);

    // Set the request timeout in MS
    request.timeout = config.timeout;

    function onloadend() {
      if (!request) {
        return;
      }
      // Prepare the response
      const responseHeaders = core_AxiosHeaders.from(
        'getAllResponseHeaders' in request && request.getAllResponseHeaders()
      );
      const responseData = !responseType || responseType === 'text' || responseType === 'json' ?
        request.responseText : request.response;
      const response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config,
        request
      };

      settle(function _resolve(value) {
        resolve(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);

      // Clean up request
      request = null;
    }

    if ('onloadend' in request) {
      // Use onloadend if available
      request.onloadend = onloadend;
    } else {
      // Listen for ready state to emulate onloadend
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }

        // The request errored out and we didn't get a response, this will be
        // handled by onerror instead
        // With one exception: request that using file: protocol, most browsers
        // will return status as 0 even though it's a successful request
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
          return;
        }
        // readystate handler is calling before onerror or ontimeout handlers,
        // so we should call onloadend on the next 'tick'
        setTimeout(onloadend);
      };
    }

    // Handle browser request cancellation (as opposed to a manual cancellation)
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }

      reject(new core_AxiosError('Request aborted', core_AxiosError.ECONNABORTED, config, request));

      // Clean up request
      request = null;
    };

    // Handle low level network errors
    request.onerror = function handleError() {
      // Real errors are hidden from us by the browser
      // onerror should only fire if it's a network error
      reject(new core_AxiosError('Network Error', core_AxiosError.ERR_NETWORK, config, request));

      // Clean up request
      request = null;
    };

    // Handle timeout
    request.ontimeout = function handleTimeout() {
      let timeoutErrorMessage = config.timeout ? 'timeout of ' + config.timeout + 'ms exceeded' : 'timeout exceeded';
      const transitional = config.transitional || defaults_transitional;
      if (config.timeoutErrorMessage) {
        timeoutErrorMessage = config.timeoutErrorMessage;
      }
      reject(new core_AxiosError(
        timeoutErrorMessage,
        transitional.clarifyTimeoutError ? core_AxiosError.ETIMEDOUT : core_AxiosError.ECONNABORTED,
        config,
        request));

      // Clean up request
      request = null;
    };

    // Add xsrf header
    // This is only done if running in a standard browser environment.
    // Specifically not if we're in a web worker, or react-native.
    if (platform_browser.isStandardBrowserEnv) {
      // Add xsrf header
      const xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath))
        && config.xsrfCookieName && cookies.read(config.xsrfCookieName);

      if (xsrfValue) {
        requestHeaders.set(config.xsrfHeaderName, xsrfValue);
      }
    }

    // Remove Content-Type if data is undefined
    requestData === undefined && requestHeaders.setContentType(null);

    // Add headers to the request
    if ('setRequestHeader' in request) {
      utils.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
        request.setRequestHeader(key, val);
      });
    }

    // Add withCredentials to request if needed
    if (!utils.isUndefined(config.withCredentials)) {
      request.withCredentials = !!config.withCredentials;
    }

    // Add responseType to request if needed
    if (responseType && responseType !== 'json') {
      request.responseType = config.responseType;
    }

    // Handle progress if needed
    if (typeof config.onDownloadProgress === 'function') {
      request.addEventListener('progress', progressEventReducer(config.onDownloadProgress, true));
    }

    // Not all browsers support upload events
    if (typeof config.onUploadProgress === 'function' && request.upload) {
      request.upload.addEventListener('progress', progressEventReducer(config.onUploadProgress));
    }

    if (config.cancelToken || config.signal) {
      // Handle cancellation
      // eslint-disable-next-line func-names
      onCanceled = cancel => {
        if (!request) {
          return;
        }
        reject(!cancel || cancel.type ? new cancel_CanceledError(null, config, request) : cancel);
        request.abort();
        request = null;
      };

      config.cancelToken && config.cancelToken.subscribe(onCanceled);
      if (config.signal) {
        config.signal.aborted ? onCanceled() : config.signal.addEventListener('abort', onCanceled);
      }
    }

    const protocol = parseProtocol(fullPath);

    if (protocol && platform_browser.protocols.indexOf(protocol) === -1) {
      reject(new core_AxiosError('Unsupported protocol ' + protocol + ':', core_AxiosError.ERR_BAD_REQUEST, config));
      return;
    }


    // Send the request
    request.send(requestData || null);
  });
});

;// CONCATENATED MODULE: ./node_modules/axios/lib/adapters/adapters.js





const knownAdapters = {
  http: helpers_null,
  xhr: xhr
}

utils.forEach(knownAdapters, (fn, value) => {
  if(fn) {
    try {
      Object.defineProperty(fn, 'name', {value});
    } catch (e) {
      // eslint-disable-next-line no-empty
    }
    Object.defineProperty(fn, 'adapterName', {value});
  }
});

/* harmony default export */ const adapters = ({
  getAdapter: (adapters) => {
    adapters = utils.isArray(adapters) ? adapters : [adapters];

    const {length} = adapters;
    let nameOrAdapter;
    let adapter;

    for (let i = 0; i < length; i++) {
      nameOrAdapter = adapters[i];
      if((adapter = utils.isString(nameOrAdapter) ? knownAdapters[nameOrAdapter.toLowerCase()] : nameOrAdapter)) {
        break;
      }
    }

    if (!adapter) {
      if (adapter === false) {
        throw new core_AxiosError(
          `Adapter ${nameOrAdapter} is not supported by the environment`,
          'ERR_NOT_SUPPORT'
        );
      }

      throw new Error(
        utils.hasOwnProp(knownAdapters, nameOrAdapter) ?
          `Adapter '${nameOrAdapter}' is not available in the build` :
          `Unknown adapter '${nameOrAdapter}'`
      );
    }

    if (!utils.isFunction(adapter)) {
      throw new TypeError('adapter is not a function');
    }

    return adapter;
  },
  adapters: knownAdapters
});

;// CONCATENATED MODULE: ./node_modules/axios/lib/core/dispatchRequest.js









/**
 * Throws a `CanceledError` if cancellation has been requested.
 *
 * @param {Object} config The config that is to be used for the request
 *
 * @returns {void}
 */
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }

  if (config.signal && config.signal.aborted) {
    throw new cancel_CanceledError(null, config);
  }
}

/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 *
 * @returns {Promise} The Promise to be fulfilled
 */
function dispatchRequest(config) {
  throwIfCancellationRequested(config);

  config.headers = core_AxiosHeaders.from(config.headers);

  // Transform request data
  config.data = transformData.call(
    config,
    config.transformRequest
  );

  if (['post', 'put', 'patch'].indexOf(config.method) !== -1) {
    config.headers.setContentType('application/x-www-form-urlencoded', false);
  }

  const adapter = adapters.getAdapter(config.adapter || lib_defaults.adapter);

  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);

    // Transform response data
    response.data = transformData.call(
      config,
      config.transformResponse,
      response
    );

    response.headers = core_AxiosHeaders.from(response.headers);

    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);

      // Transform response data
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config,
          config.transformResponse,
          reason.response
        );
        reason.response.headers = core_AxiosHeaders.from(reason.response.headers);
      }
    }

    return Promise.reject(reason);
  });
}

;// CONCATENATED MODULE: ./node_modules/axios/lib/core/mergeConfig.js





const headersToObject = (thing) => thing instanceof core_AxiosHeaders ? thing.toJSON() : thing;

/**
 * Config-specific merge-function which creates a new config-object
 * by merging two configuration objects together.
 *
 * @param {Object} config1
 * @param {Object} config2
 *
 * @returns {Object} New object resulting from merging config2 to config1
 */
function mergeConfig(config1, config2) {
  // eslint-disable-next-line no-param-reassign
  config2 = config2 || {};
  const config = {};

  function getMergedValue(target, source, caseless) {
    if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
      return utils.merge.call({caseless}, target, source);
    } else if (utils.isPlainObject(source)) {
      return utils.merge({}, source);
    } else if (utils.isArray(source)) {
      return source.slice();
    }
    return source;
  }

  // eslint-disable-next-line consistent-return
  function mergeDeepProperties(a, b, caseless) {
    if (!utils.isUndefined(b)) {
      return getMergedValue(a, b, caseless);
    } else if (!utils.isUndefined(a)) {
      return getMergedValue(undefined, a, caseless);
    }
  }

  // eslint-disable-next-line consistent-return
  function valueFromConfig2(a, b) {
    if (!utils.isUndefined(b)) {
      return getMergedValue(undefined, b);
    }
  }

  // eslint-disable-next-line consistent-return
  function defaultToConfig2(a, b) {
    if (!utils.isUndefined(b)) {
      return getMergedValue(undefined, b);
    } else if (!utils.isUndefined(a)) {
      return getMergedValue(undefined, a);
    }
  }

  // eslint-disable-next-line consistent-return
  function mergeDirectKeys(a, b, prop) {
    if (prop in config2) {
      return getMergedValue(a, b);
    } else if (prop in config1) {
      return getMergedValue(undefined, a);
    }
  }

  const mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: (a, b) => mergeDeepProperties(headersToObject(a), headersToObject(b), true)
  };

  utils.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {
    const merge = mergeMap[prop] || mergeDeepProperties;
    const configValue = merge(config1[prop], config2[prop], prop);
    (utils.isUndefined(configValue) && merge !== mergeDirectKeys) || (config[prop] = configValue);
  });

  return config;
}

;// CONCATENATED MODULE: ./node_modules/axios/lib/env/data.js
const VERSION = "1.2.2";
;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/validator.js





const validators = {};

// eslint-disable-next-line func-names
['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach((type, i) => {
  validators[type] = function validator(thing) {
    return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;
  };
});

const deprecatedWarnings = {};

/**
 * Transitional option validator
 *
 * @param {function|boolean?} validator - set to false if the transitional option has been removed
 * @param {string?} version - deprecated version / removed since version
 * @param {string?} message - some message with additional info
 *
 * @returns {function}
 */
validators.transitional = function transitional(validator, version, message) {
  function formatMessage(opt, desc) {
    return '[Axios v' + VERSION + '] Transitional option \'' + opt + '\'' + desc + (message ? '. ' + message : '');
  }

  // eslint-disable-next-line func-names
  return (value, opt, opts) => {
    if (validator === false) {
      throw new core_AxiosError(
        formatMessage(opt, ' has been removed' + (version ? ' in ' + version : '')),
        core_AxiosError.ERR_DEPRECATED
      );
    }

    if (version && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      // eslint-disable-next-line no-console
      console.warn(
        formatMessage(
          opt,
          ' has been deprecated since v' + version + ' and will be removed in the near future'
        )
      );
    }

    return validator ? validator(value, opt, opts) : true;
  };
};

/**
 * Assert object's properties type
 *
 * @param {object} options
 * @param {object} schema
 * @param {boolean?} allowUnknown
 *
 * @returns {object}
 */

function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== 'object') {
    throw new core_AxiosError('options must be an object', core_AxiosError.ERR_BAD_OPTION_VALUE);
  }
  const keys = Object.keys(options);
  let i = keys.length;
  while (i-- > 0) {
    const opt = keys[i];
    const validator = schema[opt];
    if (validator) {
      const value = options[opt];
      const result = value === undefined || validator(value, opt, options);
      if (result !== true) {
        throw new core_AxiosError('option ' + opt + ' must be ' + result, core_AxiosError.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new core_AxiosError('Unknown option ' + opt, core_AxiosError.ERR_BAD_OPTION);
    }
  }
}

/* harmony default export */ const validator = ({
  assertOptions,
  validators
});

;// CONCATENATED MODULE: ./node_modules/axios/lib/core/Axios.js











const Axios_validators = validator.validators;

/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 *
 * @return {Axios} A new instance of Axios
 */
class Axios {
  constructor(instanceConfig) {
    this.defaults = instanceConfig;
    this.interceptors = {
      request: new core_InterceptorManager(),
      response: new core_InterceptorManager()
    };
  }

  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  request(configOrUrl, config) {
    /*eslint no-param-reassign:0*/
    // Allow for axios('example/url'[, config]) a la fetch API
    if (typeof configOrUrl === 'string') {
      config = config || {};
      config.url = configOrUrl;
    } else {
      config = configOrUrl || {};
    }

    config = mergeConfig(this.defaults, config);

    const {transitional, paramsSerializer, headers} = config;

    if (transitional !== undefined) {
      validator.assertOptions(transitional, {
        silentJSONParsing: Axios_validators.transitional(Axios_validators.boolean),
        forcedJSONParsing: Axios_validators.transitional(Axios_validators.boolean),
        clarifyTimeoutError: Axios_validators.transitional(Axios_validators.boolean)
      }, false);
    }

    if (paramsSerializer !== undefined) {
      validator.assertOptions(paramsSerializer, {
        encode: Axios_validators.function,
        serialize: Axios_validators.function
      }, true);
    }

    // Set config.method
    config.method = (config.method || this.defaults.method || 'get').toLowerCase();

    let contextHeaders;

    // Flatten headers
    contextHeaders = headers && utils.merge(
      headers.common,
      headers[config.method]
    );

    contextHeaders && utils.forEach(
      ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
      (method) => {
        delete headers[method];
      }
    );

    config.headers = core_AxiosHeaders.concat(contextHeaders, headers);

    // filter out skipped interceptors
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {
        return;
      }

      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;

      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });

    const responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });

    let promise;
    let i = 0;
    let len;

    if (!synchronousRequestInterceptors) {
      const chain = [dispatchRequest.bind(this), undefined];
      chain.unshift.apply(chain, requestInterceptorChain);
      chain.push.apply(chain, responseInterceptorChain);
      len = chain.length;

      promise = Promise.resolve(config);

      while (i < len) {
        promise = promise.then(chain[i++], chain[i++]);
      }

      return promise;
    }

    len = requestInterceptorChain.length;

    let newConfig = config;

    i = 0;

    while (i < len) {
      const onFulfilled = requestInterceptorChain[i++];
      const onRejected = requestInterceptorChain[i++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error) {
        onRejected.call(this, error);
        break;
      }
    }

    try {
      promise = dispatchRequest.call(this, newConfig);
    } catch (error) {
      return Promise.reject(error);
    }

    i = 0;
    len = responseInterceptorChain.length;

    while (i < len) {
      promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
    }

    return promise;
  }

  getUri(config) {
    config = mergeConfig(this.defaults, config);
    const fullPath = buildFullPath(config.baseURL, config.url);
    return buildURL(fullPath, config.params, config.paramsSerializer);
  }
}

// Provide aliases for supported request methods
utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, config) {
    return this.request(mergeConfig(config || {}, {
      method,
      url,
      data: (config || {}).data
    }));
  };
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/

  function generateHTTPMethod(isForm) {
    return function httpMethod(url, data, config) {
      return this.request(mergeConfig(config || {}, {
        method,
        headers: isForm ? {
          'Content-Type': 'multipart/form-data'
        } : {},
        url,
        data
      }));
    };
  }

  Axios.prototype[method] = generateHTTPMethod();

  Axios.prototype[method + 'Form'] = generateHTTPMethod(true);
});

/* harmony default export */ const core_Axios = (Axios);

;// CONCATENATED MODULE: ./node_modules/axios/lib/cancel/CancelToken.js




/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @param {Function} executor The executor function.
 *
 * @returns {CancelToken}
 */
class CancelToken {
  constructor(executor) {
    if (typeof executor !== 'function') {
      throw new TypeError('executor must be a function.');
    }

    let resolvePromise;

    this.promise = new Promise(function promiseExecutor(resolve) {
      resolvePromise = resolve;
    });

    const token = this;

    // eslint-disable-next-line func-names
    this.promise.then(cancel => {
      if (!token._listeners) return;

      let i = token._listeners.length;

      while (i-- > 0) {
        token._listeners[i](cancel);
      }
      token._listeners = null;
    });

    // eslint-disable-next-line func-names
    this.promise.then = onfulfilled => {
      let _resolve;
      // eslint-disable-next-line func-names
      const promise = new Promise(resolve => {
        token.subscribe(resolve);
        _resolve = resolve;
      }).then(onfulfilled);

      promise.cancel = function reject() {
        token.unsubscribe(_resolve);
      };

      return promise;
    };

    executor(function cancel(message, config, request) {
      if (token.reason) {
        // Cancellation has already been requested
        return;
      }

      token.reason = new cancel_CanceledError(message, config, request);
      resolvePromise(token.reason);
    });
  }

  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  }

  /**
   * Subscribe to the cancel signal
   */

  subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }

    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  }

  /**
   * Unsubscribe from the cancel signal
   */

  unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    const index = this._listeners.indexOf(listener);
    if (index !== -1) {
      this._listeners.splice(index, 1);
    }
  }

  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let cancel;
    const token = new CancelToken(function executor(c) {
      cancel = c;
    });
    return {
      token,
      cancel
    };
  }
}

/* harmony default export */ const cancel_CancelToken = (CancelToken);

;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/spread.js


/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use `Function.prototype.apply`.
 *
 *  ```js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  ```
 *
 * With `spread` this example can be re-written.
 *
 *  ```js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  ```
 *
 * @param {Function} callback
 *
 * @returns {Function}
 */
function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
}

;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/isAxiosError.js




/**
 * Determines whether the payload is an error thrown by Axios
 *
 * @param {*} payload The value to test
 *
 * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
 */
function isAxiosError(payload) {
  return utils.isObject(payload) && (payload.isAxiosError === true);
}

;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/HttpStatusCode.js
const HttpStatusCode = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511,
};

Object.entries(HttpStatusCode).forEach(([key, value]) => {
  HttpStatusCode[value] = key;
});

/* harmony default export */ const helpers_HttpStatusCode = (HttpStatusCode);

;// CONCATENATED MODULE: ./node_modules/axios/lib/axios.js



















/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 *
 * @returns {Axios} A new instance of Axios
 */
function createInstance(defaultConfig) {
  const context = new core_Axios(defaultConfig);
  const instance = bind(core_Axios.prototype.request, context);

  // Copy axios.prototype to instance
  utils.extend(instance, core_Axios.prototype, context, {allOwnKeys: true});

  // Copy context to instance
  utils.extend(instance, context, null, {allOwnKeys: true});

  // Factory for creating new instances
  instance.create = function create(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig, instanceConfig));
  };

  return instance;
}

// Create the default instance to be exported
const axios = createInstance(lib_defaults);

// Expose Axios class to allow class inheritance
axios.Axios = core_Axios;

// Expose Cancel & CancelToken
axios.CanceledError = cancel_CanceledError;
axios.CancelToken = cancel_CancelToken;
axios.isCancel = isCancel;
axios.VERSION = VERSION;
axios.toFormData = helpers_toFormData;

// Expose AxiosError class
axios.AxiosError = core_AxiosError;

// alias for CanceledError for backward compatibility
axios.Cancel = axios.CanceledError;

// Expose all/spread
axios.all = function all(promises) {
  return Promise.all(promises);
};

axios.spread = spread;

// Expose isAxiosError
axios.isAxiosError = isAxiosError;

// Expose mergeConfig
axios.mergeConfig = mergeConfig;

axios.AxiosHeaders = core_AxiosHeaders;

axios.formToJSON = thing => helpers_formDataToJSON(utils.isHTMLForm(thing) ? new FormData(thing) : thing);

axios.HttpStatusCode = helpers_HttpStatusCode;

axios.default = axios;

// this module should only have a default export
/* harmony default export */ const lib_axios = (axios);

;// CONCATENATED MODULE: ./node_modules/axios/index.js


// This module is intended to unwrap Axios default export as named.
// Keep top-level export same with static properties
// so that it can keep same with es module or cjs
const {
  Axios: axios_Axios,
  AxiosError: axios_AxiosError,
  CanceledError: axios_CanceledError,
  isCancel: axios_isCancel,
  CancelToken: axios_CancelToken,
  VERSION: axios_VERSION,
  all: axios_all,
  Cancel,
  isAxiosError: axios_isAxiosError,
  spread: axios_spread,
  toFormData: axios_toFormData,
  AxiosHeaders: axios_AxiosHeaders,
  HttpStatusCode: axios_HttpStatusCode,
  formToJSON,
  mergeConfig: axios_mergeConfig
} = lib_axios;




/***/ }),

/***/ 5696:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "HTML5Backend": () => (/* binding */ HTML5Backend),
  "NativeTypes": () => (/* reexport */ NativeTypes_namespaceObject),
  "getEmptyImage": () => (/* reexport */ getEmptyImage)
});

// NAMESPACE OBJECT: ./node_modules/react-dnd-html5-backend/dist/NativeTypes.js
var NativeTypes_namespaceObject = {};
__webpack_require__.r(NativeTypes_namespaceObject);
__webpack_require__.d(NativeTypes_namespaceObject, {
  "FILE": () => (FILE),
  "HTML": () => (HTML),
  "TEXT": () => (TEXT),
  "URL": () => (URL)
});

;// CONCATENATED MODULE: ./node_modules/react-dnd-html5-backend/dist/utils/js_utils.js
// cheap lodash replacements
function memoize(fn) {
    let result = null;
    const memoized = ()=>{
        if (result == null) {
            result = fn();
        }
        return result;
    };
    return memoized;
}
/**
 * drop-in replacement for _.without
 */ function without(items, item) {
    return items.filter((i)=>i !== item
    );
}
function union(itemsA, itemsB) {
    const set = new Set();
    const insertItem = (item)=>set.add(item)
    ;
    itemsA.forEach(insertItem);
    itemsB.forEach(insertItem);
    const result = [];
    set.forEach((key)=>result.push(key)
    );
    return result;
}

//# sourceMappingURL=js_utils.js.map
;// CONCATENATED MODULE: ./node_modules/react-dnd-html5-backend/dist/EnterLeaveCounter.js

class EnterLeaveCounter {
    enter(enteringNode) {
        const previousLength = this.entered.length;
        const isNodeEntered = (node)=>this.isNodeInDocument(node) && (!node.contains || node.contains(enteringNode))
        ;
        this.entered = union(this.entered.filter(isNodeEntered), [
            enteringNode
        ]);
        return previousLength === 0 && this.entered.length > 0;
    }
    leave(leavingNode) {
        const previousLength = this.entered.length;
        this.entered = without(this.entered.filter(this.isNodeInDocument), leavingNode);
        return previousLength > 0 && this.entered.length === 0;
    }
    reset() {
        this.entered = [];
    }
    constructor(isNodeInDocument){
        this.entered = [];
        this.isNodeInDocument = isNodeInDocument;
    }
}

//# sourceMappingURL=EnterLeaveCounter.js.map
;// CONCATENATED MODULE: ./node_modules/react-dnd-html5-backend/dist/NativeDragSources/NativeDragSource.js
class NativeDragSource {
    initializeExposedProperties() {
        Object.keys(this.config.exposeProperties).forEach((property)=>{
            Object.defineProperty(this.item, property, {
                configurable: true,
                enumerable: true,
                get () {
                    // eslint-disable-next-line no-console
                    console.warn(`Browser doesn't allow reading "${property}" until the drop event.`);
                    return null;
                }
            });
        });
    }
    loadDataTransfer(dataTransfer) {
        if (dataTransfer) {
            const newProperties = {};
            Object.keys(this.config.exposeProperties).forEach((property)=>{
                const propertyFn = this.config.exposeProperties[property];
                if (propertyFn != null) {
                    newProperties[property] = {
                        value: propertyFn(dataTransfer, this.config.matchesTypes),
                        configurable: true,
                        enumerable: true
                    };
                }
            });
            Object.defineProperties(this.item, newProperties);
        }
    }
    canDrag() {
        return true;
    }
    beginDrag() {
        return this.item;
    }
    isDragging(monitor, handle) {
        return handle === monitor.getSourceId();
    }
    endDrag() {
    // empty
    }
    constructor(config){
        this.config = config;
        this.item = {};
        this.initializeExposedProperties();
    }
}

//# sourceMappingURL=NativeDragSource.js.map
;// CONCATENATED MODULE: ./node_modules/react-dnd-html5-backend/dist/NativeTypes.js
const FILE = '__NATIVE_FILE__';
const URL = '__NATIVE_URL__';
const TEXT = '__NATIVE_TEXT__';
const HTML = '__NATIVE_HTML__';

//# sourceMappingURL=NativeTypes.js.map
;// CONCATENATED MODULE: ./node_modules/react-dnd-html5-backend/dist/NativeDragSources/getDataFromDataTransfer.js
function getDataFromDataTransfer(dataTransfer, typesToTry, defaultValue) {
    const result = typesToTry.reduce((resultSoFar, typeToTry)=>resultSoFar || dataTransfer.getData(typeToTry)
    , '');
    return result != null ? result : defaultValue;
}

//# sourceMappingURL=getDataFromDataTransfer.js.map
;// CONCATENATED MODULE: ./node_modules/react-dnd-html5-backend/dist/NativeDragSources/nativeTypesConfig.js


const nativeTypesConfig = {
    [FILE]: {
        exposeProperties: {
            files: (dataTransfer)=>Array.prototype.slice.call(dataTransfer.files)
            ,
            items: (dataTransfer)=>dataTransfer.items
            ,
            dataTransfer: (dataTransfer)=>dataTransfer
        },
        matchesTypes: [
            'Files'
        ]
    },
    [HTML]: {
        exposeProperties: {
            html: (dataTransfer, matchesTypes)=>getDataFromDataTransfer(dataTransfer, matchesTypes, '')
            ,
            dataTransfer: (dataTransfer)=>dataTransfer
        },
        matchesTypes: [
            'Html',
            'text/html'
        ]
    },
    [URL]: {
        exposeProperties: {
            urls: (dataTransfer, matchesTypes)=>getDataFromDataTransfer(dataTransfer, matchesTypes, '').split('\n')
            ,
            dataTransfer: (dataTransfer)=>dataTransfer
        },
        matchesTypes: [
            'Url',
            'text/uri-list'
        ]
    },
    [TEXT]: {
        exposeProperties: {
            text: (dataTransfer, matchesTypes)=>getDataFromDataTransfer(dataTransfer, matchesTypes, '')
            ,
            dataTransfer: (dataTransfer)=>dataTransfer
        },
        matchesTypes: [
            'Text',
            'text/plain'
        ]
    }
};

//# sourceMappingURL=nativeTypesConfig.js.map
;// CONCATENATED MODULE: ./node_modules/react-dnd-html5-backend/dist/NativeDragSources/index.js


function createNativeDragSource(type, dataTransfer) {
    const config = nativeTypesConfig[type];
    if (!config) {
        throw new Error(`native type ${type} has no configuration`);
    }
    const result = new NativeDragSource(config);
    result.loadDataTransfer(dataTransfer);
    return result;
}
function matchNativeItemType(dataTransfer) {
    if (!dataTransfer) {
        return null;
    }
    const dataTransferTypes = Array.prototype.slice.call(dataTransfer.types || []);
    return Object.keys(nativeTypesConfig).filter((nativeItemType)=>{
        const typeConfig = nativeTypesConfig[nativeItemType];
        if (!(typeConfig === null || typeConfig === void 0 ? void 0 : typeConfig.matchesTypes)) {
            return false;
        }
        return typeConfig.matchesTypes.some((t)=>dataTransferTypes.indexOf(t) > -1
        );
    })[0] || null;
}

//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/react-dnd-html5-backend/dist/BrowserDetector.js

const isFirefox = memoize(()=>/firefox/i.test(navigator.userAgent)
);
const isSafari = memoize(()=>Boolean(window.safari)
);

//# sourceMappingURL=BrowserDetector.js.map
;// CONCATENATED MODULE: ./node_modules/react-dnd-html5-backend/dist/MonotonicInterpolant.js
class MonotonicInterpolant {
    interpolate(x) {
        const { xs , ys , c1s , c2s , c3s  } = this;
        // The rightmost point in the dataset should give an exact result
        let i = xs.length - 1;
        if (x === xs[i]) {
            return ys[i];
        }
        // Search for the interval x is in, returning the corresponding y if x is one of the original xs
        let low = 0;
        let high = c3s.length - 1;
        let mid;
        while(low <= high){
            mid = Math.floor(0.5 * (low + high));
            const xHere = xs[mid];
            if (xHere < x) {
                low = mid + 1;
            } else if (xHere > x) {
                high = mid - 1;
            } else {
                return ys[mid];
            }
        }
        i = Math.max(0, high);
        // Interpolate
        const diff = x - xs[i];
        const diffSq = diff * diff;
        return ys[i] + c1s[i] * diff + c2s[i] * diffSq + c3s[i] * diff * diffSq;
    }
    constructor(xs, ys){
        const { length  } = xs;
        // Rearrange xs and ys so that xs is sorted
        const indexes = [];
        for(let i = 0; i < length; i++){
            indexes.push(i);
        }
        indexes.sort((a, b)=>xs[a] < xs[b] ? -1 : 1
        );
        // Get consecutive differences and slopes
        const dys = [];
        const dxs = [];
        const ms = [];
        let dx;
        let dy;
        for(let i1 = 0; i1 < length - 1; i1++){
            dx = xs[i1 + 1] - xs[i1];
            dy = ys[i1 + 1] - ys[i1];
            dxs.push(dx);
            dys.push(dy);
            ms.push(dy / dx);
        }
        // Get degree-1 coefficients
        const c1s = [
            ms[0]
        ];
        for(let i2 = 0; i2 < dxs.length - 1; i2++){
            const m2 = ms[i2];
            const mNext = ms[i2 + 1];
            if (m2 * mNext <= 0) {
                c1s.push(0);
            } else {
                dx = dxs[i2];
                const dxNext = dxs[i2 + 1];
                const common = dx + dxNext;
                c1s.push(3 * common / ((common + dxNext) / m2 + (common + dx) / mNext));
            }
        }
        c1s.push(ms[ms.length - 1]);
        // Get degree-2 and degree-3 coefficients
        const c2s = [];
        const c3s = [];
        let m;
        for(let i3 = 0; i3 < c1s.length - 1; i3++){
            m = ms[i3];
            const c1 = c1s[i3];
            const invDx = 1 / dxs[i3];
            const common = c1 + c1s[i3 + 1] - m - m;
            c2s.push((m - c1 - common) * invDx);
            c3s.push(common * invDx * invDx);
        }
        this.xs = xs;
        this.ys = ys;
        this.c1s = c1s;
        this.c2s = c2s;
        this.c3s = c3s;
    }
}

//# sourceMappingURL=MonotonicInterpolant.js.map
;// CONCATENATED MODULE: ./node_modules/react-dnd-html5-backend/dist/OffsetUtils.js


const ELEMENT_NODE = 1;
function getNodeClientOffset(node) {
    const el = node.nodeType === ELEMENT_NODE ? node : node.parentElement;
    if (!el) {
        return null;
    }
    const { top , left  } = el.getBoundingClientRect();
    return {
        x: left,
        y: top
    };
}
function getEventClientOffset(e) {
    return {
        x: e.clientX,
        y: e.clientY
    };
}
function isImageNode(node) {
    var ref;
    return node.nodeName === 'IMG' && (isFirefox() || !((ref = document.documentElement) === null || ref === void 0 ? void 0 : ref.contains(node)));
}
function getDragPreviewSize(isImage, dragPreview, sourceWidth, sourceHeight) {
    let dragPreviewWidth = isImage ? dragPreview.width : sourceWidth;
    let dragPreviewHeight = isImage ? dragPreview.height : sourceHeight;
    // Work around @2x coordinate discrepancies in browsers
    if (isSafari() && isImage) {
        dragPreviewHeight /= window.devicePixelRatio;
        dragPreviewWidth /= window.devicePixelRatio;
    }
    return {
        dragPreviewWidth,
        dragPreviewHeight
    };
}
function getDragPreviewOffset(sourceNode, dragPreview, clientOffset, anchorPoint, offsetPoint) {
    // The browsers will use the image intrinsic size under different conditions.
    // Firefox only cares if it's an image, but WebKit also wants it to be detached.
    const isImage = isImageNode(dragPreview);
    const dragPreviewNode = isImage ? sourceNode : dragPreview;
    const dragPreviewNodeOffsetFromClient = getNodeClientOffset(dragPreviewNode);
    const offsetFromDragPreview = {
        x: clientOffset.x - dragPreviewNodeOffsetFromClient.x,
        y: clientOffset.y - dragPreviewNodeOffsetFromClient.y
    };
    const { offsetWidth: sourceWidth , offsetHeight: sourceHeight  } = sourceNode;
    const { anchorX , anchorY  } = anchorPoint;
    const { dragPreviewWidth , dragPreviewHeight  } = getDragPreviewSize(isImage, dragPreview, sourceWidth, sourceHeight);
    const calculateYOffset = ()=>{
        const interpolantY = new MonotonicInterpolant([
            0,
            0.5,
            1
        ], [
            // Dock to the top
            offsetFromDragPreview.y,
            // Align at the center
            (offsetFromDragPreview.y / sourceHeight) * dragPreviewHeight,
            // Dock to the bottom
            offsetFromDragPreview.y + dragPreviewHeight - sourceHeight, 
        ]);
        let y = interpolantY.interpolate(anchorY);
        // Work around Safari 8 positioning bug
        if (isSafari() && isImage) {
            // We'll have to wait for @3x to see if this is entirely correct
            y += (window.devicePixelRatio - 1) * dragPreviewHeight;
        }
        return y;
    };
    const calculateXOffset = ()=>{
        // Interpolate coordinates depending on anchor point
        // If you know a simpler way to do this, let me know
        const interpolantX = new MonotonicInterpolant([
            0,
            0.5,
            1
        ], [
            // Dock to the left
            offsetFromDragPreview.x,
            // Align at the center
            (offsetFromDragPreview.x / sourceWidth) * dragPreviewWidth,
            // Dock to the right
            offsetFromDragPreview.x + dragPreviewWidth - sourceWidth, 
        ]);
        return interpolantX.interpolate(anchorX);
    };
    // Force offsets if specified in the options.
    const { offsetX , offsetY  } = offsetPoint;
    const isManualOffsetX = offsetX === 0 || offsetX;
    const isManualOffsetY = offsetY === 0 || offsetY;
    return {
        x: isManualOffsetX ? offsetX : calculateXOffset(),
        y: isManualOffsetY ? offsetY : calculateYOffset()
    };
}

//# sourceMappingURL=OffsetUtils.js.map
;// CONCATENATED MODULE: ./node_modules/react-dnd-html5-backend/dist/OptionsReader.js
class OptionsReader {
    get window() {
        if (this.globalContext) {
            return this.globalContext;
        } else if (typeof window !== 'undefined') {
            return window;
        }
        return undefined;
    }
    get document() {
        var ref;
        if ((ref = this.globalContext) === null || ref === void 0 ? void 0 : ref.document) {
            return this.globalContext.document;
        } else if (this.window) {
            return this.window.document;
        } else {
            return undefined;
        }
    }
    get rootElement() {
        var ref;
        return ((ref = this.optionsArgs) === null || ref === void 0 ? void 0 : ref.rootElement) || this.window;
    }
    constructor(globalContext, options){
        this.ownerDocument = null;
        this.globalContext = globalContext;
        this.optionsArgs = options;
    }
}

//# sourceMappingURL=OptionsReader.js.map
;// CONCATENATED MODULE: ./node_modules/react-dnd-html5-backend/dist/HTML5BackendImpl.js
function _defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
function _objectSpread(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === 'function') {
            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
                return Object.getOwnPropertyDescriptor(source, sym).enumerable;
            }));
        }
        ownKeys.forEach(function(key) {
            _defineProperty(target, key, source[key]);
        });
    }
    return target;
}





class HTML5BackendImpl {
    /**
	 * Generate profiling statistics for the HTML5Backend.
	 */ profile() {
        var ref, ref1;
        return {
            sourcePreviewNodes: this.sourcePreviewNodes.size,
            sourcePreviewNodeOptions: this.sourcePreviewNodeOptions.size,
            sourceNodeOptions: this.sourceNodeOptions.size,
            sourceNodes: this.sourceNodes.size,
            dragStartSourceIds: ((ref = this.dragStartSourceIds) === null || ref === void 0 ? void 0 : ref.length) || 0,
            dropTargetIds: this.dropTargetIds.length,
            dragEnterTargetIds: this.dragEnterTargetIds.length,
            dragOverTargetIds: ((ref1 = this.dragOverTargetIds) === null || ref1 === void 0 ? void 0 : ref1.length) || 0
        };
    }
    // public for test
    get window() {
        return this.options.window;
    }
    get document() {
        return this.options.document;
    }
    /**
	 * Get the root element to use for event subscriptions
	 */ get rootElement() {
        return this.options.rootElement;
    }
    setup() {
        const root = this.rootElement;
        if (root === undefined) {
            return;
        }
        if (root.__isReactDndBackendSetUp) {
            throw new Error('Cannot have two HTML5 backends at the same time.');
        }
        root.__isReactDndBackendSetUp = true;
        this.addEventListeners(root);
    }
    teardown() {
        const root = this.rootElement;
        if (root === undefined) {
            return;
        }
        root.__isReactDndBackendSetUp = false;
        this.removeEventListeners(this.rootElement);
        this.clearCurrentDragSourceNode();
        if (this.asyncEndDragFrameId) {
            var ref;
            (ref = this.window) === null || ref === void 0 ? void 0 : ref.cancelAnimationFrame(this.asyncEndDragFrameId);
        }
    }
    connectDragPreview(sourceId, node, options) {
        this.sourcePreviewNodeOptions.set(sourceId, options);
        this.sourcePreviewNodes.set(sourceId, node);
        return ()=>{
            this.sourcePreviewNodes.delete(sourceId);
            this.sourcePreviewNodeOptions.delete(sourceId);
        };
    }
    connectDragSource(sourceId, node, options) {
        this.sourceNodes.set(sourceId, node);
        this.sourceNodeOptions.set(sourceId, options);
        const handleDragStart = (e)=>this.handleDragStart(e, sourceId)
        ;
        const handleSelectStart = (e)=>this.handleSelectStart(e)
        ;
        node.setAttribute('draggable', 'true');
        node.addEventListener('dragstart', handleDragStart);
        node.addEventListener('selectstart', handleSelectStart);
        return ()=>{
            this.sourceNodes.delete(sourceId);
            this.sourceNodeOptions.delete(sourceId);
            node.removeEventListener('dragstart', handleDragStart);
            node.removeEventListener('selectstart', handleSelectStart);
            node.setAttribute('draggable', 'false');
        };
    }
    connectDropTarget(targetId, node) {
        const handleDragEnter = (e)=>this.handleDragEnter(e, targetId)
        ;
        const handleDragOver = (e)=>this.handleDragOver(e, targetId)
        ;
        const handleDrop = (e)=>this.handleDrop(e, targetId)
        ;
        node.addEventListener('dragenter', handleDragEnter);
        node.addEventListener('dragover', handleDragOver);
        node.addEventListener('drop', handleDrop);
        return ()=>{
            node.removeEventListener('dragenter', handleDragEnter);
            node.removeEventListener('dragover', handleDragOver);
            node.removeEventListener('drop', handleDrop);
        };
    }
    addEventListeners(target) {
        // SSR Fix (https://github.com/react-dnd/react-dnd/pull/813
        if (!target.addEventListener) {
            return;
        }
        target.addEventListener('dragstart', this.handleTopDragStart);
        target.addEventListener('dragstart', this.handleTopDragStartCapture, true);
        target.addEventListener('dragend', this.handleTopDragEndCapture, true);
        target.addEventListener('dragenter', this.handleTopDragEnter);
        target.addEventListener('dragenter', this.handleTopDragEnterCapture, true);
        target.addEventListener('dragleave', this.handleTopDragLeaveCapture, true);
        target.addEventListener('dragover', this.handleTopDragOver);
        target.addEventListener('dragover', this.handleTopDragOverCapture, true);
        target.addEventListener('drop', this.handleTopDrop);
        target.addEventListener('drop', this.handleTopDropCapture, true);
    }
    removeEventListeners(target) {
        // SSR Fix (https://github.com/react-dnd/react-dnd/pull/813
        if (!target.removeEventListener) {
            return;
        }
        target.removeEventListener('dragstart', this.handleTopDragStart);
        target.removeEventListener('dragstart', this.handleTopDragStartCapture, true);
        target.removeEventListener('dragend', this.handleTopDragEndCapture, true);
        target.removeEventListener('dragenter', this.handleTopDragEnter);
        target.removeEventListener('dragenter', this.handleTopDragEnterCapture, true);
        target.removeEventListener('dragleave', this.handleTopDragLeaveCapture, true);
        target.removeEventListener('dragover', this.handleTopDragOver);
        target.removeEventListener('dragover', this.handleTopDragOverCapture, true);
        target.removeEventListener('drop', this.handleTopDrop);
        target.removeEventListener('drop', this.handleTopDropCapture, true);
    }
    getCurrentSourceNodeOptions() {
        const sourceId = this.monitor.getSourceId();
        const sourceNodeOptions = this.sourceNodeOptions.get(sourceId);
        return _objectSpread({
            dropEffect: this.altKeyPressed ? 'copy' : 'move'
        }, sourceNodeOptions || {});
    }
    getCurrentDropEffect() {
        if (this.isDraggingNativeItem()) {
            // It makes more sense to default to 'copy' for native resources
            return 'copy';
        }
        return this.getCurrentSourceNodeOptions().dropEffect;
    }
    getCurrentSourcePreviewNodeOptions() {
        const sourceId = this.monitor.getSourceId();
        const sourcePreviewNodeOptions = this.sourcePreviewNodeOptions.get(sourceId);
        return _objectSpread({
            anchorX: 0.5,
            anchorY: 0.5,
            captureDraggingState: false
        }, sourcePreviewNodeOptions || {});
    }
    isDraggingNativeItem() {
        const itemType = this.monitor.getItemType();
        return Object.keys(NativeTypes_namespaceObject).some((key)=>NativeTypes_namespaceObject[key] === itemType
        );
    }
    beginDragNativeItem(type, dataTransfer) {
        this.clearCurrentDragSourceNode();
        this.currentNativeSource = createNativeDragSource(type, dataTransfer);
        this.currentNativeHandle = this.registry.addSource(type, this.currentNativeSource);
        this.actions.beginDrag([
            this.currentNativeHandle
        ]);
    }
    setCurrentDragSourceNode(node) {
        this.clearCurrentDragSourceNode();
        this.currentDragSourceNode = node;
        // A timeout of > 0 is necessary to resolve Firefox issue referenced
        // See:
        //   * https://github.com/react-dnd/react-dnd/pull/928
        //   * https://github.com/react-dnd/react-dnd/issues/869
        const MOUSE_MOVE_TIMEOUT = 1000;
        // Receiving a mouse event in the middle of a dragging operation
        // means it has ended and the drag source node disappeared from DOM,
        // so the browser didn't dispatch the dragend event.
        //
        // We need to wait before we start listening for mousemove events.
        // This is needed because the drag preview needs to be drawn or else it fires an 'mousemove' event
        // immediately in some browsers.
        //
        // See:
        //   * https://github.com/react-dnd/react-dnd/pull/928
        //   * https://github.com/react-dnd/react-dnd/issues/869
        //
        this.mouseMoveTimeoutTimer = setTimeout(()=>{
            var ref;
            return (ref = this.rootElement) === null || ref === void 0 ? void 0 : ref.addEventListener('mousemove', this.endDragIfSourceWasRemovedFromDOM, true);
        }, MOUSE_MOVE_TIMEOUT);
    }
    clearCurrentDragSourceNode() {
        if (this.currentDragSourceNode) {
            this.currentDragSourceNode = null;
            if (this.rootElement) {
                var ref;
                (ref = this.window) === null || ref === void 0 ? void 0 : ref.clearTimeout(this.mouseMoveTimeoutTimer || undefined);
                this.rootElement.removeEventListener('mousemove', this.endDragIfSourceWasRemovedFromDOM, true);
            }
            this.mouseMoveTimeoutTimer = null;
            return true;
        }
        return false;
    }
    handleDragStart(e, sourceId) {
        if (e.defaultPrevented) {
            return;
        }
        if (!this.dragStartSourceIds) {
            this.dragStartSourceIds = [];
        }
        this.dragStartSourceIds.unshift(sourceId);
    }
    handleDragEnter(_e, targetId) {
        this.dragEnterTargetIds.unshift(targetId);
    }
    handleDragOver(_e, targetId) {
        if (this.dragOverTargetIds === null) {
            this.dragOverTargetIds = [];
        }
        this.dragOverTargetIds.unshift(targetId);
    }
    handleDrop(_e, targetId) {
        this.dropTargetIds.unshift(targetId);
    }
    constructor(manager, globalContext, options){
        this.sourcePreviewNodes = new Map();
        this.sourcePreviewNodeOptions = new Map();
        this.sourceNodes = new Map();
        this.sourceNodeOptions = new Map();
        this.dragStartSourceIds = null;
        this.dropTargetIds = [];
        this.dragEnterTargetIds = [];
        this.currentNativeSource = null;
        this.currentNativeHandle = null;
        this.currentDragSourceNode = null;
        this.altKeyPressed = false;
        this.mouseMoveTimeoutTimer = null;
        this.asyncEndDragFrameId = null;
        this.dragOverTargetIds = null;
        this.lastClientOffset = null;
        this.hoverRafId = null;
        this.getSourceClientOffset = (sourceId)=>{
            const source = this.sourceNodes.get(sourceId);
            return source && getNodeClientOffset(source) || null;
        };
        this.endDragNativeItem = ()=>{
            if (!this.isDraggingNativeItem()) {
                return;
            }
            this.actions.endDrag();
            if (this.currentNativeHandle) {
                this.registry.removeSource(this.currentNativeHandle);
            }
            this.currentNativeHandle = null;
            this.currentNativeSource = null;
        };
        this.isNodeInDocument = (node)=>{
            // Check the node either in the main document or in the current context
            return Boolean(node && this.document && this.document.body && this.document.body.contains(node));
        };
        this.endDragIfSourceWasRemovedFromDOM = ()=>{
            const node = this.currentDragSourceNode;
            if (node == null || this.isNodeInDocument(node)) {
                return;
            }
            if (this.clearCurrentDragSourceNode() && this.monitor.isDragging()) {
                this.actions.endDrag();
            }
            this.cancelHover();
        };
        this.scheduleHover = (dragOverTargetIds)=>{
            if (this.hoverRafId === null && typeof requestAnimationFrame !== 'undefined') {
                this.hoverRafId = requestAnimationFrame(()=>{
                    if (this.monitor.isDragging()) {
                        this.actions.hover(dragOverTargetIds || [], {
                            clientOffset: this.lastClientOffset
                        });
                    }
                    this.hoverRafId = null;
                });
            }
        };
        this.cancelHover = ()=>{
            if (this.hoverRafId !== null && typeof cancelAnimationFrame !== 'undefined') {
                cancelAnimationFrame(this.hoverRafId);
                this.hoverRafId = null;
            }
        };
        this.handleTopDragStartCapture = ()=>{
            this.clearCurrentDragSourceNode();
            this.dragStartSourceIds = [];
        };
        this.handleTopDragStart = (e)=>{
            if (e.defaultPrevented) {
                return;
            }
            const { dragStartSourceIds  } = this;
            this.dragStartSourceIds = null;
            const clientOffset = getEventClientOffset(e);
            // Avoid crashing if we missed a drop event or our previous drag died
            if (this.monitor.isDragging()) {
                this.actions.endDrag();
                this.cancelHover();
            }
            // Don't publish the source just yet (see why below)
            this.actions.beginDrag(dragStartSourceIds || [], {
                publishSource: false,
                getSourceClientOffset: this.getSourceClientOffset,
                clientOffset
            });
            const { dataTransfer  } = e;
            const nativeType = matchNativeItemType(dataTransfer);
            if (this.monitor.isDragging()) {
                if (dataTransfer && typeof dataTransfer.setDragImage === 'function') {
                    // Use custom drag image if user specifies it.
                    // If child drag source refuses drag but parent agrees,
                    // use parent's node as drag image. Neither works in IE though.
                    const sourceId = this.monitor.getSourceId();
                    const sourceNode = this.sourceNodes.get(sourceId);
                    const dragPreview = this.sourcePreviewNodes.get(sourceId) || sourceNode;
                    if (dragPreview) {
                        const { anchorX , anchorY , offsetX , offsetY  } = this.getCurrentSourcePreviewNodeOptions();
                        const anchorPoint = {
                            anchorX,
                            anchorY
                        };
                        const offsetPoint = {
                            offsetX,
                            offsetY
                        };
                        const dragPreviewOffset = getDragPreviewOffset(sourceNode, dragPreview, clientOffset, anchorPoint, offsetPoint);
                        dataTransfer.setDragImage(dragPreview, dragPreviewOffset.x, dragPreviewOffset.y);
                    }
                }
                try {
                    // Firefox won't drag without setting data
                    dataTransfer === null || dataTransfer === void 0 ? void 0 : dataTransfer.setData('application/json', {});
                } catch (err) {
                // IE doesn't support MIME types in setData
                }
                // Store drag source node so we can check whether
                // it is removed from DOM and trigger endDrag manually.
                this.setCurrentDragSourceNode(e.target);
                // Now we are ready to publish the drag source.. or are we not?
                const { captureDraggingState  } = this.getCurrentSourcePreviewNodeOptions();
                if (!captureDraggingState) {
                    // Usually we want to publish it in the next tick so that browser
                    // is able to screenshot the current (not yet dragging) state.
                    //
                    // It also neatly avoids a situation where render() returns null
                    // in the same tick for the source element, and browser freaks out.
                    setTimeout(()=>this.actions.publishDragSource()
                    , 0);
                } else {
                    // In some cases the user may want to override this behavior, e.g.
                    // to work around IE not supporting custom drag previews.
                    //
                    // When using a custom drag layer, the only way to prevent
                    // the default drag preview from drawing in IE is to screenshot
                    // the dragging state in which the node itself has zero opacity
                    // and height. In this case, though, returning null from render()
                    // will abruptly end the dragging, which is not obvious.
                    //
                    // This is the reason such behavior is strictly opt-in.
                    this.actions.publishDragSource();
                }
            } else if (nativeType) {
                // A native item (such as URL) dragged from inside the document
                this.beginDragNativeItem(nativeType);
            } else if (dataTransfer && !dataTransfer.types && (e.target && !e.target.hasAttribute || !e.target.hasAttribute('draggable'))) {
                // Looks like a Safari bug: dataTransfer.types is null, but there was no draggable.
                // Just let it drag. It's a native type (URL or text) and will be picked up in
                // dragenter handler.
                return;
            } else {
                // If by this time no drag source reacted, tell browser not to drag.
                e.preventDefault();
            }
        };
        this.handleTopDragEndCapture = ()=>{
            if (this.clearCurrentDragSourceNode() && this.monitor.isDragging()) {
                // Firefox can dispatch this event in an infinite loop
                // if dragend handler does something like showing an alert.
                // Only proceed if we have not handled it already.
                this.actions.endDrag();
            }
            this.cancelHover();
        };
        this.handleTopDragEnterCapture = (e)=>{
            this.dragEnterTargetIds = [];
            if (this.isDraggingNativeItem()) {
                var ref;
                (ref = this.currentNativeSource) === null || ref === void 0 ? void 0 : ref.loadDataTransfer(e.dataTransfer);
            }
            const isFirstEnter = this.enterLeaveCounter.enter(e.target);
            if (!isFirstEnter || this.monitor.isDragging()) {
                return;
            }
            const { dataTransfer  } = e;
            const nativeType = matchNativeItemType(dataTransfer);
            if (nativeType) {
                // A native item (such as file or URL) dragged from outside the document
                this.beginDragNativeItem(nativeType, dataTransfer);
            }
        };
        this.handleTopDragEnter = (e)=>{
            const { dragEnterTargetIds  } = this;
            this.dragEnterTargetIds = [];
            if (!this.monitor.isDragging()) {
                // This is probably a native item type we don't understand.
                return;
            }
            this.altKeyPressed = e.altKey;
            // If the target changes position as the result of `dragenter`, `dragover` might still
            // get dispatched despite target being no longer there. The easy solution is to check
            // whether there actually is a target before firing `hover`.
            if (dragEnterTargetIds.length > 0) {
                this.actions.hover(dragEnterTargetIds, {
                    clientOffset: getEventClientOffset(e)
                });
            }
            const canDrop = dragEnterTargetIds.some((targetId)=>this.monitor.canDropOnTarget(targetId)
            );
            if (canDrop) {
                // IE requires this to fire dragover events
                e.preventDefault();
                if (e.dataTransfer) {
                    e.dataTransfer.dropEffect = this.getCurrentDropEffect();
                }
            }
        };
        this.handleTopDragOverCapture = (e)=>{
            this.dragOverTargetIds = [];
            if (this.isDraggingNativeItem()) {
                var ref;
                (ref = this.currentNativeSource) === null || ref === void 0 ? void 0 : ref.loadDataTransfer(e.dataTransfer);
            }
        };
        this.handleTopDragOver = (e)=>{
            const { dragOverTargetIds  } = this;
            this.dragOverTargetIds = [];
            if (!this.monitor.isDragging()) {
                // This is probably a native item type we don't understand.
                // Prevent default "drop and blow away the whole document" action.
                e.preventDefault();
                if (e.dataTransfer) {
                    e.dataTransfer.dropEffect = 'none';
                }
                return;
            }
            this.altKeyPressed = e.altKey;
            this.lastClientOffset = getEventClientOffset(e);
            this.scheduleHover(dragOverTargetIds);
            const canDrop = (dragOverTargetIds || []).some((targetId)=>this.monitor.canDropOnTarget(targetId)
            );
            if (canDrop) {
                // Show user-specified drop effect.
                e.preventDefault();
                if (e.dataTransfer) {
                    e.dataTransfer.dropEffect = this.getCurrentDropEffect();
                }
            } else if (this.isDraggingNativeItem()) {
                // Don't show a nice cursor but still prevent default
                // "drop and blow away the whole document" action.
                e.preventDefault();
            } else {
                e.preventDefault();
                if (e.dataTransfer) {
                    e.dataTransfer.dropEffect = 'none';
                }
            }
        };
        this.handleTopDragLeaveCapture = (e)=>{
            if (this.isDraggingNativeItem()) {
                e.preventDefault();
            }
            const isLastLeave = this.enterLeaveCounter.leave(e.target);
            if (!isLastLeave) {
                return;
            }
            if (this.isDraggingNativeItem()) {
                setTimeout(()=>this.endDragNativeItem()
                , 0);
            }
            this.cancelHover();
        };
        this.handleTopDropCapture = (e)=>{
            this.dropTargetIds = [];
            if (this.isDraggingNativeItem()) {
                var ref;
                e.preventDefault();
                (ref = this.currentNativeSource) === null || ref === void 0 ? void 0 : ref.loadDataTransfer(e.dataTransfer);
            } else if (matchNativeItemType(e.dataTransfer)) {
                // Dragging some elements, like <a> and <img> may still behave like a native drag event,
                // even if the current drag event matches a user-defined type.
                // Stop the default behavior when we're not expecting a native item to be dropped.
                e.preventDefault();
            }
            this.enterLeaveCounter.reset();
        };
        this.handleTopDrop = (e)=>{
            const { dropTargetIds  } = this;
            this.dropTargetIds = [];
            this.actions.hover(dropTargetIds, {
                clientOffset: getEventClientOffset(e)
            });
            this.actions.drop({
                dropEffect: this.getCurrentDropEffect()
            });
            if (this.isDraggingNativeItem()) {
                this.endDragNativeItem();
            } else if (this.monitor.isDragging()) {
                this.actions.endDrag();
            }
            this.cancelHover();
        };
        this.handleSelectStart = (e)=>{
            const target = e.target;
            // Only IE requires us to explicitly say
            // we want drag drop operation to start
            if (typeof target.dragDrop !== 'function') {
                return;
            }
            // Inputs and textareas should be selectable
            if (target.tagName === 'INPUT' || target.tagName === 'SELECT' || target.tagName === 'TEXTAREA' || target.isContentEditable) {
                return;
            }
            // For other targets, ask IE
            // to enable drag and drop
            e.preventDefault();
            target.dragDrop();
        };
        this.options = new OptionsReader(globalContext, options);
        this.actions = manager.getActions();
        this.monitor = manager.getMonitor();
        this.registry = manager.getRegistry();
        this.enterLeaveCounter = new EnterLeaveCounter(this.isNodeInDocument);
    }
}

//# sourceMappingURL=HTML5BackendImpl.js.map
;// CONCATENATED MODULE: ./node_modules/react-dnd-html5-backend/dist/getEmptyImage.js
let emptyImage;
function getEmptyImage() {
    if (!emptyImage) {
        emptyImage = new Image();
        emptyImage.src = 'data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==';
    }
    return emptyImage;
}

//# sourceMappingURL=getEmptyImage.js.map
;// CONCATENATED MODULE: ./node_modules/react-dnd-html5-backend/dist/index.js




const HTML5Backend = function createBackend(manager, context, options) {
    return new HTML5BackendImpl(manager, context, options);
};

//# sourceMappingURL=index.js.map

/***/ }),

/***/ 9013:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "DndContext": () => (/* reexport */ DndContext),
  "DndProvider": () => (/* reexport */ DndProvider),
  "DragPreviewImage": () => (/* reexport */ DragPreviewImage),
  "useDrag": () => (/* reexport */ useDrag),
  "useDragDropManager": () => (/* reexport */ useDragDropManager),
  "useDragLayer": () => (/* reexport */ useDragLayer),
  "useDrop": () => (/* reexport */ useDrop)
});

// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(4191);
;// CONCATENATED MODULE: ./node_modules/react-dnd/dist/core/DndContext.js

/**
 * Create the React Context
 */ const DndContext = (0,react.createContext)({
    dragDropManager: undefined
});

//# sourceMappingURL=DndContext.js.map
// EXTERNAL MODULE: ./node_modules/react/jsx-runtime.js
var jsx_runtime = __webpack_require__(38);
;// CONCATENATED MODULE: ./node_modules/redux/es/redux.js


/**
 * Adapted from React: https://github.com/facebook/react/blob/master/packages/shared/formatProdErrorMessage.js
 *
 * Do not require this module directly! Use normal throw error calls. These messages will be replaced with error codes
 * during build.
 * @param {number} code
 */
function formatProdErrorMessage(code) {
  return "Minified Redux error #" + code + "; visit https://redux.js.org/Errors?code=" + code + " for the full message or " + 'use the non-minified dev environment for full errors. ';
}

// Inlined version of the `symbol-observable` polyfill
var $$observable = (function () {
  return typeof Symbol === 'function' && Symbol.observable || '@@observable';
})();

/**
 * These are private action types reserved by Redux.
 * For any unknown actions, you must return the current state.
 * If the current state is undefined, you must return the initial state.
 * Do not reference these action types directly in your code.
 */
var randomString = function randomString() {
  return Math.random().toString(36).substring(7).split('').join('.');
};

var ActionTypes = {
  INIT: "@@redux/INIT" + randomString(),
  REPLACE: "@@redux/REPLACE" + randomString(),
  PROBE_UNKNOWN_ACTION: function PROBE_UNKNOWN_ACTION() {
    return "@@redux/PROBE_UNKNOWN_ACTION" + randomString();
  }
};

/**
 * @param {any} obj The object to inspect.
 * @returns {boolean} True if the argument appears to be a plain object.
 */
function isPlainObject(obj) {
  if (typeof obj !== 'object' || obj === null) return false;
  var proto = obj;

  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }

  return Object.getPrototypeOf(obj) === proto;
}

// Inlined / shortened version of `kindOf` from https://github.com/jonschlinkert/kind-of
function miniKindOf(val) {
  if (val === void 0) return 'undefined';
  if (val === null) return 'null';
  var type = typeof val;

  switch (type) {
    case 'boolean':
    case 'string':
    case 'number':
    case 'symbol':
    case 'function':
      {
        return type;
      }
  }

  if (Array.isArray(val)) return 'array';
  if (isDate(val)) return 'date';
  if (isError(val)) return 'error';
  var constructorName = ctorName(val);

  switch (constructorName) {
    case 'Symbol':
    case 'Promise':
    case 'WeakMap':
    case 'WeakSet':
    case 'Map':
    case 'Set':
      return constructorName;
  } // other


  return type.slice(8, -1).toLowerCase().replace(/\s/g, '');
}

function ctorName(val) {
  return typeof val.constructor === 'function' ? val.constructor.name : null;
}

function isError(val) {
  return val instanceof Error || typeof val.message === 'string' && val.constructor && typeof val.constructor.stackTraceLimit === 'number';
}

function isDate(val) {
  if (val instanceof Date) return true;
  return typeof val.toDateString === 'function' && typeof val.getDate === 'function' && typeof val.setDate === 'function';
}

function kindOf(val) {
  var typeOfVal = typeof val;

  if (false) {}

  return typeOfVal;
}

/**
 * @deprecated
 *
 * **We recommend using the `configureStore` method
 * of the `@reduxjs/toolkit` package**, which replaces `createStore`.
 *
 * Redux Toolkit is our recommended approach for writing Redux logic today,
 * including store setup, reducers, data fetching, and more.
 *
 * **For more details, please read this Redux docs page:**
 * **https://redux.js.org/introduction/why-rtk-is-redux-today**
 *
 * `configureStore` from Redux Toolkit is an improved version of `createStore` that
 * simplifies setup and helps avoid common bugs.
 *
 * You should not be using the `redux` core package by itself today, except for learning purposes.
 * The `createStore` method from the core `redux` package will not be removed, but we encourage
 * all users to migrate to using Redux Toolkit for all Redux code.
 *
 * If you want to use `createStore` without this visual deprecation warning, use
 * the `legacy_createStore` import instead:
 *
 * `import { legacy_createStore as createStore} from 'redux'`
 *
 */

function createStore(reducer, preloadedState, enhancer) {
  var _ref2;

  if (typeof preloadedState === 'function' && typeof enhancer === 'function' || typeof enhancer === 'function' && typeof arguments[3] === 'function') {
    throw new Error( true ? formatProdErrorMessage(0) : 0);
  }

  if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {
    enhancer = preloadedState;
    preloadedState = undefined;
  }

  if (typeof enhancer !== 'undefined') {
    if (typeof enhancer !== 'function') {
      throw new Error( true ? formatProdErrorMessage(1) : 0);
    }

    return enhancer(createStore)(reducer, preloadedState);
  }

  if (typeof reducer !== 'function') {
    throw new Error( true ? formatProdErrorMessage(2) : 0);
  }

  var currentReducer = reducer;
  var currentState = preloadedState;
  var currentListeners = [];
  var nextListeners = currentListeners;
  var isDispatching = false;
  /**
   * This makes a shallow copy of currentListeners so we can use
   * nextListeners as a temporary list while dispatching.
   *
   * This prevents any bugs around consumers calling
   * subscribe/unsubscribe in the middle of a dispatch.
   */

  function ensureCanMutateNextListeners() {
    if (nextListeners === currentListeners) {
      nextListeners = currentListeners.slice();
    }
  }
  /**
   * Reads the state tree managed by the store.
   *
   * @returns {any} The current state tree of your application.
   */


  function getState() {
    if (isDispatching) {
      throw new Error( true ? formatProdErrorMessage(3) : 0);
    }

    return currentState;
  }
  /**
   * Adds a change listener. It will be called any time an action is dispatched,
   * and some part of the state tree may potentially have changed. You may then
   * call `getState()` to read the current state tree inside the callback.
   *
   * You may call `dispatch()` from a change listener, with the following
   * caveats:
   *
   * 1. The subscriptions are snapshotted just before every `dispatch()` call.
   * If you subscribe or unsubscribe while the listeners are being invoked, this
   * will not have any effect on the `dispatch()` that is currently in progress.
   * However, the next `dispatch()` call, whether nested or not, will use a more
   * recent snapshot of the subscription list.
   *
   * 2. The listener should not expect to see all state changes, as the state
   * might have been updated multiple times during a nested `dispatch()` before
   * the listener is called. It is, however, guaranteed that all subscribers
   * registered before the `dispatch()` started will be called with the latest
   * state by the time it exits.
   *
   * @param {Function} listener A callback to be invoked on every dispatch.
   * @returns {Function} A function to remove this change listener.
   */


  function subscribe(listener) {
    if (typeof listener !== 'function') {
      throw new Error( true ? formatProdErrorMessage(4) : 0);
    }

    if (isDispatching) {
      throw new Error( true ? formatProdErrorMessage(5) : 0);
    }

    var isSubscribed = true;
    ensureCanMutateNextListeners();
    nextListeners.push(listener);
    return function unsubscribe() {
      if (!isSubscribed) {
        return;
      }

      if (isDispatching) {
        throw new Error( true ? formatProdErrorMessage(6) : 0);
      }

      isSubscribed = false;
      ensureCanMutateNextListeners();
      var index = nextListeners.indexOf(listener);
      nextListeners.splice(index, 1);
      currentListeners = null;
    };
  }
  /**
   * Dispatches an action. It is the only way to trigger a state change.
   *
   * The `reducer` function, used to create the store, will be called with the
   * current state tree and the given `action`. Its return value will
   * be considered the **next** state of the tree, and the change listeners
   * will be notified.
   *
   * The base implementation only supports plain object actions. If you want to
   * dispatch a Promise, an Observable, a thunk, or something else, you need to
   * wrap your store creating function into the corresponding middleware. For
   * example, see the documentation for the `redux-thunk` package. Even the
   * middleware will eventually dispatch plain object actions using this method.
   *
   * @param {Object} action A plain object representing what changed. It is
   * a good idea to keep actions serializable so you can record and replay user
   * sessions, or use the time travelling `redux-devtools`. An action must have
   * a `type` property which may not be `undefined`. It is a good idea to use
   * string constants for action types.
   *
   * @returns {Object} For convenience, the same action object you dispatched.
   *
   * Note that, if you use a custom middleware, it may wrap `dispatch()` to
   * return something else (for example, a Promise you can await).
   */


  function dispatch(action) {
    if (!isPlainObject(action)) {
      throw new Error( true ? formatProdErrorMessage(7) : 0);
    }

    if (typeof action.type === 'undefined') {
      throw new Error( true ? formatProdErrorMessage(8) : 0);
    }

    if (isDispatching) {
      throw new Error( true ? formatProdErrorMessage(9) : 0);
    }

    try {
      isDispatching = true;
      currentState = currentReducer(currentState, action);
    } finally {
      isDispatching = false;
    }

    var listeners = currentListeners = nextListeners;

    for (var i = 0; i < listeners.length; i++) {
      var listener = listeners[i];
      listener();
    }

    return action;
  }
  /**
   * Replaces the reducer currently used by the store to calculate the state.
   *
   * You might need this if your app implements code splitting and you want to
   * load some of the reducers dynamically. You might also need this if you
   * implement a hot reloading mechanism for Redux.
   *
   * @param {Function} nextReducer The reducer for the store to use instead.
   * @returns {void}
   */


  function replaceReducer(nextReducer) {
    if (typeof nextReducer !== 'function') {
      throw new Error( true ? formatProdErrorMessage(10) : 0);
    }

    currentReducer = nextReducer; // This action has a similiar effect to ActionTypes.INIT.
    // Any reducers that existed in both the new and old rootReducer
    // will receive the previous state. This effectively populates
    // the new state tree with any relevant data from the old one.

    dispatch({
      type: ActionTypes.REPLACE
    });
  }
  /**
   * Interoperability point for observable/reactive libraries.
   * @returns {observable} A minimal observable of state changes.
   * For more information, see the observable proposal:
   * https://github.com/tc39/proposal-observable
   */


  function observable() {
    var _ref;

    var outerSubscribe = subscribe;
    return _ref = {
      /**
       * The minimal observable subscription method.
       * @param {Object} observer Any object that can be used as an observer.
       * The observer object should have a `next` method.
       * @returns {subscription} An object with an `unsubscribe` method that can
       * be used to unsubscribe the observable from the store, and prevent further
       * emission of values from the observable.
       */
      subscribe: function subscribe(observer) {
        if (typeof observer !== 'object' || observer === null) {
          throw new Error( true ? formatProdErrorMessage(11) : 0);
        }

        function observeState() {
          if (observer.next) {
            observer.next(getState());
          }
        }

        observeState();
        var unsubscribe = outerSubscribe(observeState);
        return {
          unsubscribe: unsubscribe
        };
      }
    }, _ref[$$observable] = function () {
      return this;
    }, _ref;
  } // When a store is created, an "INIT" action is dispatched so that every
  // reducer returns their initial state. This effectively populates
  // the initial state tree.


  dispatch({
    type: ActionTypes.INIT
  });
  return _ref2 = {
    dispatch: dispatch,
    subscribe: subscribe,
    getState: getState,
    replaceReducer: replaceReducer
  }, _ref2[$$observable] = observable, _ref2;
}
/**
 * Creates a Redux store that holds the state tree.
 *
 * **We recommend using `configureStore` from the
 * `@reduxjs/toolkit` package**, which replaces `createStore`:
 * **https://redux.js.org/introduction/why-rtk-is-redux-today**
 *
 * The only way to change the data in the store is to call `dispatch()` on it.
 *
 * There should only be a single store in your app. To specify how different
 * parts of the state tree respond to actions, you may combine several reducers
 * into a single reducer function by using `combineReducers`.
 *
 * @param {Function} reducer A function that returns the next state tree, given
 * the current state tree and the action to handle.
 *
 * @param {any} [preloadedState] The initial state. You may optionally specify it
 * to hydrate the state from the server in universal apps, or to restore a
 * previously serialized user session.
 * If you use `combineReducers` to produce the root reducer function, this must be
 * an object with the same shape as `combineReducers` keys.
 *
 * @param {Function} [enhancer] The store enhancer. You may optionally specify it
 * to enhance the store with third-party capabilities such as middleware,
 * time travel, persistence, etc. The only store enhancer that ships with Redux
 * is `applyMiddleware()`.
 *
 * @returns {Store} A Redux store that lets you read the state, dispatch actions
 * and subscribe to changes.
 */

var legacy_createStore = (/* unused pure expression or super */ null && (createStore));

/**
 * Prints a warning in the console if it exists.
 *
 * @param {String} message The warning message.
 * @returns {void}
 */
function warning(message) {
  /* eslint-disable no-console */
  if (typeof console !== 'undefined' && typeof console.error === 'function') {
    console.error(message);
  }
  /* eslint-enable no-console */


  try {
    // This error was thrown as a convenience so that if you enable
    // "break on all exceptions" in your console,
    // it would pause the execution at this line.
    throw new Error(message);
  } catch (e) {} // eslint-disable-line no-empty

}

function getUnexpectedStateShapeWarningMessage(inputState, reducers, action, unexpectedKeyCache) {
  var reducerKeys = Object.keys(reducers);
  var argumentName = action && action.type === ActionTypes.INIT ? 'preloadedState argument passed to createStore' : 'previous state received by the reducer';

  if (reducerKeys.length === 0) {
    return 'Store does not have a valid reducer. Make sure the argument passed ' + 'to combineReducers is an object whose values are reducers.';
  }

  if (!isPlainObject(inputState)) {
    return "The " + argumentName + " has unexpected type of \"" + kindOf(inputState) + "\". Expected argument to be an object with the following " + ("keys: \"" + reducerKeys.join('", "') + "\"");
  }

  var unexpectedKeys = Object.keys(inputState).filter(function (key) {
    return !reducers.hasOwnProperty(key) && !unexpectedKeyCache[key];
  });
  unexpectedKeys.forEach(function (key) {
    unexpectedKeyCache[key] = true;
  });
  if (action && action.type === ActionTypes.REPLACE) return;

  if (unexpectedKeys.length > 0) {
    return "Unexpected " + (unexpectedKeys.length > 1 ? 'keys' : 'key') + " " + ("\"" + unexpectedKeys.join('", "') + "\" found in " + argumentName + ". ") + "Expected to find one of the known reducer keys instead: " + ("\"" + reducerKeys.join('", "') + "\". Unexpected keys will be ignored.");
  }
}

function assertReducerShape(reducers) {
  Object.keys(reducers).forEach(function (key) {
    var reducer = reducers[key];
    var initialState = reducer(undefined, {
      type: ActionTypes.INIT
    });

    if (typeof initialState === 'undefined') {
      throw new Error( true ? formatProdErrorMessage(12) : 0);
    }

    if (typeof reducer(undefined, {
      type: ActionTypes.PROBE_UNKNOWN_ACTION()
    }) === 'undefined') {
      throw new Error( true ? formatProdErrorMessage(13) : 0);
    }
  });
}
/**
 * Turns an object whose values are different reducer functions, into a single
 * reducer function. It will call every child reducer, and gather their results
 * into a single state object, whose keys correspond to the keys of the passed
 * reducer functions.
 *
 * @param {Object} reducers An object whose values correspond to different
 * reducer functions that need to be combined into one. One handy way to obtain
 * it is to use ES6 `import * as reducers` syntax. The reducers may never return
 * undefined for any action. Instead, they should return their initial state
 * if the state passed to them was undefined, and the current state for any
 * unrecognized action.
 *
 * @returns {Function} A reducer function that invokes every reducer inside the
 * passed object, and builds a state object with the same shape.
 */


function combineReducers(reducers) {
  var reducerKeys = Object.keys(reducers);
  var finalReducers = {};

  for (var i = 0; i < reducerKeys.length; i++) {
    var key = reducerKeys[i];

    if (false) {}

    if (typeof reducers[key] === 'function') {
      finalReducers[key] = reducers[key];
    }
  }

  var finalReducerKeys = Object.keys(finalReducers); // This is used to make sure we don't warn about the same
  // keys multiple times.

  var unexpectedKeyCache;

  if (false) {}

  var shapeAssertionError;

  try {
    assertReducerShape(finalReducers);
  } catch (e) {
    shapeAssertionError = e;
  }

  return function combination(state, action) {
    if (state === void 0) {
      state = {};
    }

    if (shapeAssertionError) {
      throw shapeAssertionError;
    }

    if (false) { var warningMessage; }

    var hasChanged = false;
    var nextState = {};

    for (var _i = 0; _i < finalReducerKeys.length; _i++) {
      var _key = finalReducerKeys[_i];
      var reducer = finalReducers[_key];
      var previousStateForKey = state[_key];
      var nextStateForKey = reducer(previousStateForKey, action);

      if (typeof nextStateForKey === 'undefined') {
        var actionType = action && action.type;
        throw new Error( true ? formatProdErrorMessage(14) : 0);
      }

      nextState[_key] = nextStateForKey;
      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
    }

    hasChanged = hasChanged || finalReducerKeys.length !== Object.keys(state).length;
    return hasChanged ? nextState : state;
  };
}

function bindActionCreator(actionCreator, dispatch) {
  return function () {
    return dispatch(actionCreator.apply(this, arguments));
  };
}
/**
 * Turns an object whose values are action creators, into an object with the
 * same keys, but with every function wrapped into a `dispatch` call so they
 * may be invoked directly. This is just a convenience method, as you can call
 * `store.dispatch(MyActionCreators.doSomething())` yourself just fine.
 *
 * For convenience, you can also pass an action creator as the first argument,
 * and get a dispatch wrapped function in return.
 *
 * @param {Function|Object} actionCreators An object whose values are action
 * creator functions. One handy way to obtain it is to use ES6 `import * as`
 * syntax. You may also pass a single function.
 *
 * @param {Function} dispatch The `dispatch` function available on your Redux
 * store.
 *
 * @returns {Function|Object} The object mimicking the original object, but with
 * every action creator wrapped into the `dispatch` call. If you passed a
 * function as `actionCreators`, the return value will also be a single
 * function.
 */


function bindActionCreators(actionCreators, dispatch) {
  if (typeof actionCreators === 'function') {
    return bindActionCreator(actionCreators, dispatch);
  }

  if (typeof actionCreators !== 'object' || actionCreators === null) {
    throw new Error( true ? formatProdErrorMessage(16) : 0);
  }

  var boundActionCreators = {};

  for (var key in actionCreators) {
    var actionCreator = actionCreators[key];

    if (typeof actionCreator === 'function') {
      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);
    }
  }

  return boundActionCreators;
}

/**
 * Composes single-argument functions from right to left. The rightmost
 * function can take multiple arguments as it provides the signature for
 * the resulting composite function.
 *
 * @param {...Function} funcs The functions to compose.
 * @returns {Function} A function obtained by composing the argument functions
 * from right to left. For example, compose(f, g, h) is identical to doing
 * (...args) => f(g(h(...args))).
 */
function compose() {
  for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {
    funcs[_key] = arguments[_key];
  }

  if (funcs.length === 0) {
    return function (arg) {
      return arg;
    };
  }

  if (funcs.length === 1) {
    return funcs[0];
  }

  return funcs.reduce(function (a, b) {
    return function () {
      return a(b.apply(void 0, arguments));
    };
  });
}

/**
 * Creates a store enhancer that applies middleware to the dispatch method
 * of the Redux store. This is handy for a variety of tasks, such as expressing
 * asynchronous actions in a concise manner, or logging every action payload.
 *
 * See `redux-thunk` package as an example of the Redux middleware.
 *
 * Because middleware is potentially asynchronous, this should be the first
 * store enhancer in the composition chain.
 *
 * Note that each middleware will be given the `dispatch` and `getState` functions
 * as named arguments.
 *
 * @param {...Function} middlewares The middleware chain to be applied.
 * @returns {Function} A store enhancer applying the middleware.
 */

function applyMiddleware() {
  for (var _len = arguments.length, middlewares = new Array(_len), _key = 0; _key < _len; _key++) {
    middlewares[_key] = arguments[_key];
  }

  return function (createStore) {
    return function () {
      var store = createStore.apply(void 0, arguments);

      var _dispatch = function dispatch() {
        throw new Error( true ? formatProdErrorMessage(15) : 0);
      };

      var middlewareAPI = {
        getState: store.getState,
        dispatch: function dispatch() {
          return _dispatch.apply(void 0, arguments);
        }
      };
      var chain = middlewares.map(function (middleware) {
        return middleware(middlewareAPI);
      });
      _dispatch = compose.apply(void 0, chain)(store.dispatch);
      return _objectSpread(_objectSpread({}, store), {}, {
        dispatch: _dispatch
      });
    };
  };
}

/*
 * This is a dummy function to check if the function name has been altered by minification.
 * If the function has been minified and NODE_ENV !== 'production', warn the user.
 */

function isCrushed() {}

if (false) {}



;// CONCATENATED MODULE: ./node_modules/@react-dnd/invariant/dist/index.js
/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */ function invariant(condition, format, ...args) {
    if (isProduction()) {
        if (format === undefined) {
            throw new Error('invariant requires an error message argument');
        }
    }
    if (!condition) {
        let error;
        if (format === undefined) {
            error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
        } else {
            let argIndex = 0;
            error = new Error(format.replace(/%s/g, function() {
                return args[argIndex++];
            }));
            error.name = 'Invariant Violation';
        }
        error.framesToPop = 1 // we don't care about invariant's own frame
        ;
        throw error;
    }
}
function isProduction() {
    return typeof process !== 'undefined' && "production" === 'production';
}

//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/dnd-core/dist/utils/js_utils.js
// cheap lodash replacements
/**
 * drop-in replacement for _.get
 * @param obj
 * @param path
 * @param defaultValue
 */ function get(obj, path, defaultValue) {
    return path.split('.').reduce((a, c)=>a && a[c] ? a[c] : defaultValue || null
    , obj);
}
/**
 * drop-in replacement for _.without
 */ function without(items, item) {
    return items.filter((i)=>i !== item
    );
}
/**
 * drop-in replacement for _.isString
 * @param input
 */ function isString(input) {
    return typeof input === 'string';
}
/**
 * drop-in replacement for _.isString
 * @param input
 */ function isObject(input) {
    return typeof input === 'object';
}
/**
 * replacement for _.xor
 * @param itemsA
 * @param itemsB
 */ function xor(itemsA, itemsB) {
    const map = new Map();
    const insertItem = (item)=>{
        map.set(item, map.has(item) ? map.get(item) + 1 : 1);
    };
    itemsA.forEach(insertItem);
    itemsB.forEach(insertItem);
    const result = [];
    map.forEach((count, key)=>{
        if (count === 1) {
            result.push(key);
        }
    });
    return result;
}
/**
 * replacement for _.intersection
 * @param itemsA
 * @param itemsB
 */ function intersection(itemsA, itemsB) {
    return itemsA.filter((t)=>itemsB.indexOf(t) > -1
    );
}

//# sourceMappingURL=js_utils.js.map
;// CONCATENATED MODULE: ./node_modules/dnd-core/dist/actions/dragDrop/types.js
const INIT_COORDS = 'dnd-core/INIT_COORDS';
const BEGIN_DRAG = 'dnd-core/BEGIN_DRAG';
const PUBLISH_DRAG_SOURCE = 'dnd-core/PUBLISH_DRAG_SOURCE';
const HOVER = 'dnd-core/HOVER';
const DROP = 'dnd-core/DROP';
const END_DRAG = 'dnd-core/END_DRAG';

//# sourceMappingURL=types.js.map
;// CONCATENATED MODULE: ./node_modules/dnd-core/dist/actions/dragDrop/local/setClientOffset.js

function setClientOffset(clientOffset, sourceClientOffset) {
    return {
        type: INIT_COORDS,
        payload: {
            sourceClientOffset: sourceClientOffset || null,
            clientOffset: clientOffset || null
        }
    };
}

//# sourceMappingURL=setClientOffset.js.map
;// CONCATENATED MODULE: ./node_modules/dnd-core/dist/actions/dragDrop/beginDrag.js




const ResetCoordinatesAction = {
    type: INIT_COORDS,
    payload: {
        clientOffset: null,
        sourceClientOffset: null
    }
};
function createBeginDrag(manager) {
    return function beginDrag(sourceIds = [], options = {
        publishSource: true
    }) {
        const { publishSource =true , clientOffset , getSourceClientOffset ,  } = options;
        const monitor = manager.getMonitor();
        const registry = manager.getRegistry();
        // Initialize the coordinates using the client offset
        manager.dispatch(setClientOffset(clientOffset));
        verifyInvariants(sourceIds, monitor, registry);
        // Get the draggable source
        const sourceId = getDraggableSource(sourceIds, monitor);
        if (sourceId == null) {
            manager.dispatch(ResetCoordinatesAction);
            return;
        }
        // Get the source client offset
        let sourceClientOffset = null;
        if (clientOffset) {
            if (!getSourceClientOffset) {
                throw new Error('getSourceClientOffset must be defined');
            }
            verifyGetSourceClientOffsetIsFunction(getSourceClientOffset);
            sourceClientOffset = getSourceClientOffset(sourceId);
        }
        // Initialize the full coordinates
        manager.dispatch(setClientOffset(clientOffset, sourceClientOffset));
        const source = registry.getSource(sourceId);
        const item = source.beginDrag(monitor, sourceId);
        // If source.beginDrag returns null, this is an indicator to cancel the drag
        if (item == null) {
            return undefined;
        }
        verifyItemIsObject(item);
        registry.pinSource(sourceId);
        const itemType = registry.getSourceType(sourceId);
        return {
            type: BEGIN_DRAG,
            payload: {
                itemType,
                item,
                sourceId,
                clientOffset: clientOffset || null,
                sourceClientOffset: sourceClientOffset || null,
                isSourcePublic: !!publishSource
            }
        };
    };
}
function verifyInvariants(sourceIds, monitor, registry) {
    invariant(!monitor.isDragging(), 'Cannot call beginDrag while dragging.');
    sourceIds.forEach(function(sourceId) {
        invariant(registry.getSource(sourceId), 'Expected sourceIds to be registered.');
    });
}
function verifyGetSourceClientOffsetIsFunction(getSourceClientOffset) {
    invariant(typeof getSourceClientOffset === 'function', 'When clientOffset is provided, getSourceClientOffset must be a function.');
}
function verifyItemIsObject(item) {
    invariant(isObject(item), 'Item must be an object.');
}
function getDraggableSource(sourceIds, monitor) {
    let sourceId = null;
    for(let i = sourceIds.length - 1; i >= 0; i--){
        if (monitor.canDragSource(sourceIds[i])) {
            sourceId = sourceIds[i];
            break;
        }
    }
    return sourceId;
}

//# sourceMappingURL=beginDrag.js.map
;// CONCATENATED MODULE: ./node_modules/dnd-core/dist/actions/dragDrop/drop.js
function _defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
function drop_objectSpread(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === 'function') {
            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
                return Object.getOwnPropertyDescriptor(source, sym).enumerable;
            }));
        }
        ownKeys.forEach(function(key) {
            _defineProperty(target, key, source[key]);
        });
    }
    return target;
}



function createDrop(manager) {
    return function drop(options = {}) {
        const monitor = manager.getMonitor();
        const registry = manager.getRegistry();
        drop_verifyInvariants(monitor);
        const targetIds = getDroppableTargets(monitor);
        // Multiple actions are dispatched here, which is why this doesn't return an action
        targetIds.forEach((targetId, index)=>{
            const dropResult = determineDropResult(targetId, index, registry, monitor);
            const action = {
                type: DROP,
                payload: {
                    dropResult: drop_objectSpread({}, options, dropResult)
                }
            };
            manager.dispatch(action);
        });
    };
}
function drop_verifyInvariants(monitor) {
    invariant(monitor.isDragging(), 'Cannot call drop while not dragging.');
    invariant(!monitor.didDrop(), 'Cannot call drop twice during one drag operation.');
}
function determineDropResult(targetId, index, registry, monitor) {
    const target = registry.getTarget(targetId);
    let dropResult = target ? target.drop(monitor, targetId) : undefined;
    verifyDropResultType(dropResult);
    if (typeof dropResult === 'undefined') {
        dropResult = index === 0 ? {} : monitor.getDropResult();
    }
    return dropResult;
}
function verifyDropResultType(dropResult) {
    invariant(typeof dropResult === 'undefined' || isObject(dropResult), 'Drop result must either be an object or undefined.');
}
function getDroppableTargets(monitor) {
    const targetIds = monitor.getTargetIds().filter(monitor.canDropOnTarget, monitor);
    targetIds.reverse();
    return targetIds;
}

//# sourceMappingURL=drop.js.map
;// CONCATENATED MODULE: ./node_modules/dnd-core/dist/actions/dragDrop/endDrag.js


function createEndDrag(manager) {
    return function endDrag() {
        const monitor = manager.getMonitor();
        const registry = manager.getRegistry();
        verifyIsDragging(monitor);
        const sourceId = monitor.getSourceId();
        if (sourceId != null) {
            const source = registry.getSource(sourceId, true);
            source.endDrag(monitor, sourceId);
            registry.unpinSource();
        }
        return {
            type: END_DRAG
        };
    };
}
function verifyIsDragging(monitor) {
    invariant(monitor.isDragging(), 'Cannot call endDrag while not dragging.');
}

//# sourceMappingURL=endDrag.js.map
;// CONCATENATED MODULE: ./node_modules/dnd-core/dist/utils/matchesType.js
function matchesType(targetType, draggedItemType) {
    if (draggedItemType === null) {
        return targetType === null;
    }
    return Array.isArray(targetType) ? targetType.some((t)=>t === draggedItemType
    ) : targetType === draggedItemType;
}

//# sourceMappingURL=matchesType.js.map
;// CONCATENATED MODULE: ./node_modules/dnd-core/dist/actions/dragDrop/hover.js



function createHover(manager) {
    return function hover(targetIdsArg, { clientOffset  } = {}) {
        verifyTargetIdsIsArray(targetIdsArg);
        const targetIds = targetIdsArg.slice(0);
        const monitor = manager.getMonitor();
        const registry = manager.getRegistry();
        const draggedItemType = monitor.getItemType();
        removeNonMatchingTargetIds(targetIds, registry, draggedItemType);
        checkInvariants(targetIds, monitor, registry);
        hoverAllTargets(targetIds, monitor, registry);
        return {
            type: HOVER,
            payload: {
                targetIds,
                clientOffset: clientOffset || null
            }
        };
    };
}
function verifyTargetIdsIsArray(targetIdsArg) {
    invariant(Array.isArray(targetIdsArg), 'Expected targetIds to be an array.');
}
function checkInvariants(targetIds, monitor, registry) {
    invariant(monitor.isDragging(), 'Cannot call hover while not dragging.');
    invariant(!monitor.didDrop(), 'Cannot call hover after drop.');
    for(let i = 0; i < targetIds.length; i++){
        const targetId = targetIds[i];
        invariant(targetIds.lastIndexOf(targetId) === i, 'Expected targetIds to be unique in the passed array.');
        const target = registry.getTarget(targetId);
        invariant(target, 'Expected targetIds to be registered.');
    }
}
function removeNonMatchingTargetIds(targetIds, registry, draggedItemType) {
    // Remove those targetIds that don't match the targetType.  This
    // fixes shallow isOver which would only be non-shallow because of
    // non-matching targets.
    for(let i = targetIds.length - 1; i >= 0; i--){
        const targetId = targetIds[i];
        const targetType = registry.getTargetType(targetId);
        if (!matchesType(targetType, draggedItemType)) {
            targetIds.splice(i, 1);
        }
    }
}
function hoverAllTargets(targetIds, monitor, registry) {
    // Finally call hover on all matching targets.
    targetIds.forEach(function(targetId) {
        const target = registry.getTarget(targetId);
        target.hover(monitor, targetId);
    });
}

//# sourceMappingURL=hover.js.map
;// CONCATENATED MODULE: ./node_modules/dnd-core/dist/actions/dragDrop/publishDragSource.js

function createPublishDragSource(manager) {
    return function publishDragSource() {
        const monitor = manager.getMonitor();
        if (monitor.isDragging()) {
            return {
                type: PUBLISH_DRAG_SOURCE
            };
        }
        return;
    };
}

//# sourceMappingURL=publishDragSource.js.map
;// CONCATENATED MODULE: ./node_modules/dnd-core/dist/actions/dragDrop/index.js






function createDragDropActions(manager) {
    return {
        beginDrag: createBeginDrag(manager),
        publishDragSource: createPublishDragSource(manager),
        hover: createHover(manager),
        drop: createDrop(manager),
        endDrag: createEndDrag(manager)
    };
}

//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/dnd-core/dist/classes/DragDropManagerImpl.js

class DragDropManagerImpl {
    receiveBackend(backend) {
        this.backend = backend;
    }
    getMonitor() {
        return this.monitor;
    }
    getBackend() {
        return this.backend;
    }
    getRegistry() {
        return this.monitor.registry;
    }
    getActions() {
        /* eslint-disable-next-line @typescript-eslint/no-this-alias */ const manager = this;
        const { dispatch  } = this.store;
        function bindActionCreator(actionCreator) {
            return (...args)=>{
                const action = actionCreator.apply(manager, args);
                if (typeof action !== 'undefined') {
                    dispatch(action);
                }
            };
        }
        const actions = createDragDropActions(this);
        return Object.keys(actions).reduce((boundActions, key)=>{
            const action = actions[key];
            boundActions[key] = bindActionCreator(action);
            return boundActions;
        }, {});
    }
    dispatch(action) {
        this.store.dispatch(action);
    }
    constructor(store, monitor){
        this.isSetUp = false;
        this.handleRefCountChange = ()=>{
            const shouldSetUp = this.store.getState().refCount > 0;
            if (this.backend) {
                if (shouldSetUp && !this.isSetUp) {
                    this.backend.setup();
                    this.isSetUp = true;
                } else if (!shouldSetUp && this.isSetUp) {
                    this.backend.teardown();
                    this.isSetUp = false;
                }
            }
        };
        this.store = store;
        this.monitor = monitor;
        store.subscribe(this.handleRefCountChange);
    }
}

//# sourceMappingURL=DragDropManagerImpl.js.map
;// CONCATENATED MODULE: ./node_modules/dnd-core/dist/utils/coords.js
/**
 * Coordinate addition
 * @param a The first coordinate
 * @param b The second coordinate
 */ function add(a, b) {
    return {
        x: a.x + b.x,
        y: a.y + b.y
    };
}
/**
 * Coordinate subtraction
 * @param a The first coordinate
 * @param b The second coordinate
 */ function subtract(a, b) {
    return {
        x: a.x - b.x,
        y: a.y - b.y
    };
}
/**
 * Returns the cartesian distance of the drag source component's position, based on its position
 * at the time when the current drag operation has started, and the movement difference.
 *
 * Returns null if no item is being dragged.
 *
 * @param state The offset state to compute from
 */ function getSourceClientOffset(state) {
    const { clientOffset , initialClientOffset , initialSourceClientOffset  } = state;
    if (!clientOffset || !initialClientOffset || !initialSourceClientOffset) {
        return null;
    }
    return subtract(add(clientOffset, initialSourceClientOffset), initialClientOffset);
}
/**
 * Determines the x,y offset between the client offset and the initial client offset
 *
 * @param state The offset state to compute from
 */ function getDifferenceFromInitialOffset(state) {
    const { clientOffset , initialClientOffset  } = state;
    if (!clientOffset || !initialClientOffset) {
        return null;
    }
    return subtract(clientOffset, initialClientOffset);
}

//# sourceMappingURL=coords.js.map
;// CONCATENATED MODULE: ./node_modules/dnd-core/dist/utils/dirtiness.js

const NONE = [];
const ALL = [];
NONE.__IS_NONE__ = true;
ALL.__IS_ALL__ = true;
/**
 * Determines if the given handler IDs are dirty or not.
 *
 * @param dirtyIds The set of dirty handler ids
 * @param handlerIds The set of handler ids to check
 */ function areDirty(dirtyIds, handlerIds) {
    if (dirtyIds === NONE) {
        return false;
    }
    if (dirtyIds === ALL || typeof handlerIds === 'undefined') {
        return true;
    }
    const commonIds = intersection(handlerIds, dirtyIds);
    return commonIds.length > 0;
}

//# sourceMappingURL=dirtiness.js.map
;// CONCATENATED MODULE: ./node_modules/dnd-core/dist/classes/DragDropMonitorImpl.js




class DragDropMonitorImpl {
    subscribeToStateChange(listener, options = {}) {
        const { handlerIds  } = options;
        invariant(typeof listener === 'function', 'listener must be a function.');
        invariant(typeof handlerIds === 'undefined' || Array.isArray(handlerIds), 'handlerIds, when specified, must be an array of strings.');
        let prevStateId = this.store.getState().stateId;
        const handleChange = ()=>{
            const state = this.store.getState();
            const currentStateId = state.stateId;
            try {
                const canSkipListener = currentStateId === prevStateId || currentStateId === prevStateId + 1 && !areDirty(state.dirtyHandlerIds, handlerIds);
                if (!canSkipListener) {
                    listener();
                }
            } finally{
                prevStateId = currentStateId;
            }
        };
        return this.store.subscribe(handleChange);
    }
    subscribeToOffsetChange(listener) {
        invariant(typeof listener === 'function', 'listener must be a function.');
        let previousState = this.store.getState().dragOffset;
        const handleChange = ()=>{
            const nextState = this.store.getState().dragOffset;
            if (nextState === previousState) {
                return;
            }
            previousState = nextState;
            listener();
        };
        return this.store.subscribe(handleChange);
    }
    canDragSource(sourceId) {
        if (!sourceId) {
            return false;
        }
        const source = this.registry.getSource(sourceId);
        invariant(source, `Expected to find a valid source. sourceId=${sourceId}`);
        if (this.isDragging()) {
            return false;
        }
        return source.canDrag(this, sourceId);
    }
    canDropOnTarget(targetId) {
        // undefined on initial render
        if (!targetId) {
            return false;
        }
        const target = this.registry.getTarget(targetId);
        invariant(target, `Expected to find a valid target. targetId=${targetId}`);
        if (!this.isDragging() || this.didDrop()) {
            return false;
        }
        const targetType = this.registry.getTargetType(targetId);
        const draggedItemType = this.getItemType();
        return matchesType(targetType, draggedItemType) && target.canDrop(this, targetId);
    }
    isDragging() {
        return Boolean(this.getItemType());
    }
    isDraggingSource(sourceId) {
        // undefined on initial render
        if (!sourceId) {
            return false;
        }
        const source = this.registry.getSource(sourceId, true);
        invariant(source, `Expected to find a valid source. sourceId=${sourceId}`);
        if (!this.isDragging() || !this.isSourcePublic()) {
            return false;
        }
        const sourceType = this.registry.getSourceType(sourceId);
        const draggedItemType = this.getItemType();
        if (sourceType !== draggedItemType) {
            return false;
        }
        return source.isDragging(this, sourceId);
    }
    isOverTarget(targetId, options = {
        shallow: false
    }) {
        // undefined on initial render
        if (!targetId) {
            return false;
        }
        const { shallow  } = options;
        if (!this.isDragging()) {
            return false;
        }
        const targetType = this.registry.getTargetType(targetId);
        const draggedItemType = this.getItemType();
        if (draggedItemType && !matchesType(targetType, draggedItemType)) {
            return false;
        }
        const targetIds = this.getTargetIds();
        if (!targetIds.length) {
            return false;
        }
        const index = targetIds.indexOf(targetId);
        if (shallow) {
            return index === targetIds.length - 1;
        } else {
            return index > -1;
        }
    }
    getItemType() {
        return this.store.getState().dragOperation.itemType;
    }
    getItem() {
        return this.store.getState().dragOperation.item;
    }
    getSourceId() {
        return this.store.getState().dragOperation.sourceId;
    }
    getTargetIds() {
        return this.store.getState().dragOperation.targetIds;
    }
    getDropResult() {
        return this.store.getState().dragOperation.dropResult;
    }
    didDrop() {
        return this.store.getState().dragOperation.didDrop;
    }
    isSourcePublic() {
        return Boolean(this.store.getState().dragOperation.isSourcePublic);
    }
    getInitialClientOffset() {
        return this.store.getState().dragOffset.initialClientOffset;
    }
    getInitialSourceClientOffset() {
        return this.store.getState().dragOffset.initialSourceClientOffset;
    }
    getClientOffset() {
        return this.store.getState().dragOffset.clientOffset;
    }
    getSourceClientOffset() {
        return getSourceClientOffset(this.store.getState().dragOffset);
    }
    getDifferenceFromInitialOffset() {
        return getDifferenceFromInitialOffset(this.store.getState().dragOffset);
    }
    constructor(store, registry){
        this.store = store;
        this.registry = registry;
    }
}

//# sourceMappingURL=DragDropMonitorImpl.js.map
;// CONCATENATED MODULE: ./node_modules/@react-dnd/asap/dist/makeRequestCall.js
// Safari 6 and 6.1 for desktop, iPad, and iPhone are the only browsers that
// have WebKitMutationObserver but not un-prefixed MutationObserver.
// Must use `global` or `self` instead of `window` to work in both frames and web
// workers. `global` is a provision of Browserify, Mr, Mrs, or Mop.
/* globals self */ const scope = typeof global !== 'undefined' ? global : self;
const BrowserMutationObserver = scope.MutationObserver || scope.WebKitMutationObserver;
function makeRequestCallFromTimer(callback) {
    return function requestCall() {
        // We dispatch a timeout with a specified delay of 0 for engines that
        // can reliably accommodate that request. This will usually be snapped
        // to a 4 milisecond delay, but once we're flushing, there's no delay
        // between events.
        const timeoutHandle = setTimeout(handleTimer, 0);
        // However, since this timer gets frequently dropped in Firefox
        // workers, we enlist an interval handle that will try to fire
        // an event 20 times per second until it succeeds.
        const intervalHandle = setInterval(handleTimer, 50);
        function handleTimer() {
            // Whichever timer succeeds will cancel both timers and
            // execute the callback.
            clearTimeout(timeoutHandle);
            clearInterval(intervalHandle);
            callback();
        }
    };
}
// To request a high priority event, we induce a mutation observer by toggling
// the text of a text node between "1" and "-1".
function makeRequestCallFromMutationObserver(callback) {
    let toggle = 1;
    const observer = new BrowserMutationObserver(callback);
    const node = document.createTextNode('');
    observer.observe(node, {
        characterData: true
    });
    return function requestCall() {
        toggle = -toggle;
        node.data = toggle;
    };
}
const makeRequestCall = typeof BrowserMutationObserver === 'function' ? // reliably everywhere they are implemented.
// They are implemented in all modern browsers.
//
// - Android 4-4.3
// - Chrome 26-34
// - Firefox 14-29
// - Internet Explorer 11
// - iPad Safari 6-7.1
// - iPhone Safari 7-7.1
// - Safari 6-7
makeRequestCallFromMutationObserver : // task queue, are implemented in Internet Explorer 10, Safari 5.0-1, and Opera
// 11-12, and in web workers in many engines.
// Although message channels yield to any queued rendering and IO tasks, they
// would be better than imposing the 4ms delay of timers.
// However, they do not work reliably in Internet Explorer or Safari.
// Internet Explorer 10 is the only browser that has setImmediate but does
// not have MutationObservers.
// Although setImmediate yields to the browser's renderer, it would be
// preferrable to falling back to setTimeout since it does not have
// the minimum 4ms penalty.
// Unfortunately there appears to be a bug in Internet Explorer 10 Mobile (and
// Desktop to a lesser extent) that renders both setImmediate and
// MessageChannel useless for the purposes of ASAP.
// https://github.com/kriskowal/q/issues/396
// Timers are implemented universally.
// We fall back to timers in workers in most engines, and in foreground
// contexts in the following browsers.
// However, note that even this simple case requires nuances to operate in a
// broad spectrum of browsers.
//
// - Firefox 3-13
// - Internet Explorer 6-9
// - iPad Safari 4.3
// - Lynx 2.8.7
makeRequestCallFromTimer;

//# sourceMappingURL=makeRequestCall.js.map
;// CONCATENATED MODULE: ./node_modules/@react-dnd/asap/dist/AsapQueue.js
/* eslint-disable no-restricted-globals, @typescript-eslint/ban-ts-comment, @typescript-eslint/no-unused-vars, @typescript-eslint/no-non-null-assertion */ 
class AsapQueue {
    // Use the fastest means possible to execute a task in its own turn, with
    // priority over other events including IO, animation, reflow, and redraw
    // events in browsers.
    //
    // An exception thrown by a task will permanently interrupt the processing of
    // subsequent tasks. The higher level `asap` function ensures that if an
    // exception is thrown by a task, that the task queue will continue flushing as
    // soon as possible, but if you use `rawAsap` directly, you are responsible to
    // either ensure that no exceptions are thrown from your task, or to manually
    // call `rawAsap.requestFlush` if an exception is thrown.
    enqueueTask(task) {
        const { queue: q , requestFlush  } = this;
        if (!q.length) {
            requestFlush();
            this.flushing = true;
        }
        // Equivalent to push, but avoids a function call.
        q[q.length] = task;
    }
    constructor(){
        this.queue = [];
        // We queue errors to ensure they are thrown in right order (FIFO).
        // Array-as-queue is good enough here, since we are just dealing with exceptions.
        this.pendingErrors = [];
        // Once a flush has been requested, no further calls to `requestFlush` are
        // necessary until the next `flush` completes.
        // @ts-ignore
        this.flushing = false;
        // The position of the next task to execute in the task queue. This is
        // preserved between calls to `flush` so that it can be resumed if
        // a task throws an exception.
        this.index = 0;
        // If a task schedules additional tasks recursively, the task queue can grow
        // unbounded. To prevent memory exhaustion, the task queue will periodically
        // truncate already-completed tasks.
        this.capacity = 1024;
        // The flush function processes all tasks that have been scheduled with
        // `rawAsap` unless and until one of those tasks throws an exception.
        // If a task throws an exception, `flush` ensures that its state will remain
        // consistent and will resume where it left off when called again.
        // However, `flush` does not make any arrangements to be called again if an
        // exception is thrown.
        this.flush = ()=>{
            const { queue: q  } = this;
            while(this.index < q.length){
                const currentIndex = this.index;
                // Advance the index before calling the task. This ensures that we will
                // begin flushing on the next task the task throws an error.
                this.index++;
                q[currentIndex].call();
                // Prevent leaking memory for long chains of recursive calls to `asap`.
                // If we call `asap` within tasks scheduled by `asap`, the queue will
                // grow, but to avoid an O(n) walk for every task we execute, we don't
                // shift tasks off the queue after they have been executed.
                // Instead, we periodically shift 1024 tasks off the queue.
                if (this.index > this.capacity) {
                    // Manually shift all values starting at the index back to the
                    // beginning of the queue.
                    for(let scan = 0, newLength = q.length - this.index; scan < newLength; scan++){
                        q[scan] = q[scan + this.index];
                    }
                    q.length -= this.index;
                    this.index = 0;
                }
            }
            q.length = 0;
            this.index = 0;
            this.flushing = false;
        };
        // In a web browser, exceptions are not fatal. However, to avoid
        // slowing down the queue of pending tasks, we rethrow the error in a
        // lower priority turn.
        this.registerPendingError = (err)=>{
            this.pendingErrors.push(err);
            this.requestErrorThrow();
        };
        // `requestFlush` requests that the high priority event queue be flushed as
        // soon as possible.
        // This is useful to prevent an error thrown in a task from stalling the event
        // queue if the exception handled by Node.jss
        // `process.on("uncaughtException")` or by a domain.
        // `requestFlush` is implemented using a strategy based on data collected from
        // every available SauceLabs Selenium web driver worker at time of writing.
        // https://docs.google.com/spreadsheets/d/1mG-5UYGup5qxGdEMWkhP6BWCz053NUb2E1QoUTU16uA/edit#gid=783724593
        this.requestFlush = makeRequestCall(this.flush);
        this.requestErrorThrow = makeRequestCallFromTimer(()=>{
            // Throw first error
            if (this.pendingErrors.length) {
                throw this.pendingErrors.shift();
            }
        });
    }
} // The message channel technique was discovered by Malte Ubl and was the
 // original foundation for this library.
 // http://www.nonblocking.io/2011/06/windownexttick.html
 // Safari 6.0.5 (at least) intermittently fails to create message ports on a
 // page's first load. Thankfully, this version of Safari supports
 // MutationObservers, so we don't need to fall back in that case.
 // function makeRequestCallFromMessageChannel(callback) {
 //     var channel = new MessageChannel();
 //     channel.port1.onmessage = callback;
 //     return function requestCall() {
 //         channel.port2.postMessage(0);
 //     };
 // }
 // For reasons explained above, we are also unable to use `setImmediate`
 // under any circumstances.
 // Even if we were, there is another bug in Internet Explorer 10.
 // It is not sufficient to assign `setImmediate` to `requestFlush` because
 // `setImmediate` must be called *by name* and therefore must be wrapped in a
 // closure.
 // Never forget.
 // function makeRequestCallFromSetImmediate(callback) {
 //     return function requestCall() {
 //         setImmediate(callback);
 //     };
 // }
 // Safari 6.0 has a problem where timers will get lost while the user is
 // scrolling. This problem does not impact ASAP because Safari 6.0 supports
 // mutation observers, so that implementation is used instead.
 // However, if we ever elect to use timers in Safari, the prevalent work-around
 // is to add a scroll event listener that calls for a flush.
 // `setTimeout` does not call the passed callback if the delay is less than
 // approximately 7 in web workers in Firefox 8 through 18, and sometimes not
 // even then.
 // This is for `asap.js` only.
 // Its name will be periodically randomized to break any code that depends on
 // // its existence.
 // rawAsap.makeRequestCallFromTimer = makeRequestCallFromTimer
 // ASAP was originally a nextTick shim included in Q. This was factored out
 // into this ASAP package. It was later adapted to RSVP which made further
 // amendments. These decisions, particularly to marginalize MessageChannel and
 // to capture the MutationObserver implementation in a closure, were integrated
 // back into ASAP proper.
 // https://github.com/tildeio/rsvp.js/blob/cddf7232546a9cf858524b75cde6f9edf72620a7/lib/rsvp/asap.js

//# sourceMappingURL=AsapQueue.js.map
;// CONCATENATED MODULE: ./node_modules/@react-dnd/asap/dist/RawTask.js
// `call`, just like a function.
class RawTask {
    call() {
        try {
            this.task && this.task();
        } catch (error) {
            this.onError(error);
        } finally{
            this.task = null;
            this.release(this);
        }
    }
    constructor(onError, release){
        this.onError = onError;
        this.release = release;
        this.task = null;
    }
}

//# sourceMappingURL=RawTask.js.map
;// CONCATENATED MODULE: ./node_modules/@react-dnd/asap/dist/TaskFactory.js

class TaskFactory {
    create(task) {
        const tasks = this.freeTasks;
        const t1 = tasks.length ? tasks.pop() : new RawTask(this.onError, (t)=>tasks[tasks.length] = t
        );
        t1.task = task;
        return t1;
    }
    constructor(onError){
        this.onError = onError;
        this.freeTasks = [];
    }
}

//# sourceMappingURL=TaskFactory.js.map
;// CONCATENATED MODULE: ./node_modules/@react-dnd/asap/dist/asap.js


const asapQueue = new AsapQueue();
const taskFactory = new TaskFactory(asapQueue.registerPendingError);
/**
 * Calls a task as soon as possible after returning, in its own event, with priority
 * over other events like animation, reflow, and repaint. An error thrown from an
 * event will not interrupt, nor even substantially slow down the processing of
 * other events, but will be rather postponed to a lower priority event.
 * @param {{call}} task A callable object, typically a function that takes no
 * arguments.
 */ function asap(task) {
    asapQueue.enqueueTask(taskFactory.create(task));
}

//# sourceMappingURL=asap.js.map
;// CONCATENATED MODULE: ./node_modules/@react-dnd/asap/dist/index.js





//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/dnd-core/dist/actions/registry.js
const ADD_SOURCE = 'dnd-core/ADD_SOURCE';
const ADD_TARGET = 'dnd-core/ADD_TARGET';
const REMOVE_SOURCE = 'dnd-core/REMOVE_SOURCE';
const REMOVE_TARGET = 'dnd-core/REMOVE_TARGET';
function addSource(sourceId) {
    return {
        type: ADD_SOURCE,
        payload: {
            sourceId
        }
    };
}
function addTarget(targetId) {
    return {
        type: ADD_TARGET,
        payload: {
            targetId
        }
    };
}
function removeSource(sourceId) {
    return {
        type: REMOVE_SOURCE,
        payload: {
            sourceId
        }
    };
}
function removeTarget(targetId) {
    return {
        type: REMOVE_TARGET,
        payload: {
            targetId
        }
    };
}

//# sourceMappingURL=registry.js.map
;// CONCATENATED MODULE: ./node_modules/dnd-core/dist/contracts.js

function validateSourceContract(source) {
    invariant(typeof source.canDrag === 'function', 'Expected canDrag to be a function.');
    invariant(typeof source.beginDrag === 'function', 'Expected beginDrag to be a function.');
    invariant(typeof source.endDrag === 'function', 'Expected endDrag to be a function.');
}
function validateTargetContract(target) {
    invariant(typeof target.canDrop === 'function', 'Expected canDrop to be a function.');
    invariant(typeof target.hover === 'function', 'Expected hover to be a function.');
    invariant(typeof target.drop === 'function', 'Expected beginDrag to be a function.');
}
function validateType(type, allowArray) {
    if (allowArray && Array.isArray(type)) {
        type.forEach((t)=>validateType(t, false)
        );
        return;
    }
    invariant(typeof type === 'string' || typeof type === 'symbol', allowArray ? 'Type can only be a string, a symbol, or an array of either.' : 'Type can only be a string or a symbol.');
}

//# sourceMappingURL=contracts.js.map
;// CONCATENATED MODULE: ./node_modules/dnd-core/dist/interfaces.js
var HandlerRole;
(function(HandlerRole) {
    HandlerRole["SOURCE"] = "SOURCE";
    HandlerRole["TARGET"] = "TARGET";
})(HandlerRole || (HandlerRole = {}));

//# sourceMappingURL=interfaces.js.map
;// CONCATENATED MODULE: ./node_modules/dnd-core/dist/utils/getNextUniqueId.js
let nextUniqueId = 0;
function getNextUniqueId() {
    return nextUniqueId++;
}

//# sourceMappingURL=getNextUniqueId.js.map
;// CONCATENATED MODULE: ./node_modules/dnd-core/dist/classes/HandlerRegistryImpl.js






function getNextHandlerId(role) {
    const id = getNextUniqueId().toString();
    switch(role){
        case HandlerRole.SOURCE:
            return `S${id}`;
        case HandlerRole.TARGET:
            return `T${id}`;
        default:
            throw new Error(`Unknown Handler Role: ${role}`);
    }
}
function parseRoleFromHandlerId(handlerId) {
    switch(handlerId[0]){
        case 'S':
            return HandlerRole.SOURCE;
        case 'T':
            return HandlerRole.TARGET;
        default:
            throw new Error(`Cannot parse handler ID: ${handlerId}`);
    }
}
function mapContainsValue(map, searchValue) {
    const entries = map.entries();
    let isDone = false;
    do {
        const { done , value: [, value] ,  } = entries.next();
        if (value === searchValue) {
            return true;
        }
        isDone = !!done;
    }while (!isDone)
    return false;
}
class HandlerRegistryImpl {
    addSource(type, source) {
        validateType(type);
        validateSourceContract(source);
        const sourceId = this.addHandler(HandlerRole.SOURCE, type, source);
        this.store.dispatch(addSource(sourceId));
        return sourceId;
    }
    addTarget(type, target) {
        validateType(type, true);
        validateTargetContract(target);
        const targetId = this.addHandler(HandlerRole.TARGET, type, target);
        this.store.dispatch(addTarget(targetId));
        return targetId;
    }
    containsHandler(handler) {
        return mapContainsValue(this.dragSources, handler) || mapContainsValue(this.dropTargets, handler);
    }
    getSource(sourceId, includePinned = false) {
        invariant(this.isSourceId(sourceId), 'Expected a valid source ID.');
        const isPinned = includePinned && sourceId === this.pinnedSourceId;
        const source = isPinned ? this.pinnedSource : this.dragSources.get(sourceId);
        return source;
    }
    getTarget(targetId) {
        invariant(this.isTargetId(targetId), 'Expected a valid target ID.');
        return this.dropTargets.get(targetId);
    }
    getSourceType(sourceId) {
        invariant(this.isSourceId(sourceId), 'Expected a valid source ID.');
        return this.types.get(sourceId);
    }
    getTargetType(targetId) {
        invariant(this.isTargetId(targetId), 'Expected a valid target ID.');
        return this.types.get(targetId);
    }
    isSourceId(handlerId) {
        const role = parseRoleFromHandlerId(handlerId);
        return role === HandlerRole.SOURCE;
    }
    isTargetId(handlerId) {
        const role = parseRoleFromHandlerId(handlerId);
        return role === HandlerRole.TARGET;
    }
    removeSource(sourceId) {
        invariant(this.getSource(sourceId), 'Expected an existing source.');
        this.store.dispatch(removeSource(sourceId));
        asap(()=>{
            this.dragSources.delete(sourceId);
            this.types.delete(sourceId);
        });
    }
    removeTarget(targetId) {
        invariant(this.getTarget(targetId), 'Expected an existing target.');
        this.store.dispatch(removeTarget(targetId));
        this.dropTargets.delete(targetId);
        this.types.delete(targetId);
    }
    pinSource(sourceId) {
        const source = this.getSource(sourceId);
        invariant(source, 'Expected an existing source.');
        this.pinnedSourceId = sourceId;
        this.pinnedSource = source;
    }
    unpinSource() {
        invariant(this.pinnedSource, 'No source is pinned at the time.');
        this.pinnedSourceId = null;
        this.pinnedSource = null;
    }
    addHandler(role, type, handler) {
        const id = getNextHandlerId(role);
        this.types.set(id, type);
        if (role === HandlerRole.SOURCE) {
            this.dragSources.set(id, handler);
        } else if (role === HandlerRole.TARGET) {
            this.dropTargets.set(id, handler);
        }
        return id;
    }
    constructor(store){
        this.types = new Map();
        this.dragSources = new Map();
        this.dropTargets = new Map();
        this.pinnedSourceId = null;
        this.pinnedSource = null;
        this.store = store;
    }
}

//# sourceMappingURL=HandlerRegistryImpl.js.map
;// CONCATENATED MODULE: ./node_modules/dnd-core/dist/utils/equality.js
const strictEquality = (a, b)=>a === b
;
/**
 * Determine if two cartesian coordinate offsets are equal
 * @param offsetA
 * @param offsetB
 */ function areCoordsEqual(offsetA, offsetB) {
    if (!offsetA && !offsetB) {
        return true;
    } else if (!offsetA || !offsetB) {
        return false;
    } else {
        return offsetA.x === offsetB.x && offsetA.y === offsetB.y;
    }
}
/**
 * Determines if two arrays of items are equal
 * @param a The first array of items
 * @param b The second array of items
 */ function areArraysEqual(a, b, isEqual = strictEquality) {
    if (a.length !== b.length) {
        return false;
    }
    for(let i = 0; i < a.length; ++i){
        if (!isEqual(a[i], b[i])) {
            return false;
        }
    }
    return true;
}

//# sourceMappingURL=equality.js.map
;// CONCATENATED MODULE: ./node_modules/dnd-core/dist/reducers/dirtyHandlerIds.js





function reduce(// eslint-disable-next-line @typescript-eslint/no-unused-vars
_state = NONE, action) {
    switch(action.type){
        case HOVER:
            break;
        case ADD_SOURCE:
        case ADD_TARGET:
        case REMOVE_TARGET:
        case REMOVE_SOURCE:
            return NONE;
        case BEGIN_DRAG:
        case PUBLISH_DRAG_SOURCE:
        case END_DRAG:
        case DROP:
        default:
            return ALL;
    }
    const { targetIds =[] , prevTargetIds =[]  } = action.payload;
    const result = xor(targetIds, prevTargetIds);
    const didChange = result.length > 0 || !areArraysEqual(targetIds, prevTargetIds);
    if (!didChange) {
        return NONE;
    }
    // Check the target ids at the innermost position. If they are valid, add them
    // to the result
    const prevInnermostTargetId = prevTargetIds[prevTargetIds.length - 1];
    const innermostTargetId = targetIds[targetIds.length - 1];
    if (prevInnermostTargetId !== innermostTargetId) {
        if (prevInnermostTargetId) {
            result.push(prevInnermostTargetId);
        }
        if (innermostTargetId) {
            result.push(innermostTargetId);
        }
    }
    return result;
}

//# sourceMappingURL=dirtyHandlerIds.js.map
;// CONCATENATED MODULE: ./node_modules/dnd-core/dist/reducers/dragOffset.js
function dragOffset_defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
function dragOffset_objectSpread(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === 'function') {
            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
                return Object.getOwnPropertyDescriptor(source, sym).enumerable;
            }));
        }
        ownKeys.forEach(function(key) {
            dragOffset_defineProperty(target, key, source[key]);
        });
    }
    return target;
}


const initialState = {
    initialSourceClientOffset: null,
    initialClientOffset: null,
    clientOffset: null
};
function dragOffset_reduce(state = initialState, action) {
    const { payload  } = action;
    switch(action.type){
        case INIT_COORDS:
        case BEGIN_DRAG:
            return {
                initialSourceClientOffset: payload.sourceClientOffset,
                initialClientOffset: payload.clientOffset,
                clientOffset: payload.clientOffset
            };
        case HOVER:
            if (areCoordsEqual(state.clientOffset, payload.clientOffset)) {
                return state;
            }
            return dragOffset_objectSpread({}, state, {
                clientOffset: payload.clientOffset
            });
        case END_DRAG:
        case DROP:
            return initialState;
        default:
            return state;
    }
}

//# sourceMappingURL=dragOffset.js.map
;// CONCATENATED MODULE: ./node_modules/dnd-core/dist/reducers/dragOperation.js
function dragOperation_defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
function dragOperation_objectSpread(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === 'function') {
            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
                return Object.getOwnPropertyDescriptor(source, sym).enumerable;
            }));
        }
        ownKeys.forEach(function(key) {
            dragOperation_defineProperty(target, key, source[key]);
        });
    }
    return target;
}



const dragOperation_initialState = {
    itemType: null,
    item: null,
    sourceId: null,
    targetIds: [],
    dropResult: null,
    didDrop: false,
    isSourcePublic: null
};
function dragOperation_reduce(state = dragOperation_initialState, action) {
    const { payload  } = action;
    switch(action.type){
        case BEGIN_DRAG:
            return dragOperation_objectSpread({}, state, {
                itemType: payload.itemType,
                item: payload.item,
                sourceId: payload.sourceId,
                isSourcePublic: payload.isSourcePublic,
                dropResult: null,
                didDrop: false
            });
        case PUBLISH_DRAG_SOURCE:
            return dragOperation_objectSpread({}, state, {
                isSourcePublic: true
            });
        case HOVER:
            return dragOperation_objectSpread({}, state, {
                targetIds: payload.targetIds
            });
        case REMOVE_TARGET:
            if (state.targetIds.indexOf(payload.targetId) === -1) {
                return state;
            }
            return dragOperation_objectSpread({}, state, {
                targetIds: without(state.targetIds, payload.targetId)
            });
        case DROP:
            return dragOperation_objectSpread({}, state, {
                dropResult: payload.dropResult,
                didDrop: true,
                targetIds: []
            });
        case END_DRAG:
            return dragOperation_objectSpread({}, state, {
                itemType: null,
                item: null,
                sourceId: null,
                dropResult: null,
                didDrop: false,
                isSourcePublic: null,
                targetIds: []
            });
        default:
            return state;
    }
}

//# sourceMappingURL=dragOperation.js.map
;// CONCATENATED MODULE: ./node_modules/dnd-core/dist/reducers/refCount.js

function refCount_reduce(state = 0, action) {
    switch(action.type){
        case ADD_SOURCE:
        case ADD_TARGET:
            return state + 1;
        case REMOVE_SOURCE:
        case REMOVE_TARGET:
            return state - 1;
        default:
            return state;
    }
}

//# sourceMappingURL=refCount.js.map
;// CONCATENATED MODULE: ./node_modules/dnd-core/dist/reducers/stateId.js
function stateId_reduce(state = 0) {
    return state + 1;
}

//# sourceMappingURL=stateId.js.map
;// CONCATENATED MODULE: ./node_modules/dnd-core/dist/reducers/index.js
function reducers_defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
function reducers_objectSpread(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === 'function') {
            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
                return Object.getOwnPropertyDescriptor(source, sym).enumerable;
            }));
        }
        ownKeys.forEach(function(key) {
            reducers_defineProperty(target, key, source[key]);
        });
    }
    return target;
}






function reducers_reduce(state = {}, action) {
    return {
        dirtyHandlerIds: reduce(state.dirtyHandlerIds, {
            type: action.type,
            payload: reducers_objectSpread({}, action.payload, {
                prevTargetIds: get(state, 'dragOperation.targetIds', [])
            })
        }),
        dragOffset: dragOffset_reduce(state.dragOffset, action),
        refCount: refCount_reduce(state.refCount, action),
        dragOperation: dragOperation_reduce(state.dragOperation, action),
        stateId: stateId_reduce(state.stateId)
    };
}

//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/dnd-core/dist/createDragDropManager.js





function createDragDropManager(backendFactory, globalContext = undefined, backendOptions = {}, debugMode = false) {
    const store = makeStoreInstance(debugMode);
    const monitor = new DragDropMonitorImpl(store, new HandlerRegistryImpl(store));
    const manager = new DragDropManagerImpl(store, monitor);
    const backend = backendFactory(manager, globalContext, backendOptions);
    manager.receiveBackend(backend);
    return manager;
}
function makeStoreInstance(debugMode) {
    // TODO: if we ever make a react-native version of this,
    // we'll need to consider how to pull off dev-tooling
    const reduxDevTools = typeof window !== 'undefined' && window.__REDUX_DEVTOOLS_EXTENSION__;
    return createStore(reducers_reduce, debugMode && reduxDevTools && reduxDevTools({
        name: 'dnd-core',
        instanceId: 'dnd-core'
    }));
}

//# sourceMappingURL=createDragDropManager.js.map
;// CONCATENATED MODULE: ./node_modules/react-dnd/dist/core/DndProvider.js
function _objectWithoutProperties(source, excluded) {
    if (source == null) return {};
    var target = _objectWithoutPropertiesLoose(source, excluded);
    var key, i;
    if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
        for(i = 0; i < sourceSymbolKeys.length; i++){
            key = sourceSymbolKeys[i];
            if (excluded.indexOf(key) >= 0) continue;
            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
            target[key] = source[key];
        }
    }
    return target;
}
function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for(i = 0; i < sourceKeys.length; i++){
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        target[key] = source[key];
    }
    return target;
}




let refCount = 0;
const INSTANCE_SYM = Symbol.for('__REACT_DND_CONTEXT_INSTANCE__');
var DndProvider = /*#__PURE__*/ (0,react.memo)(function DndProvider(_param) {
    var { children  } = _param, props = _objectWithoutProperties(_param, [
        "children"
    ]);
    const [manager, isGlobalInstance] = getDndContextValue(props) // memoized from props
    ;
    /**
		 * If the global context was used to store the DND context
		 * then where theres no more references to it we should
		 * clean it up to avoid memory leaks
		 */ (0,react.useEffect)(()=>{
        if (isGlobalInstance) {
            const context = getGlobalContext();
            ++refCount;
            return ()=>{
                if (--refCount === 0) {
                    context[INSTANCE_SYM] = null;
                }
            };
        }
        return;
    }, []);
    return /*#__PURE__*/ (0,jsx_runtime.jsx)(DndContext.Provider, {
        value: manager,
        children: children
    });
});
/**
 * A React component that provides the React-DnD context
 */ 
function getDndContextValue(props) {
    if ('manager' in props) {
        const manager = {
            dragDropManager: props.manager
        };
        return [
            manager,
            false
        ];
    }
    const manager = createSingletonDndContext(props.backend, props.context, props.options, props.debugMode);
    const isGlobalInstance = !props.context;
    return [
        manager,
        isGlobalInstance
    ];
}
function createSingletonDndContext(backend, context = getGlobalContext(), options, debugMode) {
    const ctx = context;
    if (!ctx[INSTANCE_SYM]) {
        ctx[INSTANCE_SYM] = {
            dragDropManager: createDragDropManager(backend, context, options, debugMode)
        };
    }
    return ctx[INSTANCE_SYM];
}
function getGlobalContext() {
    return typeof global !== 'undefined' ? global : window;
}

//# sourceMappingURL=DndProvider.js.map
;// CONCATENATED MODULE: ./node_modules/react-dnd/dist/core/DragPreviewImage.js

/**
 * A utility for rendering a drag preview image
 */ const DragPreviewImage = (0,react.memo)(function DragPreviewImage({ connect , src  }) {
    (0,react.useEffect)(()=>{
        if (typeof Image === 'undefined') return;
        let connected = false;
        const img = new Image();
        img.src = src;
        img.onload = ()=>{
            connect(img);
            connected = true;
        };
        return ()=>{
            if (connected) {
                connect(null);
            }
        };
    });
    return null;
});

//# sourceMappingURL=DragPreviewImage.js.map
;// CONCATENATED MODULE: ./node_modules/react-dnd/dist/core/index.js




//# sourceMappingURL=index.js.map
// EXTERNAL MODULE: ./node_modules/fast-deep-equal/index.js
var fast_deep_equal = __webpack_require__(7429);
;// CONCATENATED MODULE: ./node_modules/react-dnd/dist/hooks/useIsomorphicLayoutEffect.js

// suppress the useLayoutEffect warning on server side.
const useIsomorphicLayoutEffect = typeof window !== 'undefined' ? react.useLayoutEffect : react.useEffect;

//# sourceMappingURL=useIsomorphicLayoutEffect.js.map
;// CONCATENATED MODULE: ./node_modules/react-dnd/dist/hooks/useCollector.js



/**
 *
 * @param monitor The monitor to collect state from
 * @param collect The collecting function
 * @param onUpdate A method to invoke when updates occur
 */ function useCollector(monitor, collect, onUpdate) {
    const [collected, setCollected] = (0,react.useState)(()=>collect(monitor)
    );
    const updateCollected = (0,react.useCallback)(()=>{
        const nextValue = collect(monitor);
        // This needs to be a deep-equality check because some monitor-collected values
        // include XYCoord objects that may be equivalent, but do not have instance equality.
        if (!fast_deep_equal(collected, nextValue)) {
            setCollected(nextValue);
            if (onUpdate) {
                onUpdate();
            }
        }
    }, [
        collected,
        monitor,
        onUpdate
    ]);
    // update the collected properties after react renders.
    // Note that the "Dustbin Stress Test" fails if this is not
    // done when the component updates
    useIsomorphicLayoutEffect(updateCollected);
    return [
        collected,
        updateCollected
    ];
}

//# sourceMappingURL=useCollector.js.map
;// CONCATENATED MODULE: ./node_modules/react-dnd/dist/hooks/useMonitorOutput.js


function useMonitorOutput(monitor, collect, onCollect) {
    const [collected, updateCollected] = useCollector(monitor, collect, onCollect);
    useIsomorphicLayoutEffect(function subscribeToMonitorStateChange() {
        const handlerId = monitor.getHandlerId();
        if (handlerId == null) {
            return;
        }
        return monitor.subscribeToStateChange(updateCollected, {
            handlerIds: [
                handlerId
            ]
        });
    }, [
        monitor,
        updateCollected
    ]);
    return collected;
}

//# sourceMappingURL=useMonitorOutput.js.map
;// CONCATENATED MODULE: ./node_modules/react-dnd/dist/hooks/useCollectedProps.js

function useCollectedProps(collector, monitor, connector) {
    return useMonitorOutput(monitor, collector || (()=>({})
    ), ()=>connector.reconnect()
    );
}

//# sourceMappingURL=useCollectedProps.js.map
;// CONCATENATED MODULE: ./node_modules/react-dnd/dist/hooks/useOptionalFactory.js

function useOptionalFactory(arg, deps) {
    const memoDeps = [
        ...deps || []
    ];
    if (deps == null && typeof arg !== 'function') {
        memoDeps.push(arg);
    }
    return (0,react.useMemo)(()=>{
        return typeof arg === 'function' ? arg() : arg;
    }, memoDeps);
}

//# sourceMappingURL=useOptionalFactory.js.map
;// CONCATENATED MODULE: ./node_modules/react-dnd/dist/hooks/useDrag/connectors.js

function useConnectDragSource(connector) {
    return (0,react.useMemo)(()=>connector.hooks.dragSource()
    , [
        connector
    ]);
}
function useConnectDragPreview(connector) {
    return (0,react.useMemo)(()=>connector.hooks.dragPreview()
    , [
        connector
    ]);
}

//# sourceMappingURL=connectors.js.map
;// CONCATENATED MODULE: ./node_modules/@react-dnd/shallowequal/dist/index.js
function shallowEqual(objA, objB, compare, compareContext) {
    let compareResult = compare ? compare.call(compareContext, objA, objB) : void 0;
    if (compareResult !== void 0) {
        return !!compareResult;
    }
    if (objA === objB) {
        return true;
    }
    if (typeof objA !== 'object' || !objA || typeof objB !== 'object' || !objB) {
        return false;
    }
    const keysA = Object.keys(objA);
    const keysB = Object.keys(objB);
    if (keysA.length !== keysB.length) {
        return false;
    }
    const bHasOwnProperty = Object.prototype.hasOwnProperty.bind(objB);
    // Test for A's keys different from B.
    for(let idx = 0; idx < keysA.length; idx++){
        const key = keysA[idx];
        if (!bHasOwnProperty(key)) {
            return false;
        }
        const valueA = objA[key];
        const valueB = objB[key];
        compareResult = compare ? compare.call(compareContext, valueA, valueB, key) : void 0;
        if (compareResult === false || compareResult === void 0 && valueA !== valueB) {
            return false;
        }
    }
    return true;
}

//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/react-dnd/dist/internals/isRef.js
function isRef(obj) {
    return(// eslint-disable-next-line no-prototype-builtins
    obj !== null && typeof obj === 'object' && Object.prototype.hasOwnProperty.call(obj, 'current'));
}

//# sourceMappingURL=isRef.js.map
;// CONCATENATED MODULE: ./node_modules/react-dnd/dist/internals/wrapConnectorHooks.js


function throwIfCompositeComponentElement(element) {
    // Custom components can no longer be wrapped directly in React DnD 2.0
    // so that we don't need to depend on findDOMNode() from react-dom.
    if (typeof element.type === 'string') {
        return;
    }
    const displayName = element.type.displayName || element.type.name || 'the component';
    throw new Error('Only native element nodes can now be passed to React DnD connectors.' + `You can either wrap ${displayName} into a <div>, or turn it into a ` + 'drag source or a drop target itself.');
}
function wrapHookToRecognizeElement(hook) {
    return (elementOrNode = null, options = null)=>{
        // When passed a node, call the hook straight away.
        if (!(0,react.isValidElement)(elementOrNode)) {
            const node = elementOrNode;
            hook(node, options);
            // return the node so it can be chained (e.g. when within callback refs
            // <div ref={node => connectDragSource(connectDropTarget(node))}/>
            return node;
        }
        // If passed a ReactElement, clone it and attach this function as a ref.
        // This helps us achieve a neat API where user doesn't even know that refs
        // are being used under the hood.
        const element = elementOrNode;
        throwIfCompositeComponentElement(element);
        // When no options are passed, use the hook directly
        const ref = options ? (node)=>hook(node, options)
         : hook;
        return cloneWithRef(element, ref);
    };
}
function wrapConnectorHooks(hooks) {
    const wrappedHooks = {};
    Object.keys(hooks).forEach((key)=>{
        const hook = hooks[key];
        // ref objects should be passed straight through without wrapping
        if (key.endsWith('Ref')) {
            wrappedHooks[key] = hooks[key];
        } else {
            const wrappedHook = wrapHookToRecognizeElement(hook);
            wrappedHooks[key] = ()=>wrappedHook
            ;
        }
    });
    return wrappedHooks;
}
function setRef(ref, node) {
    if (typeof ref === 'function') {
        ref(node);
    } else {
        ref.current = node;
    }
}
function cloneWithRef(element, newRef) {
    const previousRef = element.ref;
    invariant(typeof previousRef !== 'string', 'Cannot connect React DnD to an element with an existing string ref. ' + 'Please convert it to use a callback ref instead, or wrap it into a <span> or <div>. ' + 'Read more: https://reactjs.org/docs/refs-and-the-dom.html#callback-refs');
    if (!previousRef) {
        // When there is no ref on the element, use the new ref directly
        return (0,react.cloneElement)(element, {
            ref: newRef
        });
    } else {
        return (0,react.cloneElement)(element, {
            ref: (node)=>{
                setRef(previousRef, node);
                setRef(newRef, node);
            }
        });
    }
}

//# sourceMappingURL=wrapConnectorHooks.js.map
;// CONCATENATED MODULE: ./node_modules/react-dnd/dist/internals/SourceConnector.js



class SourceConnector {
    receiveHandlerId(newHandlerId) {
        if (this.handlerId === newHandlerId) {
            return;
        }
        this.handlerId = newHandlerId;
        this.reconnect();
    }
    get connectTarget() {
        return this.dragSource;
    }
    get dragSourceOptions() {
        return this.dragSourceOptionsInternal;
    }
    set dragSourceOptions(options) {
        this.dragSourceOptionsInternal = options;
    }
    get dragPreviewOptions() {
        return this.dragPreviewOptionsInternal;
    }
    set dragPreviewOptions(options) {
        this.dragPreviewOptionsInternal = options;
    }
    reconnect() {
        const didChange = this.reconnectDragSource();
        this.reconnectDragPreview(didChange);
    }
    reconnectDragSource() {
        const dragSource = this.dragSource;
        // if nothing has changed then don't resubscribe
        const didChange = this.didHandlerIdChange() || this.didConnectedDragSourceChange() || this.didDragSourceOptionsChange();
        if (didChange) {
            this.disconnectDragSource();
        }
        if (!this.handlerId) {
            return didChange;
        }
        if (!dragSource) {
            this.lastConnectedDragSource = dragSource;
            return didChange;
        }
        if (didChange) {
            this.lastConnectedHandlerId = this.handlerId;
            this.lastConnectedDragSource = dragSource;
            this.lastConnectedDragSourceOptions = this.dragSourceOptions;
            this.dragSourceUnsubscribe = this.backend.connectDragSource(this.handlerId, dragSource, this.dragSourceOptions);
        }
        return didChange;
    }
    reconnectDragPreview(forceDidChange = false) {
        const dragPreview = this.dragPreview;
        // if nothing has changed then don't resubscribe
        const didChange = forceDidChange || this.didHandlerIdChange() || this.didConnectedDragPreviewChange() || this.didDragPreviewOptionsChange();
        if (didChange) {
            this.disconnectDragPreview();
        }
        if (!this.handlerId) {
            return;
        }
        if (!dragPreview) {
            this.lastConnectedDragPreview = dragPreview;
            return;
        }
        if (didChange) {
            this.lastConnectedHandlerId = this.handlerId;
            this.lastConnectedDragPreview = dragPreview;
            this.lastConnectedDragPreviewOptions = this.dragPreviewOptions;
            this.dragPreviewUnsubscribe = this.backend.connectDragPreview(this.handlerId, dragPreview, this.dragPreviewOptions);
        }
    }
    didHandlerIdChange() {
        return this.lastConnectedHandlerId !== this.handlerId;
    }
    didConnectedDragSourceChange() {
        return this.lastConnectedDragSource !== this.dragSource;
    }
    didConnectedDragPreviewChange() {
        return this.lastConnectedDragPreview !== this.dragPreview;
    }
    didDragSourceOptionsChange() {
        return !shallowEqual(this.lastConnectedDragSourceOptions, this.dragSourceOptions);
    }
    didDragPreviewOptionsChange() {
        return !shallowEqual(this.lastConnectedDragPreviewOptions, this.dragPreviewOptions);
    }
    disconnectDragSource() {
        if (this.dragSourceUnsubscribe) {
            this.dragSourceUnsubscribe();
            this.dragSourceUnsubscribe = undefined;
        }
    }
    disconnectDragPreview() {
        if (this.dragPreviewUnsubscribe) {
            this.dragPreviewUnsubscribe();
            this.dragPreviewUnsubscribe = undefined;
            this.dragPreviewNode = null;
            this.dragPreviewRef = null;
        }
    }
    get dragSource() {
        return this.dragSourceNode || this.dragSourceRef && this.dragSourceRef.current;
    }
    get dragPreview() {
        return this.dragPreviewNode || this.dragPreviewRef && this.dragPreviewRef.current;
    }
    clearDragSource() {
        this.dragSourceNode = null;
        this.dragSourceRef = null;
    }
    clearDragPreview() {
        this.dragPreviewNode = null;
        this.dragPreviewRef = null;
    }
    constructor(backend){
        this.hooks = wrapConnectorHooks({
            dragSource: (node, options)=>{
                this.clearDragSource();
                this.dragSourceOptions = options || null;
                if (isRef(node)) {
                    this.dragSourceRef = node;
                } else {
                    this.dragSourceNode = node;
                }
                this.reconnectDragSource();
            },
            dragPreview: (node, options)=>{
                this.clearDragPreview();
                this.dragPreviewOptions = options || null;
                if (isRef(node)) {
                    this.dragPreviewRef = node;
                } else {
                    this.dragPreviewNode = node;
                }
                this.reconnectDragPreview();
            }
        });
        this.handlerId = null;
        // The drop target may either be attached via ref or connect function
        this.dragSourceRef = null;
        this.dragSourceOptionsInternal = null;
        // The drag preview may either be attached via ref or connect function
        this.dragPreviewRef = null;
        this.dragPreviewOptionsInternal = null;
        this.lastConnectedHandlerId = null;
        this.lastConnectedDragSource = null;
        this.lastConnectedDragSourceOptions = null;
        this.lastConnectedDragPreview = null;
        this.lastConnectedDragPreviewOptions = null;
        this.backend = backend;
    }
}

//# sourceMappingURL=SourceConnector.js.map
;// CONCATENATED MODULE: ./node_modules/react-dnd/dist/hooks/useDragDropManager.js



/**
 * A hook to retrieve the DragDropManager from Context
 */ function useDragDropManager() {
    const { dragDropManager  } = (0,react.useContext)(DndContext);
    invariant(dragDropManager != null, 'Expected drag drop context');
    return dragDropManager;
}

//# sourceMappingURL=useDragDropManager.js.map
;// CONCATENATED MODULE: ./node_modules/react-dnd/dist/hooks/useDrag/useDragSourceConnector.js




function useDragSourceConnector(dragSourceOptions, dragPreviewOptions) {
    const manager = useDragDropManager();
    const connector = (0,react.useMemo)(()=>new SourceConnector(manager.getBackend())
    , [
        manager
    ]);
    useIsomorphicLayoutEffect(()=>{
        connector.dragSourceOptions = dragSourceOptions || null;
        connector.reconnect();
        return ()=>connector.disconnectDragSource()
        ;
    }, [
        connector,
        dragSourceOptions
    ]);
    useIsomorphicLayoutEffect(()=>{
        connector.dragPreviewOptions = dragPreviewOptions || null;
        connector.reconnect();
        return ()=>connector.disconnectDragPreview()
        ;
    }, [
        connector,
        dragPreviewOptions
    ]);
    return connector;
}

//# sourceMappingURL=useDragSourceConnector.js.map
;// CONCATENATED MODULE: ./node_modules/react-dnd/dist/internals/DragSourceMonitorImpl.js

let isCallingCanDrag = false;
let isCallingIsDragging = false;
class DragSourceMonitorImpl {
    receiveHandlerId(sourceId) {
        this.sourceId = sourceId;
    }
    getHandlerId() {
        return this.sourceId;
    }
    canDrag() {
        invariant(!isCallingCanDrag, 'You may not call monitor.canDrag() inside your canDrag() implementation. ' + 'Read more: http://react-dnd.github.io/react-dnd/docs/api/drag-source-monitor');
        try {
            isCallingCanDrag = true;
            return this.internalMonitor.canDragSource(this.sourceId);
        } finally{
            isCallingCanDrag = false;
        }
    }
    isDragging() {
        if (!this.sourceId) {
            return false;
        }
        invariant(!isCallingIsDragging, 'You may not call monitor.isDragging() inside your isDragging() implementation. ' + 'Read more: http://react-dnd.github.io/react-dnd/docs/api/drag-source-monitor');
        try {
            isCallingIsDragging = true;
            return this.internalMonitor.isDraggingSource(this.sourceId);
        } finally{
            isCallingIsDragging = false;
        }
    }
    subscribeToStateChange(listener, options) {
        return this.internalMonitor.subscribeToStateChange(listener, options);
    }
    isDraggingSource(sourceId) {
        return this.internalMonitor.isDraggingSource(sourceId);
    }
    isOverTarget(targetId, options) {
        return this.internalMonitor.isOverTarget(targetId, options);
    }
    getTargetIds() {
        return this.internalMonitor.getTargetIds();
    }
    isSourcePublic() {
        return this.internalMonitor.isSourcePublic();
    }
    getSourceId() {
        return this.internalMonitor.getSourceId();
    }
    subscribeToOffsetChange(listener) {
        return this.internalMonitor.subscribeToOffsetChange(listener);
    }
    canDragSource(sourceId) {
        return this.internalMonitor.canDragSource(sourceId);
    }
    canDropOnTarget(targetId) {
        return this.internalMonitor.canDropOnTarget(targetId);
    }
    getItemType() {
        return this.internalMonitor.getItemType();
    }
    getItem() {
        return this.internalMonitor.getItem();
    }
    getDropResult() {
        return this.internalMonitor.getDropResult();
    }
    didDrop() {
        return this.internalMonitor.didDrop();
    }
    getInitialClientOffset() {
        return this.internalMonitor.getInitialClientOffset();
    }
    getInitialSourceClientOffset() {
        return this.internalMonitor.getInitialSourceClientOffset();
    }
    getSourceClientOffset() {
        return this.internalMonitor.getSourceClientOffset();
    }
    getClientOffset() {
        return this.internalMonitor.getClientOffset();
    }
    getDifferenceFromInitialOffset() {
        return this.internalMonitor.getDifferenceFromInitialOffset();
    }
    constructor(manager){
        this.sourceId = null;
        this.internalMonitor = manager.getMonitor();
    }
}

//# sourceMappingURL=DragSourceMonitorImpl.js.map
;// CONCATENATED MODULE: ./node_modules/react-dnd/dist/hooks/useDrag/useDragSourceMonitor.js



function useDragSourceMonitor() {
    const manager = useDragDropManager();
    return (0,react.useMemo)(()=>new DragSourceMonitorImpl(manager)
    , [
        manager
    ]);
}

//# sourceMappingURL=useDragSourceMonitor.js.map
;// CONCATENATED MODULE: ./node_modules/react-dnd/dist/internals/registration.js
function registerTarget(type, target, manager) {
    const registry = manager.getRegistry();
    const targetId = registry.addTarget(type, target);
    return [
        targetId,
        ()=>registry.removeTarget(targetId)
    ];
}
function registerSource(type, source, manager) {
    const registry = manager.getRegistry();
    const sourceId = registry.addSource(type, source);
    return [
        sourceId,
        ()=>registry.removeSource(sourceId)
    ];
}

//# sourceMappingURL=registration.js.map
;// CONCATENATED MODULE: ./node_modules/react-dnd/dist/hooks/useDrag/DragSourceImpl.js
class DragSourceImpl {
    beginDrag() {
        const spec = this.spec;
        const monitor = this.monitor;
        let result = null;
        if (typeof spec.item === 'object') {
            result = spec.item;
        } else if (typeof spec.item === 'function') {
            result = spec.item(monitor);
        } else {
            result = {};
        }
        return result !== null && result !== void 0 ? result : null;
    }
    canDrag() {
        const spec = this.spec;
        const monitor = this.monitor;
        if (typeof spec.canDrag === 'boolean') {
            return spec.canDrag;
        } else if (typeof spec.canDrag === 'function') {
            return spec.canDrag(monitor);
        } else {
            return true;
        }
    }
    isDragging(globalMonitor, target) {
        const spec = this.spec;
        const monitor = this.monitor;
        const { isDragging  } = spec;
        return isDragging ? isDragging(monitor) : target === globalMonitor.getSourceId();
    }
    endDrag() {
        const spec = this.spec;
        const monitor = this.monitor;
        const connector = this.connector;
        const { end  } = spec;
        if (end) {
            end(monitor.getItem(), monitor);
        }
        connector.reconnect();
    }
    constructor(spec, monitor, connector){
        this.spec = spec;
        this.monitor = monitor;
        this.connector = connector;
    }
}

//# sourceMappingURL=DragSourceImpl.js.map
;// CONCATENATED MODULE: ./node_modules/react-dnd/dist/hooks/useDrag/useDragSource.js


function useDragSource(spec, monitor, connector) {
    const handler = (0,react.useMemo)(()=>new DragSourceImpl(spec, monitor, connector)
    , [
        monitor,
        connector
    ]);
    (0,react.useEffect)(()=>{
        handler.spec = spec;
    }, [
        spec
    ]);
    return handler;
}

//# sourceMappingURL=useDragSource.js.map
;// CONCATENATED MODULE: ./node_modules/react-dnd/dist/hooks/useDrag/useDragType.js


function useDragType(spec) {
    return (0,react.useMemo)(()=>{
        const result = spec.type;
        invariant(result != null, 'spec.type must be defined');
        return result;
    }, [
        spec
    ]);
}

//# sourceMappingURL=useDragType.js.map
;// CONCATENATED MODULE: ./node_modules/react-dnd/dist/hooks/useDrag/useRegisteredDragSource.js





function useRegisteredDragSource(spec, monitor, connector) {
    const manager = useDragDropManager();
    const handler = useDragSource(spec, monitor, connector);
    const itemType = useDragType(spec);
    useIsomorphicLayoutEffect(function registerDragSource() {
        if (itemType != null) {
            const [handlerId, unregister] = registerSource(itemType, handler, manager);
            monitor.receiveHandlerId(handlerId);
            connector.receiveHandlerId(handlerId);
            return unregister;
        }
        return;
    }, [
        manager,
        monitor,
        connector,
        handler,
        itemType
    ]);
}

//# sourceMappingURL=useRegisteredDragSource.js.map
;// CONCATENATED MODULE: ./node_modules/react-dnd/dist/hooks/useDrag/useDrag.js







/**
 * useDragSource hook
 * @param sourceSpec The drag source specification (object or function, function preferred)
 * @param deps The memoization deps array to use when evaluating spec changes
 */ function useDrag(specArg, deps) {
    const spec = useOptionalFactory(specArg, deps);
    invariant(!spec.begin, `useDrag::spec.begin was deprecated in v14. Replace spec.begin() with spec.item(). (see more here - https://react-dnd.github.io/react-dnd/docs/api/use-drag)`);
    const monitor = useDragSourceMonitor();
    const connector = useDragSourceConnector(spec.options, spec.previewOptions);
    useRegisteredDragSource(spec, monitor, connector);
    return [
        useCollectedProps(spec.collect, monitor, connector),
        useConnectDragSource(connector),
        useConnectDragPreview(connector), 
    ];
}

//# sourceMappingURL=useDrag.js.map
;// CONCATENATED MODULE: ./node_modules/react-dnd/dist/hooks/useDrag/index.js


//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/react-dnd/dist/hooks/useDragLayer.js



/**
 * useDragLayer Hook
 * @param collector The property collector
 */ function useDragLayer(collect) {
    const dragDropManager = useDragDropManager();
    const monitor = dragDropManager.getMonitor();
    const [collected, updateCollected] = useCollector(monitor, collect);
    (0,react.useEffect)(()=>monitor.subscribeToOffsetChange(updateCollected)
    );
    (0,react.useEffect)(()=>monitor.subscribeToStateChange(updateCollected)
    );
    return collected;
}

//# sourceMappingURL=useDragLayer.js.map
;// CONCATENATED MODULE: ./node_modules/react-dnd/dist/hooks/useDrop/connectors.js

function useConnectDropTarget(connector) {
    return (0,react.useMemo)(()=>connector.hooks.dropTarget()
    , [
        connector
    ]);
}

//# sourceMappingURL=connectors.js.map
;// CONCATENATED MODULE: ./node_modules/react-dnd/dist/internals/TargetConnector.js



class TargetConnector {
    get connectTarget() {
        return this.dropTarget;
    }
    reconnect() {
        // if nothing has changed then don't resubscribe
        const didChange = this.didHandlerIdChange() || this.didDropTargetChange() || this.didOptionsChange();
        if (didChange) {
            this.disconnectDropTarget();
        }
        const dropTarget = this.dropTarget;
        if (!this.handlerId) {
            return;
        }
        if (!dropTarget) {
            this.lastConnectedDropTarget = dropTarget;
            return;
        }
        if (didChange) {
            this.lastConnectedHandlerId = this.handlerId;
            this.lastConnectedDropTarget = dropTarget;
            this.lastConnectedDropTargetOptions = this.dropTargetOptions;
            this.unsubscribeDropTarget = this.backend.connectDropTarget(this.handlerId, dropTarget, this.dropTargetOptions);
        }
    }
    receiveHandlerId(newHandlerId) {
        if (newHandlerId === this.handlerId) {
            return;
        }
        this.handlerId = newHandlerId;
        this.reconnect();
    }
    get dropTargetOptions() {
        return this.dropTargetOptionsInternal;
    }
    set dropTargetOptions(options) {
        this.dropTargetOptionsInternal = options;
    }
    didHandlerIdChange() {
        return this.lastConnectedHandlerId !== this.handlerId;
    }
    didDropTargetChange() {
        return this.lastConnectedDropTarget !== this.dropTarget;
    }
    didOptionsChange() {
        return !shallowEqual(this.lastConnectedDropTargetOptions, this.dropTargetOptions);
    }
    disconnectDropTarget() {
        if (this.unsubscribeDropTarget) {
            this.unsubscribeDropTarget();
            this.unsubscribeDropTarget = undefined;
        }
    }
    get dropTarget() {
        return this.dropTargetNode || this.dropTargetRef && this.dropTargetRef.current;
    }
    clearDropTarget() {
        this.dropTargetRef = null;
        this.dropTargetNode = null;
    }
    constructor(backend){
        this.hooks = wrapConnectorHooks({
            dropTarget: (node, options)=>{
                this.clearDropTarget();
                this.dropTargetOptions = options;
                if (isRef(node)) {
                    this.dropTargetRef = node;
                } else {
                    this.dropTargetNode = node;
                }
                this.reconnect();
            }
        });
        this.handlerId = null;
        // The drop target may either be attached via ref or connect function
        this.dropTargetRef = null;
        this.dropTargetOptionsInternal = null;
        this.lastConnectedHandlerId = null;
        this.lastConnectedDropTarget = null;
        this.lastConnectedDropTargetOptions = null;
        this.backend = backend;
    }
}

//# sourceMappingURL=TargetConnector.js.map
;// CONCATENATED MODULE: ./node_modules/react-dnd/dist/hooks/useDrop/useDropTargetConnector.js




function useDropTargetConnector(options) {
    const manager = useDragDropManager();
    const connector = (0,react.useMemo)(()=>new TargetConnector(manager.getBackend())
    , [
        manager
    ]);
    useIsomorphicLayoutEffect(()=>{
        connector.dropTargetOptions = options || null;
        connector.reconnect();
        return ()=>connector.disconnectDropTarget()
        ;
    }, [
        options
    ]);
    return connector;
}

//# sourceMappingURL=useDropTargetConnector.js.map
;// CONCATENATED MODULE: ./node_modules/react-dnd/dist/internals/DropTargetMonitorImpl.js

let isCallingCanDrop = false;
class DropTargetMonitorImpl {
    receiveHandlerId(targetId) {
        this.targetId = targetId;
    }
    getHandlerId() {
        return this.targetId;
    }
    subscribeToStateChange(listener, options) {
        return this.internalMonitor.subscribeToStateChange(listener, options);
    }
    canDrop() {
        // Cut out early if the target id has not been set. This should prevent errors
        // where the user has an older version of dnd-core like in
        // https://github.com/react-dnd/react-dnd/issues/1310
        if (!this.targetId) {
            return false;
        }
        invariant(!isCallingCanDrop, 'You may not call monitor.canDrop() inside your canDrop() implementation. ' + 'Read more: http://react-dnd.github.io/react-dnd/docs/api/drop-target-monitor');
        try {
            isCallingCanDrop = true;
            return this.internalMonitor.canDropOnTarget(this.targetId);
        } finally{
            isCallingCanDrop = false;
        }
    }
    isOver(options) {
        if (!this.targetId) {
            return false;
        }
        return this.internalMonitor.isOverTarget(this.targetId, options);
    }
    getItemType() {
        return this.internalMonitor.getItemType();
    }
    getItem() {
        return this.internalMonitor.getItem();
    }
    getDropResult() {
        return this.internalMonitor.getDropResult();
    }
    didDrop() {
        return this.internalMonitor.didDrop();
    }
    getInitialClientOffset() {
        return this.internalMonitor.getInitialClientOffset();
    }
    getInitialSourceClientOffset() {
        return this.internalMonitor.getInitialSourceClientOffset();
    }
    getSourceClientOffset() {
        return this.internalMonitor.getSourceClientOffset();
    }
    getClientOffset() {
        return this.internalMonitor.getClientOffset();
    }
    getDifferenceFromInitialOffset() {
        return this.internalMonitor.getDifferenceFromInitialOffset();
    }
    constructor(manager){
        this.targetId = null;
        this.internalMonitor = manager.getMonitor();
    }
}

//# sourceMappingURL=DropTargetMonitorImpl.js.map
;// CONCATENATED MODULE: ./node_modules/react-dnd/dist/hooks/useDrop/useDropTargetMonitor.js



function useDropTargetMonitor() {
    const manager = useDragDropManager();
    return (0,react.useMemo)(()=>new DropTargetMonitorImpl(manager)
    , [
        manager
    ]);
}

//# sourceMappingURL=useDropTargetMonitor.js.map
;// CONCATENATED MODULE: ./node_modules/react-dnd/dist/hooks/useDrop/useAccept.js


/**
 * Internal utility hook to get an array-version of spec.accept.
 * The main utility here is that we aren't creating a new array on every render if a non-array spec.accept is passed in.
 * @param spec
 */ function useAccept(spec) {
    const { accept  } = spec;
    return (0,react.useMemo)(()=>{
        invariant(spec.accept != null, 'accept must be defined');
        return Array.isArray(accept) ? accept : [
            accept
        ];
    }, [
        accept
    ]);
}

//# sourceMappingURL=useAccept.js.map
;// CONCATENATED MODULE: ./node_modules/react-dnd/dist/hooks/useDrop/DropTargetImpl.js
class DropTargetImpl {
    canDrop() {
        const spec = this.spec;
        const monitor = this.monitor;
        return spec.canDrop ? spec.canDrop(monitor.getItem(), monitor) : true;
    }
    hover() {
        const spec = this.spec;
        const monitor = this.monitor;
        if (spec.hover) {
            spec.hover(monitor.getItem(), monitor);
        }
    }
    drop() {
        const spec = this.spec;
        const monitor = this.monitor;
        if (spec.drop) {
            return spec.drop(monitor.getItem(), monitor);
        }
        return;
    }
    constructor(spec, monitor){
        this.spec = spec;
        this.monitor = monitor;
    }
}

//# sourceMappingURL=DropTargetImpl.js.map
;// CONCATENATED MODULE: ./node_modules/react-dnd/dist/hooks/useDrop/useDropTarget.js


function useDropTarget(spec, monitor) {
    const dropTarget = (0,react.useMemo)(()=>new DropTargetImpl(spec, monitor)
    , [
        monitor
    ]);
    (0,react.useEffect)(()=>{
        dropTarget.spec = spec;
    }, [
        spec
    ]);
    return dropTarget;
}

//# sourceMappingURL=useDropTarget.js.map
;// CONCATENATED MODULE: ./node_modules/react-dnd/dist/hooks/useDrop/useRegisteredDropTarget.js





function useRegisteredDropTarget(spec, monitor, connector) {
    const manager = useDragDropManager();
    const dropTarget = useDropTarget(spec, monitor);
    const accept = useAccept(spec);
    useIsomorphicLayoutEffect(function registerDropTarget() {
        const [handlerId, unregister] = registerTarget(accept, dropTarget, manager);
        monitor.receiveHandlerId(handlerId);
        connector.receiveHandlerId(handlerId);
        return unregister;
    }, [
        manager,
        monitor,
        dropTarget,
        connector,
        accept.map((a)=>a.toString()
        ).join('|'), 
    ]);
}

//# sourceMappingURL=useRegisteredDropTarget.js.map
;// CONCATENATED MODULE: ./node_modules/react-dnd/dist/hooks/useDrop/useDrop.js






/**
 * useDropTarget Hook
 * @param spec The drop target specification (object or function, function preferred)
 * @param deps The memoization deps array to use when evaluating spec changes
 */ function useDrop(specArg, deps) {
    const spec = useOptionalFactory(specArg, deps);
    const monitor = useDropTargetMonitor();
    const connector = useDropTargetConnector(spec.options);
    useRegisteredDropTarget(spec, monitor, connector);
    return [
        useCollectedProps(spec.collect, monitor, connector),
        useConnectDropTarget(connector), 
    ];
}

//# sourceMappingURL=useDrop.js.map
;// CONCATENATED MODULE: ./node_modules/react-dnd/dist/hooks/useDrop/index.js


//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/react-dnd/dist/hooks/index.js






//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/react-dnd/dist/index.js




//# sourceMappingURL=index.js.map

/***/ }),

/***/ 1609:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "V": () => (/* binding */ StyleModule)
/* harmony export */ });
const C = "\u037c"
const COUNT = typeof Symbol == "undefined" ? "__" + C : Symbol.for(C)
const SET = typeof Symbol == "undefined" ? "__styleSet" + Math.floor(Math.random() * 1e8) : Symbol("styleSet")
const top = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : {}

// :: - Style modules encapsulate a set of CSS rules defined from
// JavaScript. Their definitions are only available in a given DOM
// root after it has been _mounted_ there with `StyleModule.mount`.
//
// Style modules should be created once and stored somewhere, as
// opposed to re-creating them every time you need them. The amount of
// CSS rules generated for a given DOM root is bounded by the amount
// of style modules that were used. So to avoid leaking rules, don't
// create these dynamically, but treat them as one-time allocations.
class StyleModule {
  // :: (Object<Style>, ?{finish: ?(string)  string})
  // Create a style module from the given spec.
  //
  // When `finish` is given, it is called on regular (non-`@`)
  // selectors (after `&` expansion) to compute the final selector.
  constructor(spec, options) {
    this.rules = []
    let {finish} = options || {}

    function splitSelector(selector) {
      return /^@/.test(selector) ? [selector] : selector.split(/,\s*/)
    }

    function render(selectors, spec, target, isKeyframes) {
      let local = [], isAt = /^@(\w+)\b/.exec(selectors[0]), keyframes = isAt && isAt[1] == "keyframes"
      if (isAt && spec == null) return target.push(selectors[0] + ";")
      for (let prop in spec) {
        let value = spec[prop]
        if (/&/.test(prop)) {
          render(prop.split(/,\s*/).map(part => selectors.map(sel => part.replace(/&/, sel))).reduce((a, b) => a.concat(b)),
                 value, target)
        } else if (value && typeof value == "object") {
          if (!isAt) throw new RangeError("The value of a property (" + prop + ") should be a primitive value.")
          render(splitSelector(prop), value, local, keyframes)
        } else if (value != null) {
          local.push(prop.replace(/_.*/, "").replace(/[A-Z]/g, l => "-" + l.toLowerCase()) + ": " + value + ";")
        }
      }
      if (local.length || keyframes) {
        target.push((finish && !isAt && !isKeyframes ? selectors.map(finish) : selectors).join(", ") +
                    " {" + local.join(" ") + "}")
      }
    }

    for (let prop in spec) render(splitSelector(prop), spec[prop], this.rules)
  }

  // :: ()  string
  // Returns a string containing the module's CSS rules.
  getRules() { return this.rules.join("\n") }

  // :: ()  string
  // Generate a new unique CSS class name.
  static newName() {
    let id = top[COUNT] || 1
    top[COUNT] = id + 1
    return C + id.toString(36)
  }

  // :: (union<Document, ShadowRoot>, union<[StyleModule], StyleModule>)
  //
  // Mount the given set of modules in the given DOM root, which ensures
  // that the CSS rules defined by the module are available in that
  // context.
  //
  // Rules are only added to the document once per root.
  //
  // Rule order will follow the order of the modules, so that rules from
  // modules later in the array take precedence of those from earlier
  // modules. If you call this function multiple times for the same root
  // in a way that changes the order of already mounted modules, the old
  // order will be changed.
  static mount(root, modules) {
    (root[SET] || new StyleSet(root)).mount(Array.isArray(modules) ? modules : [modules])
  }
}

let adoptedSet = null

class StyleSet {
  constructor(root) {
    if (!root.head && root.adoptedStyleSheets && typeof CSSStyleSheet != "undefined") {
      if (adoptedSet) {
        root.adoptedStyleSheets = [adoptedSet.sheet].concat(root.adoptedStyleSheets)
        return root[SET] = adoptedSet
      }
      this.sheet = new CSSStyleSheet
      root.adoptedStyleSheets = [this.sheet].concat(root.adoptedStyleSheets)
      adoptedSet = this
    } else {
      this.styleTag = (root.ownerDocument || root).createElement("style")
      let target = root.head || root
      target.insertBefore(this.styleTag, target.firstChild)
    }
    this.modules = []
    root[SET] = this
  }

  mount(modules) {
    let sheet = this.sheet
    let pos = 0 /* Current rule offset */, j = 0 /* Index into this.modules */
    for (let i = 0; i < modules.length; i++) {
      let mod = modules[i], index = this.modules.indexOf(mod)
      if (index < j && index > -1) { // Ordering conflict
        this.modules.splice(index, 1)
        j--
        index = -1
      }
      if (index == -1) {
        this.modules.splice(j++, 0, mod)
        if (sheet) for (let k = 0; k < mod.rules.length; k++)
          sheet.insertRule(mod.rules[k], pos++)
      } else {
        while (j < index) pos += this.modules[j++].rules.length
        pos += mod.rules.length
        j++
      }
    }

    if (!sheet) {
      let text = ""
      for (let i = 0; i < this.modules.length; i++)
        text += this.modules[i].getRules() + "\n"
      this.styleTag.textContent = text
    }
  }
}

// Style::Object<union<Style,string>>
//
// A style is an object that, in the simple case, maps CSS property
// names to strings holding their values, as in `{color: "red",
// fontWeight: "bold"}`. The property names can be given in
// camel-casethe library will insert a dash before capital letters
// when converting them to CSS.
//
// If you include an underscore in a property name, it and everything
// after it will be removed from the output, which can be useful when
// providing a property multiple times, for browser compatibility
// reasons.
//
// A property in a style object can also be a sub-selector, which
// extends the current context to add a pseudo-selector or a child
// selector. Such a property should contain a `&` character, which
// will be replaced by the current selector. For example `{"&:before":
// {content: '"hi"'}}`. Sub-selectors and regular properties can
// freely be mixed in a given object. Any property containing a `&` is
// assumed to be a sub-selector.
//
// Finally, a property can specify an @-block to be wrapped around the
// styles defined inside the object that's the property's value. For
// example to create a media query you can do `{"@media screen and
// (min-width: 400px)": {...}}`.


/***/ }),

/***/ 4083:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"colors":{"dark100":"rgb(11, 16, 37)","dark90":"rgb(22, 30, 48)","dark80":"rgb(26, 35, 54)","dark70":"rgb(33, 42, 62)","dark60":"rgb(37, 47, 68)","dark50":"rgb(71, 83, 105)","dark40":"rgb(100, 114, 139)","dark30":"rgb(148, 160, 184)","dark20":"rgb(203, 211, 225)","dark10":"rgb(226, 231, 240)","dark0":"rgb(248, 250, 252)","light100":"rgb(255, 255, 255)","light90":"rgb(245, 245, 245)","light80":"rgb(221, 221, 221)","light70":"rgb(243, 243, 243)","light60":"rgb(245, 245, 245)","light50":"rgb(190, 204, 221)","light40":"rgb(161, 177, 198)","light30":"rgb(127, 144, 165)","light20":"rgb(91, 105, 123)","light10":"rgb(55, 66, 80)","light0":"rgb(19, 25, 40)","purple90":"rgb(226, 221, 248)","purple70":"rgb(76, 142, 250)","purple60":"rgb(76, 142, 250)","purple50":"rgb(76, 142, 250)","purple40":"rgb(88, 58, 220)","purple30":"rgb(45, 118, 224)","purple10":"rgb(39, 26, 104)","blue90":"rgb(243, 243, 243)","blue70":"rgb(154, 211, 244)","blue60":"rgb(94, 168, 243)","blue50":"rgb(59, 152, 246)","blue40":"rgb(41, 129, 218)","blue30":"rgb(23, 107, 190)","blue10":"rgb(16, 46, 75)","green90":"rgb(209, 250, 226)","green70":"rgb(110, 231, 170)","green60":"rgb(105, 207, 157)","green50":"rgb(16, 185, 129)","green40":"rgb(10, 153, 107)","green30":"rgb(4, 120, 83)","green10":"rgb(2, 82, 58)","yellow90":"rgb(254, 246, 195)","yellow80":"rgb(253, 241, 165)","yellow70":"rgb(192, 192, 192)","yellow50":"rgb(192, 192, 192)","yellow40":"rgb(214, 161, 0)","yellow30":"rgb(161, 123, 7)","yellow10":"rgb(79, 52, 0)","red90":"rgb(254, 226, 227)","red70":"rgb(252, 139, 142)","red50":"rgb(239, 68, 74)","red40":"rgb(194, 34, 39)","red30":"rgb(149, 0, 5)","red10":"rgb(127, 29, 32)","magenta90":"rgb(250, 213, 255)","magenta70":"rgb(218, 132, 233)","magenta50":"rgb(157, 29, 180)","magenta40":"rgb(123, 14, 142)","magenta30":"rgb(88, 0, 104)","magenta10":"rgb(67, 0, 79)","teal90":"rgb(209, 250, 248)","teal70":"rgb(110, 231, 225)","teal50":"rgb(16, 185, 176)","teal40":"rgb(10, 152, 145)","teal30":"rgb(4, 120, 114)","teal10":"rgb(6, 78, 74)","peach90":"rgb(254, 236, 224)","peach70":"rgb(252, 198, 164)","peach50":"rgb(239, 154, 108)","peach40":"rgb(222, 123, 72)","peach30":"rgb(185, 99, 56)","peach10":"rgb(127, 65, 38)","black":"rgb(0, 0, 0)","white":"rgb(255, 255, 255)","transparent":"transparent","inherit":"inherit"},"space":{"$1":"1px","$2":"2px","$4":"4px","$8":"8px","$12":"12px","$16":"16px","$20":"20px","$24":"24px","$28":"28px","$32":"32px","$36":"36px","$40":"40px","$48":"48px","$56":"56px","$64":"64px","$80":"80px","$128":"128px","$160":"160px","$240":"240px","$320":"320px"},"fontWeights":{"semibold":600,"regular":400,"bold":700},"fontSizes":{"$128":"12.8rem","$96":"9.6rem","$64":"6.4rem","$48":"4.8rem","$40":"4rem","$36":"3.6rem","$24":"2.4rem","$20":"2rem","$18":"1.8rem","$16":"1.6rem","$14":"1.4rem","$13":"1.3rem","$12":"1.2rem","$11":"1.1rem"},"lineHeights":{"$100":"100%","$115":"115%","$120":"120%","$140":"140%","$165":"165%","$200":"200%"},"sizes":{"$1":"0.1rem","$2":"0.2rem","$4":"0.4rem","$8":"0.8rem","$12":"1.2rem","$16":"1.6rem","$20":"2rem","$24":"2.4rem","$28":"2.8rem","$32":"3.2rem","$36":"3.6rem","$40":"4rem","$48":"4.8rem","$56":"5.6rem","$64":"6.4rem","$80":"8rem","$128":"12.8rem","$160":"16rem","$240":"24rem","$320":"32rem"}}');

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/create fake namespace object */
/******/ 	(() => {
/******/ 		var getProto = Object.getPrototypeOf ? (obj) => (Object.getPrototypeOf(obj)) : (obj) => (obj.__proto__);
/******/ 		var leafPrototypes;
/******/ 		// create a fake namespace object
/******/ 		// mode & 1: value is a module id, require it
/******/ 		// mode & 2: merge all properties of value into the ns
/******/ 		// mode & 4: return value when already ns object
/******/ 		// mode & 16: return value when it's Promise-like
/******/ 		// mode & 8|1: behave like require
/******/ 		__webpack_require__.t = function(value, mode) {
/******/ 			if(mode & 1) value = this(value);
/******/ 			if(mode & 8) return value;
/******/ 			if(typeof value === 'object' && value) {
/******/ 				if((mode & 4) && value.__esModule) return value;
/******/ 				if((mode & 16) && typeof value.then === 'function') return value;
/******/ 			}
/******/ 			var ns = Object.create(null);
/******/ 			__webpack_require__.r(ns);
/******/ 			var def = {};
/******/ 			leafPrototypes = leafPrototypes || [null, getProto({}), getProto([]), getProto(getProto)];
/******/ 			for(var current = mode & 2 && value; typeof current == 'object' && !~leafPrototypes.indexOf(current); current = getProto(current)) {
/******/ 				Object.getOwnPropertyNames(current).forEach((key) => (def[key] = () => (value[key])));
/******/ 			}
/******/ 			def['default'] = () => (value);
/******/ 			__webpack_require__.d(ns, def);
/******/ 			return ns;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/compat */
/******/ 	
/******/ 	if (typeof __webpack_require__ !== 'undefined') __webpack_require__.ab = "" + "/native_modules/";
/******/ 	
/******/ 	/* webpack/runtime/nonce */
/******/ 	(() => {
/******/ 		__webpack_require__.nc = undefined;
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
var exports = __webpack_exports__;
var __webpack_unused_export__;

__webpack_unused_export__ = ({ value: true });
const jsx_runtime_1 = __webpack_require__(38);
const client_1 = __webpack_require__(2412);
const inspectorApp_1 = __webpack_require__(2192);
if (false) {}
const container = document.getElementById('root');
if (container) {
    const root = (0, client_1.createRoot)(container);
    root.render((0, jsx_runtime_1.jsx)(inspectorApp_1.InspectorApp, {}, void 0));
}

})();

/******/ })()
;
//# sourceMappingURL=index.js.map